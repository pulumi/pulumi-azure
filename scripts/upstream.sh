#!/usr/bin/env bash
# WARNING: This file is autogenerated - changes will be overwritten if not made via https://github.com/pulumi/ci-mgmt

# HOW UPSTREAM PATCHES WORK
# =========================
# Rather than creating a fork of the upstream repository, we maintain a set of patches that we can apply directly to the upstream code.
# This allows us to keep a single source of the patches we maintain as well as track the changes to our patches.
# We use a git submodule called 'upstream' to track the commit of the upstream repository that we will apply our patches to.
# This is typically pointing at the the same commit as the latest tag of the upstream repository.
# We then store our patches in the 'patches' directory and apply them to the upstream repository before building our provider.
# Our patches are never pushed to the remote upstream repository.
# 
# There are two modes of patching the upstream repository:
# 1. 'apply': Only modifies the working directory. The submodule commit is checked out, then each patch is applied to the working directory.
# 2. 'checkout': Creates a branch in the local upstream repository and creates a commit for each patch in the 'patches' directory.
# 
# The 'apply' mode is used by default for when we're building the provider. The 'checkout' mode is used when we need to modify the patches.
# 
# To enter the 'checkout' mode, run `make upstream.checkout`. This will create a branch in the upstream repository with the patches applied.
# To exit the 'checkout' mode, run `make upstream.format_patches`. This will create a new set of patches in the 'patches' directory from the commits on your branch.
# 
# When rebasing the commits, you must also move the 'checkout-base' branch to the new base commit of the patches. E.g. `git branch -f checkout-base <new_base_ref>`.

set -e

# "$1" is the current make command being run.
# It is used to make the error message more actionable.
err_rebase_in_progress() {
  cat <<EOF
A rebase is already in progress. To finish the current rebase,
complete the 'git rebase' in './upstream' and then run:

    make upstream.finalize

If you want to abandon the rebase currently in progress and
execute this target anyway, run:

    rm rebase-in-progress && make "$1"

EOF
  exit 1
}

assert_upstream() {
  if [ ! -d upstream ]; then
    echo "No upstream directory detected. \"$1\" does not make sense in this context."
    exit 1
  fi
}

rebase_in_progress() {
  [ -f rebase-in-progress ]
  return $?
}

# "$1" is the current make command being run.
# It is used to make the error message more actionable.
assert_no_rebase_in_progress() {
  if rebase_in_progress; then
     err_rebase_in_progress "$1"
  fi
}

message_rebase_clean() {
  cat <<EOF

The full patch set has been cleanly applied to the './upstream' repository.
To "edit" the patch set, commit changes directly to './upstream'. When
you are done making changes, run:

    make upstream.finalize

to finish the rebase and commit those changes into the patch set.

EOF
}

message_rebase_dirty() {
cat <<EOF

The patch set did not apply cleanly. You need to manually resolve
rebase conflicts directly in './upstream'. When you have completed
the rebase, run

    make upstream.finalize

This will finalize the changes you made back into the patch set.

EOF
}

# "$1" is the current make command being run.
# It is used to make the error message more actionable.
start_rebase() {
  assert_upstream "$1"
  assert_no_rebase_in_progress "$1"

  git submodule update --force --init
  rm -rf .git/modules/upstream/rebase-merge
  cd upstream && git fetch

  git branch -f local
  if [ -n "$FROM" ]; then
      echo "Rebasing from $FROM to $(git rev-parse HEAD)"
      git checkout -B pulumi-patch "$FROM"
  else
      echo "Rebasing in place at $(git rev-parse HEAD)"
      git checkout -B pulumi-patch
  fi
  git branch --set-upstream-to=local pulumi-patch

  for patch in ../patches/*.patch; do
    echo "Applying $patch"
    if ! git am --3way "$patch"; then
      echo
      echo "Failed to apply ${patch}. Please run 'make upstream.rebase FROM=$TAG' where '$TAG' allows the patch set to apply cleanly"
      echo
      exit 1
    fi
  done

  touch ../rebase-in-progress

  if git rebase local; then
    message_rebase_clean
  else
    message_rebase_dirty
  fi
}

# "$1" is the current make command being run.
# It is used to make the error message more actionable.
assert_rebase_in_progress() {
  if ! rebase_in_progress; then
    cat <<EOF
Didn't detect an upstream rebase in progress.
To start an upstream rebase, run

    [FROM=vX.Y.Z] make upstream.rebase

If you are absolutly sure you are already in a rebase, run

    touch rebase-in-progress && make "$1"

EOF
    exit 1
  fi
}

# "$1" is the current make command being run.
# It is used to make the error message more actionable.
apply() {
  assert_upstream
  assert_no_rebase_in_progress "$1"

  git submodule update --force --init
  # Iterating over the patches folder in sorted order,
  # apply the patch using a 3-way merge strategy. This mirrors the default behavior of 'git merge'
  cd upstream
  for patch in ../patches/*.patch; do
    if ! git apply --3way "$patch" --allow-empty; then
      cat <<EOF

make "$1"' failed to apply ${patch}. This is because there is a conflict between
the checked out version of upstream and the patch set. To resolve this conflict
run:

    FROM=\$LAST_KNOWN_GOOD_COMMIT make upstream.rebase

This will walk you through resolving the conflict and producing a patch set that
cleanly applies to the current upstream.

EOF
      exit 1
    fi
  done
}

# "$1" is the current make command being run.
# It is used to make the error message more actionable.
end_rebase() {
  assert_rebase_in_progress "$1"
  # Use git to resolve the possible location of files indicating a rebase might be in progress.
  rebase_merge_dir=$(cd upstream && git rev-parse --git-path rebase-merge)
  rebase_apply_dir=$(cd upstream && git rev-parse --git-path rebase-apply)

  if [ -d "${rebase_merge_dir}" ] || [ -d "${rebase_apply_dir}" ]; then
    echo "rebase still in progress in './upstream'. Please resolve the rebase in"
    echo "'./upstream' and then run 'make \"$1\"' again."
    exit 1
  fi

  rm patches/*.patch
  cd upstream
  git format-patch local -o ../patches --zero-commit --no-signature --no-stat --no-numbered
  cd ..
  rm rebase-in-progress
  apply "$1"
}

checkout() {
  assert_upstream "$1"
  assert_no_rebase_in_progress "$1"

  git submodule update --force --init
  # Clean up any previous in-progress rebases.
  rm -rf .git/modules/upstream/rebase-merge
  cd upstream && git fetch

  # Set the 'checkout-base' branch to the current commit of the upstream repository
  # This is used to track the base commit of the patches
  # If rebasing, then this must be moved to the new base commit.
  git branch -f checkout-base
  # Create a new branch 'pulumi-patch' which will contain the commits for each patch
  git checkout -B pulumi-patch
  git branch --set-upstream-to=local pulumi-patch

  for patch in ../patches/*.patch; do
    echo "Applying $patch"
    if ! git am --3way "$patch"; then
      echo
      echo "Failed to apply ${patch}. Please run 'make upstream.rebase FROM=$TAG' where '$TAG' allows the patch set to apply cleanly"
      echo
      exit 1
    fi
  done

  touch ../rebase-in-progress

    cat <<EOF

The patches have been checked out as commits in the './upstream' repository
on the 'pulumi-patch' branch. You can now edit the commits directly in the
upstream repository e.g. using 'git rebase -i'.

The 'checkout-base' branch is tracking the base commit of the patches. If you
want to change the base commit of the patches, move the 'checkout-base' branch
first, the perform a rebase:

    git branch -f checkout-base <new-base-commit>

For example, to rebase the patches on top of v1.2.3, run:

    git branch -f checkout-base v1.2.3
    git rebase --onto v1.2.3

Once you have finished editing the patches, run:

    make upstream.format_patches

EOF
}

format_patches() {
  assert_rebase_in_progress "$1"
  # Use git to resolve the possible location of files indicating a rebase might be in progress.
  rebase_merge_dir=$(cd upstream && git rev-parse --git-path rebase-merge)
  rebase_apply_dir=$(cd upstream && git rev-parse --git-path rebase-apply)

  if [ -d "${rebase_merge_dir}" ] || [ -d "${rebase_apply_dir}" ]; then
    echo "rebase still in progress in './upstream'. Please resolve the rebase in"
    echo "'./upstream' and then run 'make \"$1\"' again."
    exit 1
  fi

  # Remove all existing patches before creating the new ones in case they've been renamed or removed.
  rm patches/*.patch
  cd upstream
  # Extract patches from the commits in the 'pulumi-patch' branch into the 'patches' directory.
  # Use the 'checkout-base' branch to determine the base commit of the patches.
  git format-patch checkout-base -o ../patches --zero-commit --no-signature --no-stat --no-numbered
  cd ..
  # Mark the rebase as complete.
  rm rebase-in-progress
}

case $2 in
  apply)
    apply "$1"
    ;;
  checkout)
    checkout "$1"
    ;;
  format_patches)
    format_patches "$1"
    ;;
  start_rebase)
    start_rebase "$1"
    ;;
  end_rebase)
    end_rebase "$1"
    ;;
  *)
    cat <<EOF
Unknown argument $2.

Expected convention ./scripts/upstream.sh $@ [apply|start_rebase|end_rebase]
EOF
    ;;
esac
