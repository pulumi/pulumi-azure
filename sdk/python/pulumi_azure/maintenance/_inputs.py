# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AssignmentDynamicScopeFilterArgs',
    'AssignmentDynamicScopeFilterArgsDict',
    'AssignmentDynamicScopeFilterTagArgs',
    'AssignmentDynamicScopeFilterTagArgsDict',
    'ConfigurationInstallPatchesArgs',
    'ConfigurationInstallPatchesArgsDict',
    'ConfigurationInstallPatchesLinuxArgs',
    'ConfigurationInstallPatchesLinuxArgsDict',
    'ConfigurationInstallPatchesWindowArgs',
    'ConfigurationInstallPatchesWindowArgsDict',
    'ConfigurationWindowArgs',
    'ConfigurationWindowArgsDict',
]

MYPY = False

if not MYPY:
    class AssignmentDynamicScopeFilterArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of locations to scope the query to.
        """
        os_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of allowed operating systems.
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of allowed resource groups.
        """
        resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of allowed resources.
        """
        tag_filter: NotRequired[pulumi.Input[str]]
        """
        Filter VMs by `Any` or `All` specified tags. Defaults to `Any`.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['AssignmentDynamicScopeFilterTagArgsDict']]]]
        """
        A mapping of tags for the VM
        """
elif False:
    AssignmentDynamicScopeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssignmentDynamicScopeFilterArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 os_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_filter: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['AssignmentDynamicScopeFilterTagArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: Specifies a list of locations to scope the query to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] os_types: Specifies a list of allowed operating systems.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specifies a list of allowed resource groups.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_types: Specifies a list of allowed resources.
        :param pulumi.Input[str] tag_filter: Filter VMs by `Any` or `All` specified tags. Defaults to `Any`.
        :param pulumi.Input[Sequence[pulumi.Input['AssignmentDynamicScopeFilterTagArgs']]] tags: A mapping of tags for the VM
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if tag_filter is not None:
            pulumi.set(__self__, "tag_filter", tag_filter)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of locations to scope the query to.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of allowed operating systems.
        """
        return pulumi.get(self, "os_types")

    @os_types.setter
    def os_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "os_types", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of allowed resource groups.
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of allowed resources.
        """
        return pulumi.get(self, "resource_types")

    @resource_types.setter
    def resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_types", value)

    @property
    @pulumi.getter(name="tagFilter")
    def tag_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Filter VMs by `Any` or `All` specified tags. Defaults to `Any`.
        """
        return pulumi.get(self, "tag_filter")

    @tag_filter.setter
    def tag_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_filter", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AssignmentDynamicScopeFilterTagArgs']]]]:
        """
        A mapping of tags for the VM
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AssignmentDynamicScopeFilterTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AssignmentDynamicScopeFilterTagArgsDict(TypedDict):
        tag: pulumi.Input[str]
        """
        Specifies the tag to filter by.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values the defined tag can have.
        """
elif False:
    AssignmentDynamicScopeFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssignmentDynamicScopeFilterTagArgs:
    def __init__(__self__, *,
                 tag: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] tag: Specifies the tag to filter by.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values the defined tag can have.
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        """
        Specifies the tag to filter by.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values the defined tag can have.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ConfigurationInstallPatchesArgsDict(TypedDict):
        linuxes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesLinuxArgsDict']]]]
        """
        A `linux` block as defined above. This property only applies when `scope` is set to `InGuestPatch`
        """
        reboot: NotRequired[pulumi.Input[str]]
        """
        Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed. Possible values are `Always`, `IfRequired` and `Never`. This property only applies when `scope` is set to `InGuestPatch`.
        """
        windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesWindowArgsDict']]]]
        """
        A `windows` block as defined above. This property only applies when `scope` is set to `InGuestPatch`
        """
elif False:
    ConfigurationInstallPatchesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstallPatchesArgs:
    def __init__(__self__, *,
                 linuxes: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesLinuxArgs']]]] = None,
                 reboot: Optional[pulumi.Input[str]] = None,
                 windows: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesWindowArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesLinuxArgs']]] linuxes: A `linux` block as defined above. This property only applies when `scope` is set to `InGuestPatch`
        :param pulumi.Input[str] reboot: Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed. Possible values are `Always`, `IfRequired` and `Never`. This property only applies when `scope` is set to `InGuestPatch`.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesWindowArgs']]] windows: A `windows` block as defined above. This property only applies when `scope` is set to `InGuestPatch`
        """
        if linuxes is not None:
            pulumi.set(__self__, "linuxes", linuxes)
        if reboot is not None:
            pulumi.set(__self__, "reboot", reboot)
        if windows is not None:
            pulumi.set(__self__, "windows", windows)

    @property
    @pulumi.getter
    def linuxes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesLinuxArgs']]]]:
        """
        A `linux` block as defined above. This property only applies when `scope` is set to `InGuestPatch`
        """
        return pulumi.get(self, "linuxes")

    @linuxes.setter
    def linuxes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesLinuxArgs']]]]):
        pulumi.set(self, "linuxes", value)

    @property
    @pulumi.getter
    def reboot(self) -> Optional[pulumi.Input[str]]:
        """
        Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed. Possible values are `Always`, `IfRequired` and `Never`. This property only applies when `scope` is set to `InGuestPatch`.
        """
        return pulumi.get(self, "reboot")

    @reboot.setter
    def reboot(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reboot", value)

    @property
    @pulumi.getter
    def windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesWindowArgs']]]]:
        """
        A `windows` block as defined above. This property only applies when `scope` is set to `InGuestPatch`
        """
        return pulumi.get(self, "windows")

    @windows.setter
    def windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstallPatchesWindowArgs']]]]):
        pulumi.set(self, "windows", value)


if not MYPY:
    class ConfigurationInstallPatchesLinuxArgsDict(TypedDict):
        classifications_to_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Classification category of patches to be patched. Possible values are `Critical`, `Security` and `Other`.
        """
        package_names_mask_to_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of package names to be excluded from patching.
        """
        package_names_mask_to_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of package names to be included for patching.
        """
elif False:
    ConfigurationInstallPatchesLinuxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstallPatchesLinuxArgs:
    def __init__(__self__, *,
                 classifications_to_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 package_names_mask_to_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 package_names_mask_to_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] classifications_to_includes: List of Classification category of patches to be patched. Possible values are `Critical`, `Security` and `Other`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] package_names_mask_to_excludes: List of package names to be excluded from patching.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] package_names_mask_to_includes: List of package names to be included for patching.
        """
        if classifications_to_includes is not None:
            pulumi.set(__self__, "classifications_to_includes", classifications_to_includes)
        if package_names_mask_to_excludes is not None:
            pulumi.set(__self__, "package_names_mask_to_excludes", package_names_mask_to_excludes)
        if package_names_mask_to_includes is not None:
            pulumi.set(__self__, "package_names_mask_to_includes", package_names_mask_to_includes)

    @property
    @pulumi.getter(name="classificationsToIncludes")
    def classifications_to_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Classification category of patches to be patched. Possible values are `Critical`, `Security` and `Other`.
        """
        return pulumi.get(self, "classifications_to_includes")

    @classifications_to_includes.setter
    def classifications_to_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "classifications_to_includes", value)

    @property
    @pulumi.getter(name="packageNamesMaskToExcludes")
    def package_names_mask_to_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of package names to be excluded from patching.
        """
        return pulumi.get(self, "package_names_mask_to_excludes")

    @package_names_mask_to_excludes.setter
    def package_names_mask_to_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "package_names_mask_to_excludes", value)

    @property
    @pulumi.getter(name="packageNamesMaskToIncludes")
    def package_names_mask_to_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of package names to be included for patching.
        """
        return pulumi.get(self, "package_names_mask_to_includes")

    @package_names_mask_to_includes.setter
    def package_names_mask_to_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "package_names_mask_to_includes", value)


if not MYPY:
    class ConfigurationInstallPatchesWindowArgsDict(TypedDict):
        classifications_to_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Classification category of patches to be patched. Possible values are `Critical`, `Security`, `UpdateRollup`, `FeaturePack`, `ServicePack`, `Definition`, `Tools` and `Updates`.
        """
        kb_numbers_to_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of KB numbers to be excluded from patching.
        """
        kb_numbers_to_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of KB numbers to be included for patching.
        """
elif False:
    ConfigurationInstallPatchesWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstallPatchesWindowArgs:
    def __init__(__self__, *,
                 classifications_to_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kb_numbers_to_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kb_numbers_to_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] classifications_to_includes: List of Classification category of patches to be patched. Possible values are `Critical`, `Security`, `UpdateRollup`, `FeaturePack`, `ServicePack`, `Definition`, `Tools` and `Updates`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kb_numbers_to_excludes: List of KB numbers to be excluded from patching.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kb_numbers_to_includes: List of KB numbers to be included for patching.
        """
        if classifications_to_includes is not None:
            pulumi.set(__self__, "classifications_to_includes", classifications_to_includes)
        if kb_numbers_to_excludes is not None:
            pulumi.set(__self__, "kb_numbers_to_excludes", kb_numbers_to_excludes)
        if kb_numbers_to_includes is not None:
            pulumi.set(__self__, "kb_numbers_to_includes", kb_numbers_to_includes)

    @property
    @pulumi.getter(name="classificationsToIncludes")
    def classifications_to_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Classification category of patches to be patched. Possible values are `Critical`, `Security`, `UpdateRollup`, `FeaturePack`, `ServicePack`, `Definition`, `Tools` and `Updates`.
        """
        return pulumi.get(self, "classifications_to_includes")

    @classifications_to_includes.setter
    def classifications_to_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "classifications_to_includes", value)

    @property
    @pulumi.getter(name="kbNumbersToExcludes")
    def kb_numbers_to_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of KB numbers to be excluded from patching.
        """
        return pulumi.get(self, "kb_numbers_to_excludes")

    @kb_numbers_to_excludes.setter
    def kb_numbers_to_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kb_numbers_to_excludes", value)

    @property
    @pulumi.getter(name="kbNumbersToIncludes")
    def kb_numbers_to_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of KB numbers to be included for patching.
        """
        return pulumi.get(self, "kb_numbers_to_includes")

    @kb_numbers_to_includes.setter
    def kb_numbers_to_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kb_numbers_to_includes", value)


if not MYPY:
    class ConfigurationWindowArgsDict(TypedDict):
        start_date_time: pulumi.Input[str]
        """
        Effective start date of the maintenance window in YYYY-MM-DD hh:mm format.
        """
        time_zone: pulumi.Input[str]
        """
        The time zone for the maintenance window. A list of timezones can be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        The duration of the maintenance window in HH:mm format.
        """
        expiration_date_time: NotRequired[pulumi.Input[str]]
        """
        Effective expiration date of the maintenance window in YYYY-MM-DD hh:mm format.
        """
        recur_every: NotRequired[pulumi.Input[str]]
        """
        The rate at which a maintenance window is expected to recur. The rate can be expressed as daily, weekly, or monthly schedules.
        """
elif False:
    ConfigurationWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationWindowArgs:
    def __init__(__self__, *,
                 start_date_time: pulumi.Input[str],
                 time_zone: pulumi.Input[str],
                 duration: Optional[pulumi.Input[str]] = None,
                 expiration_date_time: Optional[pulumi.Input[str]] = None,
                 recur_every: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] start_date_time: Effective start date of the maintenance window in YYYY-MM-DD hh:mm format.
        :param pulumi.Input[str] time_zone: The time zone for the maintenance window. A list of timezones can be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell.
        :param pulumi.Input[str] duration: The duration of the maintenance window in HH:mm format.
        :param pulumi.Input[str] expiration_date_time: Effective expiration date of the maintenance window in YYYY-MM-DD hh:mm format.
        :param pulumi.Input[str] recur_every: The rate at which a maintenance window is expected to recur. The rate can be expressed as daily, weekly, or monthly schedules.
        """
        pulumi.set(__self__, "start_date_time", start_date_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if expiration_date_time is not None:
            pulumi.set(__self__, "expiration_date_time", expiration_date_time)
        if recur_every is not None:
            pulumi.set(__self__, "recur_every", recur_every)

    @property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> pulumi.Input[str]:
        """
        Effective start date of the maintenance window in YYYY-MM-DD hh:mm format.
        """
        return pulumi.get(self, "start_date_time")

    @start_date_time.setter
    def start_date_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        """
        The time zone for the maintenance window. A list of timezones can be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration of the maintenance window in HH:mm format.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="expirationDateTime")
    def expiration_date_time(self) -> Optional[pulumi.Input[str]]:
        """
        Effective expiration date of the maintenance window in YYYY-MM-DD hh:mm format.
        """
        return pulumi.get(self, "expiration_date_time")

    @expiration_date_time.setter
    def expiration_date_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_date_time", value)

    @property
    @pulumi.getter(name="recurEvery")
    def recur_every(self) -> Optional[pulumi.Input[str]]:
        """
        The rate at which a maintenance window is expected to recur. The rate can be expressed as daily, weekly, or monthly schedules.
        """
        return pulumi.get(self, "recur_every")

    @recur_every.setter
    def recur_every(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recur_every", value)


