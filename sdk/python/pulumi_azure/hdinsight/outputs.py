# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'HBaseClusterComponentVersion',
    'HBaseClusterComputeIsolation',
    'HBaseClusterDiskEncryption',
    'HBaseClusterExtension',
    'HBaseClusterGateway',
    'HBaseClusterMetastores',
    'HBaseClusterMetastoresAmbari',
    'HBaseClusterMetastoresHive',
    'HBaseClusterMetastoresOozie',
    'HBaseClusterMonitor',
    'HBaseClusterNetwork',
    'HBaseClusterRoles',
    'HBaseClusterRolesHeadNode',
    'HBaseClusterRolesHeadNodeScriptAction',
    'HBaseClusterRolesWorkerNode',
    'HBaseClusterRolesWorkerNodeAutoscale',
    'HBaseClusterRolesWorkerNodeAutoscaleRecurrence',
    'HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule',
    'HBaseClusterRolesWorkerNodeScriptAction',
    'HBaseClusterRolesZookeeperNode',
    'HBaseClusterRolesZookeeperNodeScriptAction',
    'HBaseClusterSecurityProfile',
    'HBaseClusterStorageAccount',
    'HBaseClusterStorageAccountGen2',
    'HadoopClusterComponentVersion',
    'HadoopClusterComputeIsolation',
    'HadoopClusterDiskEncryption',
    'HadoopClusterExtension',
    'HadoopClusterGateway',
    'HadoopClusterMetastores',
    'HadoopClusterMetastoresAmbari',
    'HadoopClusterMetastoresHive',
    'HadoopClusterMetastoresOozie',
    'HadoopClusterMonitor',
    'HadoopClusterNetwork',
    'HadoopClusterRoles',
    'HadoopClusterRolesEdgeNode',
    'HadoopClusterRolesEdgeNodeHttpsEndpoint',
    'HadoopClusterRolesEdgeNodeInstallScriptAction',
    'HadoopClusterRolesEdgeNodeUninstallScriptAction',
    'HadoopClusterRolesHeadNode',
    'HadoopClusterRolesHeadNodeScriptAction',
    'HadoopClusterRolesWorkerNode',
    'HadoopClusterRolesWorkerNodeAutoscale',
    'HadoopClusterRolesWorkerNodeAutoscaleCapacity',
    'HadoopClusterRolesWorkerNodeAutoscaleRecurrence',
    'HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule',
    'HadoopClusterRolesWorkerNodeScriptAction',
    'HadoopClusterRolesZookeeperNode',
    'HadoopClusterRolesZookeeperNodeScriptAction',
    'HadoopClusterSecurityProfile',
    'HadoopClusterStorageAccount',
    'HadoopClusterStorageAccountGen2',
    'InteractiveQueryClusterComponentVersion',
    'InteractiveQueryClusterComputeIsolation',
    'InteractiveQueryClusterDiskEncryption',
    'InteractiveQueryClusterExtension',
    'InteractiveQueryClusterGateway',
    'InteractiveQueryClusterMetastores',
    'InteractiveQueryClusterMetastoresAmbari',
    'InteractiveQueryClusterMetastoresHive',
    'InteractiveQueryClusterMetastoresOozie',
    'InteractiveQueryClusterMonitor',
    'InteractiveQueryClusterNetwork',
    'InteractiveQueryClusterRoles',
    'InteractiveQueryClusterRolesHeadNode',
    'InteractiveQueryClusterRolesHeadNodeScriptAction',
    'InteractiveQueryClusterRolesWorkerNode',
    'InteractiveQueryClusterRolesWorkerNodeAutoscale',
    'InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity',
    'InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence',
    'InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule',
    'InteractiveQueryClusterRolesWorkerNodeScriptAction',
    'InteractiveQueryClusterRolesZookeeperNode',
    'InteractiveQueryClusterRolesZookeeperNodeScriptAction',
    'InteractiveQueryClusterSecurityProfile',
    'InteractiveQueryClusterStorageAccount',
    'InteractiveQueryClusterStorageAccountGen2',
    'KafkaClusterComponentVersion',
    'KafkaClusterComputeIsolation',
    'KafkaClusterDiskEncryption',
    'KafkaClusterExtension',
    'KafkaClusterGateway',
    'KafkaClusterMetastores',
    'KafkaClusterMetastoresAmbari',
    'KafkaClusterMetastoresHive',
    'KafkaClusterMetastoresOozie',
    'KafkaClusterMonitor',
    'KafkaClusterNetwork',
    'KafkaClusterRestProxy',
    'KafkaClusterRoles',
    'KafkaClusterRolesHeadNode',
    'KafkaClusterRolesHeadNodeScriptAction',
    'KafkaClusterRolesKafkaManagementNode',
    'KafkaClusterRolesKafkaManagementNodeScriptAction',
    'KafkaClusterRolesWorkerNode',
    'KafkaClusterRolesWorkerNodeScriptAction',
    'KafkaClusterRolesZookeeperNode',
    'KafkaClusterRolesZookeeperNodeScriptAction',
    'KafkaClusterSecurityProfile',
    'KafkaClusterStorageAccount',
    'KafkaClusterStorageAccountGen2',
    'SparkClusterComponentVersion',
    'SparkClusterComputeIsolation',
    'SparkClusterDiskEncryption',
    'SparkClusterExtension',
    'SparkClusterGateway',
    'SparkClusterMetastores',
    'SparkClusterMetastoresAmbari',
    'SparkClusterMetastoresHive',
    'SparkClusterMetastoresOozie',
    'SparkClusterMonitor',
    'SparkClusterNetwork',
    'SparkClusterRoles',
    'SparkClusterRolesHeadNode',
    'SparkClusterRolesHeadNodeScriptAction',
    'SparkClusterRolesWorkerNode',
    'SparkClusterRolesWorkerNodeAutoscale',
    'SparkClusterRolesWorkerNodeAutoscaleCapacity',
    'SparkClusterRolesWorkerNodeAutoscaleRecurrence',
    'SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule',
    'SparkClusterRolesWorkerNodeScriptAction',
    'SparkClusterRolesZookeeperNode',
    'SparkClusterRolesZookeeperNodeScriptAction',
    'SparkClusterSecurityProfile',
    'SparkClusterStorageAccount',
    'SparkClusterStorageAccountGen2',
    'GetClusterGatewayResult',
]

@pulumi.output_type
class HBaseClusterComponentVersion(dict):
    def __init__(__self__, *,
                 hbase: str):
        """
        :param str hbase: The version of HBase which should be used for this HDInsight HBase Cluster. Changing this forces a new resource to be created.
        """
        HBaseClusterComponentVersion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hbase=hbase,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hbase: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hbase", hbase)

    @property
    @pulumi.getter
    def hbase(self) -> str:
        """
        The version of HBase which should be used for this HDInsight HBase Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "hbase")


@pulumi.output_type
class HBaseClusterComputeIsolation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeIsolationEnabled":
            suggest = "compute_isolation_enabled"
        elif key == "hostSku":
            suggest = "host_sku"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterComputeIsolation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterComputeIsolation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterComputeIsolation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_isolation_enabled: Optional[bool] = None,
                 host_sku: Optional[str] = None):
        """
        :param bool compute_isolation_enabled: This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        :param str host_sku: The name of the host SKU.
        """
        HBaseClusterComputeIsolation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_isolation_enabled=compute_isolation_enabled,
            host_sku=host_sku,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_isolation_enabled: Optional[bool] = None,
             host_sku: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compute_isolation_enabled is not None:
            _setter("compute_isolation_enabled", compute_isolation_enabled)
        if host_sku is not None:
            _setter("host_sku", host_sku)

    @property
    @pulumi.getter(name="computeIsolationEnabled")
    def compute_isolation_enabled(self) -> Optional[bool]:
        """
        This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        """
        return pulumi.get(self, "compute_isolation_enabled")

    @property
    @pulumi.getter(name="hostSku")
    def host_sku(self) -> Optional[str]:
        """
        The name of the host SKU.
        """
        return pulumi.get(self, "host_sku")


@pulumi.output_type
class HBaseClusterDiskEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "encryptionAtHostEnabled":
            suggest = "encryption_at_host_enabled"
        elif key == "keyVaultKeyId":
            suggest = "key_vault_key_id"
        elif key == "keyVaultManagedIdentityId":
            suggest = "key_vault_managed_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterDiskEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterDiskEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterDiskEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: Optional[str] = None,
                 encryption_at_host_enabled: Optional[bool] = None,
                 key_vault_key_id: Optional[str] = None,
                 key_vault_managed_identity_id: Optional[str] = None):
        """
        :param str encryption_algorithm: This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        :param bool encryption_at_host_enabled: This is indicator to show whether resource disk encryption is enabled.
        :param str key_vault_key_id: The ID of the key vault key.
        :param str key_vault_managed_identity_id: This is the resource ID of Managed Identity used to access the key vault.
        """
        HBaseClusterDiskEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encryption_algorithm=encryption_algorithm,
            encryption_at_host_enabled=encryption_at_host_enabled,
            key_vault_key_id=key_vault_key_id,
            key_vault_managed_identity_id=key_vault_managed_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encryption_algorithm: Optional[str] = None,
             encryption_at_host_enabled: Optional[bool] = None,
             key_vault_key_id: Optional[str] = None,
             key_vault_managed_identity_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if encryption_algorithm is not None:
            _setter("encryption_algorithm", encryption_algorithm)
        if encryption_at_host_enabled is not None:
            _setter("encryption_at_host_enabled", encryption_at_host_enabled)
        if key_vault_key_id is not None:
            _setter("key_vault_key_id", key_vault_key_id)
        if key_vault_managed_identity_id is not None:
            _setter("key_vault_managed_identity_id", key_vault_managed_identity_id)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[str]:
        """
        This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter(name="encryptionAtHostEnabled")
    def encryption_at_host_enabled(self) -> Optional[bool]:
        """
        This is indicator to show whether resource disk encryption is enabled.
        """
        return pulumi.get(self, "encryption_at_host_enabled")

    @property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> Optional[str]:
        """
        The ID of the key vault key.
        """
        return pulumi.get(self, "key_vault_key_id")

    @property
    @pulumi.getter(name="keyVaultManagedIdentityId")
    def key_vault_managed_identity_id(self) -> Optional[str]:
        """
        This is the resource ID of Managed Identity used to access the key vault.
        """
        return pulumi.get(self, "key_vault_managed_identity_id")


@pulumi.output_type
class HBaseClusterExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The workspace ID of the log analytics extension.
        :param str primary_key: The workspace key of the log analytics extension.
        """
        HBaseClusterExtension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The workspace ID of the log analytics extension.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The workspace key of the log analytics extension.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class HBaseClusterGateway(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password used for the Ambari Portal.
               
               > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        :param str username: The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        HBaseClusterGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password used for the Ambari Portal.

        > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class HBaseClusterMetastores(dict):
    def __init__(__self__, *,
                 ambari: Optional['outputs.HBaseClusterMetastoresAmbari'] = None,
                 hive: Optional['outputs.HBaseClusterMetastoresHive'] = None,
                 oozie: Optional['outputs.HBaseClusterMetastoresOozie'] = None):
        """
        :param 'HBaseClusterMetastoresAmbariArgs' ambari: An `ambari` block as defined below.
        :param 'HBaseClusterMetastoresHiveArgs' hive: A `hive` block as defined below.
        :param 'HBaseClusterMetastoresOozieArgs' oozie: An `oozie` block as defined below.
        """
        HBaseClusterMetastores._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ambari=ambari,
            hive=hive,
            oozie=oozie,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ambari: Optional['outputs.HBaseClusterMetastoresAmbari'] = None,
             hive: Optional['outputs.HBaseClusterMetastoresHive'] = None,
             oozie: Optional['outputs.HBaseClusterMetastoresOozie'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ambari is not None:
            _setter("ambari", ambari)
        if hive is not None:
            _setter("hive", hive)
        if oozie is not None:
            _setter("oozie", oozie)

    @property
    @pulumi.getter
    def ambari(self) -> Optional['outputs.HBaseClusterMetastoresAmbari']:
        """
        An `ambari` block as defined below.
        """
        return pulumi.get(self, "ambari")

    @property
    @pulumi.getter
    def hive(self) -> Optional['outputs.HBaseClusterMetastoresHive']:
        """
        A `hive` block as defined below.
        """
        return pulumi.get(self, "hive")

    @property
    @pulumi.getter
    def oozie(self) -> Optional['outputs.HBaseClusterMetastoresOozie']:
        """
        An `oozie` block as defined below.
        """
        return pulumi.get(self, "oozie")


@pulumi.output_type
class HBaseClusterMetastoresAmbari(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterMetastoresAmbari. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterMetastoresAmbari.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterMetastoresAmbari.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        :param str username: The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        HBaseClusterMetastoresAmbari._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class HBaseClusterMetastoresHive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterMetastoresHive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterMetastoresHive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterMetastoresHive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        :param str username: The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        HBaseClusterMetastoresHive._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class HBaseClusterMetastoresOozie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterMetastoresOozie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterMetastoresOozie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterMetastoresOozie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        :param str username: The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        HBaseClusterMetastoresOozie._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class HBaseClusterMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The Operations Management Suite (OMS) workspace ID.
        :param str primary_key: The Operations Management Suite (OMS) workspace key.
        """
        HBaseClusterMonitor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The Operations Management Suite (OMS) workspace ID.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The Operations Management Suite (OMS) workspace key.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class HBaseClusterNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionDirection":
            suggest = "connection_direction"
        elif key == "privateLinkEnabled":
            suggest = "private_link_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_direction: Optional[str] = None,
                 private_link_enabled: Optional[bool] = None):
        """
        :param str connection_direction: The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
               
               > **NOTE:** To enable the private link the `connection_direction` must be set to `Outbound`.
        :param bool private_link_enabled: Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        HBaseClusterNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_direction=connection_direction,
            private_link_enabled=private_link_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_direction: Optional[str] = None,
             private_link_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_direction is not None:
            _setter("connection_direction", connection_direction)
        if private_link_enabled is not None:
            _setter("private_link_enabled", private_link_enabled)

    @property
    @pulumi.getter(name="connectionDirection")
    def connection_direction(self) -> Optional[str]:
        """
        The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.

        > **NOTE:** To enable the private link the `connection_direction` must be set to `Outbound`.
        """
        return pulumi.get(self, "connection_direction")

    @property
    @pulumi.getter(name="privateLinkEnabled")
    def private_link_enabled(self) -> Optional[bool]:
        """
        Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "private_link_enabled")


@pulumi.output_type
class HBaseClusterRoles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headNode":
            suggest = "head_node"
        elif key == "workerNode":
            suggest = "worker_node"
        elif key == "zookeeperNode":
            suggest = "zookeeper_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterRoles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterRoles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterRoles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 head_node: 'outputs.HBaseClusterRolesHeadNode',
                 worker_node: 'outputs.HBaseClusterRolesWorkerNode',
                 zookeeper_node: 'outputs.HBaseClusterRolesZookeeperNode'):
        """
        :param 'HBaseClusterRolesHeadNodeArgs' head_node: A `head_node` block as defined above.
        :param 'HBaseClusterRolesWorkerNodeArgs' worker_node: A `worker_node` block as defined below.
        :param 'HBaseClusterRolesZookeeperNodeArgs' zookeeper_node: A `zookeeper_node` block as defined below.
        """
        HBaseClusterRoles._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            head_node=head_node,
            worker_node=worker_node,
            zookeeper_node=zookeeper_node,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             head_node: 'outputs.HBaseClusterRolesHeadNode',
             worker_node: 'outputs.HBaseClusterRolesWorkerNode',
             zookeeper_node: 'outputs.HBaseClusterRolesZookeeperNode',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("head_node", head_node)
        _setter("worker_node", worker_node)
        _setter("zookeeper_node", zookeeper_node)

    @property
    @pulumi.getter(name="headNode")
    def head_node(self) -> 'outputs.HBaseClusterRolesHeadNode':
        """
        A `head_node` block as defined above.
        """
        return pulumi.get(self, "head_node")

    @property
    @pulumi.getter(name="workerNode")
    def worker_node(self) -> 'outputs.HBaseClusterRolesWorkerNode':
        """
        A `worker_node` block as defined below.
        """
        return pulumi.get(self, "worker_node")

    @property
    @pulumi.getter(name="zookeeperNode")
    def zookeeper_node(self) -> 'outputs.HBaseClusterRolesZookeeperNode':
        """
        A `zookeeper_node` block as defined below.
        """
        return pulumi.get(self, "zookeeper_node")


@pulumi.output_type
class HBaseClusterRolesHeadNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterRolesHeadNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterRolesHeadNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterRolesHeadNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.HBaseClusterRolesHeadNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['HBaseClusterRolesHeadNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        HBaseClusterRolesHeadNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.HBaseClusterRolesHeadNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.HBaseClusterRolesHeadNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class HBaseClusterRolesHeadNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        HBaseClusterRolesHeadNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class HBaseClusterRolesWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetInstanceCount":
            suggest = "target_instance_count"
        elif key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterRolesWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterRolesWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterRolesWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_instance_count: int,
                 username: str,
                 vm_size: str,
                 autoscale: Optional['outputs.HBaseClusterRolesWorkerNodeAutoscale'] = None,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.HBaseClusterRolesWorkerNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param int target_instance_count: The number of instances which should be run for the Worker Nodes.
        :param str username: The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['HBaseClusterRolesWorkerNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        HBaseClusterRolesWorkerNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_instance_count=target_instance_count,
            username=username,
            vm_size=vm_size,
            autoscale=autoscale,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_instance_count: int,
             username: str,
             vm_size: str,
             autoscale: Optional['outputs.HBaseClusterRolesWorkerNodeAutoscale'] = None,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.HBaseClusterRolesWorkerNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_instance_count", target_instance_count)
        _setter("username", username)
        _setter("vm_size", vm_size)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of instances which should be run for the Worker Nodes.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.HBaseClusterRolesWorkerNodeAutoscale']:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.HBaseClusterRolesWorkerNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class HBaseClusterRolesWorkerNodeAutoscale(dict):
    def __init__(__self__, *,
                 recurrence: Optional['outputs.HBaseClusterRolesWorkerNodeAutoscaleRecurrence'] = None):
        HBaseClusterRolesWorkerNodeAutoscale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recurrence=recurrence,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recurrence: Optional['outputs.HBaseClusterRolesWorkerNodeAutoscaleRecurrence'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if recurrence is not None:
            _setter("recurrence", recurrence)

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.HBaseClusterRolesWorkerNodeAutoscaleRecurrence']:
        return pulumi.get(self, "recurrence")


@pulumi.output_type
class HBaseClusterRolesWorkerNodeAutoscaleRecurrence(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule'],
                 timezone: str):
        HBaseClusterRolesWorkerNodeAutoscaleRecurrence._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schedules=schedules,
            timezone=timezone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schedules: Sequence['outputs.HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule'],
             timezone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("schedules", schedules)
        _setter("timezone", timezone)

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule']:
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        return pulumi.get(self, "timezone")


@pulumi.output_type
class HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetInstanceCount":
            suggest = "target_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Sequence[str],
                 target_instance_count: int,
                 time: str):
        """
        :param int target_instance_count: The number of instances which should be run for the Worker Nodes.
        """
        HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days=days,
            target_instance_count=target_instance_count,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days: Sequence[str],
             target_instance_count: int,
             time: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("days", days)
        _setter("target_instance_count", target_instance_count)
        _setter("time", time)

    @property
    @pulumi.getter
    def days(self) -> Sequence[str]:
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of instances which should be run for the Worker Nodes.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter
    def time(self) -> str:
        return pulumi.get(self, "time")


@pulumi.output_type
class HBaseClusterRolesWorkerNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        HBaseClusterRolesWorkerNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class HBaseClusterRolesZookeeperNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterRolesZookeeperNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterRolesZookeeperNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterRolesZookeeperNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.HBaseClusterRolesZookeeperNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['HBaseClusterRolesZookeeperNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        HBaseClusterRolesZookeeperNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.HBaseClusterRolesZookeeperNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.HBaseClusterRolesZookeeperNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class HBaseClusterRolesZookeeperNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        HBaseClusterRolesZookeeperNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class HBaseClusterSecurityProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aaddsResourceId":
            suggest = "aadds_resource_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "domainUserPassword":
            suggest = "domain_user_password"
        elif key == "domainUsername":
            suggest = "domain_username"
        elif key == "ldapsUrls":
            suggest = "ldaps_urls"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"
        elif key == "clusterUsersGroupDns":
            suggest = "cluster_users_group_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterSecurityProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterSecurityProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterSecurityProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aadds_resource_id: str,
                 domain_name: str,
                 domain_user_password: str,
                 domain_username: str,
                 ldaps_urls: Sequence[str],
                 msi_resource_id: str,
                 cluster_users_group_dns: Optional[Sequence[str]] = None):
        """
        :param str aadds_resource_id: The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        :param str domain_name: The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_user_password: The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_username: The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param Sequence[str] ldaps_urls: A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        :param str msi_resource_id: The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        :param Sequence[str] cluster_users_group_dns: A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        HBaseClusterSecurityProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aadds_resource_id=aadds_resource_id,
            domain_name=domain_name,
            domain_user_password=domain_user_password,
            domain_username=domain_username,
            ldaps_urls=ldaps_urls,
            msi_resource_id=msi_resource_id,
            cluster_users_group_dns=cluster_users_group_dns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aadds_resource_id: str,
             domain_name: str,
             domain_user_password: str,
             domain_username: str,
             ldaps_urls: Sequence[str],
             msi_resource_id: str,
             cluster_users_group_dns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aadds_resource_id", aadds_resource_id)
        _setter("domain_name", domain_name)
        _setter("domain_user_password", domain_user_password)
        _setter("domain_username", domain_username)
        _setter("ldaps_urls", ldaps_urls)
        _setter("msi_resource_id", msi_resource_id)
        if cluster_users_group_dns is not None:
            _setter("cluster_users_group_dns", cluster_users_group_dns)

    @property
    @pulumi.getter(name="aaddsResourceId")
    def aadds_resource_id(self) -> str:
        """
        The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "aadds_resource_id")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainUserPassword")
    def domain_user_password(self) -> str:
        """
        The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_user_password")

    @property
    @pulumi.getter(name="domainUsername")
    def domain_username(self) -> str:
        """
        The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_username")

    @property
    @pulumi.getter(name="ldapsUrls")
    def ldaps_urls(self) -> Sequence[str]:
        """
        A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ldaps_urls")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> str:
        """
        The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "msi_resource_id")

    @property
    @pulumi.getter(name="clusterUsersGroupDns")
    def cluster_users_group_dns(self) -> Optional[Sequence[str]]:
        """
        A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cluster_users_group_dns")


@pulumi.output_type
class HBaseClusterStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageContainerId":
            suggest = "storage_container_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_default: bool,
                 storage_account_key: str,
                 storage_container_id: str,
                 storage_resource_id: Optional[str] = None):
        """
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str storage_account_key: The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        :param str storage_container_id: The ID of the Storage Container. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        HBaseClusterStorageAccount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_default=is_default,
            storage_account_key=storage_account_key,
            storage_container_id=storage_container_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_default: bool,
             storage_account_key: str,
             storage_container_id: str,
             storage_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_default", is_default)
        _setter("storage_account_key", storage_account_key)
        _setter("storage_container_id", storage_container_id)
        if storage_resource_id is not None:
            _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> str:
        """
        The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @property
    @pulumi.getter(name="storageContainerId")
    def storage_container_id(self) -> str:
        """
        The ID of the Storage Container. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "storage_container_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> Optional[str]:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class HBaseClusterStorageAccountGen2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesystemId":
            suggest = "filesystem_id"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "managedIdentityResourceId":
            suggest = "managed_identity_resource_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HBaseClusterStorageAccountGen2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HBaseClusterStorageAccountGen2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HBaseClusterStorageAccountGen2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filesystem_id: str,
                 is_default: bool,
                 managed_identity_resource_id: str,
                 storage_resource_id: str):
        """
        :param str filesystem_id: The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str managed_identity_resource_id: The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        HBaseClusterStorageAccountGen2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filesystem_id=filesystem_id,
            is_default=is_default,
            managed_identity_resource_id=managed_identity_resource_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filesystem_id: str,
             is_default: bool,
             managed_identity_resource_id: str,
             storage_resource_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filesystem_id", filesystem_id)
        _setter("is_default", is_default)
        _setter("managed_identity_resource_id", managed_identity_resource_id)
        _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> str:
        """
        The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "filesystem_id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="managedIdentityResourceId")
    def managed_identity_resource_id(self) -> str:
        """
        The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "managed_identity_resource_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> str:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class HadoopClusterComponentVersion(dict):
    def __init__(__self__, *,
                 hadoop: str):
        """
        :param str hadoop: The version of Hadoop which should be used for this HDInsight Hadoop Cluster. Changing this forces a new resource to be created.
        """
        HadoopClusterComponentVersion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hadoop=hadoop,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hadoop: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hadoop", hadoop)

    @property
    @pulumi.getter
    def hadoop(self) -> str:
        """
        The version of Hadoop which should be used for this HDInsight Hadoop Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "hadoop")


@pulumi.output_type
class HadoopClusterComputeIsolation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeIsolationEnabled":
            suggest = "compute_isolation_enabled"
        elif key == "hostSku":
            suggest = "host_sku"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterComputeIsolation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterComputeIsolation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterComputeIsolation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_isolation_enabled: Optional[bool] = None,
                 host_sku: Optional[str] = None):
        """
        :param bool compute_isolation_enabled: This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        :param str host_sku: The name of the host SKU.
        """
        HadoopClusterComputeIsolation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_isolation_enabled=compute_isolation_enabled,
            host_sku=host_sku,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_isolation_enabled: Optional[bool] = None,
             host_sku: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compute_isolation_enabled is not None:
            _setter("compute_isolation_enabled", compute_isolation_enabled)
        if host_sku is not None:
            _setter("host_sku", host_sku)

    @property
    @pulumi.getter(name="computeIsolationEnabled")
    def compute_isolation_enabled(self) -> Optional[bool]:
        """
        This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        """
        return pulumi.get(self, "compute_isolation_enabled")

    @property
    @pulumi.getter(name="hostSku")
    def host_sku(self) -> Optional[str]:
        """
        The name of the host SKU.
        """
        return pulumi.get(self, "host_sku")


@pulumi.output_type
class HadoopClusterDiskEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "encryptionAtHostEnabled":
            suggest = "encryption_at_host_enabled"
        elif key == "keyVaultKeyId":
            suggest = "key_vault_key_id"
        elif key == "keyVaultManagedIdentityId":
            suggest = "key_vault_managed_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterDiskEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterDiskEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterDiskEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: Optional[str] = None,
                 encryption_at_host_enabled: Optional[bool] = None,
                 key_vault_key_id: Optional[str] = None,
                 key_vault_managed_identity_id: Optional[str] = None):
        """
        :param str encryption_algorithm: This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        :param bool encryption_at_host_enabled: This is indicator to show whether resource disk encryption is enabled.
        :param str key_vault_key_id: The ID of the key vault key.
        :param str key_vault_managed_identity_id: This is the resource ID of Managed Identity used to access the key vault.
        """
        HadoopClusterDiskEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encryption_algorithm=encryption_algorithm,
            encryption_at_host_enabled=encryption_at_host_enabled,
            key_vault_key_id=key_vault_key_id,
            key_vault_managed_identity_id=key_vault_managed_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encryption_algorithm: Optional[str] = None,
             encryption_at_host_enabled: Optional[bool] = None,
             key_vault_key_id: Optional[str] = None,
             key_vault_managed_identity_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if encryption_algorithm is not None:
            _setter("encryption_algorithm", encryption_algorithm)
        if encryption_at_host_enabled is not None:
            _setter("encryption_at_host_enabled", encryption_at_host_enabled)
        if key_vault_key_id is not None:
            _setter("key_vault_key_id", key_vault_key_id)
        if key_vault_managed_identity_id is not None:
            _setter("key_vault_managed_identity_id", key_vault_managed_identity_id)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[str]:
        """
        This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter(name="encryptionAtHostEnabled")
    def encryption_at_host_enabled(self) -> Optional[bool]:
        """
        This is indicator to show whether resource disk encryption is enabled.
        """
        return pulumi.get(self, "encryption_at_host_enabled")

    @property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> Optional[str]:
        """
        The ID of the key vault key.
        """
        return pulumi.get(self, "key_vault_key_id")

    @property
    @pulumi.getter(name="keyVaultManagedIdentityId")
    def key_vault_managed_identity_id(self) -> Optional[str]:
        """
        This is the resource ID of Managed Identity used to access the key vault.
        """
        return pulumi.get(self, "key_vault_managed_identity_id")


@pulumi.output_type
class HadoopClusterExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The workspace ID of the log analytics extension.
        :param str primary_key: The workspace key of the log analytics extension.
        """
        HadoopClusterExtension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The workspace ID of the log analytics extension.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The workspace key of the log analytics extension.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class HadoopClusterGateway(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password used for the Ambari Portal.
               
               > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        :param str username: The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        HadoopClusterGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password used for the Ambari Portal.

        > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class HadoopClusterMetastores(dict):
    def __init__(__self__, *,
                 ambari: Optional['outputs.HadoopClusterMetastoresAmbari'] = None,
                 hive: Optional['outputs.HadoopClusterMetastoresHive'] = None,
                 oozie: Optional['outputs.HadoopClusterMetastoresOozie'] = None):
        """
        :param 'HadoopClusterMetastoresAmbariArgs' ambari: An `ambari` block as defined below.
        :param 'HadoopClusterMetastoresHiveArgs' hive: A `hive` block as defined below.
        :param 'HadoopClusterMetastoresOozieArgs' oozie: An `oozie` block as defined below.
        """
        HadoopClusterMetastores._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ambari=ambari,
            hive=hive,
            oozie=oozie,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ambari: Optional['outputs.HadoopClusterMetastoresAmbari'] = None,
             hive: Optional['outputs.HadoopClusterMetastoresHive'] = None,
             oozie: Optional['outputs.HadoopClusterMetastoresOozie'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ambari is not None:
            _setter("ambari", ambari)
        if hive is not None:
            _setter("hive", hive)
        if oozie is not None:
            _setter("oozie", oozie)

    @property
    @pulumi.getter
    def ambari(self) -> Optional['outputs.HadoopClusterMetastoresAmbari']:
        """
        An `ambari` block as defined below.
        """
        return pulumi.get(self, "ambari")

    @property
    @pulumi.getter
    def hive(self) -> Optional['outputs.HadoopClusterMetastoresHive']:
        """
        A `hive` block as defined below.
        """
        return pulumi.get(self, "hive")

    @property
    @pulumi.getter
    def oozie(self) -> Optional['outputs.HadoopClusterMetastoresOozie']:
        """
        An `oozie` block as defined below.
        """
        return pulumi.get(self, "oozie")


@pulumi.output_type
class HadoopClusterMetastoresAmbari(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterMetastoresAmbari. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterMetastoresAmbari.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterMetastoresAmbari.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        :param str username: The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        HadoopClusterMetastoresAmbari._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class HadoopClusterMetastoresHive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterMetastoresHive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterMetastoresHive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterMetastoresHive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        :param str username: The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        HadoopClusterMetastoresHive._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class HadoopClusterMetastoresOozie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterMetastoresOozie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterMetastoresOozie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterMetastoresOozie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        :param str username: The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        HadoopClusterMetastoresOozie._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class HadoopClusterMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The Operations Management Suite (OMS) workspace ID.
        :param str primary_key: The Operations Management Suite (OMS) workspace key.
        """
        HadoopClusterMonitor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The Operations Management Suite (OMS) workspace ID.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The Operations Management Suite (OMS) workspace key.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class HadoopClusterNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionDirection":
            suggest = "connection_direction"
        elif key == "privateLinkEnabled":
            suggest = "private_link_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_direction: Optional[str] = None,
                 private_link_enabled: Optional[bool] = None):
        """
        :param str connection_direction: The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
               
               > **NOTE:** To enabled the private link the `connection_direction` must be set to `Outbound`.
        :param bool private_link_enabled: Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        HadoopClusterNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_direction=connection_direction,
            private_link_enabled=private_link_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_direction: Optional[str] = None,
             private_link_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_direction is not None:
            _setter("connection_direction", connection_direction)
        if private_link_enabled is not None:
            _setter("private_link_enabled", private_link_enabled)

    @property
    @pulumi.getter(name="connectionDirection")
    def connection_direction(self) -> Optional[str]:
        """
        The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.

        > **NOTE:** To enabled the private link the `connection_direction` must be set to `Outbound`.
        """
        return pulumi.get(self, "connection_direction")

    @property
    @pulumi.getter(name="privateLinkEnabled")
    def private_link_enabled(self) -> Optional[bool]:
        """
        Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "private_link_enabled")


@pulumi.output_type
class HadoopClusterRoles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headNode":
            suggest = "head_node"
        elif key == "workerNode":
            suggest = "worker_node"
        elif key == "zookeeperNode":
            suggest = "zookeeper_node"
        elif key == "edgeNode":
            suggest = "edge_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterRoles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterRoles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterRoles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 head_node: 'outputs.HadoopClusterRolesHeadNode',
                 worker_node: 'outputs.HadoopClusterRolesWorkerNode',
                 zookeeper_node: 'outputs.HadoopClusterRolesZookeeperNode',
                 edge_node: Optional['outputs.HadoopClusterRolesEdgeNode'] = None):
        """
        :param 'HadoopClusterRolesHeadNodeArgs' head_node: A `head_node` block as defined above.
        :param 'HadoopClusterRolesWorkerNodeArgs' worker_node: A `worker_node` block as defined below.
        :param 'HadoopClusterRolesZookeeperNodeArgs' zookeeper_node: A `zookeeper_node` block as defined below.
        :param 'HadoopClusterRolesEdgeNodeArgs' edge_node: A `edge_node` block as defined below.
        """
        HadoopClusterRoles._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            head_node=head_node,
            worker_node=worker_node,
            zookeeper_node=zookeeper_node,
            edge_node=edge_node,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             head_node: 'outputs.HadoopClusterRolesHeadNode',
             worker_node: 'outputs.HadoopClusterRolesWorkerNode',
             zookeeper_node: 'outputs.HadoopClusterRolesZookeeperNode',
             edge_node: Optional['outputs.HadoopClusterRolesEdgeNode'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("head_node", head_node)
        _setter("worker_node", worker_node)
        _setter("zookeeper_node", zookeeper_node)
        if edge_node is not None:
            _setter("edge_node", edge_node)

    @property
    @pulumi.getter(name="headNode")
    def head_node(self) -> 'outputs.HadoopClusterRolesHeadNode':
        """
        A `head_node` block as defined above.
        """
        return pulumi.get(self, "head_node")

    @property
    @pulumi.getter(name="workerNode")
    def worker_node(self) -> 'outputs.HadoopClusterRolesWorkerNode':
        """
        A `worker_node` block as defined below.
        """
        return pulumi.get(self, "worker_node")

    @property
    @pulumi.getter(name="zookeeperNode")
    def zookeeper_node(self) -> 'outputs.HadoopClusterRolesZookeeperNode':
        """
        A `zookeeper_node` block as defined below.
        """
        return pulumi.get(self, "zookeeper_node")

    @property
    @pulumi.getter(name="edgeNode")
    def edge_node(self) -> Optional['outputs.HadoopClusterRolesEdgeNode']:
        """
        A `edge_node` block as defined below.
        """
        return pulumi.get(self, "edge_node")


@pulumi.output_type
class HadoopClusterRolesEdgeNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "installScriptActions":
            suggest = "install_script_actions"
        elif key == "targetInstanceCount":
            suggest = "target_instance_count"
        elif key == "vmSize":
            suggest = "vm_size"
        elif key == "httpsEndpoints":
            suggest = "https_endpoints"
        elif key == "uninstallScriptActions":
            suggest = "uninstall_script_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterRolesEdgeNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterRolesEdgeNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterRolesEdgeNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 install_script_actions: Sequence['outputs.HadoopClusterRolesEdgeNodeInstallScriptAction'],
                 target_instance_count: int,
                 vm_size: str,
                 https_endpoints: Optional[Sequence['outputs.HadoopClusterRolesEdgeNodeHttpsEndpoint']] = None,
                 uninstall_script_actions: Optional[Sequence['outputs.HadoopClusterRolesEdgeNodeUninstallScriptAction']] = None):
        """
        :param Sequence['HadoopClusterRolesEdgeNodeInstallScriptActionArgs'] install_script_actions: A `install_script_action` block as defined below.
        :param int target_instance_count: The number of instances which should be run for the Worker Nodes.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Edge Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`.
        :param Sequence['HadoopClusterRolesEdgeNodeHttpsEndpointArgs'] https_endpoints: The HTTPS Connectivity Endpoint for this HDInsight Hadoop Cluster.
        :param Sequence['HadoopClusterRolesEdgeNodeUninstallScriptActionArgs'] uninstall_script_actions: A `uninstall_script_actions` block as defined below. Changing this forces a new resource to be created.
        """
        HadoopClusterRolesEdgeNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            install_script_actions=install_script_actions,
            target_instance_count=target_instance_count,
            vm_size=vm_size,
            https_endpoints=https_endpoints,
            uninstall_script_actions=uninstall_script_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             install_script_actions: Sequence['outputs.HadoopClusterRolesEdgeNodeInstallScriptAction'],
             target_instance_count: int,
             vm_size: str,
             https_endpoints: Optional[Sequence['outputs.HadoopClusterRolesEdgeNodeHttpsEndpoint']] = None,
             uninstall_script_actions: Optional[Sequence['outputs.HadoopClusterRolesEdgeNodeUninstallScriptAction']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("install_script_actions", install_script_actions)
        _setter("target_instance_count", target_instance_count)
        _setter("vm_size", vm_size)
        if https_endpoints is not None:
            _setter("https_endpoints", https_endpoints)
        if uninstall_script_actions is not None:
            _setter("uninstall_script_actions", uninstall_script_actions)

    @property
    @pulumi.getter(name="installScriptActions")
    def install_script_actions(self) -> Sequence['outputs.HadoopClusterRolesEdgeNodeInstallScriptAction']:
        """
        A `install_script_action` block as defined below.
        """
        return pulumi.get(self, "install_script_actions")

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of instances which should be run for the Worker Nodes.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Edge Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter(name="httpsEndpoints")
    def https_endpoints(self) -> Optional[Sequence['outputs.HadoopClusterRolesEdgeNodeHttpsEndpoint']]:
        """
        The HTTPS Connectivity Endpoint for this HDInsight Hadoop Cluster.
        """
        return pulumi.get(self, "https_endpoints")

    @property
    @pulumi.getter(name="uninstallScriptActions")
    def uninstall_script_actions(self) -> Optional[Sequence['outputs.HadoopClusterRolesEdgeNodeUninstallScriptAction']]:
        """
        A `uninstall_script_actions` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "uninstall_script_actions")


@pulumi.output_type
class HadoopClusterRolesEdgeNodeHttpsEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessModes":
            suggest = "access_modes"
        elif key == "destinationPort":
            suggest = "destination_port"
        elif key == "disableGatewayAuth":
            suggest = "disable_gateway_auth"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "subDomainSuffix":
            suggest = "sub_domain_suffix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterRolesEdgeNodeHttpsEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterRolesEdgeNodeHttpsEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterRolesEdgeNodeHttpsEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_modes: Optional[Sequence[str]] = None,
                 destination_port: Optional[int] = None,
                 disable_gateway_auth: Optional[bool] = None,
                 private_ip_address: Optional[str] = None,
                 sub_domain_suffix: Optional[str] = None):
        """
        :param Sequence[str] access_modes: A list of access modes for the application.
        :param int destination_port: The destination port to connect to.
        :param bool disable_gateway_auth: The value indicates whether the gateway authentication is enabled or not.
        :param str private_ip_address: The private ip address of the endpoint.
        :param str sub_domain_suffix: The application's subdomain suffix.
        """
        HadoopClusterRolesEdgeNodeHttpsEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_modes=access_modes,
            destination_port=destination_port,
            disable_gateway_auth=disable_gateway_auth,
            private_ip_address=private_ip_address,
            sub_domain_suffix=sub_domain_suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_modes: Optional[Sequence[str]] = None,
             destination_port: Optional[int] = None,
             disable_gateway_auth: Optional[bool] = None,
             private_ip_address: Optional[str] = None,
             sub_domain_suffix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access_modes is not None:
            _setter("access_modes", access_modes)
        if destination_port is not None:
            _setter("destination_port", destination_port)
        if disable_gateway_auth is not None:
            _setter("disable_gateway_auth", disable_gateway_auth)
        if private_ip_address is not None:
            _setter("private_ip_address", private_ip_address)
        if sub_domain_suffix is not None:
            _setter("sub_domain_suffix", sub_domain_suffix)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Optional[Sequence[str]]:
        """
        A list of access modes for the application.
        """
        return pulumi.get(self, "access_modes")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[int]:
        """
        The destination port to connect to.
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter(name="disableGatewayAuth")
    def disable_gateway_auth(self) -> Optional[bool]:
        """
        The value indicates whether the gateway authentication is enabled or not.
        """
        return pulumi.get(self, "disable_gateway_auth")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private ip address of the endpoint.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="subDomainSuffix")
    def sub_domain_suffix(self) -> Optional[str]:
        """
        The application's subdomain suffix.
        """
        return pulumi.get(self, "sub_domain_suffix")


@pulumi.output_type
class HadoopClusterRolesEdgeNodeInstallScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the install script action.
        :param str uri: The URI pointing to the script to run during the installation of the edge node.
        :param str parameters: The parameters for the script.
        """
        HadoopClusterRolesEdgeNodeInstallScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the install script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI pointing to the script to run during the installation of the edge node.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class HadoopClusterRolesEdgeNodeUninstallScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the uninstall script action.
        :param str uri: The URI pointing to the script to run during the installation of the edge node.
        :param str parameters: The parameters for the script.
        """
        HadoopClusterRolesEdgeNodeUninstallScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the uninstall script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI pointing to the script to run during the installation of the edge node.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class HadoopClusterRolesHeadNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterRolesHeadNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterRolesHeadNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterRolesHeadNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.HadoopClusterRolesHeadNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['HadoopClusterRolesHeadNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        HadoopClusterRolesHeadNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.HadoopClusterRolesHeadNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.HadoopClusterRolesHeadNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class HadoopClusterRolesHeadNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        HadoopClusterRolesHeadNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class HadoopClusterRolesWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetInstanceCount":
            suggest = "target_instance_count"
        elif key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterRolesWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterRolesWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterRolesWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_instance_count: int,
                 username: str,
                 vm_size: str,
                 autoscale: Optional['outputs.HadoopClusterRolesWorkerNodeAutoscale'] = None,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.HadoopClusterRolesWorkerNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param int target_instance_count: The number of instances which should be run for the Worker Nodes.
        :param str username: The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param 'HadoopClusterRolesWorkerNodeAutoscaleArgs' autoscale: A `autoscale` block as defined below.
        :param str password: The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['HadoopClusterRolesWorkerNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        HadoopClusterRolesWorkerNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_instance_count=target_instance_count,
            username=username,
            vm_size=vm_size,
            autoscale=autoscale,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_instance_count: int,
             username: str,
             vm_size: str,
             autoscale: Optional['outputs.HadoopClusterRolesWorkerNodeAutoscale'] = None,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.HadoopClusterRolesWorkerNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_instance_count", target_instance_count)
        _setter("username", username)
        _setter("vm_size", vm_size)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of instances which should be run for the Worker Nodes.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.HadoopClusterRolesWorkerNodeAutoscale']:
        """
        A `autoscale` block as defined below.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.HadoopClusterRolesWorkerNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class HadoopClusterRolesWorkerNodeAutoscale(dict):
    def __init__(__self__, *,
                 capacity: Optional['outputs.HadoopClusterRolesWorkerNodeAutoscaleCapacity'] = None,
                 recurrence: Optional['outputs.HadoopClusterRolesWorkerNodeAutoscaleRecurrence'] = None):
        """
        :param 'HadoopClusterRolesWorkerNodeAutoscaleCapacityArgs' capacity: A `capacity` block as defined below.
        :param 'HadoopClusterRolesWorkerNodeAutoscaleRecurrenceArgs' recurrence: A `recurrence` block as defined below.
               
               > **NOTE:** Either a `capacity` or `recurrence` block must be specified - but not both.
        """
        HadoopClusterRolesWorkerNodeAutoscale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity=capacity,
            recurrence=recurrence,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity: Optional['outputs.HadoopClusterRolesWorkerNodeAutoscaleCapacity'] = None,
             recurrence: Optional['outputs.HadoopClusterRolesWorkerNodeAutoscaleRecurrence'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if capacity is not None:
            _setter("capacity", capacity)
        if recurrence is not None:
            _setter("recurrence", recurrence)

    @property
    @pulumi.getter
    def capacity(self) -> Optional['outputs.HadoopClusterRolesWorkerNodeAutoscaleCapacity']:
        """
        A `capacity` block as defined below.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.HadoopClusterRolesWorkerNodeAutoscaleRecurrence']:
        """
        A `recurrence` block as defined below.

        > **NOTE:** Either a `capacity` or `recurrence` block must be specified - but not both.
        """
        return pulumi.get(self, "recurrence")


@pulumi.output_type
class HadoopClusterRolesWorkerNodeAutoscaleCapacity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"
        elif key == "minInstanceCount":
            suggest = "min_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterRolesWorkerNodeAutoscaleCapacity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterRolesWorkerNodeAutoscaleCapacity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterRolesWorkerNodeAutoscaleCapacity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: int,
                 min_instance_count: int):
        """
        :param int max_instance_count: The maximum number of worker nodes to autoscale to based on the cluster's activity.
        :param int min_instance_count: The minimum number of worker nodes to autoscale to based on the cluster's activity.
        """
        HadoopClusterRolesWorkerNodeAutoscaleCapacity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_instance_count=max_instance_count,
            min_instance_count=min_instance_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_instance_count: int,
             min_instance_count: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_instance_count", max_instance_count)
        _setter("min_instance_count", min_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> int:
        """
        The maximum number of worker nodes to autoscale to based on the cluster's activity.
        """
        return pulumi.get(self, "max_instance_count")

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> int:
        """
        The minimum number of worker nodes to autoscale to based on the cluster's activity.
        """
        return pulumi.get(self, "min_instance_count")


@pulumi.output_type
class HadoopClusterRolesWorkerNodeAutoscaleRecurrence(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule'],
                 timezone: str):
        """
        :param Sequence['HadoopClusterRolesWorkerNodeAutoscaleRecurrenceScheduleArgs'] schedules: A list of `schedule` blocks as defined below.
        :param str timezone: The time zone for the autoscale schedule times.
        """
        HadoopClusterRolesWorkerNodeAutoscaleRecurrence._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schedules=schedules,
            timezone=timezone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schedules: Sequence['outputs.HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule'],
             timezone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("schedules", schedules)
        _setter("timezone", timezone)

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule']:
        """
        A list of `schedule` blocks as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        The time zone for the autoscale schedule times.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetInstanceCount":
            suggest = "target_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Sequence[str],
                 target_instance_count: int,
                 time: str):
        """
        :param Sequence[str] days: The days of the week to perform autoscale. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        :param int target_instance_count: The number of worker nodes to autoscale at the specified time.
        :param str time: The time of day to perform the autoscale in 24hour format.
        """
        HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days=days,
            target_instance_count=target_instance_count,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days: Sequence[str],
             target_instance_count: int,
             time: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("days", days)
        _setter("target_instance_count", target_instance_count)
        _setter("time", time)

    @property
    @pulumi.getter
    def days(self) -> Sequence[str]:
        """
        The days of the week to perform autoscale. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of worker nodes to autoscale at the specified time.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        The time of day to perform the autoscale in 24hour format.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class HadoopClusterRolesWorkerNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        HadoopClusterRolesWorkerNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class HadoopClusterRolesZookeeperNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterRolesZookeeperNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterRolesZookeeperNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterRolesZookeeperNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.HadoopClusterRolesZookeeperNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['HadoopClusterRolesZookeeperNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        HadoopClusterRolesZookeeperNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.HadoopClusterRolesZookeeperNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.HadoopClusterRolesZookeeperNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class HadoopClusterRolesZookeeperNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        HadoopClusterRolesZookeeperNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class HadoopClusterSecurityProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aaddsResourceId":
            suggest = "aadds_resource_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "domainUserPassword":
            suggest = "domain_user_password"
        elif key == "domainUsername":
            suggest = "domain_username"
        elif key == "ldapsUrls":
            suggest = "ldaps_urls"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"
        elif key == "clusterUsersGroupDns":
            suggest = "cluster_users_group_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterSecurityProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterSecurityProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterSecurityProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aadds_resource_id: str,
                 domain_name: str,
                 domain_user_password: str,
                 domain_username: str,
                 ldaps_urls: Sequence[str],
                 msi_resource_id: str,
                 cluster_users_group_dns: Optional[Sequence[str]] = None):
        """
        :param str aadds_resource_id: The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        :param str domain_name: The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_user_password: The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_username: The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param Sequence[str] ldaps_urls: A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        :param str msi_resource_id: The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        :param Sequence[str] cluster_users_group_dns: A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        HadoopClusterSecurityProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aadds_resource_id=aadds_resource_id,
            domain_name=domain_name,
            domain_user_password=domain_user_password,
            domain_username=domain_username,
            ldaps_urls=ldaps_urls,
            msi_resource_id=msi_resource_id,
            cluster_users_group_dns=cluster_users_group_dns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aadds_resource_id: str,
             domain_name: str,
             domain_user_password: str,
             domain_username: str,
             ldaps_urls: Sequence[str],
             msi_resource_id: str,
             cluster_users_group_dns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aadds_resource_id", aadds_resource_id)
        _setter("domain_name", domain_name)
        _setter("domain_user_password", domain_user_password)
        _setter("domain_username", domain_username)
        _setter("ldaps_urls", ldaps_urls)
        _setter("msi_resource_id", msi_resource_id)
        if cluster_users_group_dns is not None:
            _setter("cluster_users_group_dns", cluster_users_group_dns)

    @property
    @pulumi.getter(name="aaddsResourceId")
    def aadds_resource_id(self) -> str:
        """
        The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "aadds_resource_id")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainUserPassword")
    def domain_user_password(self) -> str:
        """
        The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_user_password")

    @property
    @pulumi.getter(name="domainUsername")
    def domain_username(self) -> str:
        """
        The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_username")

    @property
    @pulumi.getter(name="ldapsUrls")
    def ldaps_urls(self) -> Sequence[str]:
        """
        A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ldaps_urls")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> str:
        """
        The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "msi_resource_id")

    @property
    @pulumi.getter(name="clusterUsersGroupDns")
    def cluster_users_group_dns(self) -> Optional[Sequence[str]]:
        """
        A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cluster_users_group_dns")


@pulumi.output_type
class HadoopClusterStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageContainerId":
            suggest = "storage_container_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_default: bool,
                 storage_account_key: str,
                 storage_container_id: str,
                 storage_resource_id: Optional[str] = None):
        """
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str storage_account_key: The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        :param str storage_container_id: The ID of the Storage Container. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        HadoopClusterStorageAccount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_default=is_default,
            storage_account_key=storage_account_key,
            storage_container_id=storage_container_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_default: bool,
             storage_account_key: str,
             storage_container_id: str,
             storage_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_default", is_default)
        _setter("storage_account_key", storage_account_key)
        _setter("storage_container_id", storage_container_id)
        if storage_resource_id is not None:
            _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> str:
        """
        The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @property
    @pulumi.getter(name="storageContainerId")
    def storage_container_id(self) -> str:
        """
        The ID of the Storage Container. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "storage_container_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> Optional[str]:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class HadoopClusterStorageAccountGen2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesystemId":
            suggest = "filesystem_id"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "managedIdentityResourceId":
            suggest = "managed_identity_resource_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HadoopClusterStorageAccountGen2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HadoopClusterStorageAccountGen2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HadoopClusterStorageAccountGen2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filesystem_id: str,
                 is_default: bool,
                 managed_identity_resource_id: str,
                 storage_resource_id: str):
        """
        :param str filesystem_id: The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str managed_identity_resource_id: The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        HadoopClusterStorageAccountGen2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filesystem_id=filesystem_id,
            is_default=is_default,
            managed_identity_resource_id=managed_identity_resource_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filesystem_id: str,
             is_default: bool,
             managed_identity_resource_id: str,
             storage_resource_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filesystem_id", filesystem_id)
        _setter("is_default", is_default)
        _setter("managed_identity_resource_id", managed_identity_resource_id)
        _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> str:
        """
        The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "filesystem_id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="managedIdentityResourceId")
    def managed_identity_resource_id(self) -> str:
        """
        The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "managed_identity_resource_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> str:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class InteractiveQueryClusterComponentVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interactiveHive":
            suggest = "interactive_hive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterComponentVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterComponentVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterComponentVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interactive_hive: str):
        """
        :param str interactive_hive: The version of Interactive Query which should be used for this HDInsight Interactive Query Cluster. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterComponentVersion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interactive_hive=interactive_hive,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interactive_hive: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("interactive_hive", interactive_hive)

    @property
    @pulumi.getter(name="interactiveHive")
    def interactive_hive(self) -> str:
        """
        The version of Interactive Query which should be used for this HDInsight Interactive Query Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "interactive_hive")


@pulumi.output_type
class InteractiveQueryClusterComputeIsolation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeIsolationEnabled":
            suggest = "compute_isolation_enabled"
        elif key == "hostSku":
            suggest = "host_sku"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterComputeIsolation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterComputeIsolation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterComputeIsolation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_isolation_enabled: Optional[bool] = None,
                 host_sku: Optional[str] = None):
        """
        :param bool compute_isolation_enabled: This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        :param str host_sku: The name of the host SKU.
        """
        InteractiveQueryClusterComputeIsolation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_isolation_enabled=compute_isolation_enabled,
            host_sku=host_sku,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_isolation_enabled: Optional[bool] = None,
             host_sku: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compute_isolation_enabled is not None:
            _setter("compute_isolation_enabled", compute_isolation_enabled)
        if host_sku is not None:
            _setter("host_sku", host_sku)

    @property
    @pulumi.getter(name="computeIsolationEnabled")
    def compute_isolation_enabled(self) -> Optional[bool]:
        """
        This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        """
        return pulumi.get(self, "compute_isolation_enabled")

    @property
    @pulumi.getter(name="hostSku")
    def host_sku(self) -> Optional[str]:
        """
        The name of the host SKU.
        """
        return pulumi.get(self, "host_sku")


@pulumi.output_type
class InteractiveQueryClusterDiskEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "encryptionAtHostEnabled":
            suggest = "encryption_at_host_enabled"
        elif key == "keyVaultKeyId":
            suggest = "key_vault_key_id"
        elif key == "keyVaultManagedIdentityId":
            suggest = "key_vault_managed_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterDiskEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterDiskEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterDiskEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: Optional[str] = None,
                 encryption_at_host_enabled: Optional[bool] = None,
                 key_vault_key_id: Optional[str] = None,
                 key_vault_managed_identity_id: Optional[str] = None):
        """
        :param str encryption_algorithm: This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        :param bool encryption_at_host_enabled: This is indicator to show whether resource disk encryption is enabled.
        :param str key_vault_key_id: The ID of the key vault key.
        :param str key_vault_managed_identity_id: This is the resource ID of Managed Identity used to access the key vault.
        """
        InteractiveQueryClusterDiskEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encryption_algorithm=encryption_algorithm,
            encryption_at_host_enabled=encryption_at_host_enabled,
            key_vault_key_id=key_vault_key_id,
            key_vault_managed_identity_id=key_vault_managed_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encryption_algorithm: Optional[str] = None,
             encryption_at_host_enabled: Optional[bool] = None,
             key_vault_key_id: Optional[str] = None,
             key_vault_managed_identity_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if encryption_algorithm is not None:
            _setter("encryption_algorithm", encryption_algorithm)
        if encryption_at_host_enabled is not None:
            _setter("encryption_at_host_enabled", encryption_at_host_enabled)
        if key_vault_key_id is not None:
            _setter("key_vault_key_id", key_vault_key_id)
        if key_vault_managed_identity_id is not None:
            _setter("key_vault_managed_identity_id", key_vault_managed_identity_id)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[str]:
        """
        This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter(name="encryptionAtHostEnabled")
    def encryption_at_host_enabled(self) -> Optional[bool]:
        """
        This is indicator to show whether resource disk encryption is enabled.
        """
        return pulumi.get(self, "encryption_at_host_enabled")

    @property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> Optional[str]:
        """
        The ID of the key vault key.
        """
        return pulumi.get(self, "key_vault_key_id")

    @property
    @pulumi.getter(name="keyVaultManagedIdentityId")
    def key_vault_managed_identity_id(self) -> Optional[str]:
        """
        This is the resource ID of Managed Identity used to access the key vault.
        """
        return pulumi.get(self, "key_vault_managed_identity_id")


@pulumi.output_type
class InteractiveQueryClusterExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The workspace ID of the log analytics extension.
        :param str primary_key: The workspace key of the log analytics extension.
        """
        InteractiveQueryClusterExtension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The workspace ID of the log analytics extension.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The workspace key of the log analytics extension.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class InteractiveQueryClusterGateway(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password used for the Ambari Portal.
               
               > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        :param str username: The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password used for the Ambari Portal.

        > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class InteractiveQueryClusterMetastores(dict):
    def __init__(__self__, *,
                 ambari: Optional['outputs.InteractiveQueryClusterMetastoresAmbari'] = None,
                 hive: Optional['outputs.InteractiveQueryClusterMetastoresHive'] = None,
                 oozie: Optional['outputs.InteractiveQueryClusterMetastoresOozie'] = None):
        """
        :param 'InteractiveQueryClusterMetastoresAmbariArgs' ambari: An `ambari` block as defined below.
        :param 'InteractiveQueryClusterMetastoresHiveArgs' hive: A `hive` block as defined below.
        :param 'InteractiveQueryClusterMetastoresOozieArgs' oozie: An `oozie` block as defined below.
        """
        InteractiveQueryClusterMetastores._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ambari=ambari,
            hive=hive,
            oozie=oozie,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ambari: Optional['outputs.InteractiveQueryClusterMetastoresAmbari'] = None,
             hive: Optional['outputs.InteractiveQueryClusterMetastoresHive'] = None,
             oozie: Optional['outputs.InteractiveQueryClusterMetastoresOozie'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ambari is not None:
            _setter("ambari", ambari)
        if hive is not None:
            _setter("hive", hive)
        if oozie is not None:
            _setter("oozie", oozie)

    @property
    @pulumi.getter
    def ambari(self) -> Optional['outputs.InteractiveQueryClusterMetastoresAmbari']:
        """
        An `ambari` block as defined below.
        """
        return pulumi.get(self, "ambari")

    @property
    @pulumi.getter
    def hive(self) -> Optional['outputs.InteractiveQueryClusterMetastoresHive']:
        """
        A `hive` block as defined below.
        """
        return pulumi.get(self, "hive")

    @property
    @pulumi.getter
    def oozie(self) -> Optional['outputs.InteractiveQueryClusterMetastoresOozie']:
        """
        An `oozie` block as defined below.
        """
        return pulumi.get(self, "oozie")


@pulumi.output_type
class InteractiveQueryClusterMetastoresAmbari(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterMetastoresAmbari. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterMetastoresAmbari.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterMetastoresAmbari.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        :param str username: The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterMetastoresAmbari._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class InteractiveQueryClusterMetastoresHive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterMetastoresHive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterMetastoresHive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterMetastoresHive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        :param str username: The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterMetastoresHive._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class InteractiveQueryClusterMetastoresOozie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterMetastoresOozie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterMetastoresOozie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterMetastoresOozie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        :param str username: The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterMetastoresOozie._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class InteractiveQueryClusterMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The Operations Management Suite (OMS) workspace ID.
        :param str primary_key: The Operations Management Suite (OMS) workspace key.
        """
        InteractiveQueryClusterMonitor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The Operations Management Suite (OMS) workspace ID.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The Operations Management Suite (OMS) workspace key.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class InteractiveQueryClusterNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionDirection":
            suggest = "connection_direction"
        elif key == "privateLinkEnabled":
            suggest = "private_link_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_direction: Optional[str] = None,
                 private_link_enabled: Optional[bool] = None):
        """
        :param str connection_direction: The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
               
               > **NOTE:** To enabled the private link the `connection_direction` must be set to `Outbound`.
        :param bool private_link_enabled: Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_direction=connection_direction,
            private_link_enabled=private_link_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_direction: Optional[str] = None,
             private_link_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_direction is not None:
            _setter("connection_direction", connection_direction)
        if private_link_enabled is not None:
            _setter("private_link_enabled", private_link_enabled)

    @property
    @pulumi.getter(name="connectionDirection")
    def connection_direction(self) -> Optional[str]:
        """
        The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.

        > **NOTE:** To enabled the private link the `connection_direction` must be set to `Outbound`.
        """
        return pulumi.get(self, "connection_direction")

    @property
    @pulumi.getter(name="privateLinkEnabled")
    def private_link_enabled(self) -> Optional[bool]:
        """
        Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "private_link_enabled")


@pulumi.output_type
class InteractiveQueryClusterRoles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headNode":
            suggest = "head_node"
        elif key == "workerNode":
            suggest = "worker_node"
        elif key == "zookeeperNode":
            suggest = "zookeeper_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterRoles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterRoles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterRoles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 head_node: 'outputs.InteractiveQueryClusterRolesHeadNode',
                 worker_node: 'outputs.InteractiveQueryClusterRolesWorkerNode',
                 zookeeper_node: 'outputs.InteractiveQueryClusterRolesZookeeperNode'):
        """
        :param 'InteractiveQueryClusterRolesHeadNodeArgs' head_node: A `head_node` block as defined above.
        :param 'InteractiveQueryClusterRolesWorkerNodeArgs' worker_node: A `worker_node` block as defined below.
        :param 'InteractiveQueryClusterRolesZookeeperNodeArgs' zookeeper_node: A `zookeeper_node` block as defined below.
        """
        InteractiveQueryClusterRoles._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            head_node=head_node,
            worker_node=worker_node,
            zookeeper_node=zookeeper_node,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             head_node: 'outputs.InteractiveQueryClusterRolesHeadNode',
             worker_node: 'outputs.InteractiveQueryClusterRolesWorkerNode',
             zookeeper_node: 'outputs.InteractiveQueryClusterRolesZookeeperNode',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("head_node", head_node)
        _setter("worker_node", worker_node)
        _setter("zookeeper_node", zookeeper_node)

    @property
    @pulumi.getter(name="headNode")
    def head_node(self) -> 'outputs.InteractiveQueryClusterRolesHeadNode':
        """
        A `head_node` block as defined above.
        """
        return pulumi.get(self, "head_node")

    @property
    @pulumi.getter(name="workerNode")
    def worker_node(self) -> 'outputs.InteractiveQueryClusterRolesWorkerNode':
        """
        A `worker_node` block as defined below.
        """
        return pulumi.get(self, "worker_node")

    @property
    @pulumi.getter(name="zookeeperNode")
    def zookeeper_node(self) -> 'outputs.InteractiveQueryClusterRolesZookeeperNode':
        """
        A `zookeeper_node` block as defined below.
        """
        return pulumi.get(self, "zookeeper_node")


@pulumi.output_type
class InteractiveQueryClusterRolesHeadNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterRolesHeadNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterRolesHeadNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterRolesHeadNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.InteractiveQueryClusterRolesHeadNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
               
               > **NOTE:** High memory instances must be specified for the Head Node (Azure suggests a `Standard_D13_V2`).
        :param str password: The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['InteractiveQueryClusterRolesHeadNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterRolesHeadNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.InteractiveQueryClusterRolesHeadNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.

        > **NOTE:** High memory instances must be specified for the Head Node (Azure suggests a `Standard_D13_V2`).
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.InteractiveQueryClusterRolesHeadNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class InteractiveQueryClusterRolesHeadNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        InteractiveQueryClusterRolesHeadNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class InteractiveQueryClusterRolesWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetInstanceCount":
            suggest = "target_instance_count"
        elif key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterRolesWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterRolesWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterRolesWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_instance_count: int,
                 username: str,
                 vm_size: str,
                 autoscale: Optional['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscale'] = None,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.InteractiveQueryClusterRolesWorkerNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param int target_instance_count: The number of instances which should be run for the Worker Nodes.
        :param str username: The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
               
               > **NOTE:** High memory instances must be specified for the Head Node (Azure suggests a `Standard_D14_V2`).
        :param 'InteractiveQueryClusterRolesWorkerNodeAutoscaleArgs' autoscale: A `autoscale` block as defined below.
        :param str password: The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['InteractiveQueryClusterRolesWorkerNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterRolesWorkerNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_instance_count=target_instance_count,
            username=username,
            vm_size=vm_size,
            autoscale=autoscale,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_instance_count: int,
             username: str,
             vm_size: str,
             autoscale: Optional['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscale'] = None,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.InteractiveQueryClusterRolesWorkerNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_instance_count", target_instance_count)
        _setter("username", username)
        _setter("vm_size", vm_size)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of instances which should be run for the Worker Nodes.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.

        > **NOTE:** High memory instances must be specified for the Head Node (Azure suggests a `Standard_D14_V2`).
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscale']:
        """
        A `autoscale` block as defined below.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.InteractiveQueryClusterRolesWorkerNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class InteractiveQueryClusterRolesWorkerNodeAutoscale(dict):
    def __init__(__self__, *,
                 capacity: Optional['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity'] = None,
                 recurrence: Optional['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence'] = None):
        """
        :param 'InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceArgs' recurrence: A `recurrence` block as defined below.
        """
        InteractiveQueryClusterRolesWorkerNodeAutoscale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity=capacity,
            recurrence=recurrence,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity: Optional['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity'] = None,
             recurrence: Optional['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if capacity is not None:
            _setter("capacity", capacity)
        if recurrence is not None:
            _setter("recurrence", recurrence)

    @property
    @pulumi.getter
    def capacity(self) -> Optional['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity']:
        warnings.warn("""HDInsight interactive query clusters can no longer be configured through `autoscale.0.capacity`. Use `autoscale.0.recurrence` instead.""", DeprecationWarning)
        pulumi.log.warn("""capacity is deprecated: HDInsight interactive query clusters can no longer be configured through `autoscale.0.capacity`. Use `autoscale.0.recurrence` instead.""")

        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence']:
        """
        A `recurrence` block as defined below.
        """
        return pulumi.get(self, "recurrence")


@pulumi.output_type
class InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"
        elif key == "minInstanceCount":
            suggest = "min_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: int,
                 min_instance_count: int):
        InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_instance_count=max_instance_count,
            min_instance_count=min_instance_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_instance_count: int,
             min_instance_count: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_instance_count", max_instance_count)
        _setter("min_instance_count", min_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> int:
        return pulumi.get(self, "max_instance_count")

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> int:
        return pulumi.get(self, "min_instance_count")


@pulumi.output_type
class InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule'],
                 timezone: str):
        """
        :param Sequence['InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceScheduleArgs'] schedules: A list of `schedule` blocks as defined below.
        :param str timezone: The time zone for the autoscale schedule times.
        """
        InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schedules=schedules,
            timezone=timezone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schedules: Sequence['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule'],
             timezone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("schedules", schedules)
        _setter("timezone", timezone)

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule']:
        """
        A list of `schedule` blocks as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        The time zone for the autoscale schedule times.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetInstanceCount":
            suggest = "target_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Sequence[str],
                 target_instance_count: int,
                 time: str):
        """
        :param Sequence[str] days: The days of the week to perform autoscale. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        :param int target_instance_count: The number of worker nodes to autoscale at the specified time.
        :param str time: The time of day to perform the autoscale in 24hour format.
        """
        InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days=days,
            target_instance_count=target_instance_count,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days: Sequence[str],
             target_instance_count: int,
             time: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("days", days)
        _setter("target_instance_count", target_instance_count)
        _setter("time", time)

    @property
    @pulumi.getter
    def days(self) -> Sequence[str]:
        """
        The days of the week to perform autoscale. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of worker nodes to autoscale at the specified time.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        The time of day to perform the autoscale in 24hour format.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class InteractiveQueryClusterRolesWorkerNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        InteractiveQueryClusterRolesWorkerNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class InteractiveQueryClusterRolesZookeeperNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterRolesZookeeperNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterRolesZookeeperNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterRolesZookeeperNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.InteractiveQueryClusterRolesZookeeperNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['InteractiveQueryClusterRolesZookeeperNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterRolesZookeeperNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.InteractiveQueryClusterRolesZookeeperNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.InteractiveQueryClusterRolesZookeeperNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class InteractiveQueryClusterRolesZookeeperNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        InteractiveQueryClusterRolesZookeeperNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class InteractiveQueryClusterSecurityProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aaddsResourceId":
            suggest = "aadds_resource_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "domainUserPassword":
            suggest = "domain_user_password"
        elif key == "domainUsername":
            suggest = "domain_username"
        elif key == "ldapsUrls":
            suggest = "ldaps_urls"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"
        elif key == "clusterUsersGroupDns":
            suggest = "cluster_users_group_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterSecurityProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterSecurityProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterSecurityProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aadds_resource_id: str,
                 domain_name: str,
                 domain_user_password: str,
                 domain_username: str,
                 ldaps_urls: Sequence[str],
                 msi_resource_id: str,
                 cluster_users_group_dns: Optional[Sequence[str]] = None):
        """
        :param str aadds_resource_id: The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        :param str domain_name: The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_user_password: The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_username: The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param Sequence[str] ldaps_urls: A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        :param str msi_resource_id: The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        :param Sequence[str] cluster_users_group_dns: A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterSecurityProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aadds_resource_id=aadds_resource_id,
            domain_name=domain_name,
            domain_user_password=domain_user_password,
            domain_username=domain_username,
            ldaps_urls=ldaps_urls,
            msi_resource_id=msi_resource_id,
            cluster_users_group_dns=cluster_users_group_dns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aadds_resource_id: str,
             domain_name: str,
             domain_user_password: str,
             domain_username: str,
             ldaps_urls: Sequence[str],
             msi_resource_id: str,
             cluster_users_group_dns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aadds_resource_id", aadds_resource_id)
        _setter("domain_name", domain_name)
        _setter("domain_user_password", domain_user_password)
        _setter("domain_username", domain_username)
        _setter("ldaps_urls", ldaps_urls)
        _setter("msi_resource_id", msi_resource_id)
        if cluster_users_group_dns is not None:
            _setter("cluster_users_group_dns", cluster_users_group_dns)

    @property
    @pulumi.getter(name="aaddsResourceId")
    def aadds_resource_id(self) -> str:
        """
        The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "aadds_resource_id")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainUserPassword")
    def domain_user_password(self) -> str:
        """
        The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_user_password")

    @property
    @pulumi.getter(name="domainUsername")
    def domain_username(self) -> str:
        """
        The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_username")

    @property
    @pulumi.getter(name="ldapsUrls")
    def ldaps_urls(self) -> Sequence[str]:
        """
        A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ldaps_urls")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> str:
        """
        The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "msi_resource_id")

    @property
    @pulumi.getter(name="clusterUsersGroupDns")
    def cluster_users_group_dns(self) -> Optional[Sequence[str]]:
        """
        A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cluster_users_group_dns")


@pulumi.output_type
class InteractiveQueryClusterStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageContainerId":
            suggest = "storage_container_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_default: bool,
                 storage_account_key: str,
                 storage_container_id: str,
                 storage_resource_id: Optional[str] = None):
        """
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str storage_account_key: The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        :param str storage_container_id: The ID of the Storage Container. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterStorageAccount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_default=is_default,
            storage_account_key=storage_account_key,
            storage_container_id=storage_container_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_default: bool,
             storage_account_key: str,
             storage_container_id: str,
             storage_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_default", is_default)
        _setter("storage_account_key", storage_account_key)
        _setter("storage_container_id", storage_container_id)
        if storage_resource_id is not None:
            _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> str:
        """
        The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @property
    @pulumi.getter(name="storageContainerId")
    def storage_container_id(self) -> str:
        """
        The ID of the Storage Container. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "storage_container_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> Optional[str]:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class InteractiveQueryClusterStorageAccountGen2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesystemId":
            suggest = "filesystem_id"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "managedIdentityResourceId":
            suggest = "managed_identity_resource_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InteractiveQueryClusterStorageAccountGen2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InteractiveQueryClusterStorageAccountGen2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InteractiveQueryClusterStorageAccountGen2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filesystem_id: str,
                 is_default: bool,
                 managed_identity_resource_id: str,
                 storage_resource_id: str):
        """
        :param str filesystem_id: The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str managed_identity_resource_id: The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        InteractiveQueryClusterStorageAccountGen2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filesystem_id=filesystem_id,
            is_default=is_default,
            managed_identity_resource_id=managed_identity_resource_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filesystem_id: str,
             is_default: bool,
             managed_identity_resource_id: str,
             storage_resource_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filesystem_id", filesystem_id)
        _setter("is_default", is_default)
        _setter("managed_identity_resource_id", managed_identity_resource_id)
        _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> str:
        """
        The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "filesystem_id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="managedIdentityResourceId")
    def managed_identity_resource_id(self) -> str:
        """
        The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "managed_identity_resource_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> str:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class KafkaClusterComponentVersion(dict):
    def __init__(__self__, *,
                 kafka: str):
        """
        :param str kafka: The version of Kafka which should be used for this HDInsight Kafka Cluster. Changing this forces a new resource to be created.
        """
        KafkaClusterComponentVersion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kafka=kafka,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kafka: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("kafka", kafka)

    @property
    @pulumi.getter
    def kafka(self) -> str:
        """
        The version of Kafka which should be used for this HDInsight Kafka Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "kafka")


@pulumi.output_type
class KafkaClusterComputeIsolation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeIsolationEnabled":
            suggest = "compute_isolation_enabled"
        elif key == "hostSku":
            suggest = "host_sku"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterComputeIsolation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterComputeIsolation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterComputeIsolation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_isolation_enabled: Optional[bool] = None,
                 host_sku: Optional[str] = None):
        """
        :param bool compute_isolation_enabled: This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        :param str host_sku: The name of the host SKU.
        """
        KafkaClusterComputeIsolation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_isolation_enabled=compute_isolation_enabled,
            host_sku=host_sku,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_isolation_enabled: Optional[bool] = None,
             host_sku: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compute_isolation_enabled is not None:
            _setter("compute_isolation_enabled", compute_isolation_enabled)
        if host_sku is not None:
            _setter("host_sku", host_sku)

    @property
    @pulumi.getter(name="computeIsolationEnabled")
    def compute_isolation_enabled(self) -> Optional[bool]:
        """
        This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        """
        return pulumi.get(self, "compute_isolation_enabled")

    @property
    @pulumi.getter(name="hostSku")
    def host_sku(self) -> Optional[str]:
        """
        The name of the host SKU.
        """
        return pulumi.get(self, "host_sku")


@pulumi.output_type
class KafkaClusterDiskEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "encryptionAtHostEnabled":
            suggest = "encryption_at_host_enabled"
        elif key == "keyVaultKeyId":
            suggest = "key_vault_key_id"
        elif key == "keyVaultManagedIdentityId":
            suggest = "key_vault_managed_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterDiskEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterDiskEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterDiskEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: Optional[str] = None,
                 encryption_at_host_enabled: Optional[bool] = None,
                 key_vault_key_id: Optional[str] = None,
                 key_vault_managed_identity_id: Optional[str] = None):
        """
        :param str encryption_algorithm: This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        :param bool encryption_at_host_enabled: This is indicator to show whether resource disk encryption is enabled.
        :param str key_vault_key_id: The ID of the key vault key.
        :param str key_vault_managed_identity_id: This is the resource ID of Managed Identity used to access the key vault.
        """
        KafkaClusterDiskEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encryption_algorithm=encryption_algorithm,
            encryption_at_host_enabled=encryption_at_host_enabled,
            key_vault_key_id=key_vault_key_id,
            key_vault_managed_identity_id=key_vault_managed_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encryption_algorithm: Optional[str] = None,
             encryption_at_host_enabled: Optional[bool] = None,
             key_vault_key_id: Optional[str] = None,
             key_vault_managed_identity_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if encryption_algorithm is not None:
            _setter("encryption_algorithm", encryption_algorithm)
        if encryption_at_host_enabled is not None:
            _setter("encryption_at_host_enabled", encryption_at_host_enabled)
        if key_vault_key_id is not None:
            _setter("key_vault_key_id", key_vault_key_id)
        if key_vault_managed_identity_id is not None:
            _setter("key_vault_managed_identity_id", key_vault_managed_identity_id)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[str]:
        """
        This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter(name="encryptionAtHostEnabled")
    def encryption_at_host_enabled(self) -> Optional[bool]:
        """
        This is indicator to show whether resource disk encryption is enabled.
        """
        return pulumi.get(self, "encryption_at_host_enabled")

    @property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> Optional[str]:
        """
        The ID of the key vault key.
        """
        return pulumi.get(self, "key_vault_key_id")

    @property
    @pulumi.getter(name="keyVaultManagedIdentityId")
    def key_vault_managed_identity_id(self) -> Optional[str]:
        """
        This is the resource ID of Managed Identity used to access the key vault.
        """
        return pulumi.get(self, "key_vault_managed_identity_id")


@pulumi.output_type
class KafkaClusterExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The workspace ID of the log analytics extension.
        :param str primary_key: The workspace key of the log analytics extension.
        """
        KafkaClusterExtension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The workspace ID of the log analytics extension.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The workspace key of the log analytics extension.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class KafkaClusterGateway(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password used for the Ambari Portal.
               
               > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        :param str username: The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        KafkaClusterGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password used for the Ambari Portal.

        > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KafkaClusterMetastores(dict):
    def __init__(__self__, *,
                 ambari: Optional['outputs.KafkaClusterMetastoresAmbari'] = None,
                 hive: Optional['outputs.KafkaClusterMetastoresHive'] = None,
                 oozie: Optional['outputs.KafkaClusterMetastoresOozie'] = None):
        """
        :param 'KafkaClusterMetastoresAmbariArgs' ambari: An `ambari` block as defined below.
        :param 'KafkaClusterMetastoresHiveArgs' hive: A `hive` block as defined below.
        :param 'KafkaClusterMetastoresOozieArgs' oozie: An `oozie` block as defined below.
        """
        KafkaClusterMetastores._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ambari=ambari,
            hive=hive,
            oozie=oozie,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ambari: Optional['outputs.KafkaClusterMetastoresAmbari'] = None,
             hive: Optional['outputs.KafkaClusterMetastoresHive'] = None,
             oozie: Optional['outputs.KafkaClusterMetastoresOozie'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ambari is not None:
            _setter("ambari", ambari)
        if hive is not None:
            _setter("hive", hive)
        if oozie is not None:
            _setter("oozie", oozie)

    @property
    @pulumi.getter
    def ambari(self) -> Optional['outputs.KafkaClusterMetastoresAmbari']:
        """
        An `ambari` block as defined below.
        """
        return pulumi.get(self, "ambari")

    @property
    @pulumi.getter
    def hive(self) -> Optional['outputs.KafkaClusterMetastoresHive']:
        """
        A `hive` block as defined below.
        """
        return pulumi.get(self, "hive")

    @property
    @pulumi.getter
    def oozie(self) -> Optional['outputs.KafkaClusterMetastoresOozie']:
        """
        An `oozie` block as defined below.
        """
        return pulumi.get(self, "oozie")


@pulumi.output_type
class KafkaClusterMetastoresAmbari(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterMetastoresAmbari. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterMetastoresAmbari.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterMetastoresAmbari.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        :param str username: The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        KafkaClusterMetastoresAmbari._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KafkaClusterMetastoresHive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterMetastoresHive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterMetastoresHive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterMetastoresHive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        :param str username: The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        KafkaClusterMetastoresHive._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KafkaClusterMetastoresOozie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterMetastoresOozie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterMetastoresOozie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterMetastoresOozie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        :param str username: The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        KafkaClusterMetastoresOozie._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KafkaClusterMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The Operations Management Suite (OMS) workspace ID.
        :param str primary_key: The Operations Management Suite (OMS) workspace key.
        """
        KafkaClusterMonitor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The Operations Management Suite (OMS) workspace ID.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The Operations Management Suite (OMS) workspace key.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class KafkaClusterNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionDirection":
            suggest = "connection_direction"
        elif key == "privateLinkEnabled":
            suggest = "private_link_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_direction: Optional[str] = None,
                 private_link_enabled: Optional[bool] = None):
        """
        :param str connection_direction: The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
               
               > **NOTE:** To enabled the private link the `connection_direction` must be set to `Outbound`.
        :param bool private_link_enabled: Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        KafkaClusterNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_direction=connection_direction,
            private_link_enabled=private_link_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_direction: Optional[str] = None,
             private_link_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_direction is not None:
            _setter("connection_direction", connection_direction)
        if private_link_enabled is not None:
            _setter("private_link_enabled", private_link_enabled)

    @property
    @pulumi.getter(name="connectionDirection")
    def connection_direction(self) -> Optional[str]:
        """
        The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.

        > **NOTE:** To enabled the private link the `connection_direction` must be set to `Outbound`.
        """
        return pulumi.get(self, "connection_direction")

    @property
    @pulumi.getter(name="privateLinkEnabled")
    def private_link_enabled(self) -> Optional[bool]:
        """
        Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "private_link_enabled")


@pulumi.output_type
class KafkaClusterRestProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "securityGroupName":
            suggest = "security_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterRestProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterRestProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterRestProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_id: str,
                 security_group_name: str):
        """
        :param str security_group_id: The Azure Active Directory Security Group ID. Changing this forces a new resource to be created.
        :param str security_group_name: The Azure Active Directory Security Group name. Changing this forces a new resource to be created.
               
               > **Note:** The `security_group_name` property will be Required in version 3.0 of the AzureRM Provider.
        """
        KafkaClusterRestProxy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            security_group_id=security_group_id,
            security_group_name=security_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             security_group_id: str,
             security_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("security_group_id", security_group_id)
        _setter("security_group_name", security_group_name)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The Azure Active Directory Security Group ID. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> str:
        """
        The Azure Active Directory Security Group name. Changing this forces a new resource to be created.

        > **Note:** The `security_group_name` property will be Required in version 3.0 of the AzureRM Provider.
        """
        return pulumi.get(self, "security_group_name")


@pulumi.output_type
class KafkaClusterRoles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headNode":
            suggest = "head_node"
        elif key == "workerNode":
            suggest = "worker_node"
        elif key == "zookeeperNode":
            suggest = "zookeeper_node"
        elif key == "kafkaManagementNode":
            suggest = "kafka_management_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterRoles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterRoles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterRoles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 head_node: 'outputs.KafkaClusterRolesHeadNode',
                 worker_node: 'outputs.KafkaClusterRolesWorkerNode',
                 zookeeper_node: 'outputs.KafkaClusterRolesZookeeperNode',
                 kafka_management_node: Optional['outputs.KafkaClusterRolesKafkaManagementNode'] = None):
        """
        :param 'KafkaClusterRolesHeadNodeArgs' head_node: A `head_node` block as defined above.
        :param 'KafkaClusterRolesWorkerNodeArgs' worker_node: A `worker_node` block as defined below.
        :param 'KafkaClusterRolesZookeeperNodeArgs' zookeeper_node: A `zookeeper_node` block as defined below.
        :param 'KafkaClusterRolesKafkaManagementNodeArgs' kafka_management_node: A `kafka_management_node` block as defined below.
               
               > **Note:** This property has been deprecated and will be removed in version 4.0.
        """
        KafkaClusterRoles._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            head_node=head_node,
            worker_node=worker_node,
            zookeeper_node=zookeeper_node,
            kafka_management_node=kafka_management_node,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             head_node: 'outputs.KafkaClusterRolesHeadNode',
             worker_node: 'outputs.KafkaClusterRolesWorkerNode',
             zookeeper_node: 'outputs.KafkaClusterRolesZookeeperNode',
             kafka_management_node: Optional['outputs.KafkaClusterRolesKafkaManagementNode'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("head_node", head_node)
        _setter("worker_node", worker_node)
        _setter("zookeeper_node", zookeeper_node)
        if kafka_management_node is not None:
            _setter("kafka_management_node", kafka_management_node)

    @property
    @pulumi.getter(name="headNode")
    def head_node(self) -> 'outputs.KafkaClusterRolesHeadNode':
        """
        A `head_node` block as defined above.
        """
        return pulumi.get(self, "head_node")

    @property
    @pulumi.getter(name="workerNode")
    def worker_node(self) -> 'outputs.KafkaClusterRolesWorkerNode':
        """
        A `worker_node` block as defined below.
        """
        return pulumi.get(self, "worker_node")

    @property
    @pulumi.getter(name="zookeeperNode")
    def zookeeper_node(self) -> 'outputs.KafkaClusterRolesZookeeperNode':
        """
        A `zookeeper_node` block as defined below.
        """
        return pulumi.get(self, "zookeeper_node")

    @property
    @pulumi.getter(name="kafkaManagementNode")
    def kafka_management_node(self) -> Optional['outputs.KafkaClusterRolesKafkaManagementNode']:
        """
        A `kafka_management_node` block as defined below.

        > **Note:** This property has been deprecated and will be removed in version 4.0.
        """
        return pulumi.get(self, "kafka_management_node")


@pulumi.output_type
class KafkaClusterRolesHeadNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterRolesHeadNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterRolesHeadNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterRolesHeadNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.KafkaClusterRolesHeadNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['KafkaClusterRolesHeadNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        KafkaClusterRolesHeadNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.KafkaClusterRolesHeadNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.KafkaClusterRolesHeadNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class KafkaClusterRolesHeadNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        KafkaClusterRolesHeadNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class KafkaClusterRolesKafkaManagementNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterRolesKafkaManagementNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterRolesKafkaManagementNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterRolesKafkaManagementNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.KafkaClusterRolesKafkaManagementNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Kafka Management Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Kafka Management Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Kafka Management Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['KafkaClusterRolesKafkaManagementNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Kafka Management Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Kafka Management Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Kafka Management Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        KafkaClusterRolesKafkaManagementNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.KafkaClusterRolesKafkaManagementNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Kafka Management Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Kafka Management Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Kafka Management Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.KafkaClusterRolesKafkaManagementNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Kafka Management Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Kafka Management Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Kafka Management Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class KafkaClusterRolesKafkaManagementNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        KafkaClusterRolesKafkaManagementNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class KafkaClusterRolesWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfDisksPerNode":
            suggest = "number_of_disks_per_node"
        elif key == "targetInstanceCount":
            suggest = "target_instance_count"
        elif key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterRolesWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterRolesWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterRolesWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_disks_per_node: int,
                 target_instance_count: int,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.KafkaClusterRolesWorkerNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param int number_of_disks_per_node: The number of Data Disks which should be assigned to each Worker Node, which can be between 1 and 8. Changing this forces a new resource to be created.
        :param int target_instance_count: The number of instances which should be run for the Worker Nodes.
        :param str username: The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['KafkaClusterRolesWorkerNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        KafkaClusterRolesWorkerNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            number_of_disks_per_node=number_of_disks_per_node,
            target_instance_count=target_instance_count,
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             number_of_disks_per_node: int,
             target_instance_count: int,
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.KafkaClusterRolesWorkerNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("number_of_disks_per_node", number_of_disks_per_node)
        _setter("target_instance_count", target_instance_count)
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="numberOfDisksPerNode")
    def number_of_disks_per_node(self) -> int:
        """
        The number of Data Disks which should be assigned to each Worker Node, which can be between 1 and 8. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "number_of_disks_per_node")

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of instances which should be run for the Worker Nodes.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.KafkaClusterRolesWorkerNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class KafkaClusterRolesWorkerNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        KafkaClusterRolesWorkerNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class KafkaClusterRolesZookeeperNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterRolesZookeeperNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterRolesZookeeperNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterRolesZookeeperNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.KafkaClusterRolesZookeeperNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['KafkaClusterRolesZookeeperNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        KafkaClusterRolesZookeeperNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.KafkaClusterRolesZookeeperNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.KafkaClusterRolesZookeeperNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class KafkaClusterRolesZookeeperNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        KafkaClusterRolesZookeeperNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class KafkaClusterSecurityProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aaddsResourceId":
            suggest = "aadds_resource_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "domainUserPassword":
            suggest = "domain_user_password"
        elif key == "domainUsername":
            suggest = "domain_username"
        elif key == "ldapsUrls":
            suggest = "ldaps_urls"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"
        elif key == "clusterUsersGroupDns":
            suggest = "cluster_users_group_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterSecurityProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterSecurityProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterSecurityProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aadds_resource_id: str,
                 domain_name: str,
                 domain_user_password: str,
                 domain_username: str,
                 ldaps_urls: Sequence[str],
                 msi_resource_id: str,
                 cluster_users_group_dns: Optional[Sequence[str]] = None):
        """
        :param str aadds_resource_id: The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        :param str domain_name: The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_user_password: The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_username: The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param Sequence[str] ldaps_urls: A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        :param str msi_resource_id: The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        :param Sequence[str] cluster_users_group_dns: A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        KafkaClusterSecurityProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aadds_resource_id=aadds_resource_id,
            domain_name=domain_name,
            domain_user_password=domain_user_password,
            domain_username=domain_username,
            ldaps_urls=ldaps_urls,
            msi_resource_id=msi_resource_id,
            cluster_users_group_dns=cluster_users_group_dns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aadds_resource_id: str,
             domain_name: str,
             domain_user_password: str,
             domain_username: str,
             ldaps_urls: Sequence[str],
             msi_resource_id: str,
             cluster_users_group_dns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aadds_resource_id", aadds_resource_id)
        _setter("domain_name", domain_name)
        _setter("domain_user_password", domain_user_password)
        _setter("domain_username", domain_username)
        _setter("ldaps_urls", ldaps_urls)
        _setter("msi_resource_id", msi_resource_id)
        if cluster_users_group_dns is not None:
            _setter("cluster_users_group_dns", cluster_users_group_dns)

    @property
    @pulumi.getter(name="aaddsResourceId")
    def aadds_resource_id(self) -> str:
        """
        The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "aadds_resource_id")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainUserPassword")
    def domain_user_password(self) -> str:
        """
        The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_user_password")

    @property
    @pulumi.getter(name="domainUsername")
    def domain_username(self) -> str:
        """
        The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_username")

    @property
    @pulumi.getter(name="ldapsUrls")
    def ldaps_urls(self) -> Sequence[str]:
        """
        A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ldaps_urls")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> str:
        """
        The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "msi_resource_id")

    @property
    @pulumi.getter(name="clusterUsersGroupDns")
    def cluster_users_group_dns(self) -> Optional[Sequence[str]]:
        """
        A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cluster_users_group_dns")


@pulumi.output_type
class KafkaClusterStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageContainerId":
            suggest = "storage_container_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_default: bool,
                 storage_account_key: str,
                 storage_container_id: str,
                 storage_resource_id: Optional[str] = None):
        """
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str storage_account_key: The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        :param str storage_container_id: The ID of the Storage Container. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        KafkaClusterStorageAccount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_default=is_default,
            storage_account_key=storage_account_key,
            storage_container_id=storage_container_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_default: bool,
             storage_account_key: str,
             storage_container_id: str,
             storage_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_default", is_default)
        _setter("storage_account_key", storage_account_key)
        _setter("storage_container_id", storage_container_id)
        if storage_resource_id is not None:
            _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> str:
        """
        The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @property
    @pulumi.getter(name="storageContainerId")
    def storage_container_id(self) -> str:
        """
        The ID of the Storage Container. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "storage_container_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> Optional[str]:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class KafkaClusterStorageAccountGen2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesystemId":
            suggest = "filesystem_id"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "managedIdentityResourceId":
            suggest = "managed_identity_resource_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterStorageAccountGen2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterStorageAccountGen2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterStorageAccountGen2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filesystem_id: str,
                 is_default: bool,
                 managed_identity_resource_id: str,
                 storage_resource_id: str):
        """
        :param str filesystem_id: The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str managed_identity_resource_id: The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        KafkaClusterStorageAccountGen2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filesystem_id=filesystem_id,
            is_default=is_default,
            managed_identity_resource_id=managed_identity_resource_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filesystem_id: str,
             is_default: bool,
             managed_identity_resource_id: str,
             storage_resource_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filesystem_id", filesystem_id)
        _setter("is_default", is_default)
        _setter("managed_identity_resource_id", managed_identity_resource_id)
        _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> str:
        """
        The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "filesystem_id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="managedIdentityResourceId")
    def managed_identity_resource_id(self) -> str:
        """
        The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "managed_identity_resource_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> str:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class SparkClusterComponentVersion(dict):
    def __init__(__self__, *,
                 spark: str):
        """
        :param str spark: The version of Spark which should be used for this HDInsight Spark Cluster. Changing this forces a new resource to be created.
        """
        SparkClusterComponentVersion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            spark=spark,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             spark: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("spark", spark)

    @property
    @pulumi.getter
    def spark(self) -> str:
        """
        The version of Spark which should be used for this HDInsight Spark Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "spark")


@pulumi.output_type
class SparkClusterComputeIsolation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeIsolationEnabled":
            suggest = "compute_isolation_enabled"
        elif key == "hostSku":
            suggest = "host_sku"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterComputeIsolation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterComputeIsolation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterComputeIsolation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_isolation_enabled: Optional[bool] = None,
                 host_sku: Optional[str] = None):
        """
        :param bool compute_isolation_enabled: This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        :param str host_sku: The name of the host SKU.
        """
        SparkClusterComputeIsolation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_isolation_enabled=compute_isolation_enabled,
            host_sku=host_sku,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_isolation_enabled: Optional[bool] = None,
             host_sku: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compute_isolation_enabled is not None:
            _setter("compute_isolation_enabled", compute_isolation_enabled)
        if host_sku is not None:
            _setter("host_sku", host_sku)

    @property
    @pulumi.getter(name="computeIsolationEnabled")
    def compute_isolation_enabled(self) -> Optional[bool]:
        """
        This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
        """
        return pulumi.get(self, "compute_isolation_enabled")

    @property
    @pulumi.getter(name="hostSku")
    def host_sku(self) -> Optional[str]:
        """
        The name of the host SKU.
        """
        return pulumi.get(self, "host_sku")


@pulumi.output_type
class SparkClusterDiskEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "encryptionAtHostEnabled":
            suggest = "encryption_at_host_enabled"
        elif key == "keyVaultKeyId":
            suggest = "key_vault_key_id"
        elif key == "keyVaultManagedIdentityId":
            suggest = "key_vault_managed_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterDiskEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterDiskEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterDiskEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: Optional[str] = None,
                 encryption_at_host_enabled: Optional[bool] = None,
                 key_vault_key_id: Optional[str] = None,
                 key_vault_managed_identity_id: Optional[str] = None):
        """
        :param str encryption_algorithm: This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        :param bool encryption_at_host_enabled: This is indicator to show whether resource disk encryption is enabled.
        :param str key_vault_key_id: The ID of the key vault key.
        :param str key_vault_managed_identity_id: This is the resource ID of Managed Identity used to access the key vault.
        """
        SparkClusterDiskEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encryption_algorithm=encryption_algorithm,
            encryption_at_host_enabled=encryption_at_host_enabled,
            key_vault_key_id=key_vault_key_id,
            key_vault_managed_identity_id=key_vault_managed_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encryption_algorithm: Optional[str] = None,
             encryption_at_host_enabled: Optional[bool] = None,
             key_vault_key_id: Optional[str] = None,
             key_vault_managed_identity_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if encryption_algorithm is not None:
            _setter("encryption_algorithm", encryption_algorithm)
        if encryption_at_host_enabled is not None:
            _setter("encryption_at_host_enabled", encryption_at_host_enabled)
        if key_vault_key_id is not None:
            _setter("key_vault_key_id", key_vault_key_id)
        if key_vault_managed_identity_id is not None:
            _setter("key_vault_managed_identity_id", key_vault_managed_identity_id)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[str]:
        """
        This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter(name="encryptionAtHostEnabled")
    def encryption_at_host_enabled(self) -> Optional[bool]:
        """
        This is indicator to show whether resource disk encryption is enabled.
        """
        return pulumi.get(self, "encryption_at_host_enabled")

    @property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> Optional[str]:
        """
        The ID of the key vault key.
        """
        return pulumi.get(self, "key_vault_key_id")

    @property
    @pulumi.getter(name="keyVaultManagedIdentityId")
    def key_vault_managed_identity_id(self) -> Optional[str]:
        """
        This is the resource ID of Managed Identity used to access the key vault.
        """
        return pulumi.get(self, "key_vault_managed_identity_id")


@pulumi.output_type
class SparkClusterExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The workspace ID of the log analytics extension.
        :param str primary_key: The workspace key of the log analytics extension.
        """
        SparkClusterExtension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The workspace ID of the log analytics extension.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The workspace key of the log analytics extension.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class SparkClusterGateway(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password used for the Ambari Portal.
               
               > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        :param str username: The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        SparkClusterGateway._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password used for the Ambari Portal.

        > **NOTE:** This password must be different from the one used for the `head_node`, `worker_node` and `zookeeper_node` roles.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username used for the Ambari Portal. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SparkClusterMetastores(dict):
    def __init__(__self__, *,
                 ambari: Optional['outputs.SparkClusterMetastoresAmbari'] = None,
                 hive: Optional['outputs.SparkClusterMetastoresHive'] = None,
                 oozie: Optional['outputs.SparkClusterMetastoresOozie'] = None):
        """
        :param 'SparkClusterMetastoresAmbariArgs' ambari: An `ambari` block as defined below.
        :param 'SparkClusterMetastoresHiveArgs' hive: A `hive` block as defined below.
        :param 'SparkClusterMetastoresOozieArgs' oozie: An `oozie` block as defined below.
        """
        SparkClusterMetastores._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ambari=ambari,
            hive=hive,
            oozie=oozie,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ambari: Optional['outputs.SparkClusterMetastoresAmbari'] = None,
             hive: Optional['outputs.SparkClusterMetastoresHive'] = None,
             oozie: Optional['outputs.SparkClusterMetastoresOozie'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ambari is not None:
            _setter("ambari", ambari)
        if hive is not None:
            _setter("hive", hive)
        if oozie is not None:
            _setter("oozie", oozie)

    @property
    @pulumi.getter
    def ambari(self) -> Optional['outputs.SparkClusterMetastoresAmbari']:
        """
        An `ambari` block as defined below.
        """
        return pulumi.get(self, "ambari")

    @property
    @pulumi.getter
    def hive(self) -> Optional['outputs.SparkClusterMetastoresHive']:
        """
        A `hive` block as defined below.
        """
        return pulumi.get(self, "hive")

    @property
    @pulumi.getter
    def oozie(self) -> Optional['outputs.SparkClusterMetastoresOozie']:
        """
        An `oozie` block as defined below.
        """
        return pulumi.get(self, "oozie")


@pulumi.output_type
class SparkClusterMetastoresAmbari(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterMetastoresAmbari. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterMetastoresAmbari.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterMetastoresAmbari.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        :param str username: The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        SparkClusterMetastoresAmbari._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SparkClusterMetastoresHive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterMetastoresHive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterMetastoresHive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterMetastoresHive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        :param str username: The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        SparkClusterMetastoresHive._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SparkClusterMetastoresOozie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterMetastoresOozie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterMetastoresOozie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterMetastoresOozie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str database_name: The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        :param str password: The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        :param str server: The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        :param str username: The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        SparkClusterMetastoresOozie._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            password=password,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             password: str,
             server: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("password", password)
        _setter("server", server)
        _setter("username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SparkClusterMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: str,
                 primary_key: str):
        """
        :param str log_analytics_workspace_id: The Operations Management Suite (OMS) workspace ID.
        :param str primary_key: The Operations Management Suite (OMS) workspace key.
        """
        SparkClusterMonitor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_analytics_workspace_id=log_analytics_workspace_id,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_analytics_workspace_id: str,
             primary_key: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_analytics_workspace_id", log_analytics_workspace_id)
        _setter("primary_key", primary_key)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The Operations Management Suite (OMS) workspace ID.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> str:
        """
        The Operations Management Suite (OMS) workspace key.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class SparkClusterNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionDirection":
            suggest = "connection_direction"
        elif key == "privateLinkEnabled":
            suggest = "private_link_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_direction: Optional[str] = None,
                 private_link_enabled: Optional[bool] = None):
        """
        :param str connection_direction: The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
               
               > **NOTE:** To enabled the private link the `connection_direction` must be set to `Outbound`.
        :param bool private_link_enabled: Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        SparkClusterNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_direction=connection_direction,
            private_link_enabled=private_link_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_direction: Optional[str] = None,
             private_link_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_direction is not None:
            _setter("connection_direction", connection_direction)
        if private_link_enabled is not None:
            _setter("private_link_enabled", private_link_enabled)

    @property
    @pulumi.getter(name="connectionDirection")
    def connection_direction(self) -> Optional[str]:
        """
        The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.

        > **NOTE:** To enabled the private link the `connection_direction` must be set to `Outbound`.
        """
        return pulumi.get(self, "connection_direction")

    @property
    @pulumi.getter(name="privateLinkEnabled")
    def private_link_enabled(self) -> Optional[bool]:
        """
        Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "private_link_enabled")


@pulumi.output_type
class SparkClusterRoles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headNode":
            suggest = "head_node"
        elif key == "workerNode":
            suggest = "worker_node"
        elif key == "zookeeperNode":
            suggest = "zookeeper_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterRoles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterRoles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterRoles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 head_node: 'outputs.SparkClusterRolesHeadNode',
                 worker_node: 'outputs.SparkClusterRolesWorkerNode',
                 zookeeper_node: 'outputs.SparkClusterRolesZookeeperNode'):
        """
        :param 'SparkClusterRolesHeadNodeArgs' head_node: A `head_node` block as defined above.
        :param 'SparkClusterRolesWorkerNodeArgs' worker_node: A `worker_node` block as defined below.
        :param 'SparkClusterRolesZookeeperNodeArgs' zookeeper_node: A `zookeeper_node` block as defined below.
        """
        SparkClusterRoles._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            head_node=head_node,
            worker_node=worker_node,
            zookeeper_node=zookeeper_node,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             head_node: 'outputs.SparkClusterRolesHeadNode',
             worker_node: 'outputs.SparkClusterRolesWorkerNode',
             zookeeper_node: 'outputs.SparkClusterRolesZookeeperNode',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("head_node", head_node)
        _setter("worker_node", worker_node)
        _setter("zookeeper_node", zookeeper_node)

    @property
    @pulumi.getter(name="headNode")
    def head_node(self) -> 'outputs.SparkClusterRolesHeadNode':
        """
        A `head_node` block as defined above.
        """
        return pulumi.get(self, "head_node")

    @property
    @pulumi.getter(name="workerNode")
    def worker_node(self) -> 'outputs.SparkClusterRolesWorkerNode':
        """
        A `worker_node` block as defined below.
        """
        return pulumi.get(self, "worker_node")

    @property
    @pulumi.getter(name="zookeeperNode")
    def zookeeper_node(self) -> 'outputs.SparkClusterRolesZookeeperNode':
        """
        A `zookeeper_node` block as defined below.
        """
        return pulumi.get(self, "zookeeper_node")


@pulumi.output_type
class SparkClusterRolesHeadNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterRolesHeadNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterRolesHeadNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterRolesHeadNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.SparkClusterRolesHeadNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['SparkClusterRolesHeadNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        SparkClusterRolesHeadNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.SparkClusterRolesHeadNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.SparkClusterRolesHeadNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class SparkClusterRolesHeadNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        SparkClusterRolesHeadNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class SparkClusterRolesWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetInstanceCount":
            suggest = "target_instance_count"
        elif key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterRolesWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterRolesWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterRolesWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_instance_count: int,
                 username: str,
                 vm_size: str,
                 autoscale: Optional['outputs.SparkClusterRolesWorkerNodeAutoscale'] = None,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.SparkClusterRolesWorkerNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param int target_instance_count: The number of instances which should be run for the Worker Nodes.
        :param str username: The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param 'SparkClusterRolesWorkerNodeAutoscaleArgs' autoscale: A `autoscale` block as defined below.
        :param str password: The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['SparkClusterRolesWorkerNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        SparkClusterRolesWorkerNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_instance_count=target_instance_count,
            username=username,
            vm_size=vm_size,
            autoscale=autoscale,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_instance_count: int,
             username: str,
             vm_size: str,
             autoscale: Optional['outputs.SparkClusterRolesWorkerNodeAutoscale'] = None,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.SparkClusterRolesWorkerNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_instance_count", target_instance_count)
        _setter("username", username)
        _setter("vm_size", vm_size)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of instances which should be run for the Worker Nodes.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.SparkClusterRolesWorkerNodeAutoscale']:
        """
        A `autoscale` block as defined below.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.SparkClusterRolesWorkerNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class SparkClusterRolesWorkerNodeAutoscale(dict):
    def __init__(__self__, *,
                 capacity: Optional['outputs.SparkClusterRolesWorkerNodeAutoscaleCapacity'] = None,
                 recurrence: Optional['outputs.SparkClusterRolesWorkerNodeAutoscaleRecurrence'] = None):
        """
        :param 'SparkClusterRolesWorkerNodeAutoscaleCapacityArgs' capacity: A `capacity` block as defined below.
        :param 'SparkClusterRolesWorkerNodeAutoscaleRecurrenceArgs' recurrence: A `recurrence` block as defined below.
               
               > **NOTE:** Either a `capacity` or `recurrence` block must be specified - but not both.
        """
        SparkClusterRolesWorkerNodeAutoscale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity=capacity,
            recurrence=recurrence,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity: Optional['outputs.SparkClusterRolesWorkerNodeAutoscaleCapacity'] = None,
             recurrence: Optional['outputs.SparkClusterRolesWorkerNodeAutoscaleRecurrence'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if capacity is not None:
            _setter("capacity", capacity)
        if recurrence is not None:
            _setter("recurrence", recurrence)

    @property
    @pulumi.getter
    def capacity(self) -> Optional['outputs.SparkClusterRolesWorkerNodeAutoscaleCapacity']:
        """
        A `capacity` block as defined below.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.SparkClusterRolesWorkerNodeAutoscaleRecurrence']:
        """
        A `recurrence` block as defined below.

        > **NOTE:** Either a `capacity` or `recurrence` block must be specified - but not both.
        """
        return pulumi.get(self, "recurrence")


@pulumi.output_type
class SparkClusterRolesWorkerNodeAutoscaleCapacity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"
        elif key == "minInstanceCount":
            suggest = "min_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterRolesWorkerNodeAutoscaleCapacity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterRolesWorkerNodeAutoscaleCapacity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterRolesWorkerNodeAutoscaleCapacity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: int,
                 min_instance_count: int):
        """
        :param int max_instance_count: The maximum number of worker nodes to autoscale to based on the cluster's activity.
        :param int min_instance_count: The minimum number of worker nodes to autoscale to based on the cluster's activity.
        """
        SparkClusterRolesWorkerNodeAutoscaleCapacity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_instance_count=max_instance_count,
            min_instance_count=min_instance_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_instance_count: int,
             min_instance_count: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_instance_count", max_instance_count)
        _setter("min_instance_count", min_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> int:
        """
        The maximum number of worker nodes to autoscale to based on the cluster's activity.
        """
        return pulumi.get(self, "max_instance_count")

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> int:
        """
        The minimum number of worker nodes to autoscale to based on the cluster's activity.
        """
        return pulumi.get(self, "min_instance_count")


@pulumi.output_type
class SparkClusterRolesWorkerNodeAutoscaleRecurrence(dict):
    def __init__(__self__, *,
                 schedules: Sequence['outputs.SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule'],
                 timezone: str):
        """
        :param Sequence['SparkClusterRolesWorkerNodeAutoscaleRecurrenceScheduleArgs'] schedules: A list of `schedule` blocks as defined below.
        :param str timezone: The time zone for the autoscale schedule times.
        """
        SparkClusterRolesWorkerNodeAutoscaleRecurrence._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schedules=schedules,
            timezone=timezone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schedules: Sequence['outputs.SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule'],
             timezone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("schedules", schedules)
        _setter("timezone", timezone)

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule']:
        """
        A list of `schedule` blocks as defined below.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        The time zone for the autoscale schedule times.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetInstanceCount":
            suggest = "target_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Sequence[str],
                 target_instance_count: int,
                 time: str):
        """
        :param Sequence[str] days: The days of the week to perform autoscale. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        :param int target_instance_count: The number of worker nodes to autoscale at the specified time.
        :param str time: The time of day to perform the autoscale in 24hour format.
        """
        SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days=days,
            target_instance_count=target_instance_count,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days: Sequence[str],
             target_instance_count: int,
             time: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("days", days)
        _setter("target_instance_count", target_instance_count)
        _setter("time", time)

    @property
    @pulumi.getter
    def days(self) -> Sequence[str]:
        """
        The days of the week to perform autoscale. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> int:
        """
        The number of worker nodes to autoscale at the specified time.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        The time of day to perform the autoscale in 24hour format.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class SparkClusterRolesWorkerNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        SparkClusterRolesWorkerNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class SparkClusterRolesZookeeperNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkId":
            suggest = "virtual_network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterRolesZookeeperNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterRolesZookeeperNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterRolesZookeeperNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username: str,
                 vm_size: str,
                 password: Optional[str] = None,
                 script_actions: Optional[Sequence['outputs.SparkClusterRolesZookeeperNodeScriptAction']] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str username: The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        :param str vm_size: The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        :param str password: The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        :param Sequence['SparkClusterRolesZookeeperNodeScriptActionArgs'] script_actions: The script action which will run on the cluster. Changing this forces a new resource to be created.
        :param Sequence[str] ssh_keys: A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
               
               > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        :param str subnet_id: The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        :param str virtual_network_id: The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        SparkClusterRolesZookeeperNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            vm_size=vm_size,
            password=password,
            script_actions=script_actions,
            ssh_keys=ssh_keys,
            subnet_id=subnet_id,
            virtual_network_id=virtual_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             vm_size: str,
             password: Optional[str] = None,
             script_actions: Optional[Sequence['outputs.SparkClusterRolesZookeeperNodeScriptAction']] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             virtual_network_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)
        _setter("vm_size", vm_size)
        if password is not None:
            _setter("password", password)
        if script_actions is not None:
            _setter("script_actions", script_actions)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if virtual_network_id is not None:
            _setter("virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \\).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.SparkClusterRolesZookeeperNodeScriptAction']]:
        """
        The script action which will run on the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.

        > **NOTE:** Either a `password` or one or more `ssh_keys` must be specified - but not both.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class SparkClusterRolesZookeeperNodeScriptAction(dict):
    def __init__(__self__, *,
                 name: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        :param str name: The name of the script action.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script provided.
        """
        SparkClusterRolesZookeeperNodeScriptAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             uri: str,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("uri", uri)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class SparkClusterSecurityProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aaddsResourceId":
            suggest = "aadds_resource_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "domainUserPassword":
            suggest = "domain_user_password"
        elif key == "domainUsername":
            suggest = "domain_username"
        elif key == "ldapsUrls":
            suggest = "ldaps_urls"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"
        elif key == "clusterUsersGroupDns":
            suggest = "cluster_users_group_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterSecurityProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterSecurityProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterSecurityProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aadds_resource_id: str,
                 domain_name: str,
                 domain_user_password: str,
                 domain_username: str,
                 ldaps_urls: Sequence[str],
                 msi_resource_id: str,
                 cluster_users_group_dns: Optional[Sequence[str]] = None):
        """
        :param str aadds_resource_id: The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        :param str domain_name: The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_user_password: The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param str domain_username: The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        :param Sequence[str] ldaps_urls: A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        :param str msi_resource_id: The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        :param Sequence[str] cluster_users_group_dns: A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        SparkClusterSecurityProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aadds_resource_id=aadds_resource_id,
            domain_name=domain_name,
            domain_user_password=domain_user_password,
            domain_username=domain_username,
            ldaps_urls=ldaps_urls,
            msi_resource_id=msi_resource_id,
            cluster_users_group_dns=cluster_users_group_dns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aadds_resource_id: str,
             domain_name: str,
             domain_user_password: str,
             domain_username: str,
             ldaps_urls: Sequence[str],
             msi_resource_id: str,
             cluster_users_group_dns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aadds_resource_id", aadds_resource_id)
        _setter("domain_name", domain_name)
        _setter("domain_user_password", domain_user_password)
        _setter("domain_username", domain_username)
        _setter("ldaps_urls", ldaps_urls)
        _setter("msi_resource_id", msi_resource_id)
        if cluster_users_group_dns is not None:
            _setter("cluster_users_group_dns", cluster_users_group_dns)

    @property
    @pulumi.getter(name="aaddsResourceId")
    def aadds_resource_id(self) -> str:
        """
        The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "aadds_resource_id")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainUserPassword")
    def domain_user_password(self) -> str:
        """
        The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_user_password")

    @property
    @pulumi.getter(name="domainUsername")
    def domain_username(self) -> str:
        """
        The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "domain_username")

    @property
    @pulumi.getter(name="ldapsUrls")
    def ldaps_urls(self) -> Sequence[str]:
        """
        A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ldaps_urls")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> str:
        """
        The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "msi_resource_id")

    @property
    @pulumi.getter(name="clusterUsersGroupDns")
    def cluster_users_group_dns(self) -> Optional[Sequence[str]]:
        """
        A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cluster_users_group_dns")


@pulumi.output_type
class SparkClusterStorageAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageContainerId":
            suggest = "storage_container_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterStorageAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterStorageAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterStorageAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_default: bool,
                 storage_account_key: str,
                 storage_container_id: str,
                 storage_resource_id: Optional[str] = None):
        """
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str storage_account_key: The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        :param str storage_container_id: The ID of the Storage Container. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        SparkClusterStorageAccount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_default=is_default,
            storage_account_key=storage_account_key,
            storage_container_id=storage_container_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_default: bool,
             storage_account_key: str,
             storage_container_id: str,
             storage_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_default", is_default)
        _setter("storage_account_key", storage_account_key)
        _setter("storage_container_id", storage_container_id)
        if storage_resource_id is not None:
            _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> str:
        """
        The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @property
    @pulumi.getter(name="storageContainerId")
    def storage_container_id(self) -> str:
        """
        The ID of the Storage Container. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "storage_container_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> Optional[str]:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class SparkClusterStorageAccountGen2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesystemId":
            suggest = "filesystem_id"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "managedIdentityResourceId":
            suggest = "managed_identity_resource_id"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkClusterStorageAccountGen2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkClusterStorageAccountGen2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkClusterStorageAccountGen2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filesystem_id: str,
                 is_default: bool,
                 managed_identity_resource_id: str,
                 storage_resource_id: str):
        """
        :param str filesystem_id: The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        :param bool is_default: Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
               
               > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        :param str managed_identity_resource_id: The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        :param str storage_resource_id: The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        SparkClusterStorageAccountGen2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filesystem_id=filesystem_id,
            is_default=is_default,
            managed_identity_resource_id=managed_identity_resource_id,
            storage_resource_id=storage_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filesystem_id: str,
             is_default: bool,
             managed_identity_resource_id: str,
             storage_resource_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filesystem_id", filesystem_id)
        _setter("is_default", is_default)
        _setter("managed_identity_resource_id", managed_identity_resource_id)
        _setter("storage_resource_id", storage_resource_id)

    @property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> str:
        """
        The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "filesystem_id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.

        > **NOTE:** One of the `storage_account` or `storage_account_gen2` blocks must be marked as the default.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="managedIdentityResourceId")
    def managed_identity_resource_id(self) -> str:
        """
        The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.

        > **NOTE:** This can be obtained from the `id` of the `storage.Container` resource.
        """
        return pulumi.get(self, "managed_identity_resource_id")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> str:
        """
        The ID of the Storage Account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_resource_id")


@pulumi.output_type
class GetClusterGatewayResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 password: str,
                 username: str):
        """
        :param bool enabled: Is the Ambari Portal enabled?
        :param str password: The password used for the Ambari Portal.
        :param str username: The username used for the Ambari Portal.
        """
        GetClusterGatewayResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             password: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Ambari Portal enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password used for the Ambari Portal.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username used for the Ambari Portal.
        """
        return pulumi.get(self, "username")


