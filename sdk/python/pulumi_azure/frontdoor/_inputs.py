# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'CustomHttpsConfigurationCustomHttpsConfigurationArgs',
    'FirewallPolicyCustomRuleArgs',
    'FirewallPolicyCustomRuleMatchConditionArgs',
    'FirewallPolicyManagedRuleArgs',
    'FirewallPolicyManagedRuleExclusionArgs',
    'FirewallPolicyManagedRuleOverrideArgs',
    'FirewallPolicyManagedRuleOverrideExclusionArgs',
    'FirewallPolicyManagedRuleOverrideRuleArgs',
    'FirewallPolicyManagedRuleOverrideRuleExclusionArgs',
    'FrontdoorBackendPoolArgs',
    'FrontdoorBackendPoolBackendArgs',
    'FrontdoorBackendPoolHealthProbeArgs',
    'FrontdoorBackendPoolLoadBalancingArgs',
    'FrontdoorExplicitResourceOrderArgs',
    'FrontdoorFrontendEndpointArgs',
    'FrontdoorRoutingRuleArgs',
    'FrontdoorRoutingRuleForwardingConfigurationArgs',
    'FrontdoorRoutingRuleRedirectConfigurationArgs',
]

@pulumi.input_type
class CustomHttpsConfigurationCustomHttpsConfigurationArgs:
    def __init__(__self__, *,
                 azure_key_vault_certificate_secret_name: Optional[pulumi.Input[str]] = None,
                 azure_key_vault_certificate_secret_version: Optional[pulumi.Input[str]] = None,
                 azure_key_vault_certificate_vault_id: Optional[pulumi.Input[str]] = None,
                 certificate_source: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 provisioning_state: Optional[pulumi.Input[str]] = None,
                 provisioning_substate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] azure_key_vault_certificate_secret_name: The name of the Key Vault secret representing the full certificate PFX.
        :param pulumi.Input[str] azure_key_vault_certificate_secret_version: The version of the Key Vault secret representing the full certificate PFX. Defaults to `Latest`.
        :param pulumi.Input[str] azure_key_vault_certificate_vault_id: The ID of the Key Vault containing the SSL certificate.
        :param pulumi.Input[str] certificate_source: Certificate source to encrypted `HTTPS` traffic with. Allowed values are `FrontDoor` or `AzureKeyVault`. Defaults to `FrontDoor`.
        :param pulumi.Input[str] minimum_tls_version: Minimum client TLS version supported.
        """
        if azure_key_vault_certificate_secret_name is not None:
            pulumi.set(__self__, "azure_key_vault_certificate_secret_name", azure_key_vault_certificate_secret_name)
        if azure_key_vault_certificate_secret_version is not None:
            pulumi.set(__self__, "azure_key_vault_certificate_secret_version", azure_key_vault_certificate_secret_version)
        if azure_key_vault_certificate_vault_id is not None:
            pulumi.set(__self__, "azure_key_vault_certificate_vault_id", azure_key_vault_certificate_vault_id)
        if certificate_source is not None:
            pulumi.set(__self__, "certificate_source", certificate_source)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if provisioning_substate is not None:
            pulumi.set(__self__, "provisioning_substate", provisioning_substate)

    @property
    @pulumi.getter(name="azureKeyVaultCertificateSecretName")
    def azure_key_vault_certificate_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Key Vault secret representing the full certificate PFX.
        """
        return pulumi.get(self, "azure_key_vault_certificate_secret_name")

    @azure_key_vault_certificate_secret_name.setter
    def azure_key_vault_certificate_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_key_vault_certificate_secret_name", value)

    @property
    @pulumi.getter(name="azureKeyVaultCertificateSecretVersion")
    def azure_key_vault_certificate_secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Key Vault secret representing the full certificate PFX. Defaults to `Latest`.
        """
        return pulumi.get(self, "azure_key_vault_certificate_secret_version")

    @azure_key_vault_certificate_secret_version.setter
    def azure_key_vault_certificate_secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_key_vault_certificate_secret_version", value)

    @property
    @pulumi.getter(name="azureKeyVaultCertificateVaultId")
    def azure_key_vault_certificate_vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Key Vault containing the SSL certificate.
        """
        return pulumi.get(self, "azure_key_vault_certificate_vault_id")

    @azure_key_vault_certificate_vault_id.setter
    def azure_key_vault_certificate_vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_key_vault_certificate_vault_id", value)

    @property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate source to encrypted `HTTPS` traffic with. Allowed values are `FrontDoor` or `AzureKeyVault`. Defaults to `FrontDoor`.
        """
        return pulumi.get(self, "certificate_source")

    @certificate_source.setter
    def certificate_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_source", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum client TLS version supported.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provisioning_state")

    @provisioning_state.setter
    def provisioning_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provisioning_state", value)

    @property
    @pulumi.getter(name="provisioningSubstate")
    def provisioning_substate(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provisioning_substate")

    @provisioning_substate.setter
    def provisioning_substate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provisioning_substate", value)


@pulumi.input_type
class FirewallPolicyCustomRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 match_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomRuleMatchConditionArgs']]]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 rate_limit_duration_in_minutes: Optional[pulumi.Input[int]] = None,
                 rate_limit_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] action: The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        :param pulumi.Input[str] name: Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        :param pulumi.Input[str] type: The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        :param pulumi.Input[bool] enabled: Is the rule is enabled or disabled? Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomRuleMatchConditionArgs']]] match_conditions: One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        :param pulumi.Input[int] priority: The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        :param pulumi.Input[int] rate_limit_duration_in_minutes: The rate limit duration in minutes. Defaults to `1`.
        :param pulumi.Input[int] rate_limit_threshold: The rate limit threshold. Defaults to `10`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rate_limit_duration_in_minutes is not None:
            pulumi.set(__self__, "rate_limit_duration_in_minutes", rate_limit_duration_in_minutes)
        if rate_limit_threshold is not None:
            pulumi.set(__self__, "rate_limit_threshold", rate_limit_threshold)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the rule is enabled or disabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomRuleMatchConditionArgs']]]]:
        """
        One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        """
        return pulumi.get(self, "match_conditions")

    @match_conditions.setter
    def match_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomRuleMatchConditionArgs']]]]):
        pulumi.set(self, "match_conditions", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="rateLimitDurationInMinutes")
    def rate_limit_duration_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The rate limit duration in minutes. Defaults to `1`.
        """
        return pulumi.get(self, "rate_limit_duration_in_minutes")

    @rate_limit_duration_in_minutes.setter
    def rate_limit_duration_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate_limit_duration_in_minutes", value)

    @property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The rate limit threshold. Defaults to `10`.
        """
        return pulumi.get(self, "rate_limit_threshold")

    @rate_limit_threshold.setter
    def rate_limit_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate_limit_threshold", value)


@pulumi.input_type
class FirewallPolicyCustomRuleMatchConditionArgs:
    def __init__(__self__, *,
                 match_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 match_variable: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 negation_condition: Optional[pulumi.Input[bool]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters long.
        :param pulumi.Input[str] match_variable: The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        :param pulumi.Input[str] operator: Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
        :param pulumi.Input[bool] negation_condition: Should the result of the condition be negated.
        :param pulumi.Input[str] selector: Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transforms: Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or`URLEncode`.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        if negation_condition is not None:
            pulumi.set(__self__, "negation_condition", negation_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters long.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[str]:
        """
        The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="negationCondition")
    def negation_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the result of the condition be negated.
        """
        return pulumi.get(self, "negation_condition")

    @negation_condition.setter
    def negation_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negation_condition", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or`URLEncode`.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class FirewallPolicyManagedRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 version: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleExclusionArgs']]]] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The name of the managed rule to use with this resource.
        :param pulumi.Input[str] version: The version on the managed rule to use with this resource.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleExclusionArgs']]] exclusions: One or more `exclusion` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideArgs']]] overrides: One or more `override` blocks as defined below.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The name of the managed rule to use with this resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        The version on the managed rule to use with this resource.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleExclusionArgs']]]]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideArgs']]]]:
        """
        One or more `override` blocks as defined below.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideArgs']]]]):
        pulumi.set(self, "overrides", value)


@pulumi.input_type
class FirewallPolicyManagedRuleExclusionArgs:
    def __init__(__self__, *,
                 match_variable: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 selector: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        :param pulumi.Input[str] operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param pulumi.Input[str] selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[str]:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)


@pulumi.input_type
class FirewallPolicyManagedRuleOverrideArgs:
    def __init__(__self__, *,
                 rule_group_name: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideExclusionArgs']]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] rule_group_name: The managed rule group to override.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideExclusionArgs']]] exclusions: One or more `exclusion` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideRuleArgs']]] rules: One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        pulumi.set(__self__, "rule_group_name", rule_group_name)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> pulumi.Input[str]:
        """
        The managed rule group to override.
        """
        return pulumi.get(self, "rule_group_name")

    @rule_group_name.setter
    def rule_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_group_name", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideExclusionArgs']]]]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideRuleArgs']]]]:
        """
        One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class FirewallPolicyManagedRuleOverrideExclusionArgs:
    def __init__(__self__, *,
                 match_variable: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 selector: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        :param pulumi.Input[str] operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param pulumi.Input[str] selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[str]:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)


@pulumi.input_type
class FirewallPolicyManagedRuleOverrideRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 rule_id: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideRuleExclusionArgs']]]] = None):
        """
        :param pulumi.Input[str] action: The action to be applied when the rule matches. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        :param pulumi.Input[str] rule_id: Identifier for the managed rule.
        :param pulumi.Input[bool] enabled: Is the managed rule override enabled or disabled. Defaults to `false`
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideRuleExclusionArgs']]] exclusions: One or more `exclusion` blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "rule_id", rule_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to be applied when the rule matches. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[str]:
        """
        Identifier for the managed rule.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the managed rule override enabled or disabled. Defaults to `false`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideRuleExclusionArgs']]]]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyManagedRuleOverrideRuleExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)


@pulumi.input_type
class FirewallPolicyManagedRuleOverrideRuleExclusionArgs:
    def __init__(__self__, *,
                 match_variable: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 selector: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        :param pulumi.Input[str] operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param pulumi.Input[str] selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[str]:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)


@pulumi.input_type
class FrontdoorBackendPoolArgs:
    def __init__(__self__, *,
                 backends: pulumi.Input[Sequence[pulumi.Input['FrontdoorBackendPoolBackendArgs']]],
                 health_probe_name: pulumi.Input[str],
                 load_balancing_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FrontdoorBackendPoolBackendArgs']]] backends: A `backend` block as defined below.
        :param pulumi.Input[str] health_probe_name: Specifies the name of the `backend_pool_health_probe` block within this resource to use for this `Backend Pool`.
        :param pulumi.Input[str] load_balancing_name: Specifies the name of the `backend_pool_load_balancing` block within this resource to use for this `Backend Pool`.
        :param pulumi.Input[str] name: Specifies the name of the Backend Pool.
        :param pulumi.Input[str] id: The ID of the FrontDoor.
        """
        pulumi.set(__self__, "backends", backends)
        pulumi.set(__self__, "health_probe_name", health_probe_name)
        pulumi.set(__self__, "load_balancing_name", load_balancing_name)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def backends(self) -> pulumi.Input[Sequence[pulumi.Input['FrontdoorBackendPoolBackendArgs']]]:
        """
        A `backend` block as defined below.
        """
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: pulumi.Input[Sequence[pulumi.Input['FrontdoorBackendPoolBackendArgs']]]):
        pulumi.set(self, "backends", value)

    @property
    @pulumi.getter(name="healthProbeName")
    def health_probe_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the `backend_pool_health_probe` block within this resource to use for this `Backend Pool`.
        """
        return pulumi.get(self, "health_probe_name")

    @health_probe_name.setter
    def health_probe_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "health_probe_name", value)

    @property
    @pulumi.getter(name="loadBalancingName")
    def load_balancing_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the `backend_pool_load_balancing` block within this resource to use for this `Backend Pool`.
        """
        return pulumi.get(self, "load_balancing_name")

    @load_balancing_name.setter
    def load_balancing_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "load_balancing_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Backend Pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class FrontdoorBackendPoolBackendArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 host_header: pulumi.Input[str],
                 http_port: pulumi.Input[int],
                 https_port: pulumi.Input[int],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] address: Location of the backend (IP address or FQDN)
        :param pulumi.Input[str] host_header: The value to use as the host header sent to the backend.
        :param pulumi.Input[int] http_port: The HTTP TCP port number. Possible values are between `1` - `65535`.
        :param pulumi.Input[int] https_port: The HTTPS TCP port number. Possible values are between `1` - `65535`.
        :param pulumi.Input[bool] enabled: Specifies if the backend is enabled or not. Valid options are `true` or `false`. Defaults to `true`.
        :param pulumi.Input[int] priority: Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy. Defaults to `1`.
        :param pulumi.Input[int] weight: Weight of this endpoint for load balancing purposes. Defaults to `50`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        Location of the backend (IP address or FQDN)
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> pulumi.Input[str]:
        """
        The value to use as the host header sent to the backend.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> pulumi.Input[int]:
        """
        The HTTP TCP port number. Possible values are between `1` - `65535`.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> pulumi.Input[int]:
        """
        The HTTPS TCP port number. Possible values are between `1` - `65535`.
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "https_port", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the backend is enabled or not. Valid options are `true` or `false`. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy. Defaults to `1`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight of this endpoint for load balancing purposes. Defaults to `50`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class FrontdoorBackendPoolHealthProbeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 probe_method: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Specifies the name of the Health Probe.
        :param pulumi.Input[bool] enabled: Is this health probe enabled? Dafaults to `true`.
        :param pulumi.Input[str] id: The ID of the FrontDoor.
        :param pulumi.Input[int] interval_in_seconds: The number of seconds between each Health Probe. Defaults to `120`.
        :param pulumi.Input[str] path: The path to use for the Health Probe. Default is `/`.
        :param pulumi.Input[str] probe_method: Specifies HTTP method the health probe uses when querying the backend pool instances. Possible values include: `Get` and `Head`. Defaults to `Get`.
        :param pulumi.Input[str] protocol: Protocol scheme to use for the Health Probe. Defaults to `Http`.
        """
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if probe_method is not None:
            pulumi.set(__self__, "probe_method", probe_method)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Health Probe.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this health probe enabled? Dafaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds between each Health Probe. Defaults to `120`.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_in_seconds", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to use for the Health Probe. Default is `/`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="probeMethod")
    def probe_method(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies HTTP method the health probe uses when querying the backend pool instances. Possible values include: `Get` and `Head`. Defaults to `Get`.
        """
        return pulumi.get(self, "probe_method")

    @probe_method.setter
    def probe_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probe_method", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol scheme to use for the Health Probe. Defaults to `Http`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class FrontdoorBackendPoolLoadBalancingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 additional_latency_milliseconds: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 sample_size: Optional[pulumi.Input[int]] = None,
                 successful_samples_required: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Specifies the name of the Load Balancer.
        :param pulumi.Input[int] additional_latency_milliseconds: The additional latency in milliseconds for probes to fall into the lowest latency bucket. Defaults to `0`.
        :param pulumi.Input[str] id: The ID of the FrontDoor.
        :param pulumi.Input[int] sample_size: The number of samples to consider for load balancing decisions. Defaults to `4`.
        :param pulumi.Input[int] successful_samples_required: The number of samples within the sample period that must succeed. Defaults to `2`.
        """
        pulumi.set(__self__, "name", name)
        if additional_latency_milliseconds is not None:
            pulumi.set(__self__, "additional_latency_milliseconds", additional_latency_milliseconds)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if successful_samples_required is not None:
            pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="additionalLatencyMilliseconds")
    def additional_latency_milliseconds(self) -> Optional[pulumi.Input[int]]:
        """
        The additional latency in milliseconds for probes to fall into the lowest latency bucket. Defaults to `0`.
        """
        return pulumi.get(self, "additional_latency_milliseconds")

    @additional_latency_milliseconds.setter
    def additional_latency_milliseconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_latency_milliseconds", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of samples to consider for load balancing decisions. Defaults to `4`.
        """
        return pulumi.get(self, "sample_size")

    @sample_size.setter
    def sample_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_size", value)

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[pulumi.Input[int]]:
        """
        The number of samples within the sample period that must succeed. Defaults to `2`.
        """
        return pulumi.get(self, "successful_samples_required")

    @successful_samples_required.setter
    def successful_samples_required(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "successful_samples_required", value)


@pulumi.input_type
class FrontdoorExplicitResourceOrderArgs:
    def __init__(__self__, *,
                 backend_pool_health_probe_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 backend_pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 backend_pool_load_balancing_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 frontend_endpoint_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 routing_rule_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if backend_pool_health_probe_ids is not None:
            pulumi.set(__self__, "backend_pool_health_probe_ids", backend_pool_health_probe_ids)
        if backend_pool_ids is not None:
            pulumi.set(__self__, "backend_pool_ids", backend_pool_ids)
        if backend_pool_load_balancing_ids is not None:
            pulumi.set(__self__, "backend_pool_load_balancing_ids", backend_pool_load_balancing_ids)
        if frontend_endpoint_ids is not None:
            pulumi.set(__self__, "frontend_endpoint_ids", frontend_endpoint_ids)
        if routing_rule_ids is not None:
            pulumi.set(__self__, "routing_rule_ids", routing_rule_ids)

    @property
    @pulumi.getter(name="backendPoolHealthProbeIds")
    def backend_pool_health_probe_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "backend_pool_health_probe_ids")

    @backend_pool_health_probe_ids.setter
    def backend_pool_health_probe_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "backend_pool_health_probe_ids", value)

    @property
    @pulumi.getter(name="backendPoolIds")
    def backend_pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "backend_pool_ids")

    @backend_pool_ids.setter
    def backend_pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "backend_pool_ids", value)

    @property
    @pulumi.getter(name="backendPoolLoadBalancingIds")
    def backend_pool_load_balancing_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "backend_pool_load_balancing_ids")

    @backend_pool_load_balancing_ids.setter
    def backend_pool_load_balancing_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "backend_pool_load_balancing_ids", value)

    @property
    @pulumi.getter(name="frontendEndpointIds")
    def frontend_endpoint_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "frontend_endpoint_ids")

    @frontend_endpoint_ids.setter
    def frontend_endpoint_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "frontend_endpoint_ids", value)

    @property
    @pulumi.getter(name="routingRuleIds")
    def routing_rule_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "routing_rule_ids")

    @routing_rule_ids.setter
    def routing_rule_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "routing_rule_ids", value)


@pulumi.input_type
class FrontdoorFrontendEndpointArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 session_affinity_enabled: Optional[pulumi.Input[bool]] = None,
                 session_affinity_ttl_seconds: Optional[pulumi.Input[int]] = None,
                 web_application_firewall_policy_link_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host_name: Specifies the host name of the `frontend_endpoint`. Must be a domain name. In order to use a name.azurefd.net domain, the name value must match the Front Door name.
        :param pulumi.Input[str] name: Specifies the name of the `frontend_endpoint`.
        :param pulumi.Input[str] id: The ID of the FrontDoor.
        :param pulumi.Input[bool] session_affinity_enabled: Whether to allow session affinity on this host. Valid options are `true` or `false` Defaults to `false`.
        :param pulumi.Input[int] session_affinity_ttl_seconds: The TTL to use in seconds for session affinity, if applicable. Defaults to `0`.
        :param pulumi.Input[str] web_application_firewall_policy_link_id: Defines the Web Application Firewall policy `ID` for each host.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if session_affinity_enabled is not None:
            pulumi.set(__self__, "session_affinity_enabled", session_affinity_enabled)
        if session_affinity_ttl_seconds is not None:
            pulumi.set(__self__, "session_affinity_ttl_seconds", session_affinity_ttl_seconds)
        if web_application_firewall_policy_link_id is not None:
            pulumi.set(__self__, "web_application_firewall_policy_link_id", web_application_firewall_policy_link_id)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[str]:
        """
        Specifies the host name of the `frontend_endpoint`. Must be a domain name. In order to use a name.azurefd.net domain, the name value must match the Front Door name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the `frontend_endpoint`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="sessionAffinityEnabled")
    def session_affinity_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow session affinity on this host. Valid options are `true` or `false` Defaults to `false`.
        """
        return pulumi.get(self, "session_affinity_enabled")

    @session_affinity_enabled.setter
    def session_affinity_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "session_affinity_enabled", value)

    @property
    @pulumi.getter(name="sessionAffinityTtlSeconds")
    def session_affinity_ttl_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The TTL to use in seconds for session affinity, if applicable. Defaults to `0`.
        """
        return pulumi.get(self, "session_affinity_ttl_seconds")

    @session_affinity_ttl_seconds.setter
    def session_affinity_ttl_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_affinity_ttl_seconds", value)

    @property
    @pulumi.getter(name="webApplicationFirewallPolicyLinkId")
    def web_application_firewall_policy_link_id(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the Web Application Firewall policy `ID` for each host.
        """
        return pulumi.get(self, "web_application_firewall_policy_link_id")

    @web_application_firewall_policy_link_id.setter
    def web_application_firewall_policy_link_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_application_firewall_policy_link_id", value)


@pulumi.input_type
class FrontdoorRoutingRuleArgs:
    def __init__(__self__, *,
                 accepted_protocols: pulumi.Input[Sequence[pulumi.Input[str]]],
                 frontend_endpoints: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 patterns_to_matches: pulumi.Input[Sequence[pulumi.Input[str]]],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 forwarding_configuration: Optional[pulumi.Input['FrontdoorRoutingRuleForwardingConfigurationArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 redirect_configuration: Optional[pulumi.Input['FrontdoorRoutingRuleRedirectConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] accepted_protocols: Protocol schemes to match for the Backend Routing Rule. Defaults to `Http`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] frontend_endpoints: The names of the `frontend_endpoint` blocks within this resource to associate with this `routing_rule`.
        :param pulumi.Input[str] name: Specifies the name of the Routing Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] patterns_to_matches: The route patterns for the Backend Routing Rule. Defaults to `/*`.
        :param pulumi.Input[bool] enabled: `Enable` or `Disable` use of this Backend Routing Rule. Permitted values are `true` or `false`. Defaults to `true`.
        :param pulumi.Input['FrontdoorRoutingRuleForwardingConfigurationArgs'] forwarding_configuration: A `forwarding_configuration` block as defined below.
        :param pulumi.Input[str] id: The ID of the FrontDoor.
        :param pulumi.Input['FrontdoorRoutingRuleRedirectConfigurationArgs'] redirect_configuration: A `redirect_configuration` block as defined below.
        """
        pulumi.set(__self__, "accepted_protocols", accepted_protocols)
        pulumi.set(__self__, "frontend_endpoints", frontend_endpoints)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "patterns_to_matches", patterns_to_matches)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if forwarding_configuration is not None:
            pulumi.set(__self__, "forwarding_configuration", forwarding_configuration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if redirect_configuration is not None:
            pulumi.set(__self__, "redirect_configuration", redirect_configuration)

    @property
    @pulumi.getter(name="acceptedProtocols")
    def accepted_protocols(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Protocol schemes to match for the Backend Routing Rule. Defaults to `Http`.
        """
        return pulumi.get(self, "accepted_protocols")

    @accepted_protocols.setter
    def accepted_protocols(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "accepted_protocols", value)

    @property
    @pulumi.getter(name="frontendEndpoints")
    def frontend_endpoints(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The names of the `frontend_endpoint` blocks within this resource to associate with this `routing_rule`.
        """
        return pulumi.get(self, "frontend_endpoints")

    @frontend_endpoints.setter
    def frontend_endpoints(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "frontend_endpoints", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Routing Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="patternsToMatches")
    def patterns_to_matches(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The route patterns for the Backend Routing Rule. Defaults to `/*`.
        """
        return pulumi.get(self, "patterns_to_matches")

    @patterns_to_matches.setter
    def patterns_to_matches(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "patterns_to_matches", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        `Enable` or `Disable` use of this Backend Routing Rule. Permitted values are `true` or `false`. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="forwardingConfiguration")
    def forwarding_configuration(self) -> Optional[pulumi.Input['FrontdoorRoutingRuleForwardingConfigurationArgs']]:
        """
        A `forwarding_configuration` block as defined below.
        """
        return pulumi.get(self, "forwarding_configuration")

    @forwarding_configuration.setter
    def forwarding_configuration(self, value: Optional[pulumi.Input['FrontdoorRoutingRuleForwardingConfigurationArgs']]):
        pulumi.set(self, "forwarding_configuration", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="redirectConfiguration")
    def redirect_configuration(self) -> Optional[pulumi.Input['FrontdoorRoutingRuleRedirectConfigurationArgs']]:
        """
        A `redirect_configuration` block as defined below.
        """
        return pulumi.get(self, "redirect_configuration")

    @redirect_configuration.setter
    def redirect_configuration(self, value: Optional[pulumi.Input['FrontdoorRoutingRuleRedirectConfigurationArgs']]):
        pulumi.set(self, "redirect_configuration", value)


@pulumi.input_type
class FrontdoorRoutingRuleForwardingConfigurationArgs:
    def __init__(__self__, *,
                 backend_pool_name: pulumi.Input[str],
                 cache_duration: Optional[pulumi.Input[str]] = None,
                 cache_enabled: Optional[pulumi.Input[bool]] = None,
                 cache_query_parameter_strip_directive: Optional[pulumi.Input[str]] = None,
                 cache_query_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cache_use_dynamic_compression: Optional[pulumi.Input[bool]] = None,
                 custom_forwarding_path: Optional[pulumi.Input[str]] = None,
                 forwarding_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_pool_name: Specifies the name of the Backend Pool to forward the incoming traffic to.
        :param pulumi.Input[str] cache_duration: Specify the caching duration (in ISO8601 notation e.g. `P1DT2H` for 1 day and 2 hours). Needs to be greater than 0 and smaller than 365 days. `cache_duration` works only in combination with `cache_enabled` set to `true`.
        :param pulumi.Input[bool] cache_enabled: Specifies whether to Enable caching or not. Valid options are `true` or `false`. Defaults to `false`.
        :param pulumi.Input[str] cache_query_parameter_strip_directive: Defines cache behaviour in relation to query string parameters. Valid options are `StripAll`, `StripAllExcept`, `StripOnly` or `StripNone`. Defaults to `StripAll`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cache_query_parameters: Specify query parameters (array). Works only in combination with `cache_query_parameter_strip_directive` set to `StripAllExcept` or `StripOnly`.
        :param pulumi.Input[bool] cache_use_dynamic_compression: Whether to use dynamic compression when caching. Valid options are `true` or `false`. Defaults to `false`.
        :param pulumi.Input[str] custom_forwarding_path: Path to use when constructing the request to forward to the backend. This functions as a URL Rewrite. Default behaviour preserves the URL path.
        :param pulumi.Input[str] forwarding_protocol: Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `HttpsOnly`.
        """
        pulumi.set(__self__, "backend_pool_name", backend_pool_name)
        if cache_duration is not None:
            pulumi.set(__self__, "cache_duration", cache_duration)
        if cache_enabled is not None:
            pulumi.set(__self__, "cache_enabled", cache_enabled)
        if cache_query_parameter_strip_directive is not None:
            pulumi.set(__self__, "cache_query_parameter_strip_directive", cache_query_parameter_strip_directive)
        if cache_query_parameters is not None:
            pulumi.set(__self__, "cache_query_parameters", cache_query_parameters)
        if cache_use_dynamic_compression is not None:
            pulumi.set(__self__, "cache_use_dynamic_compression", cache_use_dynamic_compression)
        if custom_forwarding_path is not None:
            pulumi.set(__self__, "custom_forwarding_path", custom_forwarding_path)
        if forwarding_protocol is not None:
            pulumi.set(__self__, "forwarding_protocol", forwarding_protocol)

    @property
    @pulumi.getter(name="backendPoolName")
    def backend_pool_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Backend Pool to forward the incoming traffic to.
        """
        return pulumi.get(self, "backend_pool_name")

    @backend_pool_name.setter
    def backend_pool_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "backend_pool_name", value)

    @property
    @pulumi.getter(name="cacheDuration")
    def cache_duration(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the caching duration (in ISO8601 notation e.g. `P1DT2H` for 1 day and 2 hours). Needs to be greater than 0 and smaller than 365 days. `cache_duration` works only in combination with `cache_enabled` set to `true`.
        """
        return pulumi.get(self, "cache_duration")

    @cache_duration.setter
    def cache_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_duration", value)

    @property
    @pulumi.getter(name="cacheEnabled")
    def cache_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to Enable caching or not. Valid options are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "cache_enabled")

    @cache_enabled.setter
    def cache_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache_enabled", value)

    @property
    @pulumi.getter(name="cacheQueryParameterStripDirective")
    def cache_query_parameter_strip_directive(self) -> Optional[pulumi.Input[str]]:
        """
        Defines cache behaviour in relation to query string parameters. Valid options are `StripAll`, `StripAllExcept`, `StripOnly` or `StripNone`. Defaults to `StripAll`.
        """
        return pulumi.get(self, "cache_query_parameter_strip_directive")

    @cache_query_parameter_strip_directive.setter
    def cache_query_parameter_strip_directive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_query_parameter_strip_directive", value)

    @property
    @pulumi.getter(name="cacheQueryParameters")
    def cache_query_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify query parameters (array). Works only in combination with `cache_query_parameter_strip_directive` set to `StripAllExcept` or `StripOnly`.
        """
        return pulumi.get(self, "cache_query_parameters")

    @cache_query_parameters.setter
    def cache_query_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cache_query_parameters", value)

    @property
    @pulumi.getter(name="cacheUseDynamicCompression")
    def cache_use_dynamic_compression(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use dynamic compression when caching. Valid options are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "cache_use_dynamic_compression")

    @cache_use_dynamic_compression.setter
    def cache_use_dynamic_compression(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache_use_dynamic_compression", value)

    @property
    @pulumi.getter(name="customForwardingPath")
    def custom_forwarding_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to use when constructing the request to forward to the backend. This functions as a URL Rewrite. Default behaviour preserves the URL path.
        """
        return pulumi.get(self, "custom_forwarding_path")

    @custom_forwarding_path.setter
    def custom_forwarding_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_forwarding_path", value)

    @property
    @pulumi.getter(name="forwardingProtocol")
    def forwarding_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `HttpsOnly`.
        """
        return pulumi.get(self, "forwarding_protocol")

    @forwarding_protocol.setter
    def forwarding_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forwarding_protocol", value)


@pulumi.input_type
class FrontdoorRoutingRuleRedirectConfigurationArgs:
    def __init__(__self__, *,
                 redirect_protocol: pulumi.Input[str],
                 redirect_type: pulumi.Input[str],
                 custom_fragment: Optional[pulumi.Input[str]] = None,
                 custom_host: Optional[pulumi.Input[str]] = None,
                 custom_path: Optional[pulumi.Input[str]] = None,
                 custom_query_string: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] redirect_protocol: Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `MatchRequest`
        :param pulumi.Input[str] redirect_type: Status code for the redirect. Valida options are `Moved`, `Found`, `TemporaryRedirect`, `PermanentRedirect`.
        :param pulumi.Input[str] custom_fragment: The destination fragment in the portion of URL after '#'. Set this to add a fragment to the redirect URL.
        :param pulumi.Input[str] custom_host: Set this to change the URL for the redirection.
        :param pulumi.Input[str] custom_path: The path to retain as per the incoming request, or update in the URL for the redirection.
        :param pulumi.Input[str] custom_query_string: Replace any existing query string from the incoming request URL.
        """
        pulumi.set(__self__, "redirect_protocol", redirect_protocol)
        pulumi.set(__self__, "redirect_type", redirect_type)
        if custom_fragment is not None:
            pulumi.set(__self__, "custom_fragment", custom_fragment)
        if custom_host is not None:
            pulumi.set(__self__, "custom_host", custom_host)
        if custom_path is not None:
            pulumi.set(__self__, "custom_path", custom_path)
        if custom_query_string is not None:
            pulumi.set(__self__, "custom_query_string", custom_query_string)

    @property
    @pulumi.getter(name="redirectProtocol")
    def redirect_protocol(self) -> pulumi.Input[str]:
        """
        Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `MatchRequest`
        """
        return pulumi.get(self, "redirect_protocol")

    @redirect_protocol.setter
    def redirect_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "redirect_protocol", value)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> pulumi.Input[str]:
        """
        Status code for the redirect. Valida options are `Moved`, `Found`, `TemporaryRedirect`, `PermanentRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @redirect_type.setter
    def redirect_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "redirect_type", value)

    @property
    @pulumi.getter(name="customFragment")
    def custom_fragment(self) -> Optional[pulumi.Input[str]]:
        """
        The destination fragment in the portion of URL after '#'. Set this to add a fragment to the redirect URL.
        """
        return pulumi.get(self, "custom_fragment")

    @custom_fragment.setter
    def custom_fragment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fragment", value)

    @property
    @pulumi.getter(name="customHost")
    def custom_host(self) -> Optional[pulumi.Input[str]]:
        """
        Set this to change the URL for the redirection.
        """
        return pulumi.get(self, "custom_host")

    @custom_host.setter
    def custom_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_host", value)

    @property
    @pulumi.getter(name="customPath")
    def custom_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to retain as per the incoming request, or update in the URL for the redirection.
        """
        return pulumi.get(self, "custom_path")

    @custom_path.setter
    def custom_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_path", value)

    @property
    @pulumi.getter(name="customQueryString")
    def custom_query_string(self) -> Optional[pulumi.Input[str]]:
        """
        Replace any existing query string from the incoming request URL.
        """
        return pulumi.get(self, "custom_query_string")

    @custom_query_string.setter
    def custom_query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_query_string", value)


