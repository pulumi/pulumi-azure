# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'CustomHttpsConfigurationCustomHttpsConfiguration',
    'FirewallPolicyCustomRule',
    'FirewallPolicyCustomRuleMatchCondition',
    'FirewallPolicyManagedRule',
    'FirewallPolicyManagedRuleExclusion',
    'FirewallPolicyManagedRuleOverride',
    'FirewallPolicyManagedRuleOverrideExclusion',
    'FirewallPolicyManagedRuleOverrideRule',
    'FirewallPolicyManagedRuleOverrideRuleExclusion',
    'FrontdoorBackendPool',
    'FrontdoorBackendPoolBackend',
    'FrontdoorBackendPoolHealthProbe',
    'FrontdoorBackendPoolLoadBalancing',
    'FrontdoorFrontendEndpoint',
    'FrontdoorFrontendEndpointCustomHttpsConfiguration',
    'FrontdoorRoutingRule',
    'FrontdoorRoutingRuleForwardingConfiguration',
    'FrontdoorRoutingRuleRedirectConfiguration',
]

@pulumi.output_type
class CustomHttpsConfigurationCustomHttpsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureKeyVaultCertificateSecretName":
            suggest = "azure_key_vault_certificate_secret_name"
        elif key == "azureKeyVaultCertificateSecretVersion":
            suggest = "azure_key_vault_certificate_secret_version"
        elif key == "azureKeyVaultCertificateVaultId":
            suggest = "azure_key_vault_certificate_vault_id"
        elif key == "certificateSource":
            suggest = "certificate_source"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "provisioningSubstate":
            suggest = "provisioning_substate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomHttpsConfigurationCustomHttpsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomHttpsConfigurationCustomHttpsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomHttpsConfigurationCustomHttpsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_key_vault_certificate_secret_name: Optional[str] = None,
                 azure_key_vault_certificate_secret_version: Optional[str] = None,
                 azure_key_vault_certificate_vault_id: Optional[str] = None,
                 certificate_source: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 provisioning_substate: Optional[str] = None):
        """
        :param str azure_key_vault_certificate_secret_name: The name of the Key Vault secret representing the full certificate PFX.
        :param str azure_key_vault_certificate_secret_version: The version of the Key Vault secret representing the full certificate PFX.
        :param str azure_key_vault_certificate_vault_id: The ID of the Key Vault containing the SSL certificate.
        :param str certificate_source: Certificate source to encrypted `HTTPS` traffic with. Allowed values are `FrontDoor` or `AzureKeyVault`. Defaults to `FrontDoor`.
        :param str minimum_tls_version: Minimum client TLS version supported.
        """
        if azure_key_vault_certificate_secret_name is not None:
            pulumi.set(__self__, "azure_key_vault_certificate_secret_name", azure_key_vault_certificate_secret_name)
        if azure_key_vault_certificate_secret_version is not None:
            pulumi.set(__self__, "azure_key_vault_certificate_secret_version", azure_key_vault_certificate_secret_version)
        if azure_key_vault_certificate_vault_id is not None:
            pulumi.set(__self__, "azure_key_vault_certificate_vault_id", azure_key_vault_certificate_vault_id)
        if certificate_source is not None:
            pulumi.set(__self__, "certificate_source", certificate_source)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if provisioning_substate is not None:
            pulumi.set(__self__, "provisioning_substate", provisioning_substate)

    @property
    @pulumi.getter(name="azureKeyVaultCertificateSecretName")
    def azure_key_vault_certificate_secret_name(self) -> Optional[str]:
        """
        The name of the Key Vault secret representing the full certificate PFX.
        """
        return pulumi.get(self, "azure_key_vault_certificate_secret_name")

    @property
    @pulumi.getter(name="azureKeyVaultCertificateSecretVersion")
    def azure_key_vault_certificate_secret_version(self) -> Optional[str]:
        """
        The version of the Key Vault secret representing the full certificate PFX.
        """
        return pulumi.get(self, "azure_key_vault_certificate_secret_version")

    @property
    @pulumi.getter(name="azureKeyVaultCertificateVaultId")
    def azure_key_vault_certificate_vault_id(self) -> Optional[str]:
        """
        The ID of the Key Vault containing the SSL certificate.
        """
        return pulumi.get(self, "azure_key_vault_certificate_vault_id")

    @property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> Optional[str]:
        """
        Certificate source to encrypted `HTTPS` traffic with. Allowed values are `FrontDoor` or `AzureKeyVault`. Defaults to `FrontDoor`.
        """
        return pulumi.get(self, "certificate_source")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        Minimum client TLS version supported.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="provisioningSubstate")
    def provisioning_substate(self) -> Optional[str]:
        return pulumi.get(self, "provisioning_substate")


@pulumi.output_type
class FirewallPolicyCustomRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchConditions":
            suggest = "match_conditions"
        elif key == "rateLimitDurationInMinutes":
            suggest = "rate_limit_duration_in_minutes"
        elif key == "rateLimitThreshold":
            suggest = "rate_limit_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyCustomRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyCustomRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyCustomRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 name: str,
                 type: str,
                 enabled: Optional[bool] = None,
                 match_conditions: Optional[Sequence['outputs.FirewallPolicyCustomRuleMatchCondition']] = None,
                 priority: Optional[int] = None,
                 rate_limit_duration_in_minutes: Optional[int] = None,
                 rate_limit_threshold: Optional[int] = None):
        """
        :param str action: The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        :param str name: Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        :param str type: The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        :param bool enabled: Is the rule is enabled or disabled? Defaults to `true`.
        :param Sequence['FirewallPolicyCustomRuleMatchConditionArgs'] match_conditions: One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        :param int priority: The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        :param int rate_limit_duration_in_minutes: The rate limit duration in minutes. Defaults to `1`.
        :param int rate_limit_threshold: The rate limit threshold. Defaults to `10`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rate_limit_duration_in_minutes is not None:
            pulumi.set(__self__, "rate_limit_duration_in_minutes", rate_limit_duration_in_minutes)
        if rate_limit_threshold is not None:
            pulumi.set(__self__, "rate_limit_threshold", rate_limit_threshold)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Gets name of the resource that is unique within a policy. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is the rule is enabled or disabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[Sequence['outputs.FirewallPolicyCustomRuleMatchCondition']]:
        """
        One or more `match_condition` block defined below. Can support up to `10` `match_condition` blocks.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="rateLimitDurationInMinutes")
    def rate_limit_duration_in_minutes(self) -> Optional[int]:
        """
        The rate limit duration in minutes. Defaults to `1`.
        """
        return pulumi.get(self, "rate_limit_duration_in_minutes")

    @property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> Optional[int]:
        """
        The rate limit threshold. Defaults to `10`.
        """
        return pulumi.get(self, "rate_limit_threshold")


@pulumi.output_type
class FirewallPolicyCustomRuleMatchCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValues":
            suggest = "match_values"
        elif key == "matchVariable":
            suggest = "match_variable"
        elif key == "negationCondition":
            suggest = "negation_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyCustomRuleMatchCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyCustomRuleMatchCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyCustomRuleMatchCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_values: Sequence[str],
                 match_variable: str,
                 operator: str,
                 negation_condition: Optional[bool] = None,
                 selector: Optional[str] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] match_values: Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters long.
        :param str match_variable: The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        :param str operator: Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
        :param bool negation_condition: Should the result of the condition be negated.
        :param str selector: Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
        :param Sequence[str] transforms: Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or`URLEncode`.
        """
        pulumi.set(__self__, "match_values", match_values)
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        if negation_condition is not None:
            pulumi.set(__self__, "negation_condition", negation_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Sequence[str]:
        """
        Up to `600` possible values to match. Limit is in total across all `match_condition` blocks and `match_values` arguments. String value itself can be up to `256` characters long.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="negationCondition")
    def negation_condition(self) -> Optional[bool]:
        """
        Should the result of the condition be negated.
        """
        return pulumi.get(self, "negation_condition")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        Match against a specific key if the `match_variable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or`URLEncode`.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class FirewallPolicyManagedRule(dict):
    def __init__(__self__, *,
                 type: str,
                 version: str,
                 exclusions: Optional[Sequence['outputs.FirewallPolicyManagedRuleExclusion']] = None,
                 overrides: Optional[Sequence['outputs.FirewallPolicyManagedRuleOverride']] = None):
        """
        :param str type: The name of the managed rule to use with this resource.
        :param str version: The version on the managed rule to use with this resource.
        :param Sequence['FirewallPolicyManagedRuleExclusionArgs'] exclusions: One or more `exclusion` blocks as defined below.
        :param Sequence['FirewallPolicyManagedRuleOverrideArgs'] overrides: One or more `override` blocks as defined below.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The name of the managed rule to use with this resource.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version on the managed rule to use with this resource.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.FirewallPolicyManagedRuleExclusion']]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.FirewallPolicyManagedRuleOverride']]:
        """
        One or more `override` blocks as defined below.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class FirewallPolicyManagedRuleExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyManagedRuleExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyManagedRuleExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyManagedRuleExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 operator: str,
                 selector: str):
        """
        :param str match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        :param str operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param str selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class FirewallPolicyManagedRuleOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleGroupName":
            suggest = "rule_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyManagedRuleOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyManagedRuleOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyManagedRuleOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_group_name: str,
                 exclusions: Optional[Sequence['outputs.FirewallPolicyManagedRuleOverrideExclusion']] = None,
                 rules: Optional[Sequence['outputs.FirewallPolicyManagedRuleOverrideRule']] = None):
        """
        :param str rule_group_name: The managed rule group to override.
        :param Sequence['FirewallPolicyManagedRuleOverrideExclusionArgs'] exclusions: One or more `exclusion` blocks as defined below.
        :param Sequence['FirewallPolicyManagedRuleOverrideRuleArgs'] rules: One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        pulumi.set(__self__, "rule_group_name", rule_group_name)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> str:
        """
        The managed rule group to override.
        """
        return pulumi.get(self, "rule_group_name")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.FirewallPolicyManagedRuleOverrideExclusion']]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.FirewallPolicyManagedRuleOverrideRule']]:
        """
        One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FirewallPolicyManagedRuleOverrideExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyManagedRuleOverrideExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyManagedRuleOverrideExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyManagedRuleOverrideExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 operator: str,
                 selector: str):
        """
        :param str match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        :param str operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param str selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class FirewallPolicyManagedRuleOverrideRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyManagedRuleOverrideRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyManagedRuleOverrideRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyManagedRuleOverrideRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 rule_id: str,
                 enabled: Optional[bool] = None,
                 exclusions: Optional[Sequence['outputs.FirewallPolicyManagedRuleOverrideRuleExclusion']] = None):
        """
        :param str action: The action to be applied when the rule matches. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        :param str rule_id: Identifier for the managed rule.
        :param bool enabled: Is the managed rule override enabled or disabled. Defaults to `false`
        :param Sequence['FirewallPolicyManagedRuleOverrideRuleExclusionArgs'] exclusions: One or more `exclusion` blocks as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "rule_id", rule_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to be applied when the rule matches. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Identifier for the managed rule.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is the managed rule override enabled or disabled. Defaults to `false`
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence['outputs.FirewallPolicyManagedRuleOverrideRuleExclusion']]:
        """
        One or more `exclusion` blocks as defined below.
        """
        return pulumi.get(self, "exclusions")


@pulumi.output_type
class FirewallPolicyManagedRuleOverrideRuleExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchVariable":
            suggest = "match_variable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyManagedRuleOverrideRuleExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyManagedRuleOverrideRuleExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyManagedRuleOverrideRuleExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_variable: str,
                 operator: str,
                 selector: str):
        """
        :param str match_variable: The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        :param str operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        :param str selector: Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def selector(self) -> str:
        """
        Selector for the value in the `match_variable` attribute this exclusion applies to.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class FrontdoorBackendPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthProbeName":
            suggest = "health_probe_name"
        elif key == "loadBalancingName":
            suggest = "load_balancing_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorBackendPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorBackendPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorBackendPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backends: Sequence['outputs.FrontdoorBackendPoolBackend'],
                 health_probe_name: str,
                 load_balancing_name: str,
                 name: str,
                 id: Optional[str] = None):
        """
        :param Sequence['FrontdoorBackendPoolBackendArgs'] backends: A `backend` block as defined below.
        :param str health_probe_name: Specifies the name of the `backend_pool_health_probe` block within this resource to use for this `Backend Pool`.
        :param str load_balancing_name: Specifies the name of the `backend_pool_load_balancing` block within this resource to use for this `Backend Pool`.
        :param str name: Specifies the name of the Backend Pool.
        :param str id: The ID of the FrontDoor.
        """
        pulumi.set(__self__, "backends", backends)
        pulumi.set(__self__, "health_probe_name", health_probe_name)
        pulumi.set(__self__, "load_balancing_name", load_balancing_name)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def backends(self) -> Sequence['outputs.FrontdoorBackendPoolBackend']:
        """
        A `backend` block as defined below.
        """
        return pulumi.get(self, "backends")

    @property
    @pulumi.getter(name="healthProbeName")
    def health_probe_name(self) -> str:
        """
        Specifies the name of the `backend_pool_health_probe` block within this resource to use for this `Backend Pool`.
        """
        return pulumi.get(self, "health_probe_name")

    @property
    @pulumi.getter(name="loadBalancingName")
    def load_balancing_name(self) -> str:
        """
        Specifies the name of the `backend_pool_load_balancing` block within this resource to use for this `Backend Pool`.
        """
        return pulumi.get(self, "load_balancing_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Backend Pool.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class FrontdoorBackendPoolBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostHeader":
            suggest = "host_header"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorBackendPoolBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorBackendPoolBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorBackendPoolBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 host_header: str,
                 http_port: int,
                 https_port: int,
                 enabled: Optional[bool] = None,
                 priority: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        :param str address: Location of the backend (IP address or FQDN)
        :param str host_header: The value to use as the host header sent to the backend.
        :param int http_port: The HTTP TCP port number. Possible values are between `1` - `65535`.
        :param int https_port: The HTTPS TCP port number. Possible values are between `1` - `65535`.
        :param bool enabled: Specifies if the backend is enabled or not. Valid options are `true` or `false`. Defaults to `true`.
        :param int priority: Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy. Defaults to `1`.
        :param int weight: Weight of this endpoint for load balancing purposes. Defaults to `50`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Location of the backend (IP address or FQDN)
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        The value to use as the host header sent to the backend.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> int:
        """
        The HTTP TCP port number. Possible values are between `1` - `65535`.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> int:
        """
        The HTTPS TCP port number. Possible values are between `1` - `65535`.
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies if the backend is enabled or not. Valid options are `true` or `false`. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy. Defaults to `1`.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of this endpoint for load balancing purposes. Defaults to `50`.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class FrontdoorBackendPoolHealthProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalInSeconds":
            suggest = "interval_in_seconds"
        elif key == "probeMethod":
            suggest = "probe_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorBackendPoolHealthProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorBackendPoolHealthProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorBackendPoolHealthProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 interval_in_seconds: Optional[int] = None,
                 path: Optional[str] = None,
                 probe_method: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str name: Specifies the name of the Health Probe.
        :param bool enabled: Is this health probe enabled? Dafaults to `true`.
        :param str id: The ID of the FrontDoor.
        :param int interval_in_seconds: The number of seconds between each Health Probe. Defaults to `120`.
        :param str path: The path to use for the Health Probe. Default is `/`.
        :param str probe_method: Specifies HTTP method the health probe uses when querying the backend pool instances. Possible values include: `Get` and `Head`. Defaults to `Get`.
        :param str protocol: Protocol scheme to use for the Health Probe. Defaults to `Http`.
        """
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if probe_method is not None:
            pulumi.set(__self__, "probe_method", probe_method)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Health Probe.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is this health probe enabled? Dafaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[int]:
        """
        The number of seconds between each Health Probe. Defaults to `120`.
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to use for the Health Probe. Default is `/`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="probeMethod")
    def probe_method(self) -> Optional[str]:
        """
        Specifies HTTP method the health probe uses when querying the backend pool instances. Possible values include: `Get` and `Head`. Defaults to `Get`.
        """
        return pulumi.get(self, "probe_method")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol scheme to use for the Health Probe. Defaults to `Http`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class FrontdoorBackendPoolLoadBalancing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalLatencyMilliseconds":
            suggest = "additional_latency_milliseconds"
        elif key == "sampleSize":
            suggest = "sample_size"
        elif key == "successfulSamplesRequired":
            suggest = "successful_samples_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorBackendPoolLoadBalancing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorBackendPoolLoadBalancing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorBackendPoolLoadBalancing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 additional_latency_milliseconds: Optional[int] = None,
                 id: Optional[str] = None,
                 sample_size: Optional[int] = None,
                 successful_samples_required: Optional[int] = None):
        """
        :param str name: Specifies the name of the Load Balancer.
        :param int additional_latency_milliseconds: The additional latency in milliseconds for probes to fall into the lowest latency bucket. Defaults to `0`.
        :param str id: The ID of the FrontDoor.
        :param int sample_size: The number of samples to consider for load balancing decisions. Defaults to `4`.
        :param int successful_samples_required: The number of samples within the sample period that must succeed. Defaults to `2`.
        """
        pulumi.set(__self__, "name", name)
        if additional_latency_milliseconds is not None:
            pulumi.set(__self__, "additional_latency_milliseconds", additional_latency_milliseconds)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if successful_samples_required is not None:
            pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="additionalLatencyMilliseconds")
    def additional_latency_milliseconds(self) -> Optional[int]:
        """
        The additional latency in milliseconds for probes to fall into the lowest latency bucket. Defaults to `0`.
        """
        return pulumi.get(self, "additional_latency_milliseconds")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[int]:
        """
        The number of samples to consider for load balancing decisions. Defaults to `4`.
        """
        return pulumi.get(self, "sample_size")

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[int]:
        """
        The number of samples within the sample period that must succeed. Defaults to `2`.
        """
        return pulumi.get(self, "successful_samples_required")


@pulumi.output_type
class FrontdoorFrontendEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "customHttpsConfiguration":
            suggest = "custom_https_configuration"
        elif key == "customHttpsProvisioningEnabled":
            suggest = "custom_https_provisioning_enabled"
        elif key == "sessionAffinityEnabled":
            suggest = "session_affinity_enabled"
        elif key == "sessionAffinityTtlSeconds":
            suggest = "session_affinity_ttl_seconds"
        elif key == "webApplicationFirewallPolicyLinkId":
            suggest = "web_application_firewall_policy_link_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFrontendEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFrontendEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFrontendEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: str,
                 name: str,
                 custom_https_configuration: Optional['outputs.FrontdoorFrontendEndpointCustomHttpsConfiguration'] = None,
                 custom_https_provisioning_enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 session_affinity_enabled: Optional[bool] = None,
                 session_affinity_ttl_seconds: Optional[int] = None,
                 web_application_firewall_policy_link_id: Optional[str] = None):
        """
        :param str host_name: Specifies the host name of the `frontend_endpoint`. Must be a domain name. In order to use a name.azurefd.net domain, the name value must match the Front Door name.
        :param str name: Specifies the name of the `frontend_endpoint`.
        :param 'FrontdoorFrontendEndpointCustomHttpsConfigurationArgs' custom_https_configuration: A `custom_https_configuration` block as defined below.
        :param bool custom_https_provisioning_enabled: Should the HTTPS protocol be enabled for a custom domain associated with the Front Door?
        :param str id: The ID of the FrontDoor.
        :param bool session_affinity_enabled: Whether to allow session affinity on this host. Valid options are `true` or `false` Defaults to `false`.
        :param int session_affinity_ttl_seconds: The TTL to use in seconds for session affinity, if applicable. Defaults to `0`.
        :param str web_application_firewall_policy_link_id: Defines the Web Application Firewall policy `ID` for each host.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "name", name)
        if custom_https_configuration is not None:
            pulumi.set(__self__, "custom_https_configuration", custom_https_configuration)
        if custom_https_provisioning_enabled is not None:
            pulumi.set(__self__, "custom_https_provisioning_enabled", custom_https_provisioning_enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if session_affinity_enabled is not None:
            pulumi.set(__self__, "session_affinity_enabled", session_affinity_enabled)
        if session_affinity_ttl_seconds is not None:
            pulumi.set(__self__, "session_affinity_ttl_seconds", session_affinity_ttl_seconds)
        if web_application_firewall_policy_link_id is not None:
            pulumi.set(__self__, "web_application_firewall_policy_link_id", web_application_firewall_policy_link_id)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        """
        Specifies the host name of the `frontend_endpoint`. Must be a domain name. In order to use a name.azurefd.net domain, the name value must match the Front Door name.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the `frontend_endpoint`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="customHttpsConfiguration")
    def custom_https_configuration(self) -> Optional['outputs.FrontdoorFrontendEndpointCustomHttpsConfiguration']:
        """
        A `custom_https_configuration` block as defined below.
        """
        return pulumi.get(self, "custom_https_configuration")

    @property
    @pulumi.getter(name="customHttpsProvisioningEnabled")
    def custom_https_provisioning_enabled(self) -> Optional[bool]:
        """
        Should the HTTPS protocol be enabled for a custom domain associated with the Front Door?
        """
        return pulumi.get(self, "custom_https_provisioning_enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="sessionAffinityEnabled")
    def session_affinity_enabled(self) -> Optional[bool]:
        """
        Whether to allow session affinity on this host. Valid options are `true` or `false` Defaults to `false`.
        """
        return pulumi.get(self, "session_affinity_enabled")

    @property
    @pulumi.getter(name="sessionAffinityTtlSeconds")
    def session_affinity_ttl_seconds(self) -> Optional[int]:
        """
        The TTL to use in seconds for session affinity, if applicable. Defaults to `0`.
        """
        return pulumi.get(self, "session_affinity_ttl_seconds")

    @property
    @pulumi.getter(name="webApplicationFirewallPolicyLinkId")
    def web_application_firewall_policy_link_id(self) -> Optional[str]:
        """
        Defines the Web Application Firewall policy `ID` for each host.
        """
        return pulumi.get(self, "web_application_firewall_policy_link_id")


@pulumi.output_type
class FrontdoorFrontendEndpointCustomHttpsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureKeyVaultCertificateSecretName":
            suggest = "azure_key_vault_certificate_secret_name"
        elif key == "azureKeyVaultCertificateSecretVersion":
            suggest = "azure_key_vault_certificate_secret_version"
        elif key == "azureKeyVaultCertificateVaultId":
            suggest = "azure_key_vault_certificate_vault_id"
        elif key == "certificateSource":
            suggest = "certificate_source"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "provisioningSubstate":
            suggest = "provisioning_substate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorFrontendEndpointCustomHttpsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorFrontendEndpointCustomHttpsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorFrontendEndpointCustomHttpsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_key_vault_certificate_secret_name: Optional[str] = None,
                 azure_key_vault_certificate_secret_version: Optional[str] = None,
                 azure_key_vault_certificate_vault_id: Optional[str] = None,
                 certificate_source: Optional[str] = None,
                 minimum_tls_version: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 provisioning_substate: Optional[str] = None):
        """
        :param str azure_key_vault_certificate_secret_name: The name of the Key Vault secret representing the full certificate PFX.
        :param str azure_key_vault_certificate_secret_version: The version of the Key Vault secret representing the full certificate PFX.
        :param str azure_key_vault_certificate_vault_id: The ID of the Key Vault containing the SSL certificate.
        :param str certificate_source: Certificate source to encrypted `HTTPS` traffic with. Allowed values are `FrontDoor` or `AzureKeyVault`. Defaults to `FrontDoor`.
        :param str minimum_tls_version: Minimum client TLS version supported.
        :param str provisioning_state: Provisioning state of the Front Door.
        :param str provisioning_substate: Provisioning substate of the Front Door
        """
        if azure_key_vault_certificate_secret_name is not None:
            pulumi.set(__self__, "azure_key_vault_certificate_secret_name", azure_key_vault_certificate_secret_name)
        if azure_key_vault_certificate_secret_version is not None:
            pulumi.set(__self__, "azure_key_vault_certificate_secret_version", azure_key_vault_certificate_secret_version)
        if azure_key_vault_certificate_vault_id is not None:
            pulumi.set(__self__, "azure_key_vault_certificate_vault_id", azure_key_vault_certificate_vault_id)
        if certificate_source is not None:
            pulumi.set(__self__, "certificate_source", certificate_source)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if provisioning_substate is not None:
            pulumi.set(__self__, "provisioning_substate", provisioning_substate)

    @property
    @pulumi.getter(name="azureKeyVaultCertificateSecretName")
    def azure_key_vault_certificate_secret_name(self) -> Optional[str]:
        """
        The name of the Key Vault secret representing the full certificate PFX.
        """
        return pulumi.get(self, "azure_key_vault_certificate_secret_name")

    @property
    @pulumi.getter(name="azureKeyVaultCertificateSecretVersion")
    def azure_key_vault_certificate_secret_version(self) -> Optional[str]:
        """
        The version of the Key Vault secret representing the full certificate PFX.
        """
        return pulumi.get(self, "azure_key_vault_certificate_secret_version")

    @property
    @pulumi.getter(name="azureKeyVaultCertificateVaultId")
    def azure_key_vault_certificate_vault_id(self) -> Optional[str]:
        """
        The ID of the Key Vault containing the SSL certificate.
        """
        return pulumi.get(self, "azure_key_vault_certificate_vault_id")

    @property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> Optional[str]:
        """
        Certificate source to encrypted `HTTPS` traffic with. Allowed values are `FrontDoor` or `AzureKeyVault`. Defaults to `FrontDoor`.
        """
        return pulumi.get(self, "certificate_source")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        Minimum client TLS version supported.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Provisioning state of the Front Door.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="provisioningSubstate")
    def provisioning_substate(self) -> Optional[str]:
        """
        Provisioning substate of the Front Door
        """
        return pulumi.get(self, "provisioning_substate")


@pulumi.output_type
class FrontdoorRoutingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptedProtocols":
            suggest = "accepted_protocols"
        elif key == "frontendEndpoints":
            suggest = "frontend_endpoints"
        elif key == "patternsToMatches":
            suggest = "patterns_to_matches"
        elif key == "forwardingConfiguration":
            suggest = "forwarding_configuration"
        elif key == "redirectConfiguration":
            suggest = "redirect_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRoutingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRoutingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRoutingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accepted_protocols: Sequence[str],
                 frontend_endpoints: Sequence[str],
                 name: str,
                 patterns_to_matches: Sequence[str],
                 enabled: Optional[bool] = None,
                 forwarding_configuration: Optional['outputs.FrontdoorRoutingRuleForwardingConfiguration'] = None,
                 id: Optional[str] = None,
                 redirect_configuration: Optional['outputs.FrontdoorRoutingRuleRedirectConfiguration'] = None):
        """
        :param Sequence[str] accepted_protocols: Protocol schemes to match for the Backend Routing Rule. Defaults to `Http`.
        :param Sequence[str] frontend_endpoints: The names of the `frontend_endpoint` blocks within this resource to associate with this `routing_rule`.
        :param str name: Specifies the name of the Routing Rule.
        :param Sequence[str] patterns_to_matches: The route patterns for the Backend Routing Rule. Defaults to `/*`.
        :param bool enabled: `Enable` or `Disable` use of this Backend Routing Rule. Permitted values are `true` or `false`. Defaults to `true`.
        :param 'FrontdoorRoutingRuleForwardingConfigurationArgs' forwarding_configuration: A `forwarding_configuration` block as defined below.
        :param str id: The ID of the FrontDoor.
        :param 'FrontdoorRoutingRuleRedirectConfigurationArgs' redirect_configuration: A `redirect_configuration` block as defined below.
        """
        pulumi.set(__self__, "accepted_protocols", accepted_protocols)
        pulumi.set(__self__, "frontend_endpoints", frontend_endpoints)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "patterns_to_matches", patterns_to_matches)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if forwarding_configuration is not None:
            pulumi.set(__self__, "forwarding_configuration", forwarding_configuration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if redirect_configuration is not None:
            pulumi.set(__self__, "redirect_configuration", redirect_configuration)

    @property
    @pulumi.getter(name="acceptedProtocols")
    def accepted_protocols(self) -> Sequence[str]:
        """
        Protocol schemes to match for the Backend Routing Rule. Defaults to `Http`.
        """
        return pulumi.get(self, "accepted_protocols")

    @property
    @pulumi.getter(name="frontendEndpoints")
    def frontend_endpoints(self) -> Sequence[str]:
        """
        The names of the `frontend_endpoint` blocks within this resource to associate with this `routing_rule`.
        """
        return pulumi.get(self, "frontend_endpoints")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Routing Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="patternsToMatches")
    def patterns_to_matches(self) -> Sequence[str]:
        """
        The route patterns for the Backend Routing Rule. Defaults to `/*`.
        """
        return pulumi.get(self, "patterns_to_matches")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        `Enable` or `Disable` use of this Backend Routing Rule. Permitted values are `true` or `false`. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="forwardingConfiguration")
    def forwarding_configuration(self) -> Optional['outputs.FrontdoorRoutingRuleForwardingConfiguration']:
        """
        A `forwarding_configuration` block as defined below.
        """
        return pulumi.get(self, "forwarding_configuration")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the FrontDoor.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="redirectConfiguration")
    def redirect_configuration(self) -> Optional['outputs.FrontdoorRoutingRuleRedirectConfiguration']:
        """
        A `redirect_configuration` block as defined below.
        """
        return pulumi.get(self, "redirect_configuration")


@pulumi.output_type
class FrontdoorRoutingRuleForwardingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendPoolName":
            suggest = "backend_pool_name"
        elif key == "cacheEnabled":
            suggest = "cache_enabled"
        elif key == "cacheQueryParameterStripDirective":
            suggest = "cache_query_parameter_strip_directive"
        elif key == "cacheUseDynamicCompression":
            suggest = "cache_use_dynamic_compression"
        elif key == "customForwardingPath":
            suggest = "custom_forwarding_path"
        elif key == "forwardingProtocol":
            suggest = "forwarding_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRoutingRuleForwardingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRoutingRuleForwardingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRoutingRuleForwardingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_pool_name: str,
                 cache_enabled: Optional[bool] = None,
                 cache_query_parameter_strip_directive: Optional[str] = None,
                 cache_use_dynamic_compression: Optional[bool] = None,
                 custom_forwarding_path: Optional[str] = None,
                 forwarding_protocol: Optional[str] = None):
        """
        :param str backend_pool_name: Specifies the name of the Backend Pool to forward the incoming traffic to.
        :param bool cache_enabled: Specifies whether to Enable caching or not. Valid options are `true` or `false`. Defaults to `false`.
        :param str cache_query_parameter_strip_directive: Defines cache behaviour in relation to query string parameters. Valid options are `StripAll` or `StripNone`. Defaults to `StripAll`.
        :param bool cache_use_dynamic_compression: Whether to use dynamic compression when caching. Valid options are `true` or `false`. Defaults to `false`.
        :param str custom_forwarding_path: Path to use when constructing the request to forward to the backend. This functions as a URL Rewrite. Default behaviour preserves the URL path.
        :param str forwarding_protocol: Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `HttpsOnly`.
        """
        pulumi.set(__self__, "backend_pool_name", backend_pool_name)
        if cache_enabled is not None:
            pulumi.set(__self__, "cache_enabled", cache_enabled)
        if cache_query_parameter_strip_directive is not None:
            pulumi.set(__self__, "cache_query_parameter_strip_directive", cache_query_parameter_strip_directive)
        if cache_use_dynamic_compression is not None:
            pulumi.set(__self__, "cache_use_dynamic_compression", cache_use_dynamic_compression)
        if custom_forwarding_path is not None:
            pulumi.set(__self__, "custom_forwarding_path", custom_forwarding_path)
        if forwarding_protocol is not None:
            pulumi.set(__self__, "forwarding_protocol", forwarding_protocol)

    @property
    @pulumi.getter(name="backendPoolName")
    def backend_pool_name(self) -> str:
        """
        Specifies the name of the Backend Pool to forward the incoming traffic to.
        """
        return pulumi.get(self, "backend_pool_name")

    @property
    @pulumi.getter(name="cacheEnabled")
    def cache_enabled(self) -> Optional[bool]:
        """
        Specifies whether to Enable caching or not. Valid options are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "cache_enabled")

    @property
    @pulumi.getter(name="cacheQueryParameterStripDirective")
    def cache_query_parameter_strip_directive(self) -> Optional[str]:
        """
        Defines cache behaviour in relation to query string parameters. Valid options are `StripAll` or `StripNone`. Defaults to `StripAll`.
        """
        return pulumi.get(self, "cache_query_parameter_strip_directive")

    @property
    @pulumi.getter(name="cacheUseDynamicCompression")
    def cache_use_dynamic_compression(self) -> Optional[bool]:
        """
        Whether to use dynamic compression when caching. Valid options are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "cache_use_dynamic_compression")

    @property
    @pulumi.getter(name="customForwardingPath")
    def custom_forwarding_path(self) -> Optional[str]:
        """
        Path to use when constructing the request to forward to the backend. This functions as a URL Rewrite. Default behaviour preserves the URL path.
        """
        return pulumi.get(self, "custom_forwarding_path")

    @property
    @pulumi.getter(name="forwardingProtocol")
    def forwarding_protocol(self) -> Optional[str]:
        """
        Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `HttpsOnly`.
        """
        return pulumi.get(self, "forwarding_protocol")


@pulumi.output_type
class FrontdoorRoutingRuleRedirectConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectProtocol":
            suggest = "redirect_protocol"
        elif key == "redirectType":
            suggest = "redirect_type"
        elif key == "customFragment":
            suggest = "custom_fragment"
        elif key == "customHost":
            suggest = "custom_host"
        elif key == "customPath":
            suggest = "custom_path"
        elif key == "customQueryString":
            suggest = "custom_query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontdoorRoutingRuleRedirectConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontdoorRoutingRuleRedirectConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontdoorRoutingRuleRedirectConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_protocol: str,
                 redirect_type: str,
                 custom_fragment: Optional[str] = None,
                 custom_host: Optional[str] = None,
                 custom_path: Optional[str] = None,
                 custom_query_string: Optional[str] = None):
        """
        :param str redirect_protocol: Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `MatchRequest`
        :param str redirect_type: Status code for the redirect. Valida options are `Moved`, `Found`, `TemporaryRedirect`, `PermanentRedirect`.
        :param str custom_fragment: The destination fragment in the portion of URL after '#'. Set this to add a fragment to the redirect URL.
        :param str custom_host: Set this to change the URL for the redirection.
        :param str custom_path: The path to retain as per the incoming request, or update in the URL for the redirection.
        :param str custom_query_string: Replace any existing query string from the incoming request URL.
        """
        pulumi.set(__self__, "redirect_protocol", redirect_protocol)
        pulumi.set(__self__, "redirect_type", redirect_type)
        if custom_fragment is not None:
            pulumi.set(__self__, "custom_fragment", custom_fragment)
        if custom_host is not None:
            pulumi.set(__self__, "custom_host", custom_host)
        if custom_path is not None:
            pulumi.set(__self__, "custom_path", custom_path)
        if custom_query_string is not None:
            pulumi.set(__self__, "custom_query_string", custom_query_string)

    @property
    @pulumi.getter(name="redirectProtocol")
    def redirect_protocol(self) -> str:
        """
        Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `MatchRequest`
        """
        return pulumi.get(self, "redirect_protocol")

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> str:
        """
        Status code for the redirect. Valida options are `Moved`, `Found`, `TemporaryRedirect`, `PermanentRedirect`.
        """
        return pulumi.get(self, "redirect_type")

    @property
    @pulumi.getter(name="customFragment")
    def custom_fragment(self) -> Optional[str]:
        """
        The destination fragment in the portion of URL after '#'. Set this to add a fragment to the redirect URL.
        """
        return pulumi.get(self, "custom_fragment")

    @property
    @pulumi.getter(name="customHost")
    def custom_host(self) -> Optional[str]:
        """
        Set this to change the URL for the redirection.
        """
        return pulumi.get(self, "custom_host")

    @property
    @pulumi.getter(name="customPath")
    def custom_path(self) -> Optional[str]:
        """
        The path to retain as per the incoming request, or update in the URL for the redirection.
        """
        return pulumi.get(self, "custom_path")

    @property
    @pulumi.getter(name="customQueryString")
    def custom_query_string(self) -> Optional[str]:
        """
        Replace any existing query string from the incoming request URL.
        """
        return pulumi.get(self, "custom_query_string")


