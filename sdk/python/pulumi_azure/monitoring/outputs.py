# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AadDiagnosticSettingEnabledLog',
    'AadDiagnosticSettingEnabledLogRetentionPolicy',
    'ActionGroupArmRoleReceiver',
    'ActionGroupAutomationRunbookReceiver',
    'ActionGroupAzureAppPushReceiver',
    'ActionGroupAzureFunctionReceiver',
    'ActionGroupEmailReceiver',
    'ActionGroupEventHubReceiver',
    'ActionGroupItsmReceiver',
    'ActionGroupLogicAppReceiver',
    'ActionGroupSmsReceiver',
    'ActionGroupVoiceReceiver',
    'ActionGroupWebhookReceiver',
    'ActionGroupWebhookReceiverAadAuth',
    'ActivityLogAlertAction',
    'ActivityLogAlertCriteria',
    'ActivityLogAlertCriteriaResourceHealth',
    'ActivityLogAlertCriteriaServiceHealth',
    'AlertProcessingRuleActionGroupCondition',
    'AlertProcessingRuleActionGroupConditionAlertContext',
    'AlertProcessingRuleActionGroupConditionAlertRuleId',
    'AlertProcessingRuleActionGroupConditionAlertRuleName',
    'AlertProcessingRuleActionGroupConditionDescription',
    'AlertProcessingRuleActionGroupConditionMonitorCondition',
    'AlertProcessingRuleActionGroupConditionMonitorService',
    'AlertProcessingRuleActionGroupConditionSeverity',
    'AlertProcessingRuleActionGroupConditionSignalType',
    'AlertProcessingRuleActionGroupConditionTargetResource',
    'AlertProcessingRuleActionGroupConditionTargetResourceGroup',
    'AlertProcessingRuleActionGroupConditionTargetResourceType',
    'AlertProcessingRuleActionGroupSchedule',
    'AlertProcessingRuleActionGroupScheduleRecurrence',
    'AlertProcessingRuleActionGroupScheduleRecurrenceDaily',
    'AlertProcessingRuleActionGroupScheduleRecurrenceMonthly',
    'AlertProcessingRuleActionGroupScheduleRecurrenceWeekly',
    'AlertProcessingRuleSuppressionCondition',
    'AlertProcessingRuleSuppressionConditionAlertContext',
    'AlertProcessingRuleSuppressionConditionAlertRuleId',
    'AlertProcessingRuleSuppressionConditionAlertRuleName',
    'AlertProcessingRuleSuppressionConditionDescription',
    'AlertProcessingRuleSuppressionConditionMonitorCondition',
    'AlertProcessingRuleSuppressionConditionMonitorService',
    'AlertProcessingRuleSuppressionConditionSeverity',
    'AlertProcessingRuleSuppressionConditionSignalType',
    'AlertProcessingRuleSuppressionConditionTargetResource',
    'AlertProcessingRuleSuppressionConditionTargetResourceGroup',
    'AlertProcessingRuleSuppressionConditionTargetResourceType',
    'AlertProcessingRuleSuppressionSchedule',
    'AlertProcessingRuleSuppressionScheduleRecurrence',
    'AlertProcessingRuleSuppressionScheduleRecurrenceDaily',
    'AlertProcessingRuleSuppressionScheduleRecurrenceMonthly',
    'AlertProcessingRuleSuppressionScheduleRecurrenceWeekly',
    'AlertPrometheusRuleGroupRule',
    'AlertPrometheusRuleGroupRuleAction',
    'AlertPrometheusRuleGroupRuleAlertResolution',
    'AutoscaleSettingNotification',
    'AutoscaleSettingNotificationEmail',
    'AutoscaleSettingNotificationWebhook',
    'AutoscaleSettingPredictive',
    'AutoscaleSettingProfile',
    'AutoscaleSettingProfileCapacity',
    'AutoscaleSettingProfileFixedDate',
    'AutoscaleSettingProfileRecurrence',
    'AutoscaleSettingProfileRule',
    'AutoscaleSettingProfileRuleMetricTrigger',
    'AutoscaleSettingProfileRuleMetricTriggerDimension',
    'AutoscaleSettingProfileRuleScaleAction',
    'DataCollectionRuleDataFlow',
    'DataCollectionRuleDataSources',
    'DataCollectionRuleDataSourcesDataImport',
    'DataCollectionRuleDataSourcesDataImportEventHubDataSource',
    'DataCollectionRuleDataSourcesExtension',
    'DataCollectionRuleDataSourcesIisLog',
    'DataCollectionRuleDataSourcesLogFile',
    'DataCollectionRuleDataSourcesLogFileSettings',
    'DataCollectionRuleDataSourcesLogFileSettingsText',
    'DataCollectionRuleDataSourcesPerformanceCounter',
    'DataCollectionRuleDataSourcesPlatformTelemetry',
    'DataCollectionRuleDataSourcesPrometheusForwarder',
    'DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilter',
    'DataCollectionRuleDataSourcesSyslog',
    'DataCollectionRuleDataSourcesWindowsEventLog',
    'DataCollectionRuleDataSourcesWindowsFirewallLog',
    'DataCollectionRuleDestinations',
    'DataCollectionRuleDestinationsAzureMonitorMetrics',
    'DataCollectionRuleDestinationsEventHub',
    'DataCollectionRuleDestinationsEventHubDirect',
    'DataCollectionRuleDestinationsLogAnalytic',
    'DataCollectionRuleDestinationsMonitorAccount',
    'DataCollectionRuleDestinationsStorageBlob',
    'DataCollectionRuleDestinationsStorageBlobDirect',
    'DataCollectionRuleDestinationsStorageTableDirect',
    'DataCollectionRuleIdentity',
    'DataCollectionRuleStreamDeclaration',
    'DataCollectionRuleStreamDeclarationColumn',
    'DiagnosticSettingEnabledLog',
    'DiagnosticSettingEnabledLogRetentionPolicy',
    'DiagnosticSettingMetric',
    'DiagnosticSettingMetricRetentionPolicy',
    'MetricAlertAction',
    'MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteria',
    'MetricAlertCriteria',
    'MetricAlertCriteriaDimension',
    'MetricAlertDynamicCriteria',
    'MetricAlertDynamicCriteriaDimension',
    'ScheduledQueryRulesAlertAction',
    'ScheduledQueryRulesAlertTrigger',
    'ScheduledQueryRulesAlertTriggerMetricTrigger',
    'ScheduledQueryRulesAlertV2Action',
    'ScheduledQueryRulesAlertV2Criteria',
    'ScheduledQueryRulesAlertV2CriteriaDimension',
    'ScheduledQueryRulesAlertV2CriteriaFailingPeriods',
    'ScheduledQueryRulesAlertV2Identity',
    'ScheduledQueryRulesLogCriteria',
    'ScheduledQueryRulesLogCriteriaDimension',
    'SmartDetectorAlertRuleActionGroup',
    'GetActionGroupArmRoleReceiverResult',
    'GetActionGroupAutomationRunbookReceiverResult',
    'GetActionGroupAzureAppPushReceiverResult',
    'GetActionGroupAzureFunctionReceiverResult',
    'GetActionGroupEmailReceiverResult',
    'GetActionGroupEventHubReceiverResult',
    'GetActionGroupItsmReceiverResult',
    'GetActionGroupLogicAppReceiverResult',
    'GetActionGroupSmsReceiverResult',
    'GetActionGroupVoiceReceiverResult',
    'GetActionGroupWebhookReceiverResult',
    'GetActionGroupWebhookReceiverAadAuthResult',
    'GetDataCollectionRuleDataFlowResult',
    'GetDataCollectionRuleDataSourceResult',
    'GetDataCollectionRuleDataSourceDataImportResult',
    'GetDataCollectionRuleDataSourceDataImportEventHubDataSourceResult',
    'GetDataCollectionRuleDataSourceExtensionResult',
    'GetDataCollectionRuleDataSourceIisLogResult',
    'GetDataCollectionRuleDataSourceLogFileResult',
    'GetDataCollectionRuleDataSourceLogFileSettingResult',
    'GetDataCollectionRuleDataSourceLogFileSettingTextResult',
    'GetDataCollectionRuleDataSourcePerformanceCounterResult',
    'GetDataCollectionRuleDataSourcePlatformTelemetryResult',
    'GetDataCollectionRuleDataSourcePrometheusForwarderResult',
    'GetDataCollectionRuleDataSourcePrometheusForwarderLabelIncludeFilterResult',
    'GetDataCollectionRuleDataSourceSyslogResult',
    'GetDataCollectionRuleDataSourceWindowsEventLogResult',
    'GetDataCollectionRuleDataSourceWindowsFirewallLogResult',
    'GetDataCollectionRuleDestinationResult',
    'GetDataCollectionRuleDestinationAzureMonitorMetricResult',
    'GetDataCollectionRuleDestinationEventHubResult',
    'GetDataCollectionRuleDestinationEventHubDirectResult',
    'GetDataCollectionRuleDestinationLogAnalyticResult',
    'GetDataCollectionRuleDestinationMonitorAccountResult',
    'GetDataCollectionRuleDestinationStorageBlobResult',
    'GetDataCollectionRuleDestinationStorageBlobDirectResult',
    'GetDataCollectionRuleDestinationStorageTableDirectResult',
    'GetDataCollectionRuleIdentityResult',
    'GetDataCollectionRuleStreamDeclarationResult',
    'GetDataCollectionRuleStreamDeclarationColumnResult',
    'GetScheduledQueryRulesAlertActionResult',
    'GetScheduledQueryRulesAlertTriggerResult',
    'GetScheduledQueryRulesAlertTriggerMetricTriggerResult',
    'GetScheduledQueryRulesLogCriteriaResult',
    'GetScheduledQueryRulesLogCriteriaDimensionResult',
]

@pulumi.output_type
class AadDiagnosticSettingEnabledLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionPolicy":
            suggest = "retention_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AadDiagnosticSettingEnabledLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AadDiagnosticSettingEnabledLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AadDiagnosticSettingEnabledLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: str,
                 retention_policy: Optional['outputs.AadDiagnosticSettingEnabledLogRetentionPolicy'] = None):
        """
        :param str category: The log category for the Azure Active Directory Diagnostic.
        """
        pulumi.set(__self__, "category", category)
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The log category for the Azure Active Directory Diagnostic.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="retentionPolicy")
    @_utilities.deprecated("""Azure does not support retention for new Azure Active Directory Diagnostic Settings""")
    def retention_policy(self) -> Optional['outputs.AadDiagnosticSettingEnabledLogRetentionPolicy']:
        return pulumi.get(self, "retention_policy")


@pulumi.output_type
class AadDiagnosticSettingEnabledLogRetentionPolicy(dict):
    def __init__(__self__, *,
                 days: Optional[int] = None,
                 enabled: Optional[bool] = None):
        if days is not None:
            pulumi.set(__self__, "days", days)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        return pulumi.get(self, "days")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ActionGroupArmRoleReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "useCommonAlertSchema":
            suggest = "use_common_alert_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupArmRoleReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupArmRoleReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupArmRoleReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 role_id: str,
                 use_common_alert_schema: Optional[bool] = None):
        """
        :param str name: The name of the ARM role receiver.
        :param str role_id: The arm role id.
        :param bool use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role_id", role_id)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ARM role receiver.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        The arm role id.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[bool]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class ActionGroupAutomationRunbookReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automationAccountId":
            suggest = "automation_account_id"
        elif key == "isGlobalRunbook":
            suggest = "is_global_runbook"
        elif key == "runbookName":
            suggest = "runbook_name"
        elif key == "serviceUri":
            suggest = "service_uri"
        elif key == "webhookResourceId":
            suggest = "webhook_resource_id"
        elif key == "useCommonAlertSchema":
            suggest = "use_common_alert_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupAutomationRunbookReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupAutomationRunbookReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupAutomationRunbookReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automation_account_id: str,
                 is_global_runbook: bool,
                 name: str,
                 runbook_name: str,
                 service_uri: str,
                 webhook_resource_id: str,
                 use_common_alert_schema: Optional[bool] = None):
        """
        :param str automation_account_id: The automation account ID which holds this runbook and authenticates to Azure resources.
        :param bool is_global_runbook: Indicates whether this instance is global runbook.
        :param str name: The name of the automation runbook receiver.
        :param str runbook_name: The name for this runbook.
        :param str service_uri: The URI where webhooks should be sent.
        :param str webhook_resource_id: The resource id for webhook linked to this runbook.
        :param bool use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "automation_account_id", automation_account_id)
        pulumi.set(__self__, "is_global_runbook", is_global_runbook)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "runbook_name", runbook_name)
        pulumi.set(__self__, "service_uri", service_uri)
        pulumi.set(__self__, "webhook_resource_id", webhook_resource_id)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="automationAccountId")
    def automation_account_id(self) -> str:
        """
        The automation account ID which holds this runbook and authenticates to Azure resources.
        """
        return pulumi.get(self, "automation_account_id")

    @property
    @pulumi.getter(name="isGlobalRunbook")
    def is_global_runbook(self) -> bool:
        """
        Indicates whether this instance is global runbook.
        """
        return pulumi.get(self, "is_global_runbook")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the automation runbook receiver.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="runbookName")
    def runbook_name(self) -> str:
        """
        The name for this runbook.
        """
        return pulumi.get(self, "runbook_name")

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> str:
        """
        The URI where webhooks should be sent.
        """
        return pulumi.get(self, "service_uri")

    @property
    @pulumi.getter(name="webhookResourceId")
    def webhook_resource_id(self) -> str:
        """
        The resource id for webhook linked to this runbook.
        """
        return pulumi.get(self, "webhook_resource_id")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[bool]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class ActionGroupAzureAppPushReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddress":
            suggest = "email_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupAzureAppPushReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupAzureAppPushReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupAzureAppPushReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_address: str,
                 name: str):
        """
        :param str email_address: The email address of the user signed into the mobile app who will receive push notifications from this receiver.
        :param str name: The name of the Azure app push receiver.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        The email address of the user signed into the mobile app who will receive push notifications from this receiver.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Azure app push receiver.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ActionGroupAzureFunctionReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionAppResourceId":
            suggest = "function_app_resource_id"
        elif key == "functionName":
            suggest = "function_name"
        elif key == "httpTriggerUrl":
            suggest = "http_trigger_url"
        elif key == "useCommonAlertSchema":
            suggest = "use_common_alert_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupAzureFunctionReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupAzureFunctionReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupAzureFunctionReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_app_resource_id: str,
                 function_name: str,
                 http_trigger_url: str,
                 name: str,
                 use_common_alert_schema: Optional[bool] = None):
        """
        :param str function_app_resource_id: The Azure resource ID of the function app.
        :param str function_name: The function name in the function app.
        :param str http_trigger_url: The HTTP trigger url where HTTP request sent to.
        :param str name: The name of the Azure Function receiver.
        :param bool use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "function_app_resource_id", function_app_resource_id)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "http_trigger_url", http_trigger_url)
        pulumi.set(__self__, "name", name)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="functionAppResourceId")
    def function_app_resource_id(self) -> str:
        """
        The Azure resource ID of the function app.
        """
        return pulumi.get(self, "function_app_resource_id")

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> str:
        """
        The function name in the function app.
        """
        return pulumi.get(self, "function_name")

    @property
    @pulumi.getter(name="httpTriggerUrl")
    def http_trigger_url(self) -> str:
        """
        The HTTP trigger url where HTTP request sent to.
        """
        return pulumi.get(self, "http_trigger_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Azure Function receiver.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[bool]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class ActionGroupEmailReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddress":
            suggest = "email_address"
        elif key == "useCommonAlertSchema":
            suggest = "use_common_alert_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupEmailReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupEmailReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupEmailReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_address: str,
                 name: str,
                 use_common_alert_schema: Optional[bool] = None):
        """
        :param str email_address: The email address of this receiver.
        :param str name: The name of the email receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        :param bool use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "name", name)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        The email address of this receiver.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the email receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[bool]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class ActionGroupEventHubReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "eventHubNamespace":
            suggest = "event_hub_namespace"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "useCommonAlertSchema":
            suggest = "use_common_alert_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupEventHubReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupEventHubReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupEventHubReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_hub_name: str,
                 event_hub_namespace: str,
                 name: str,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 use_common_alert_schema: Optional[bool] = None):
        """
        :param str event_hub_name: The name of the specific Event Hub queue.
        :param str event_hub_namespace: The namespace name of the Event Hub.
        :param str name: The name of the EventHub Receiver, must be unique within action group.
        :param str subscription_id: The ID for the subscription containing this Event Hub. Default to the subscription ID of the Action Group.
        :param str tenant_id: The Tenant ID for the subscription containing this Event Hub.
        :param bool use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "event_hub_name", event_hub_name)
        pulumi.set(__self__, "event_hub_namespace", event_hub_namespace)
        pulumi.set(__self__, "name", name)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> str:
        """
        The name of the specific Event Hub queue.
        """
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="eventHubNamespace")
    def event_hub_namespace(self) -> str:
        """
        The namespace name of the Event Hub.
        """
        return pulumi.get(self, "event_hub_namespace")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the EventHub Receiver, must be unique within action group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        The ID for the subscription containing this Event Hub. Default to the subscription ID of the Action Group.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the subscription containing this Event Hub.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[bool]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class ActionGroupItsmReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionId":
            suggest = "connection_id"
        elif key == "ticketConfiguration":
            suggest = "ticket_configuration"
        elif key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupItsmReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupItsmReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupItsmReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_id: str,
                 name: str,
                 region: str,
                 ticket_configuration: str,
                 workspace_id: str):
        """
        :param str connection_id: The unique connection identifier of the ITSM connection.
        :param str name: The name of the ITSM receiver.
        :param str region: The region of the workspace.
               
               > **NOTE** `ticket_configuration` should be JSON blob with `PayloadRevision` and `WorkItemType` keys (e.g., `ticket_configuration="{\\"PayloadRevision\\":0,\\"WorkItemType\\":\\"Incident\\"}"`), and `ticket_configuration="{}"` will return an error, see more at this [REST API issue](https://github.com/Azure/azure-rest-api-specs/issues/20488)
        :param str ticket_configuration: A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        :param str workspace_id: The Azure Log Analytics workspace ID where this connection is defined. Format is `<subscription id>|<workspace id>`, for example `00000000-0000-0000-0000-000000000000|00000000-0000-0000-0000-000000000000`.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "ticket_configuration", ticket_configuration)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> str:
        """
        The unique connection identifier of the ITSM connection.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ITSM receiver.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The region of the workspace.

        > **NOTE** `ticket_configuration` should be JSON blob with `PayloadRevision` and `WorkItemType` keys (e.g., `ticket_configuration="{\\"PayloadRevision\\":0,\\"WorkItemType\\":\\"Incident\\"}"`), and `ticket_configuration="{}"` will return an error, see more at this [REST API issue](https://github.com/Azure/azure-rest-api-specs/issues/20488)
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="ticketConfiguration")
    def ticket_configuration(self) -> str:
        """
        A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        """
        return pulumi.get(self, "ticket_configuration")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        The Azure Log Analytics workspace ID where this connection is defined. Format is `<subscription id>|<workspace id>`, for example `00000000-0000-0000-0000-000000000000|00000000-0000-0000-0000-000000000000`.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class ActionGroupLogicAppReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "callbackUrl":
            suggest = "callback_url"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "useCommonAlertSchema":
            suggest = "use_common_alert_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupLogicAppReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupLogicAppReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupLogicAppReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 callback_url: str,
                 name: str,
                 resource_id: str,
                 use_common_alert_schema: Optional[bool] = None):
        """
        :param str callback_url: The callback url where HTTP request sent to.
        :param str name: The name of the logic app receiver.
        :param str resource_id: The Azure resource ID of the logic app.
        :param bool use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "callback_url", callback_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_id", resource_id)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="callbackUrl")
    def callback_url(self) -> str:
        """
        The callback url where HTTP request sent to.
        """
        return pulumi.get(self, "callback_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the logic app receiver.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The Azure resource ID of the logic app.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[bool]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class ActionGroupSmsReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupSmsReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupSmsReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupSmsReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str,
                 name: str,
                 phone_number: str):
        """
        :param str country_code: The country code of the SMS receiver.
        :param str name: The name of the SMS receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        :param str phone_number: The phone number of the SMS receiver.
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code of the SMS receiver.
        """
        return pulumi.get(self, "country_code")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SMS receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        The phone number of the SMS receiver.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ActionGroupVoiceReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupVoiceReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupVoiceReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupVoiceReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_code: str,
                 name: str,
                 phone_number: str):
        """
        :param str country_code: The country code of the voice receiver.
        :param str name: The name of the voice receiver.
        :param str phone_number: The phone number of the voice receiver.
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code of the voice receiver.
        """
        return pulumi.get(self, "country_code")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the voice receiver.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        The phone number of the voice receiver.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ActionGroupWebhookReceiver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceUri":
            suggest = "service_uri"
        elif key == "aadAuth":
            suggest = "aad_auth"
        elif key == "useCommonAlertSchema":
            suggest = "use_common_alert_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupWebhookReceiver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupWebhookReceiver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupWebhookReceiver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 service_uri: str,
                 aad_auth: Optional['outputs.ActionGroupWebhookReceiverAadAuth'] = None,
                 use_common_alert_schema: Optional[bool] = None):
        """
        :param str name: The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        :param str service_uri: The URI where webhooks should be sent.
        :param 'ActionGroupWebhookReceiverAadAuthArgs' aad_auth: The `aad_auth` block as defined below.
               
               > **NOTE:** Before adding a secure webhook receiver by setting `aad_auth`, please read [the configuration instruction of the AAD application](https://docs.microsoft.com/azure/azure-monitor/platform/action-groups#secure-webhook).
        :param bool use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_uri", service_uri)
        if aad_auth is not None:
            pulumi.set(__self__, "aad_auth", aad_auth)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> str:
        """
        The URI where webhooks should be sent.
        """
        return pulumi.get(self, "service_uri")

    @property
    @pulumi.getter(name="aadAuth")
    def aad_auth(self) -> Optional['outputs.ActionGroupWebhookReceiverAadAuth']:
        """
        The `aad_auth` block as defined below.

        > **NOTE:** Before adding a secure webhook receiver by setting `aad_auth`, please read [the configuration instruction of the AAD application](https://docs.microsoft.com/azure/azure-monitor/platform/action-groups#secure-webhook).
        """
        return pulumi.get(self, "aad_auth")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[bool]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class ActionGroupWebhookReceiverAadAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"
        elif key == "identifierUri":
            suggest = "identifier_uri"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupWebhookReceiverAadAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupWebhookReceiverAadAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupWebhookReceiverAadAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_id: str,
                 identifier_uri: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str object_id: The webhook application object Id for AAD auth.
        :param str identifier_uri: The identifier URI for AAD auth.
        :param str tenant_id: The tenant id for AAD auth.
        """
        pulumi.set(__self__, "object_id", object_id)
        if identifier_uri is not None:
            pulumi.set(__self__, "identifier_uri", identifier_uri)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        """
        The webhook application object Id for AAD auth.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="identifierUri")
    def identifier_uri(self) -> Optional[str]:
        """
        The identifier URI for AAD auth.
        """
        return pulumi.get(self, "identifier_uri")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The tenant id for AAD auth.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ActivityLogAlertAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroupId":
            suggest = "action_group_id"
        elif key == "webhookProperties":
            suggest = "webhook_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActivityLogAlertAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActivityLogAlertAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActivityLogAlertAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_group_id: str,
                 webhook_properties: Optional[Mapping[str, str]] = None):
        """
        :param str action_group_id: The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource.
        :param Mapping[str, str] webhook_properties: The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
        pulumi.set(__self__, "action_group_id", action_group_id)
        if webhook_properties is not None:
            pulumi.set(__self__, "webhook_properties", webhook_properties)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> str:
        """
        The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource.
        """
        return pulumi.get(self, "action_group_id")

    @property
    @pulumi.getter(name="webhookProperties")
    def webhook_properties(self) -> Optional[Mapping[str, str]]:
        """
        The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
        return pulumi.get(self, "webhook_properties")


@pulumi.output_type
class ActivityLogAlertCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationName":
            suggest = "operation_name"
        elif key == "recommendationCategory":
            suggest = "recommendation_category"
        elif key == "recommendationImpact":
            suggest = "recommendation_impact"
        elif key == "recommendationType":
            suggest = "recommendation_type"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceGroups":
            suggest = "resource_groups"
        elif key == "resourceHealth":
            suggest = "resource_health"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceIds":
            suggest = "resource_ids"
        elif key == "resourceProvider":
            suggest = "resource_provider"
        elif key == "resourceProviders":
            suggest = "resource_providers"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "resourceTypes":
            suggest = "resource_types"
        elif key == "serviceHealth":
            suggest = "service_health"
        elif key == "subStatus":
            suggest = "sub_status"
        elif key == "subStatuses":
            suggest = "sub_statuses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActivityLogAlertCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActivityLogAlertCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActivityLogAlertCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: str,
                 caller: Optional[str] = None,
                 level: Optional[str] = None,
                 levels: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 recommendation_category: Optional[str] = None,
                 recommendation_impact: Optional[str] = None,
                 recommendation_type: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 resource_groups: Optional[Sequence[str]] = None,
                 resource_health: Optional['outputs.ActivityLogAlertCriteriaResourceHealth'] = None,
                 resource_id: Optional[str] = None,
                 resource_ids: Optional[Sequence[str]] = None,
                 resource_provider: Optional[str] = None,
                 resource_providers: Optional[Sequence[str]] = None,
                 resource_type: Optional[str] = None,
                 resource_types: Optional[Sequence[str]] = None,
                 service_health: Optional['outputs.ActivityLogAlertCriteriaServiceHealth'] = None,
                 status: Optional[str] = None,
                 statuses: Optional[Sequence[str]] = None,
                 sub_status: Optional[str] = None,
                 sub_statuses: Optional[Sequence[str]] = None):
        """
        :param str category: The category of the operation. Possible values are `Administrative`, `Autoscale`, `Policy`, `Recommendation`, `ResourceHealth`, `Security` and `ServiceHealth`.
        :param str caller: The email address or Azure Active Directory identifier of the user who performed the operation.
        :param str level: The severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
        :param Sequence[str] levels: A list of severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
               
               > **NOTE:** `level` and `levels` are mutually exclusive.
        :param str operation_name: The Resource Manager Role-Based Access Control operation name. Supported operation should be of the form: `<resourceProvider>/<resourceType>/<operation>`.
        :param str recommendation_category: The recommendation category of the event. Possible values are `Cost`, `Reliability`, `OperationalExcellence`, `HighAvailability` and `Performance`. It is only allowed when `category` is `Recommendation`.
        :param str recommendation_impact: The recommendation impact of the event. Possible values are `High`, `Medium` and `Low`. It is only allowed when `category` is `Recommendation`.
        :param str recommendation_type: The recommendation type of the event. It is only allowed when `category` is `Recommendation`.
        :param str resource_group: The name of resource group monitored by the activity log alert.
        :param Sequence[str] resource_groups: A list of names of resource groups monitored by the activity log alert.
               
               > **NOTE:** `resource_group` and `resource_groups` are mutually exclusive.
        :param 'ActivityLogAlertCriteriaResourceHealthArgs' resource_health: A block to define fine grain resource health settings.
        :param str resource_id: The specific resource monitored by the activity log alert. It should be within one of the `scopes`.
        :param Sequence[str] resource_ids: A list of specific resources monitored by the activity log alert. It should be within one of the `scopes`.
               
               > **NOTE:** `resource_id` and `resource_ids` are mutually exclusive.
        :param str resource_provider: The name of the resource provider monitored by the activity log alert.
        :param Sequence[str] resource_providers: A list of names of resource providers monitored by the activity log alert.
               
               > **NOTE:** `resource_provider` and `resource_providers` are mutually exclusive.
        :param str resource_type: The resource type monitored by the activity log alert.
        :param Sequence[str] resource_types: A list of resource types monitored by the activity log alert.
               
               > **NOTE:** `resource_type` and `resource_types` are mutually exclusive.
        :param 'ActivityLogAlertCriteriaServiceHealthArgs' service_health: A block to define fine grain service health settings.
        :param str status: The status of the event. For example, `Started`, `Failed`, or `Succeeded`.
        :param Sequence[str] statuses: A list of status of the event. For example, `Started`, `Failed`, or `Succeeded`.
               
               > **NOTE:** `status` and `statuses` are mutually exclusive.
        :param str sub_status: The sub status of the event.
        :param Sequence[str] sub_statuses: A list of sub status of the event.
               
               > **NOTE:** `sub_status` and `sub_statuses` are mutually exclusive.
        """
        pulumi.set(__self__, "category", category)
        if caller is not None:
            pulumi.set(__self__, "caller", caller)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if levels is not None:
            pulumi.set(__self__, "levels", levels)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if recommendation_category is not None:
            pulumi.set(__self__, "recommendation_category", recommendation_category)
        if recommendation_impact is not None:
            pulumi.set(__self__, "recommendation_impact", recommendation_impact)
        if recommendation_type is not None:
            pulumi.set(__self__, "recommendation_type", recommendation_type)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)
        if resource_health is not None:
            pulumi.set(__self__, "resource_health", resource_health)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_ids is not None:
            pulumi.set(__self__, "resource_ids", resource_ids)
        if resource_provider is not None:
            pulumi.set(__self__, "resource_provider", resource_provider)
        if resource_providers is not None:
            pulumi.set(__self__, "resource_providers", resource_providers)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if service_health is not None:
            pulumi.set(__self__, "service_health", service_health)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if sub_statuses is not None:
            pulumi.set(__self__, "sub_statuses", sub_statuses)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The category of the operation. Possible values are `Administrative`, `Autoscale`, `Policy`, `Recommendation`, `ResourceHealth`, `Security` and `ServiceHealth`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def caller(self) -> Optional[str]:
        """
        The email address or Azure Active Directory identifier of the user who performed the operation.
        """
        return pulumi.get(self, "caller")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def levels(self) -> Optional[Sequence[str]]:
        """
        A list of severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.

        > **NOTE:** `level` and `levels` are mutually exclusive.
        """
        return pulumi.get(self, "levels")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        The Resource Manager Role-Based Access Control operation name. Supported operation should be of the form: `<resourceProvider>/<resourceType>/<operation>`.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="recommendationCategory")
    def recommendation_category(self) -> Optional[str]:
        """
        The recommendation category of the event. Possible values are `Cost`, `Reliability`, `OperationalExcellence`, `HighAvailability` and `Performance`. It is only allowed when `category` is `Recommendation`.
        """
        return pulumi.get(self, "recommendation_category")

    @property
    @pulumi.getter(name="recommendationImpact")
    def recommendation_impact(self) -> Optional[str]:
        """
        The recommendation impact of the event. Possible values are `High`, `Medium` and `Low`. It is only allowed when `category` is `Recommendation`.
        """
        return pulumi.get(self, "recommendation_impact")

    @property
    @pulumi.getter(name="recommendationType")
    def recommendation_type(self) -> Optional[str]:
        """
        The recommendation type of the event. It is only allowed when `category` is `Recommendation`.
        """
        return pulumi.get(self, "recommendation_type")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        The name of resource group monitored by the activity log alert.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[Sequence[str]]:
        """
        A list of names of resource groups monitored by the activity log alert.

        > **NOTE:** `resource_group` and `resource_groups` are mutually exclusive.
        """
        return pulumi.get(self, "resource_groups")

    @property
    @pulumi.getter(name="resourceHealth")
    def resource_health(self) -> Optional['outputs.ActivityLogAlertCriteriaResourceHealth']:
        """
        A block to define fine grain resource health settings.
        """
        return pulumi.get(self, "resource_health")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The specific resource monitored by the activity log alert. It should be within one of the `scopes`.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Optional[Sequence[str]]:
        """
        A list of specific resources monitored by the activity log alert. It should be within one of the `scopes`.

        > **NOTE:** `resource_id` and `resource_ids` are mutually exclusive.
        """
        return pulumi.get(self, "resource_ids")

    @property
    @pulumi.getter(name="resourceProvider")
    def resource_provider(self) -> Optional[str]:
        """
        The name of the resource provider monitored by the activity log alert.
        """
        return pulumi.get(self, "resource_provider")

    @property
    @pulumi.getter(name="resourceProviders")
    def resource_providers(self) -> Optional[Sequence[str]]:
        """
        A list of names of resource providers monitored by the activity log alert.

        > **NOTE:** `resource_provider` and `resource_providers` are mutually exclusive.
        """
        return pulumi.get(self, "resource_providers")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The resource type monitored by the activity log alert.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence[str]]:
        """
        A list of resource types monitored by the activity log alert.

        > **NOTE:** `resource_type` and `resource_types` are mutually exclusive.
        """
        return pulumi.get(self, "resource_types")

    @property
    @pulumi.getter(name="serviceHealth")
    def service_health(self) -> Optional['outputs.ActivityLogAlertCriteriaServiceHealth']:
        """
        A block to define fine grain service health settings.
        """
        return pulumi.get(self, "service_health")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the event. For example, `Started`, `Failed`, or `Succeeded`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence[str]]:
        """
        A list of status of the event. For example, `Started`, `Failed`, or `Succeeded`.

        > **NOTE:** `status` and `statuses` are mutually exclusive.
        """
        return pulumi.get(self, "statuses")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[str]:
        """
        The sub status of the event.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="subStatuses")
    def sub_statuses(self) -> Optional[Sequence[str]]:
        """
        A list of sub status of the event.

        > **NOTE:** `sub_status` and `sub_statuses` are mutually exclusive.
        """
        return pulumi.get(self, "sub_statuses")


@pulumi.output_type
class ActivityLogAlertCriteriaResourceHealth(dict):
    def __init__(__self__, *,
                 currents: Optional[Sequence[str]] = None,
                 previouses: Optional[Sequence[str]] = None,
                 reasons: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] currents: The current resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        :param Sequence[str] previouses: The previous resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        :param Sequence[str] reasons: The reason that will log an alert. Possible values are `PlatformInitiated` (such as a problem with the resource in an affected region of an Azure incident), `UserInitiated` (such as a shutdown request of a VM) and `Unknown`.
        """
        if currents is not None:
            pulumi.set(__self__, "currents", currents)
        if previouses is not None:
            pulumi.set(__self__, "previouses", previouses)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)

    @property
    @pulumi.getter
    def currents(self) -> Optional[Sequence[str]]:
        """
        The current resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        """
        return pulumi.get(self, "currents")

    @property
    @pulumi.getter
    def previouses(self) -> Optional[Sequence[str]]:
        """
        The previous resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        """
        return pulumi.get(self, "previouses")

    @property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence[str]]:
        """
        The reason that will log an alert. Possible values are `PlatformInitiated` (such as a problem with the resource in an affected region of an Azure incident), `UserInitiated` (such as a shutdown request of a VM) and `Unknown`.
        """
        return pulumi.get(self, "reasons")


@pulumi.output_type
class ActivityLogAlertCriteriaServiceHealth(dict):
    def __init__(__self__, *,
                 events: Optional[Sequence[str]] = None,
                 locations: Optional[Sequence[str]] = None,
                 services: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] events: Events this alert will monitor Possible values are `Incident`, `Maintenance`, `Informational`, `ActionRequired` and `Security`.
        :param Sequence[str] locations: Locations this alert will monitor. For example, `West Europe`.
        :param Sequence[str] services: Services this alert will monitor. For example, `Activity Logs & Alerts`, `Action Groups`. Defaults to all Services.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence[str]]:
        """
        Events this alert will monitor Possible values are `Incident`, `Maintenance`, `Informational`, `ActionRequired` and `Security`.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        """
        Locations this alert will monitor. For example, `West Europe`.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence[str]]:
        """
        Services this alert will monitor. For example, `Activity Logs & Alerts`, `Action Groups`. Defaults to all Services.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class AlertProcessingRuleActionGroupCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertContext":
            suggest = "alert_context"
        elif key == "alertRuleId":
            suggest = "alert_rule_id"
        elif key == "alertRuleName":
            suggest = "alert_rule_name"
        elif key == "monitorCondition":
            suggest = "monitor_condition"
        elif key == "monitorService":
            suggest = "monitor_service"
        elif key == "signalType":
            suggest = "signal_type"
        elif key == "targetResource":
            suggest = "target_resource"
        elif key == "targetResourceGroup":
            suggest = "target_resource_group"
        elif key == "targetResourceType":
            suggest = "target_resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleActionGroupCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleActionGroupCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleActionGroupCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_context: Optional['outputs.AlertProcessingRuleActionGroupConditionAlertContext'] = None,
                 alert_rule_id: Optional['outputs.AlertProcessingRuleActionGroupConditionAlertRuleId'] = None,
                 alert_rule_name: Optional['outputs.AlertProcessingRuleActionGroupConditionAlertRuleName'] = None,
                 description: Optional['outputs.AlertProcessingRuleActionGroupConditionDescription'] = None,
                 monitor_condition: Optional['outputs.AlertProcessingRuleActionGroupConditionMonitorCondition'] = None,
                 monitor_service: Optional['outputs.AlertProcessingRuleActionGroupConditionMonitorService'] = None,
                 severity: Optional['outputs.AlertProcessingRuleActionGroupConditionSeverity'] = None,
                 signal_type: Optional['outputs.AlertProcessingRuleActionGroupConditionSignalType'] = None,
                 target_resource: Optional['outputs.AlertProcessingRuleActionGroupConditionTargetResource'] = None,
                 target_resource_group: Optional['outputs.AlertProcessingRuleActionGroupConditionTargetResourceGroup'] = None,
                 target_resource_type: Optional['outputs.AlertProcessingRuleActionGroupConditionTargetResourceType'] = None):
        """
        :param 'AlertProcessingRuleActionGroupConditionAlertContextArgs' alert_context: A `alert_context` block as defined above.
        :param 'AlertProcessingRuleActionGroupConditionAlertRuleIdArgs' alert_rule_id: A `alert_rule_id` block as defined above.
        :param 'AlertProcessingRuleActionGroupConditionAlertRuleNameArgs' alert_rule_name: A `alert_rule_name` block as defined above.
        :param 'AlertProcessingRuleActionGroupConditionDescriptionArgs' description: A `description` block as defined below.
        :param 'AlertProcessingRuleActionGroupConditionMonitorConditionArgs' monitor_condition: A `monitor_condition` block as defined below.
        :param 'AlertProcessingRuleActionGroupConditionMonitorServiceArgs' monitor_service: A `monitor_service` block as defined below.
        :param 'AlertProcessingRuleActionGroupConditionSeverityArgs' severity: A `severity` block as defined below.
        :param 'AlertProcessingRuleActionGroupConditionSignalTypeArgs' signal_type: A `signal_type` block as defined below.
        :param 'AlertProcessingRuleActionGroupConditionTargetResourceArgs' target_resource: A `target_resource` block as defined below.
        :param 'AlertProcessingRuleActionGroupConditionTargetResourceGroupArgs' target_resource_group: A `target_resource_group` block as defined below.
        :param 'AlertProcessingRuleActionGroupConditionTargetResourceTypeArgs' target_resource_type: A `target_resource_type` block as defined below.
               
               > **Note:** At least one of the `alert_context`, `alert_rule_id`, `alert_rule_name`, `description`, `monitor_condition`, `monitor_service`, `severity`, `signal_type`, `target_resource`, `target_resource_group`, `target_resource_type` must be specified.
        """
        if alert_context is not None:
            pulumi.set(__self__, "alert_context", alert_context)
        if alert_rule_id is not None:
            pulumi.set(__self__, "alert_rule_id", alert_rule_id)
        if alert_rule_name is not None:
            pulumi.set(__self__, "alert_rule_name", alert_rule_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if monitor_condition is not None:
            pulumi.set(__self__, "monitor_condition", monitor_condition)
        if monitor_service is not None:
            pulumi.set(__self__, "monitor_service", monitor_service)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if signal_type is not None:
            pulumi.set(__self__, "signal_type", signal_type)
        if target_resource is not None:
            pulumi.set(__self__, "target_resource", target_resource)
        if target_resource_group is not None:
            pulumi.set(__self__, "target_resource_group", target_resource_group)
        if target_resource_type is not None:
            pulumi.set(__self__, "target_resource_type", target_resource_type)

    @property
    @pulumi.getter(name="alertContext")
    def alert_context(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionAlertContext']:
        """
        A `alert_context` block as defined above.
        """
        return pulumi.get(self, "alert_context")

    @property
    @pulumi.getter(name="alertRuleId")
    def alert_rule_id(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionAlertRuleId']:
        """
        A `alert_rule_id` block as defined above.
        """
        return pulumi.get(self, "alert_rule_id")

    @property
    @pulumi.getter(name="alertRuleName")
    def alert_rule_name(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionAlertRuleName']:
        """
        A `alert_rule_name` block as defined above.
        """
        return pulumi.get(self, "alert_rule_name")

    @property
    @pulumi.getter
    def description(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionDescription']:
        """
        A `description` block as defined below.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="monitorCondition")
    def monitor_condition(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionMonitorCondition']:
        """
        A `monitor_condition` block as defined below.
        """
        return pulumi.get(self, "monitor_condition")

    @property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionMonitorService']:
        """
        A `monitor_service` block as defined below.
        """
        return pulumi.get(self, "monitor_service")

    @property
    @pulumi.getter
    def severity(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionSeverity']:
        """
        A `severity` block as defined below.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="signalType")
    def signal_type(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionSignalType']:
        """
        A `signal_type` block as defined below.
        """
        return pulumi.get(self, "signal_type")

    @property
    @pulumi.getter(name="targetResource")
    def target_resource(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionTargetResource']:
        """
        A `target_resource` block as defined below.
        """
        return pulumi.get(self, "target_resource")

    @property
    @pulumi.getter(name="targetResourceGroup")
    def target_resource_group(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionTargetResourceGroup']:
        """
        A `target_resource_group` block as defined below.
        """
        return pulumi.get(self, "target_resource_group")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional['outputs.AlertProcessingRuleActionGroupConditionTargetResourceType']:
        """
        A `target_resource_type` block as defined below.

        > **Note:** At least one of the `alert_context`, `alert_rule_id`, `alert_rule_name`, `description`, `monitor_condition`, `monitor_service`, `severity`, `signal_type`, `target_resource`, `target_resource_group`, `target_resource_type` must be specified.
        """
        return pulumi.get(self, "target_resource_type")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionAlertContext(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionAlertRuleId(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionAlertRuleName(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionDescription(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionMonitorCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionMonitorService(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param Sequence[str] values: A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionSeverity(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param Sequence[str] values: Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionSignalType(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionTargetResource(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: A list of values to match for a given condition. The values should be valid resource IDs.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match for a given condition. The values should be valid resource IDs.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionTargetResourceGroup(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: A list of values to match for a given condition. The values should be valid resource group IDs.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match for a given condition. The values should be valid resource group IDs.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupConditionTargetResourceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleActionGroupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveFrom":
            suggest = "effective_from"
        elif key == "effectiveUntil":
            suggest = "effective_until"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleActionGroupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleActionGroupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleActionGroupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_from: Optional[str] = None,
                 effective_until: Optional[str] = None,
                 recurrence: Optional['outputs.AlertProcessingRuleActionGroupScheduleRecurrence'] = None,
                 time_zone: Optional[str] = None):
        """
        :param str effective_from: Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        :param str effective_until: Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        :param 'AlertProcessingRuleActionGroupScheduleRecurrenceArgs' recurrence: A `recurrence` block as defined above.
        :param str time_zone: The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
        if effective_from is not None:
            pulumi.set(__self__, "effective_from", effective_from)
        if effective_until is not None:
            pulumi.set(__self__, "effective_until", effective_until)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="effectiveFrom")
    def effective_from(self) -> Optional[str]:
        """
        Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        """
        return pulumi.get(self, "effective_from")

    @property
    @pulumi.getter(name="effectiveUntil")
    def effective_until(self) -> Optional[str]:
        """
        Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        """
        return pulumi.get(self, "effective_until")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.AlertProcessingRuleActionGroupScheduleRecurrence']:
        """
        A `recurrence` block as defined above.
        """
        return pulumi.get(self, "recurrence")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class AlertProcessingRuleActionGroupScheduleRecurrence(dict):
    def __init__(__self__, *,
                 dailies: Optional[Sequence['outputs.AlertProcessingRuleActionGroupScheduleRecurrenceDaily']] = None,
                 monthlies: Optional[Sequence['outputs.AlertProcessingRuleActionGroupScheduleRecurrenceMonthly']] = None,
                 weeklies: Optional[Sequence['outputs.AlertProcessingRuleActionGroupScheduleRecurrenceWeekly']] = None):
        """
        :param Sequence['AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgs'] dailies: One or more `daily` blocks as defined above.
        :param Sequence['AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgs'] monthlies: One or more `monthly` blocks as defined above.
        :param Sequence['AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgs'] weeklies: One or more `weekly` blocks as defined below.
        """
        if dailies is not None:
            pulumi.set(__self__, "dailies", dailies)
        if monthlies is not None:
            pulumi.set(__self__, "monthlies", monthlies)
        if weeklies is not None:
            pulumi.set(__self__, "weeklies", weeklies)

    @property
    @pulumi.getter
    def dailies(self) -> Optional[Sequence['outputs.AlertProcessingRuleActionGroupScheduleRecurrenceDaily']]:
        """
        One or more `daily` blocks as defined above.
        """
        return pulumi.get(self, "dailies")

    @property
    @pulumi.getter
    def monthlies(self) -> Optional[Sequence['outputs.AlertProcessingRuleActionGroupScheduleRecurrenceMonthly']]:
        """
        One or more `monthly` blocks as defined above.
        """
        return pulumi.get(self, "monthlies")

    @property
    @pulumi.getter
    def weeklies(self) -> Optional[Sequence['outputs.AlertProcessingRuleActionGroupScheduleRecurrenceWeekly']]:
        """
        One or more `weekly` blocks as defined below.
        """
        return pulumi.get(self, "weeklies")


@pulumi.output_type
class AlertProcessingRuleActionGroupScheduleRecurrenceDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleActionGroupScheduleRecurrenceDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleActionGroupScheduleRecurrenceDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleActionGroupScheduleRecurrenceDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str):
        """
        :param str end_time: Specifies the recurrence end time (H:M:S).
        :param str start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class AlertProcessingRuleActionGroupScheduleRecurrenceMonthly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonths":
            suggest = "days_of_months"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleActionGroupScheduleRecurrenceMonthly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleActionGroupScheduleRecurrenceMonthly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleActionGroupScheduleRecurrenceMonthly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_months: Sequence[int],
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        :param Sequence[int] days_of_months: Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        :param str end_time: Specifies the recurrence end time (H:M:S).
        :param str start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "days_of_months", days_of_months)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Sequence[int]:
        """
        Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        """
        return pulumi.get(self, "days_of_months")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class AlertProcessingRuleActionGroupScheduleRecurrenceWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleActionGroupScheduleRecurrenceWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleActionGroupScheduleRecurrenceWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleActionGroupScheduleRecurrenceWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Sequence[str],
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        :param Sequence[str] days_of_weeks: Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        :param str end_time: Specifies the recurrence end time (H:M:S).
        :param str start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence[str]:
        """
        Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class AlertProcessingRuleSuppressionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertContext":
            suggest = "alert_context"
        elif key == "alertRuleId":
            suggest = "alert_rule_id"
        elif key == "alertRuleName":
            suggest = "alert_rule_name"
        elif key == "monitorCondition":
            suggest = "monitor_condition"
        elif key == "monitorService":
            suggest = "monitor_service"
        elif key == "signalType":
            suggest = "signal_type"
        elif key == "targetResource":
            suggest = "target_resource"
        elif key == "targetResourceGroup":
            suggest = "target_resource_group"
        elif key == "targetResourceType":
            suggest = "target_resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleSuppressionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleSuppressionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleSuppressionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_context: Optional['outputs.AlertProcessingRuleSuppressionConditionAlertContext'] = None,
                 alert_rule_id: Optional['outputs.AlertProcessingRuleSuppressionConditionAlertRuleId'] = None,
                 alert_rule_name: Optional['outputs.AlertProcessingRuleSuppressionConditionAlertRuleName'] = None,
                 description: Optional['outputs.AlertProcessingRuleSuppressionConditionDescription'] = None,
                 monitor_condition: Optional['outputs.AlertProcessingRuleSuppressionConditionMonitorCondition'] = None,
                 monitor_service: Optional['outputs.AlertProcessingRuleSuppressionConditionMonitorService'] = None,
                 severity: Optional['outputs.AlertProcessingRuleSuppressionConditionSeverity'] = None,
                 signal_type: Optional['outputs.AlertProcessingRuleSuppressionConditionSignalType'] = None,
                 target_resource: Optional['outputs.AlertProcessingRuleSuppressionConditionTargetResource'] = None,
                 target_resource_group: Optional['outputs.AlertProcessingRuleSuppressionConditionTargetResourceGroup'] = None,
                 target_resource_type: Optional['outputs.AlertProcessingRuleSuppressionConditionTargetResourceType'] = None):
        """
        :param 'AlertProcessingRuleSuppressionConditionAlertContextArgs' alert_context: A `alert_context` block as defined above.
        :param 'AlertProcessingRuleSuppressionConditionAlertRuleIdArgs' alert_rule_id: A `alert_rule_id` block as defined above.
        :param 'AlertProcessingRuleSuppressionConditionAlertRuleNameArgs' alert_rule_name: A `alert_rule_name` block as defined above.
        :param 'AlertProcessingRuleSuppressionConditionDescriptionArgs' description: A `description` block as defined below.
        :param 'AlertProcessingRuleSuppressionConditionMonitorConditionArgs' monitor_condition: A `monitor_condition` block as defined below.
        :param 'AlertProcessingRuleSuppressionConditionMonitorServiceArgs' monitor_service: A `monitor_service` block as defined below.
        :param 'AlertProcessingRuleSuppressionConditionSeverityArgs' severity: A `severity` block as defined below.
        :param 'AlertProcessingRuleSuppressionConditionSignalTypeArgs' signal_type: A `signal_type` block as defined below.
        :param 'AlertProcessingRuleSuppressionConditionTargetResourceArgs' target_resource: A `target_resource` block as defined below.
        :param 'AlertProcessingRuleSuppressionConditionTargetResourceGroupArgs' target_resource_group: A `target_resource_group` block as defined below.
        :param 'AlertProcessingRuleSuppressionConditionTargetResourceTypeArgs' target_resource_type: A `target_resource_type` block as defined below.
        """
        if alert_context is not None:
            pulumi.set(__self__, "alert_context", alert_context)
        if alert_rule_id is not None:
            pulumi.set(__self__, "alert_rule_id", alert_rule_id)
        if alert_rule_name is not None:
            pulumi.set(__self__, "alert_rule_name", alert_rule_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if monitor_condition is not None:
            pulumi.set(__self__, "monitor_condition", monitor_condition)
        if monitor_service is not None:
            pulumi.set(__self__, "monitor_service", monitor_service)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if signal_type is not None:
            pulumi.set(__self__, "signal_type", signal_type)
        if target_resource is not None:
            pulumi.set(__self__, "target_resource", target_resource)
        if target_resource_group is not None:
            pulumi.set(__self__, "target_resource_group", target_resource_group)
        if target_resource_type is not None:
            pulumi.set(__self__, "target_resource_type", target_resource_type)

    @property
    @pulumi.getter(name="alertContext")
    def alert_context(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionAlertContext']:
        """
        A `alert_context` block as defined above.
        """
        return pulumi.get(self, "alert_context")

    @property
    @pulumi.getter(name="alertRuleId")
    def alert_rule_id(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionAlertRuleId']:
        """
        A `alert_rule_id` block as defined above.
        """
        return pulumi.get(self, "alert_rule_id")

    @property
    @pulumi.getter(name="alertRuleName")
    def alert_rule_name(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionAlertRuleName']:
        """
        A `alert_rule_name` block as defined above.
        """
        return pulumi.get(self, "alert_rule_name")

    @property
    @pulumi.getter
    def description(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionDescription']:
        """
        A `description` block as defined below.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="monitorCondition")
    def monitor_condition(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionMonitorCondition']:
        """
        A `monitor_condition` block as defined below.
        """
        return pulumi.get(self, "monitor_condition")

    @property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionMonitorService']:
        """
        A `monitor_service` block as defined below.
        """
        return pulumi.get(self, "monitor_service")

    @property
    @pulumi.getter
    def severity(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionSeverity']:
        """
        A `severity` block as defined below.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="signalType")
    def signal_type(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionSignalType']:
        """
        A `signal_type` block as defined below.
        """
        return pulumi.get(self, "signal_type")

    @property
    @pulumi.getter(name="targetResource")
    def target_resource(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionTargetResource']:
        """
        A `target_resource` block as defined below.
        """
        return pulumi.get(self, "target_resource")

    @property
    @pulumi.getter(name="targetResourceGroup")
    def target_resource_group(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionTargetResourceGroup']:
        """
        A `target_resource_group` block as defined below.
        """
        return pulumi.get(self, "target_resource_group")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional['outputs.AlertProcessingRuleSuppressionConditionTargetResourceType']:
        """
        A `target_resource_type` block as defined below.
        """
        return pulumi.get(self, "target_resource_type")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionAlertContext(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionAlertRuleId(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionAlertRuleName(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionDescription(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionMonitorCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionMonitorService(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param Sequence[str] values: A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionSeverity(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param Sequence[str] values: Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionSignalType(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param Sequence[str] values: Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionTargetResource(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: A list of values to match for a given condition. The values should be valid resource IDs.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match for a given condition. The values should be valid resource IDs.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionTargetResourceGroup(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: A list of values to match for a given condition. The values should be valid resource group IDs.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match for a given condition. The values should be valid resource group IDs.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionConditionTargetResourceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param Sequence[str] values: A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlertProcessingRuleSuppressionSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveFrom":
            suggest = "effective_from"
        elif key == "effectiveUntil":
            suggest = "effective_until"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleSuppressionSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleSuppressionSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleSuppressionSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_from: Optional[str] = None,
                 effective_until: Optional[str] = None,
                 recurrence: Optional['outputs.AlertProcessingRuleSuppressionScheduleRecurrence'] = None,
                 time_zone: Optional[str] = None):
        """
        :param str effective_from: Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        :param str effective_until: Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        :param 'AlertProcessingRuleSuppressionScheduleRecurrenceArgs' recurrence: A `recurrence` block as defined above.
        :param str time_zone: The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
        if effective_from is not None:
            pulumi.set(__self__, "effective_from", effective_from)
        if effective_until is not None:
            pulumi.set(__self__, "effective_until", effective_until)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="effectiveFrom")
    def effective_from(self) -> Optional[str]:
        """
        Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        """
        return pulumi.get(self, "effective_from")

    @property
    @pulumi.getter(name="effectiveUntil")
    def effective_until(self) -> Optional[str]:
        """
        Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        """
        return pulumi.get(self, "effective_until")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.AlertProcessingRuleSuppressionScheduleRecurrence']:
        """
        A `recurrence` block as defined above.
        """
        return pulumi.get(self, "recurrence")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class AlertProcessingRuleSuppressionScheduleRecurrence(dict):
    def __init__(__self__, *,
                 dailies: Optional[Sequence['outputs.AlertProcessingRuleSuppressionScheduleRecurrenceDaily']] = None,
                 monthlies: Optional[Sequence['outputs.AlertProcessingRuleSuppressionScheduleRecurrenceMonthly']] = None,
                 weeklies: Optional[Sequence['outputs.AlertProcessingRuleSuppressionScheduleRecurrenceWeekly']] = None):
        """
        :param Sequence['AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgs'] dailies: One or more `daily` blocks as defined above.
        :param Sequence['AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgs'] monthlies: One or more `monthly` blocks as defined above.
        :param Sequence['AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgs'] weeklies: One or more `weekly` blocks as defined below.
        """
        if dailies is not None:
            pulumi.set(__self__, "dailies", dailies)
        if monthlies is not None:
            pulumi.set(__self__, "monthlies", monthlies)
        if weeklies is not None:
            pulumi.set(__self__, "weeklies", weeklies)

    @property
    @pulumi.getter
    def dailies(self) -> Optional[Sequence['outputs.AlertProcessingRuleSuppressionScheduleRecurrenceDaily']]:
        """
        One or more `daily` blocks as defined above.
        """
        return pulumi.get(self, "dailies")

    @property
    @pulumi.getter
    def monthlies(self) -> Optional[Sequence['outputs.AlertProcessingRuleSuppressionScheduleRecurrenceMonthly']]:
        """
        One or more `monthly` blocks as defined above.
        """
        return pulumi.get(self, "monthlies")

    @property
    @pulumi.getter
    def weeklies(self) -> Optional[Sequence['outputs.AlertProcessingRuleSuppressionScheduleRecurrenceWeekly']]:
        """
        One or more `weekly` blocks as defined below.
        """
        return pulumi.get(self, "weeklies")


@pulumi.output_type
class AlertProcessingRuleSuppressionScheduleRecurrenceDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleSuppressionScheduleRecurrenceDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleSuppressionScheduleRecurrenceDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleSuppressionScheduleRecurrenceDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str):
        """
        :param str end_time: Specifies the recurrence end time (H:M:S).
        :param str start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class AlertProcessingRuleSuppressionScheduleRecurrenceMonthly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonths":
            suggest = "days_of_months"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleSuppressionScheduleRecurrenceMonthly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleSuppressionScheduleRecurrenceMonthly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleSuppressionScheduleRecurrenceMonthly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_months: Sequence[int],
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        :param Sequence[int] days_of_months: Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        :param str end_time: Specifies the recurrence end time (H:M:S).
        :param str start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "days_of_months", days_of_months)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Sequence[int]:
        """
        Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        """
        return pulumi.get(self, "days_of_months")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class AlertProcessingRuleSuppressionScheduleRecurrenceWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertProcessingRuleSuppressionScheduleRecurrenceWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertProcessingRuleSuppressionScheduleRecurrenceWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertProcessingRuleSuppressionScheduleRecurrenceWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Sequence[str],
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        :param Sequence[str] days_of_weeks: Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        :param str end_time: Specifies the recurrence end time (H:M:S).
        :param str start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence[str]:
        """
        Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class AlertPrometheusRuleGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertResolution":
            suggest = "alert_resolution"
        elif key == "for":
            suggest = "for_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPrometheusRuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPrometheusRuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPrometheusRuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 actions: Optional[Sequence['outputs.AlertPrometheusRuleGroupRuleAction']] = None,
                 alert: Optional[str] = None,
                 alert_resolution: Optional['outputs.AlertPrometheusRuleGroupRuleAlertResolution'] = None,
                 annotations: Optional[Mapping[str, str]] = None,
                 enabled: Optional[bool] = None,
                 for_: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 record: Optional[str] = None,
                 severity: Optional[int] = None):
        """
        :param str expression: Specifies the Prometheus Query Language expression to evaluate. For more details see [this doc](https://prometheus.io/docs/prometheus/latest/querying/basics). Evaluate at the period given by `interval` and record the result as a new set of time series with the metric name given by `record`.
        :param Sequence['AlertPrometheusRuleGroupRuleActionArgs'] actions: An `action` block as defined below.
        :param str alert: Specifies the Alert rule name.
        :param 'AlertPrometheusRuleGroupRuleAlertResolutionArgs' alert_resolution: An `alert_resolution` block as defined below.
        :param Mapping[str, str] annotations: Specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links.
        :param bool enabled: Is this rule enabled? Possible values are `true` and `false`.
        :param str for_: Specifies the amount of time alert must be active before firing, represented in ISO 8601 duration format.
        :param Mapping[str, str] labels: Specifies the labels to add or overwrite before storing the result.
        :param str record: Specifies the recorded metrics name.
        :param int severity: Specifies the severity of the alerts fired by the rule. Possible values are between 0 and 4.
        """
        pulumi.set(__self__, "expression", expression)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if alert_resolution is not None:
            pulumi.set(__self__, "alert_resolution", alert_resolution)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if record is not None:
            pulumi.set(__self__, "record", record)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Specifies the Prometheus Query Language expression to evaluate. For more details see [this doc](https://prometheus.io/docs/prometheus/latest/querying/basics). Evaluate at the period given by `interval` and record the result as a new set of time series with the metric name given by `record`.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AlertPrometheusRuleGroupRuleAction']]:
        """
        An `action` block as defined below.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def alert(self) -> Optional[str]:
        """
        Specifies the Alert rule name.
        """
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter(name="alertResolution")
    def alert_resolution(self) -> Optional['outputs.AlertPrometheusRuleGroupRuleAlertResolution']:
        """
        An `alert_resolution` block as defined below.
        """
        return pulumi.get(self, "alert_resolution")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is this rule enabled? Possible values are `true` and `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[str]:
        """
        Specifies the amount of time alert must be active before firing, represented in ISO 8601 duration format.
        """
        return pulumi.get(self, "for_")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Specifies the labels to add or overwrite before storing the result.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def record(self) -> Optional[str]:
        """
        Specifies the recorded metrics name.
        """
        return pulumi.get(self, "record")

    @property
    @pulumi.getter
    def severity(self) -> Optional[int]:
        """
        Specifies the severity of the alerts fired by the rule. Possible values are between 0 and 4.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class AlertPrometheusRuleGroupRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroupId":
            suggest = "action_group_id"
        elif key == "actionProperties":
            suggest = "action_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPrometheusRuleGroupRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPrometheusRuleGroupRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPrometheusRuleGroupRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_group_id: str,
                 action_properties: Optional[Mapping[str, str]] = None):
        """
        :param str action_group_id: Specifies the resource id of the monitor action group.
        :param Mapping[str, str] action_properties: Specifies the properties of an action group object.
               
               > **Note:** `action_properties` can only be configured for IcM Connector Action Groups for now. Other public features will be supported in the future.
        """
        pulumi.set(__self__, "action_group_id", action_group_id)
        if action_properties is not None:
            pulumi.set(__self__, "action_properties", action_properties)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> str:
        """
        Specifies the resource id of the monitor action group.
        """
        return pulumi.get(self, "action_group_id")

    @property
    @pulumi.getter(name="actionProperties")
    def action_properties(self) -> Optional[Mapping[str, str]]:
        """
        Specifies the properties of an action group object.

        > **Note:** `action_properties` can only be configured for IcM Connector Action Groups for now. Other public features will be supported in the future.
        """
        return pulumi.get(self, "action_properties")


@pulumi.output_type
class AlertPrometheusRuleGroupRuleAlertResolution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoResolved":
            suggest = "auto_resolved"
        elif key == "timeToResolve":
            suggest = "time_to_resolve"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPrometheusRuleGroupRuleAlertResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPrometheusRuleGroupRuleAlertResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPrometheusRuleGroupRuleAlertResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_resolved: Optional[bool] = None,
                 time_to_resolve: Optional[str] = None):
        """
        :param bool auto_resolved: Is the alert auto-resolution? Possible values are `true` and `false`.
        :param str time_to_resolve: Specifies the alert auto-resolution interval, represented in ISO 8601 duration format.
        """
        if auto_resolved is not None:
            pulumi.set(__self__, "auto_resolved", auto_resolved)
        if time_to_resolve is not None:
            pulumi.set(__self__, "time_to_resolve", time_to_resolve)

    @property
    @pulumi.getter(name="autoResolved")
    def auto_resolved(self) -> Optional[bool]:
        """
        Is the alert auto-resolution? Possible values are `true` and `false`.
        """
        return pulumi.get(self, "auto_resolved")

    @property
    @pulumi.getter(name="timeToResolve")
    def time_to_resolve(self) -> Optional[str]:
        """
        Specifies the alert auto-resolution interval, represented in ISO 8601 duration format.
        """
        return pulumi.get(self, "time_to_resolve")


@pulumi.output_type
class AutoscaleSettingNotification(dict):
    def __init__(__self__, *,
                 email: Optional['outputs.AutoscaleSettingNotificationEmail'] = None,
                 webhooks: Optional[Sequence['outputs.AutoscaleSettingNotificationWebhook']] = None):
        """
        :param 'AutoscaleSettingNotificationEmailArgs' email: A `email` block as defined below.
        :param Sequence['AutoscaleSettingNotificationWebhookArgs'] webhooks: One or more `webhook` blocks as defined below.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter
    def email(self) -> Optional['outputs.AutoscaleSettingNotificationEmail']:
        """
        A `email` block as defined below.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def webhooks(self) -> Optional[Sequence['outputs.AutoscaleSettingNotificationWebhook']]:
        """
        One or more `webhook` blocks as defined below.
        """
        return pulumi.get(self, "webhooks")


@pulumi.output_type
class AutoscaleSettingNotificationEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customEmails":
            suggest = "custom_emails"
        elif key == "sendToSubscriptionAdministrator":
            suggest = "send_to_subscription_administrator"
        elif key == "sendToSubscriptionCoAdministrator":
            suggest = "send_to_subscription_co_administrator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleSettingNotificationEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleSettingNotificationEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleSettingNotificationEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_emails: Optional[Sequence[str]] = None,
                 send_to_subscription_administrator: Optional[bool] = None,
                 send_to_subscription_co_administrator: Optional[bool] = None):
        """
        :param Sequence[str] custom_emails: Specifies a list of custom email addresses to which the email notifications will be sent.
        :param bool send_to_subscription_administrator: Should email notifications be sent to the subscription administrator? Defaults to `false`.
        :param bool send_to_subscription_co_administrator: Should email notifications be sent to the subscription co-administrator? Defaults to `false`.
        """
        if custom_emails is not None:
            pulumi.set(__self__, "custom_emails", custom_emails)
        if send_to_subscription_administrator is not None:
            pulumi.set(__self__, "send_to_subscription_administrator", send_to_subscription_administrator)
        if send_to_subscription_co_administrator is not None:
            pulumi.set(__self__, "send_to_subscription_co_administrator", send_to_subscription_co_administrator)

    @property
    @pulumi.getter(name="customEmails")
    def custom_emails(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of custom email addresses to which the email notifications will be sent.
        """
        return pulumi.get(self, "custom_emails")

    @property
    @pulumi.getter(name="sendToSubscriptionAdministrator")
    def send_to_subscription_administrator(self) -> Optional[bool]:
        """
        Should email notifications be sent to the subscription administrator? Defaults to `false`.
        """
        return pulumi.get(self, "send_to_subscription_administrator")

    @property
    @pulumi.getter(name="sendToSubscriptionCoAdministrator")
    def send_to_subscription_co_administrator(self) -> Optional[bool]:
        """
        Should email notifications be sent to the subscription co-administrator? Defaults to `false`.
        """
        return pulumi.get(self, "send_to_subscription_co_administrator")


@pulumi.output_type
class AutoscaleSettingNotificationWebhook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceUri":
            suggest = "service_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleSettingNotificationWebhook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleSettingNotificationWebhook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleSettingNotificationWebhook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_uri: str,
                 properties: Optional[Mapping[str, str]] = None):
        """
        :param str service_uri: The HTTPS URI which should receive scale notifications.
        :param Mapping[str, str] properties: A map of settings.
        """
        pulumi.set(__self__, "service_uri", service_uri)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> str:
        """
        The HTTPS URI which should receive scale notifications.
        """
        return pulumi.get(self, "service_uri")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        A map of settings.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class AutoscaleSettingPredictive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleMode":
            suggest = "scale_mode"
        elif key == "lookAheadTime":
            suggest = "look_ahead_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleSettingPredictive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleSettingPredictive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleSettingPredictive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_mode: str,
                 look_ahead_time: Optional[str] = None):
        """
        :param str scale_mode: Specifies the predictive scale mode. Possible values are `Enabled` or `ForecastOnly`.
        :param str look_ahead_time: Specifies the amount of time by which instances are launched in advance. It must be between `PT1M` and `PT1H` in ISO 8601 format.
        """
        pulumi.set(__self__, "scale_mode", scale_mode)
        if look_ahead_time is not None:
            pulumi.set(__self__, "look_ahead_time", look_ahead_time)

    @property
    @pulumi.getter(name="scaleMode")
    def scale_mode(self) -> str:
        """
        Specifies the predictive scale mode. Possible values are `Enabled` or `ForecastOnly`.
        """
        return pulumi.get(self, "scale_mode")

    @property
    @pulumi.getter(name="lookAheadTime")
    def look_ahead_time(self) -> Optional[str]:
        """
        Specifies the amount of time by which instances are launched in advance. It must be between `PT1M` and `PT1H` in ISO 8601 format.
        """
        return pulumi.get(self, "look_ahead_time")


@pulumi.output_type
class AutoscaleSettingProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedDate":
            suggest = "fixed_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleSettingProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleSettingProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleSettingProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity: 'outputs.AutoscaleSettingProfileCapacity',
                 name: str,
                 fixed_date: Optional['outputs.AutoscaleSettingProfileFixedDate'] = None,
                 recurrence: Optional['outputs.AutoscaleSettingProfileRecurrence'] = None,
                 rules: Optional[Sequence['outputs.AutoscaleSettingProfileRule']] = None):
        """
        :param 'AutoscaleSettingProfileCapacityArgs' capacity: A `capacity` block as defined below.
        :param str name: Specifies the name of the profile.
        :param 'AutoscaleSettingProfileFixedDateArgs' fixed_date: A `fixed_date` block as defined below. This cannot be specified if a `recurrence` block is specified.
        :param 'AutoscaleSettingProfileRecurrenceArgs' recurrence: A `recurrence` block as defined below. This cannot be specified if a `fixed_date` block is specified.
        :param Sequence['AutoscaleSettingProfileRuleArgs'] rules: One or more (up to 10) `rule` blocks as defined below.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        if fixed_date is not None:
            pulumi.set(__self__, "fixed_date", fixed_date)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def capacity(self) -> 'outputs.AutoscaleSettingProfileCapacity':
        """
        A `capacity` block as defined below.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the profile.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="fixedDate")
    def fixed_date(self) -> Optional['outputs.AutoscaleSettingProfileFixedDate']:
        """
        A `fixed_date` block as defined below. This cannot be specified if a `recurrence` block is specified.
        """
        return pulumi.get(self, "fixed_date")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.AutoscaleSettingProfileRecurrence']:
        """
        A `recurrence` block as defined below. This cannot be specified if a `fixed_date` block is specified.
        """
        return pulumi.get(self, "recurrence")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AutoscaleSettingProfileRule']]:
        """
        One or more (up to 10) `rule` blocks as defined below.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AutoscaleSettingProfileCapacity(dict):
    def __init__(__self__, *,
                 default: int,
                 maximum: int,
                 minimum: int):
        """
        :param int default: The number of instances that are available for scaling if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default. Valid values are between `0` and `1000`.
        :param int maximum: The maximum number of instances for this resource. Valid values are between `0` and `1000`.
               
               > **NOTE:** The maximum number of instances is also limited by the amount of Cores available in the subscription.
        :param int minimum: The minimum number of instances for this resource. Valid values are between `0` and `1000`.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "maximum", maximum)
        pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def default(self) -> int:
        """
        The number of instances that are available for scaling if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default. Valid values are between `0` and `1000`.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def maximum(self) -> int:
        """
        The maximum number of instances for this resource. Valid values are between `0` and `1000`.

        > **NOTE:** The maximum number of instances is also limited by the amount of Cores available in the subscription.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> int:
        """
        The minimum number of instances for this resource. Valid values are between `0` and `1000`.
        """
        return pulumi.get(self, "minimum")


@pulumi.output_type
class AutoscaleSettingProfileFixedDate(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str,
                 timezone: Optional[str] = None):
        """
        :param str end: Specifies the end date for the profile, formatted as an RFC3339 date string.
        :param str start: Specifies the start date for the profile, formatted as an RFC3339 date string.
        :param str timezone: The Time Zone of the `start` and `end` times. A list of [possible values can be found here](https://learn.microsoft.com/en-us/rest/api/monitor/autoscale-settings/create-or-update?view=rest-monitor-2022-10-01&tabs=HTTP#recurrentschedule). Defaults to `UTC`.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        Specifies the end date for the profile, formatted as an RFC3339 date string.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        Specifies the start date for the profile, formatted as an RFC3339 date string.
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        The Time Zone of the `start` and `end` times. A list of [possible values can be found here](https://learn.microsoft.com/en-us/rest/api/monitor/autoscale-settings/create-or-update?view=rest-monitor-2022-10-01&tabs=HTTP#recurrentschedule). Defaults to `UTC`.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class AutoscaleSettingProfileRecurrence(dict):
    def __init__(__self__, *,
                 days: Sequence[str],
                 hours: int,
                 minutes: int,
                 timezone: Optional[str] = None):
        """
        :param Sequence[str] days: A list of days that this profile takes effect on. Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        :param int hours: A list containing a single item, which specifies the Hour interval at which this recurrence should be triggered (in 24-hour time). Possible values are from `0` to `23`.
        :param int minutes: A list containing a single item which specifies the Minute interval at which this recurrence should be triggered.
        :param str timezone: The Time Zone used for the `hours` field. A list of possible values can be found here). Defaults to `UTC`.
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def days(self) -> Sequence[str]:
        """
        A list of days that this profile takes effect on. Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter
    def hours(self) -> int:
        """
        A list containing a single item, which specifies the Hour interval at which this recurrence should be triggered (in 24-hour time). Possible values are from `0` to `23`.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> int:
        """
        A list containing a single item which specifies the Minute interval at which this recurrence should be triggered.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        The Time Zone used for the `hours` field. A list of possible values can be found here). Defaults to `UTC`.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class AutoscaleSettingProfileRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricTrigger":
            suggest = "metric_trigger"
        elif key == "scaleAction":
            suggest = "scale_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleSettingProfileRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleSettingProfileRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleSettingProfileRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_trigger: 'outputs.AutoscaleSettingProfileRuleMetricTrigger',
                 scale_action: 'outputs.AutoscaleSettingProfileRuleScaleAction'):
        """
        :param 'AutoscaleSettingProfileRuleMetricTriggerArgs' metric_trigger: A `metric_trigger` block as defined below.
        :param 'AutoscaleSettingProfileRuleScaleActionArgs' scale_action: A `scale_action` block as defined below.
        """
        pulumi.set(__self__, "metric_trigger", metric_trigger)
        pulumi.set(__self__, "scale_action", scale_action)

    @property
    @pulumi.getter(name="metricTrigger")
    def metric_trigger(self) -> 'outputs.AutoscaleSettingProfileRuleMetricTrigger':
        """
        A `metric_trigger` block as defined below.
        """
        return pulumi.get(self, "metric_trigger")

    @property
    @pulumi.getter(name="scaleAction")
    def scale_action(self) -> 'outputs.AutoscaleSettingProfileRuleScaleAction':
        """
        A `scale_action` block as defined below.
        """
        return pulumi.get(self, "scale_action")


@pulumi.output_type
class AutoscaleSettingProfileRuleMetricTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricResourceId":
            suggest = "metric_resource_id"
        elif key == "timeAggregation":
            suggest = "time_aggregation"
        elif key == "timeGrain":
            suggest = "time_grain"
        elif key == "timeWindow":
            suggest = "time_window"
        elif key == "divideByInstanceCount":
            suggest = "divide_by_instance_count"
        elif key == "metricNamespace":
            suggest = "metric_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleSettingProfileRuleMetricTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleSettingProfileRuleMetricTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleSettingProfileRuleMetricTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 metric_resource_id: str,
                 operator: str,
                 statistic: str,
                 threshold: float,
                 time_aggregation: str,
                 time_grain: str,
                 time_window: str,
                 dimensions: Optional[Sequence['outputs.AutoscaleSettingProfileRuleMetricTriggerDimension']] = None,
                 divide_by_instance_count: Optional[bool] = None,
                 metric_namespace: Optional[str] = None):
        """
        :param str metric_name: The name of the metric that defines what the rule monitors, such as `Percentage CPU` for `Virtual Machine Scale Sets` and `CpuPercentage` for `App Service Plan`.
               
               > **NOTE:** The allowed value of `metric_name` highly depends on the targeting resource type, please visit [Supported metrics with Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported) for more details.
        :param str metric_resource_id: The ID of the Resource which the Rule monitors.
        :param str operator: Specifies the operator used to compare the metric data and threshold. Possible values are: `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`.
        :param str statistic: Specifies how the metrics from multiple instances are combined. Possible values are `Average`, `Max`, `Min` and `Sum`.
        :param float threshold: Specifies the threshold of the metric that triggers the scale action.
        :param str time_aggregation: Specifies how the data that's collected should be combined over time. Possible values include `Average`, `Count`, `Maximum`, `Minimum`, `Last` and `Total`.
        :param str time_grain: Specifies the granularity of metrics that the rule monitors, which must be one of the pre-defined values returned from the metric definitions for the metric. This value must be between 1 minute and 12 hours an be formatted as an ISO 8601 string.
        :param str time_window: Specifies the time range for which data is collected, which must be greater than the delay in metric collection (which varies from resource to resource). This value must be between 5 minutes and 12 hours and be formatted as an ISO 8601 string.
        :param Sequence['AutoscaleSettingProfileRuleMetricTriggerDimensionArgs'] dimensions: One or more `dimensions` block as defined below.
        :param bool divide_by_instance_count: Whether to enable metric divide by instance count.
        :param str metric_namespace: The namespace of the metric that defines what the rule monitors, such as `microsoft.compute/virtualmachinescalesets` for `Virtual Machine Scale Sets`.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_resource_id", metric_resource_id)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "statistic", statistic)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "time_aggregation", time_aggregation)
        pulumi.set(__self__, "time_grain", time_grain)
        pulumi.set(__self__, "time_window", time_window)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if divide_by_instance_count is not None:
            pulumi.set(__self__, "divide_by_instance_count", divide_by_instance_count)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric that defines what the rule monitors, such as `Percentage CPU` for `Virtual Machine Scale Sets` and `CpuPercentage` for `App Service Plan`.

        > **NOTE:** The allowed value of `metric_name` highly depends on the targeting resource type, please visit [Supported metrics with Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported) for more details.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricResourceId")
    def metric_resource_id(self) -> str:
        """
        The ID of the Resource which the Rule monitors.
        """
        return pulumi.get(self, "metric_resource_id")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Specifies the operator used to compare the metric data and threshold. Possible values are: `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def statistic(self) -> str:
        """
        Specifies how the metrics from multiple instances are combined. Possible values are `Average`, `Max`, `Min` and `Sum`.
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Specifies the threshold of the metric that triggers the scale action.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="timeAggregation")
    def time_aggregation(self) -> str:
        """
        Specifies how the data that's collected should be combined over time. Possible values include `Average`, `Count`, `Maximum`, `Minimum`, `Last` and `Total`.
        """
        return pulumi.get(self, "time_aggregation")

    @property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> str:
        """
        Specifies the granularity of metrics that the rule monitors, which must be one of the pre-defined values returned from the metric definitions for the metric. This value must be between 1 minute and 12 hours an be formatted as an ISO 8601 string.
        """
        return pulumi.get(self, "time_grain")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> str:
        """
        Specifies the time range for which data is collected, which must be greater than the delay in metric collection (which varies from resource to resource). This value must be between 5 minutes and 12 hours and be formatted as an ISO 8601 string.
        """
        return pulumi.get(self, "time_window")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.AutoscaleSettingProfileRuleMetricTriggerDimension']]:
        """
        One or more `dimensions` block as defined below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="divideByInstanceCount")
    def divide_by_instance_count(self) -> Optional[bool]:
        """
        Whether to enable metric divide by instance count.
        """
        return pulumi.get(self, "divide_by_instance_count")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[str]:
        """
        The namespace of the metric that defines what the rule monitors, such as `microsoft.compute/virtualmachinescalesets` for `Virtual Machine Scale Sets`.
        """
        return pulumi.get(self, "metric_namespace")


@pulumi.output_type
class AutoscaleSettingProfileRuleMetricTriggerDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the dimension.
        :param str operator: The dimension operator. Possible values are `Equals` and `NotEquals`. `Equals` means being equal to any of the values. `NotEquals` means being not equal to any of the values.
        :param Sequence[str] values: A list of dimension values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the dimension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The dimension operator. Possible values are `Equals` and `NotEquals`. `Equals` means being equal to any of the values. `NotEquals` means being not equal to any of the values.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of dimension values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AutoscaleSettingProfileRuleScaleAction(dict):
    def __init__(__self__, *,
                 cooldown: str,
                 direction: str,
                 type: str,
                 value: int):
        """
        :param str cooldown: The amount of time to wait since the last scaling action before this action occurs. Must be between 1 minute and 1 week and formatted as a ISO 8601 string.
        :param str direction: The scale direction. Possible values are `Increase` and `Decrease`.
        :param str type: The type of action that should occur. Possible values are `ChangeCount`, `ExactCount`, `PercentChangeCount` and `ServiceAllowedNextValue`.
        :param int value: The number of instances involved in the scaling action.
        """
        pulumi.set(__self__, "cooldown", cooldown)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def cooldown(self) -> str:
        """
        The amount of time to wait since the last scaling action before this action occurs. Must be between 1 minute and 1 week and formatted as a ISO 8601 string.
        """
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The scale direction. Possible values are `Increase` and `Decrease`.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of action that should occur. Possible values are `ChangeCount`, `ExactCount`, `PercentChangeCount` and `ServiceAllowedNextValue`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        The number of instances involved in the scaling action.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataCollectionRuleDataFlow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "builtInTransform":
            suggest = "built_in_transform"
        elif key == "outputStream":
            suggest = "output_stream"
        elif key == "transformKql":
            suggest = "transform_kql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataFlow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataFlow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataFlow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destinations: Sequence[str],
                 streams: Sequence[str],
                 built_in_transform: Optional[str] = None,
                 output_stream: Optional[str] = None,
                 transform_kql: Optional[str] = None):
        """
        :param Sequence[str] destinations: Specifies a list of destination names. A `azure_monitor_metrics` data source only allows for stream of kind `Microsoft-InsightsMetrics`.
        :param Sequence[str] streams: Specifies a list of streams. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`, and `Microsoft-PrometheusMetrics`.
        :param str built_in_transform: The built-in transform to transform stream data.
        :param str output_stream: The output stream of the transform. Only required if the data flow changes data to a different stream.
        :param str transform_kql: The KQL query to transform stream data.
        """
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "streams", streams)
        if built_in_transform is not None:
            pulumi.set(__self__, "built_in_transform", built_in_transform)
        if output_stream is not None:
            pulumi.set(__self__, "output_stream", output_stream)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter
    def destinations(self) -> Sequence[str]:
        """
        Specifies a list of destination names. A `azure_monitor_metrics` data source only allows for stream of kind `Microsoft-InsightsMetrics`.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`, and `Microsoft-PrometheusMetrics`.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="builtInTransform")
    def built_in_transform(self) -> Optional[str]:
        """
        The built-in transform to transform stream data.
        """
        return pulumi.get(self, "built_in_transform")

    @property
    @pulumi.getter(name="outputStream")
    def output_stream(self) -> Optional[str]:
        """
        The output stream of the transform. Only required if the data flow changes data to a different stream.
        """
        return pulumi.get(self, "output_stream")

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[str]:
        """
        The KQL query to transform stream data.
        """
        return pulumi.get(self, "transform_kql")


@pulumi.output_type
class DataCollectionRuleDataSources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataImport":
            suggest = "data_import"
        elif key == "iisLogs":
            suggest = "iis_logs"
        elif key == "logFiles":
            suggest = "log_files"
        elif key == "performanceCounters":
            suggest = "performance_counters"
        elif key == "platformTelemetries":
            suggest = "platform_telemetries"
        elif key == "prometheusForwarders":
            suggest = "prometheus_forwarders"
        elif key == "windowsEventLogs":
            suggest = "windows_event_logs"
        elif key == "windowsFirewallLogs":
            suggest = "windows_firewall_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_import: Optional['outputs.DataCollectionRuleDataSourcesDataImport'] = None,
                 extensions: Optional[Sequence['outputs.DataCollectionRuleDataSourcesExtension']] = None,
                 iis_logs: Optional[Sequence['outputs.DataCollectionRuleDataSourcesIisLog']] = None,
                 log_files: Optional[Sequence['outputs.DataCollectionRuleDataSourcesLogFile']] = None,
                 performance_counters: Optional[Sequence['outputs.DataCollectionRuleDataSourcesPerformanceCounter']] = None,
                 platform_telemetries: Optional[Sequence['outputs.DataCollectionRuleDataSourcesPlatformTelemetry']] = None,
                 prometheus_forwarders: Optional[Sequence['outputs.DataCollectionRuleDataSourcesPrometheusForwarder']] = None,
                 syslogs: Optional[Sequence['outputs.DataCollectionRuleDataSourcesSyslog']] = None,
                 windows_event_logs: Optional[Sequence['outputs.DataCollectionRuleDataSourcesWindowsEventLog']] = None,
                 windows_firewall_logs: Optional[Sequence['outputs.DataCollectionRuleDataSourcesWindowsFirewallLog']] = None):
        """
        :param 'DataCollectionRuleDataSourcesDataImportArgs' data_import: A `data_import` block as defined above.
        :param Sequence['DataCollectionRuleDataSourcesExtensionArgs'] extensions: One or more `extension` blocks as defined below.
        :param Sequence['DataCollectionRuleDataSourcesIisLogArgs'] iis_logs: One or more `iis_log` blocks as defined below.
        :param Sequence['DataCollectionRuleDataSourcesLogFileArgs'] log_files: One or more `log_file` blocks as defined below.
        :param Sequence['DataCollectionRuleDataSourcesPerformanceCounterArgs'] performance_counters: One or more `performance_counter` blocks as defined below.
        :param Sequence['DataCollectionRuleDataSourcesPlatformTelemetryArgs'] platform_telemetries: One or more `platform_telemetry` blocks as defined below.
        :param Sequence['DataCollectionRuleDataSourcesPrometheusForwarderArgs'] prometheus_forwarders: One or more `prometheus_forwarder` blocks as defined below.
        :param Sequence['DataCollectionRuleDataSourcesSyslogArgs'] syslogs: One or more `syslog` blocks as defined below.
        :param Sequence['DataCollectionRuleDataSourcesWindowsEventLogArgs'] windows_event_logs: One or more `windows_event_log` blocks as defined below.
        :param Sequence['DataCollectionRuleDataSourcesWindowsFirewallLogArgs'] windows_firewall_logs: One or more `windows_firewall_log` blocks as defined below.
        """
        if data_import is not None:
            pulumi.set(__self__, "data_import", data_import)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if iis_logs is not None:
            pulumi.set(__self__, "iis_logs", iis_logs)
        if log_files is not None:
            pulumi.set(__self__, "log_files", log_files)
        if performance_counters is not None:
            pulumi.set(__self__, "performance_counters", performance_counters)
        if platform_telemetries is not None:
            pulumi.set(__self__, "platform_telemetries", platform_telemetries)
        if prometheus_forwarders is not None:
            pulumi.set(__self__, "prometheus_forwarders", prometheus_forwarders)
        if syslogs is not None:
            pulumi.set(__self__, "syslogs", syslogs)
        if windows_event_logs is not None:
            pulumi.set(__self__, "windows_event_logs", windows_event_logs)
        if windows_firewall_logs is not None:
            pulumi.set(__self__, "windows_firewall_logs", windows_firewall_logs)

    @property
    @pulumi.getter(name="dataImport")
    def data_import(self) -> Optional['outputs.DataCollectionRuleDataSourcesDataImport']:
        """
        A `data_import` block as defined above.
        """
        return pulumi.get(self, "data_import")

    @property
    @pulumi.getter
    def extensions(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesExtension']]:
        """
        One or more `extension` blocks as defined below.
        """
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter(name="iisLogs")
    def iis_logs(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesIisLog']]:
        """
        One or more `iis_log` blocks as defined below.
        """
        return pulumi.get(self, "iis_logs")

    @property
    @pulumi.getter(name="logFiles")
    def log_files(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesLogFile']]:
        """
        One or more `log_file` blocks as defined below.
        """
        return pulumi.get(self, "log_files")

    @property
    @pulumi.getter(name="performanceCounters")
    def performance_counters(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesPerformanceCounter']]:
        """
        One or more `performance_counter` blocks as defined below.
        """
        return pulumi.get(self, "performance_counters")

    @property
    @pulumi.getter(name="platformTelemetries")
    def platform_telemetries(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesPlatformTelemetry']]:
        """
        One or more `platform_telemetry` blocks as defined below.
        """
        return pulumi.get(self, "platform_telemetries")

    @property
    @pulumi.getter(name="prometheusForwarders")
    def prometheus_forwarders(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesPrometheusForwarder']]:
        """
        One or more `prometheus_forwarder` blocks as defined below.
        """
        return pulumi.get(self, "prometheus_forwarders")

    @property
    @pulumi.getter
    def syslogs(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesSyslog']]:
        """
        One or more `syslog` blocks as defined below.
        """
        return pulumi.get(self, "syslogs")

    @property
    @pulumi.getter(name="windowsEventLogs")
    def windows_event_logs(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesWindowsEventLog']]:
        """
        One or more `windows_event_log` blocks as defined below.
        """
        return pulumi.get(self, "windows_event_logs")

    @property
    @pulumi.getter(name="windowsFirewallLogs")
    def windows_firewall_logs(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesWindowsFirewallLog']]:
        """
        One or more `windows_firewall_log` blocks as defined below.
        """
        return pulumi.get(self, "windows_firewall_logs")


@pulumi.output_type
class DataCollectionRuleDataSourcesDataImport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventHubDataSources":
            suggest = "event_hub_data_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesDataImport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesDataImport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesDataImport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_hub_data_sources: Sequence['outputs.DataCollectionRuleDataSourcesDataImportEventHubDataSource']):
        """
        :param Sequence['DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgs'] event_hub_data_sources: An `event_hub_data_source` block as defined below.
        """
        pulumi.set(__self__, "event_hub_data_sources", event_hub_data_sources)

    @property
    @pulumi.getter(name="eventHubDataSources")
    def event_hub_data_sources(self) -> Sequence['outputs.DataCollectionRuleDataSourcesDataImportEventHubDataSource']:
        """
        An `event_hub_data_source` block as defined below.
        """
        return pulumi.get(self, "event_hub_data_sources")


@pulumi.output_type
class DataCollectionRuleDataSourcesDataImportEventHubDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroup":
            suggest = "consumer_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesDataImportEventHubDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesDataImportEventHubDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesDataImportEventHubDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 stream: str,
                 consumer_group: Optional[str] = None):
        """
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param str stream: The stream to collect from Event Hub. Possible value should be a custom stream name.
        :param str consumer_group: The Event Hub consumer group name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stream", stream)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def stream(self) -> str:
        """
        The stream to collect from Event Hub. Possible value should be a custom stream name.
        """
        return pulumi.get(self, "stream")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[str]:
        """
        The Event Hub consumer group name.
        """
        return pulumi.get(self, "consumer_group")


@pulumi.output_type
class DataCollectionRuleDataSourcesExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionName":
            suggest = "extension_name"
        elif key == "extensionJson":
            suggest = "extension_json"
        elif key == "inputDataSources":
            suggest = "input_data_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_name: str,
                 name: str,
                 streams: Sequence[str],
                 extension_json: Optional[str] = None,
                 input_data_sources: Optional[Sequence[str]] = None):
        """
        :param str extension_name: The name of the VM extension.
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`.
        :param str extension_json: A JSON String which specifies the extension setting.
        :param Sequence[str] input_data_sources: Specifies a list of data sources this extension needs data from. An item should be a name of a supported data source which produces only one stream. Supported data sources type: `performance_counter`, `windows_event_log`,and `syslog`.
        """
        pulumi.set(__self__, "extension_name", extension_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        if extension_json is not None:
            pulumi.set(__self__, "extension_json", extension_json)
        if input_data_sources is not None:
            pulumi.set(__self__, "input_data_sources", input_data_sources)

    @property
    @pulumi.getter(name="extensionName")
    def extension_name(self) -> str:
        """
        The name of the VM extension.
        """
        return pulumi.get(self, "extension_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="extensionJson")
    def extension_json(self) -> Optional[str]:
        """
        A JSON String which specifies the extension setting.
        """
        return pulumi.get(self, "extension_json")

    @property
    @pulumi.getter(name="inputDataSources")
    def input_data_sources(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of data sources this extension needs data from. An item should be a name of a supported data source which produces only one stream. Supported data sources type: `performance_counter`, `windows_event_log`,and `syslog`.
        """
        return pulumi.get(self, "input_data_sources")


@pulumi.output_type
class DataCollectionRuleDataSourcesIisLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logDirectories":
            suggest = "log_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesIisLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesIisLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesIisLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 streams: Sequence[str],
                 log_directories: Optional[Sequence[str]] = None):
        """
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-W3CIISLog`.
        :param Sequence[str] log_directories: Specifies a list of absolute paths where the log files are located.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        if log_directories is not None:
            pulumi.set(__self__, "log_directories", log_directories)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-W3CIISLog`.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="logDirectories")
    def log_directories(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of absolute paths where the log files are located.
        """
        return pulumi.get(self, "log_directories")


@pulumi.output_type
class DataCollectionRuleDataSourcesLogFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePatterns":
            suggest = "file_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesLogFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesLogFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesLogFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_patterns: Sequence[str],
                 format: str,
                 name: str,
                 streams: Sequence[str],
                 settings: Optional['outputs.DataCollectionRuleDataSourcesLogFileSettings'] = None):
        """
        :param Sequence[str] file_patterns: Specifies a list of file patterns where the log files are located. For example, `C:\\\\JavaLogs\\\\*.log`.
        :param str format: The data format of the log files. possible value is `text`.
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value should be custom stream names.
        :param 'DataCollectionRuleDataSourcesLogFileSettingsArgs' settings: A `settings` block as defined below.
        """
        pulumi.set(__self__, "file_patterns", file_patterns)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter(name="filePatterns")
    def file_patterns(self) -> Sequence[str]:
        """
        Specifies a list of file patterns where the log files are located. For example, `C:\\\\JavaLogs\\\\*.log`.
        """
        return pulumi.get(self, "file_patterns")

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        The data format of the log files. possible value is `text`.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value should be custom stream names.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.DataCollectionRuleDataSourcesLogFileSettings']:
        """
        A `settings` block as defined below.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class DataCollectionRuleDataSourcesLogFileSettings(dict):
    def __init__(__self__, *,
                 text: 'outputs.DataCollectionRuleDataSourcesLogFileSettingsText'):
        """
        :param 'DataCollectionRuleDataSourcesLogFileSettingsTextArgs' text: A `text` block as defined below.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> 'outputs.DataCollectionRuleDataSourcesLogFileSettingsText':
        """
        A `text` block as defined below.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class DataCollectionRuleDataSourcesLogFileSettingsText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordStartTimestampFormat":
            suggest = "record_start_timestamp_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesLogFileSettingsText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesLogFileSettingsText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesLogFileSettingsText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_start_timestamp_format: str):
        """
        :param str record_start_timestamp_format: The timestamp format of the text log files. Possible values are `ISO 8601`, `YYYY-MM-DD HH:MM:SS`, `M/D/YYYY HH:MM:SS AM/PM`, `Mon DD, YYYY HH:MM:SS`, `yyMMdd HH:mm:ss`, `ddMMyy HH:mm:ss`, `MMM d hh:mm:ss`, `dd/MMM/yyyy:HH:mm:ss zzz`,and `yyyy-MM-ddTHH:mm:ssK`.
        """
        pulumi.set(__self__, "record_start_timestamp_format", record_start_timestamp_format)

    @property
    @pulumi.getter(name="recordStartTimestampFormat")
    def record_start_timestamp_format(self) -> str:
        """
        The timestamp format of the text log files. Possible values are `ISO 8601`, `YYYY-MM-DD HH:MM:SS`, `M/D/YYYY HH:MM:SS AM/PM`, `Mon DD, YYYY HH:MM:SS`, `yyMMdd HH:mm:ss`, `ddMMyy HH:mm:ss`, `MMM d hh:mm:ss`, `dd/MMM/yyyy:HH:mm:ss zzz`,and `yyyy-MM-ddTHH:mm:ssK`.
        """
        return pulumi.get(self, "record_start_timestamp_format")


@pulumi.output_type
class DataCollectionRuleDataSourcesPerformanceCounter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "counterSpecifiers":
            suggest = "counter_specifiers"
        elif key == "samplingFrequencyInSeconds":
            suggest = "sampling_frequency_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesPerformanceCounter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesPerformanceCounter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesPerformanceCounter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 counter_specifiers: Sequence[str],
                 name: str,
                 sampling_frequency_in_seconds: int,
                 streams: Sequence[str]):
        """
        :param Sequence[str] counter_specifiers: Specifies a list of specifier names of the performance counters you want to collect. To get a list of performance counters on Windows, run the command `typeperf`. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-sources-performance-counters#configure-performance-counters) for more information.
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param int sampling_frequency_in_seconds: The number of seconds between consecutive counter measurements (samples). The value should be integer between `1` and `1800` inclusive. `sampling_frequency_in_seconds` must be equal to `60` seconds for counters collected with `Microsoft-InsightsMetrics` stream.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-InsightsMetrics`,and `Microsoft-Perf`.
        """
        pulumi.set(__self__, "counter_specifiers", counter_specifiers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sampling_frequency_in_seconds", sampling_frequency_in_seconds)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="counterSpecifiers")
    def counter_specifiers(self) -> Sequence[str]:
        """
        Specifies a list of specifier names of the performance counters you want to collect. To get a list of performance counters on Windows, run the command `typeperf`. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-sources-performance-counters#configure-performance-counters) for more information.
        """
        return pulumi.get(self, "counter_specifiers")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="samplingFrequencyInSeconds")
    def sampling_frequency_in_seconds(self) -> int:
        """
        The number of seconds between consecutive counter measurements (samples). The value should be integer between `1` and `1800` inclusive. `sampling_frequency_in_seconds` must be equal to `60` seconds for counters collected with `Microsoft-InsightsMetrics` stream.
        """
        return pulumi.get(self, "sampling_frequency_in_seconds")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-InsightsMetrics`,and `Microsoft-Perf`.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class DataCollectionRuleDataSourcesPlatformTelemetry(dict):
    def __init__(__self__, *,
                 name: str,
                 streams: Sequence[str]):
        """
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft.Cache/redis:Metrics-Group-All`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft.Cache/redis:Metrics-Group-All`.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class DataCollectionRuleDataSourcesPrometheusForwarder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelIncludeFilters":
            suggest = "label_include_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesPrometheusForwarder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesPrometheusForwarder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesPrometheusForwarder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 streams: Sequence[str],
                 label_include_filters: Optional[Sequence['outputs.DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilter']] = None):
        """
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-PrometheusMetrics`.
        :param Sequence['DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgs'] label_include_filters: One or more `label_include_filter` blocks as defined above.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        if label_include_filters is not None:
            pulumi.set(__self__, "label_include_filters", label_include_filters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-PrometheusMetrics`.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="labelIncludeFilters")
    def label_include_filters(self) -> Optional[Sequence['outputs.DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilter']]:
        """
        One or more `label_include_filter` blocks as defined above.
        """
        return pulumi.get(self, "label_include_filters")


@pulumi.output_type
class DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilter(dict):
    def __init__(__self__, *,
                 label: str,
                 value: str):
        """
        :param str label: The label of the filter. This label should be unique across all `label_include_fileter` block. Possible value is `microsoft_metrics_include_label`.
        :param str value: The value of the filter.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The label of the filter. This label should be unique across all `label_include_fileter` block. Possible value is `microsoft_metrics_include_label`.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the filter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataCollectionRuleDataSourcesSyslog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "facilityNames":
            suggest = "facility_names"
        elif key == "logLevels":
            suggest = "log_levels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesSyslog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesSyslog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesSyslog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facility_names: Sequence[str],
                 log_levels: Sequence[str],
                 name: str,
                 streams: Sequence[str]):
        """
        :param Sequence[str] facility_names: Specifies a list of facility names. Use a wildcard `*` to collect logs for all facility names. Possible values are `alert`, `*`, `audit`, `auth`, `authpriv`, `clock`, `cron`, `daemon`, `ftp`, `kern`, `local5`, `local4`, `local1`, `local7`, `local6`, `local3`, `local2`, `local0`, `lpr`, `mail`, `mark`, `news`, `nopri`, `ntp`, `syslog`, `user` and `uucp`.
        :param Sequence[str] log_levels: Specifies a list of log levels. Use a wildcard `*` to collect logs for all log levels. Possible values are `Debug`, `Info`, `Notice`, `Warning`, `Error`, `Critical`, `Alert`, `Emergency`,and `*`.
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Syslog`,and `Microsoft-CiscoAsa`, and `Microsoft-CommonSecurityLog`.
        """
        pulumi.set(__self__, "facility_names", facility_names)
        pulumi.set(__self__, "log_levels", log_levels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="facilityNames")
    def facility_names(self) -> Sequence[str]:
        """
        Specifies a list of facility names. Use a wildcard `*` to collect logs for all facility names. Possible values are `alert`, `*`, `audit`, `auth`, `authpriv`, `clock`, `cron`, `daemon`, `ftp`, `kern`, `local5`, `local4`, `local1`, `local7`, `local6`, `local3`, `local2`, `local0`, `lpr`, `mail`, `mark`, `news`, `nopri`, `ntp`, `syslog`, `user` and `uucp`.
        """
        return pulumi.get(self, "facility_names")

    @property
    @pulumi.getter(name="logLevels")
    def log_levels(self) -> Sequence[str]:
        """
        Specifies a list of log levels. Use a wildcard `*` to collect logs for all log levels. Possible values are `Debug`, `Info`, `Notice`, `Warning`, `Error`, `Critical`, `Alert`, `Emergency`,and `*`.
        """
        return pulumi.get(self, "log_levels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Syslog`,and `Microsoft-CiscoAsa`, and `Microsoft-CommonSecurityLog`.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class DataCollectionRuleDataSourcesWindowsEventLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xPathQueries":
            suggest = "x_path_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDataSourcesWindowsEventLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDataSourcesWindowsEventLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDataSourcesWindowsEventLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 streams: Sequence[str],
                 x_path_queries: Sequence[str]):
        """
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`,and `Microsoft-WindowsEvent` and `Microsoft-SecurityEvent`.
        :param Sequence[str] x_path_queries: Specifies a list of Windows Event Log queries in XPath expression. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-collection-rule-azure-monitor-agent?tabs=cli#filter-events-using-xpath-queries) for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        pulumi.set(__self__, "x_path_queries", x_path_queries)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`,and `Microsoft-WindowsEvent` and `Microsoft-SecurityEvent`.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="xPathQueries")
    def x_path_queries(self) -> Sequence[str]:
        """
        Specifies a list of Windows Event Log queries in XPath expression. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-collection-rule-azure-monitor-agent?tabs=cli#filter-events-using-xpath-queries) for more information.
        """
        return pulumi.get(self, "x_path_queries")


@pulumi.output_type
class DataCollectionRuleDataSourcesWindowsFirewallLog(dict):
    def __init__(__self__, *,
                 name: str,
                 streams: Sequence[str]):
        """
        :param str name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class DataCollectionRuleDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureMonitorMetrics":
            suggest = "azure_monitor_metrics"
        elif key == "eventHub":
            suggest = "event_hub"
        elif key == "eventHubDirect":
            suggest = "event_hub_direct"
        elif key == "logAnalytics":
            suggest = "log_analytics"
        elif key == "monitorAccounts":
            suggest = "monitor_accounts"
        elif key == "storageBlobDirects":
            suggest = "storage_blob_directs"
        elif key == "storageBlobs":
            suggest = "storage_blobs"
        elif key == "storageTableDirects":
            suggest = "storage_table_directs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_monitor_metrics: Optional['outputs.DataCollectionRuleDestinationsAzureMonitorMetrics'] = None,
                 event_hub: Optional['outputs.DataCollectionRuleDestinationsEventHub'] = None,
                 event_hub_direct: Optional['outputs.DataCollectionRuleDestinationsEventHubDirect'] = None,
                 log_analytics: Optional[Sequence['outputs.DataCollectionRuleDestinationsLogAnalytic']] = None,
                 monitor_accounts: Optional[Sequence['outputs.DataCollectionRuleDestinationsMonitorAccount']] = None,
                 storage_blob_directs: Optional[Sequence['outputs.DataCollectionRuleDestinationsStorageBlobDirect']] = None,
                 storage_blobs: Optional[Sequence['outputs.DataCollectionRuleDestinationsStorageBlob']] = None,
                 storage_table_directs: Optional[Sequence['outputs.DataCollectionRuleDestinationsStorageTableDirect']] = None):
        """
        :param 'DataCollectionRuleDestinationsAzureMonitorMetricsArgs' azure_monitor_metrics: A `azure_monitor_metrics` block as defined above.
        :param 'DataCollectionRuleDestinationsEventHubArgs' event_hub: One or more `event_hub` blocks as defined below.
        :param 'DataCollectionRuleDestinationsEventHubDirectArgs' event_hub_direct: One or more `event_hub` blocks as defined below.
        :param Sequence['DataCollectionRuleDestinationsLogAnalyticArgs'] log_analytics: One or more `log_analytics` blocks as defined below.
        :param Sequence['DataCollectionRuleDestinationsMonitorAccountArgs'] monitor_accounts: One or more `monitor_account` blocks as defined below.
        :param Sequence['DataCollectionRuleDestinationsStorageBlobDirectArgs'] storage_blob_directs: One or more `storage_blob_direct` blocks as defined below.
        :param Sequence['DataCollectionRuleDestinationsStorageBlobArgs'] storage_blobs: One or more `storage_blob` blocks as defined below.
        :param Sequence['DataCollectionRuleDestinationsStorageTableDirectArgs'] storage_table_directs: One or more `storage_table_direct` blocks as defined below.
               
               > **NOTE** `event_hub_direct`, `storage_blob_direct`, and `storage_table_direct` are only available for rules of kind `AgentDirectToStore`.
               
               > **NOTE** At least one of `azure_monitor_metrics`, `event_hub`, `event_hub_direct`, `log_analytics`, `monitor_account`, `storage_blob`, `storage_blob_direct`,and `storage_table_direct` blocks must be specified.
        """
        if azure_monitor_metrics is not None:
            pulumi.set(__self__, "azure_monitor_metrics", azure_monitor_metrics)
        if event_hub is not None:
            pulumi.set(__self__, "event_hub", event_hub)
        if event_hub_direct is not None:
            pulumi.set(__self__, "event_hub_direct", event_hub_direct)
        if log_analytics is not None:
            pulumi.set(__self__, "log_analytics", log_analytics)
        if monitor_accounts is not None:
            pulumi.set(__self__, "monitor_accounts", monitor_accounts)
        if storage_blob_directs is not None:
            pulumi.set(__self__, "storage_blob_directs", storage_blob_directs)
        if storage_blobs is not None:
            pulumi.set(__self__, "storage_blobs", storage_blobs)
        if storage_table_directs is not None:
            pulumi.set(__self__, "storage_table_directs", storage_table_directs)

    @property
    @pulumi.getter(name="azureMonitorMetrics")
    def azure_monitor_metrics(self) -> Optional['outputs.DataCollectionRuleDestinationsAzureMonitorMetrics']:
        """
        A `azure_monitor_metrics` block as defined above.
        """
        return pulumi.get(self, "azure_monitor_metrics")

    @property
    @pulumi.getter(name="eventHub")
    def event_hub(self) -> Optional['outputs.DataCollectionRuleDestinationsEventHub']:
        """
        One or more `event_hub` blocks as defined below.
        """
        return pulumi.get(self, "event_hub")

    @property
    @pulumi.getter(name="eventHubDirect")
    def event_hub_direct(self) -> Optional['outputs.DataCollectionRuleDestinationsEventHubDirect']:
        """
        One or more `event_hub` blocks as defined below.
        """
        return pulumi.get(self, "event_hub_direct")

    @property
    @pulumi.getter(name="logAnalytics")
    def log_analytics(self) -> Optional[Sequence['outputs.DataCollectionRuleDestinationsLogAnalytic']]:
        """
        One or more `log_analytics` blocks as defined below.
        """
        return pulumi.get(self, "log_analytics")

    @property
    @pulumi.getter(name="monitorAccounts")
    def monitor_accounts(self) -> Optional[Sequence['outputs.DataCollectionRuleDestinationsMonitorAccount']]:
        """
        One or more `monitor_account` blocks as defined below.
        """
        return pulumi.get(self, "monitor_accounts")

    @property
    @pulumi.getter(name="storageBlobDirects")
    def storage_blob_directs(self) -> Optional[Sequence['outputs.DataCollectionRuleDestinationsStorageBlobDirect']]:
        """
        One or more `storage_blob_direct` blocks as defined below.
        """
        return pulumi.get(self, "storage_blob_directs")

    @property
    @pulumi.getter(name="storageBlobs")
    def storage_blobs(self) -> Optional[Sequence['outputs.DataCollectionRuleDestinationsStorageBlob']]:
        """
        One or more `storage_blob` blocks as defined below.
        """
        return pulumi.get(self, "storage_blobs")

    @property
    @pulumi.getter(name="storageTableDirects")
    def storage_table_directs(self) -> Optional[Sequence['outputs.DataCollectionRuleDestinationsStorageTableDirect']]:
        """
        One or more `storage_table_direct` blocks as defined below.

        > **NOTE** `event_hub_direct`, `storage_blob_direct`, and `storage_table_direct` are only available for rules of kind `AgentDirectToStore`.

        > **NOTE** At least one of `azure_monitor_metrics`, `event_hub`, `event_hub_direct`, `log_analytics`, `monitor_account`, `storage_blob`, `storage_blob_direct`,and `storage_table_direct` blocks must be specified.
        """
        return pulumi.get(self, "storage_table_directs")


@pulumi.output_type
class DataCollectionRuleDestinationsAzureMonitorMetrics(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DataCollectionRuleDestinationsEventHub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventHubId":
            suggest = "event_hub_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDestinationsEventHub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDestinationsEventHub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDestinationsEventHub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_hub_id: str,
                 name: str):
        """
        :param str event_hub_id: The resource ID of the Event Hub.
        :param str name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        pulumi.set(__self__, "event_hub_id", event_hub_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubId")
    def event_hub_id(self) -> str:
        """
        The resource ID of the Event Hub.
        """
        return pulumi.get(self, "event_hub_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DataCollectionRuleDestinationsEventHubDirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventHubId":
            suggest = "event_hub_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDestinationsEventHubDirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDestinationsEventHubDirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDestinationsEventHubDirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_hub_id: str,
                 name: str):
        """
        :param str event_hub_id: The resource ID of the Event Hub.
        :param str name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        pulumi.set(__self__, "event_hub_id", event_hub_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubId")
    def event_hub_id(self) -> str:
        """
        The resource ID of the Event Hub.
        """
        return pulumi.get(self, "event_hub_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DataCollectionRuleDestinationsLogAnalytic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceResourceId":
            suggest = "workspace_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDestinationsLogAnalytic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDestinationsLogAnalytic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDestinationsLogAnalytic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 workspace_resource_id: str):
        """
        :param str name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        :param str workspace_resource_id: The ID of a Log Analytic Workspace resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> str:
        """
        The ID of a Log Analytic Workspace resource.
        """
        return pulumi.get(self, "workspace_resource_id")


@pulumi.output_type
class DataCollectionRuleDestinationsMonitorAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorAccountId":
            suggest = "monitor_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDestinationsMonitorAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDestinationsMonitorAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDestinationsMonitorAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitor_account_id: str,
                 name: str):
        """
        :param str monitor_account_id: The resource ID of the Monitor Account.
        :param str name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        pulumi.set(__self__, "monitor_account_id", monitor_account_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="monitorAccountId")
    def monitor_account_id(self) -> str:
        """
        The resource ID of the Monitor Account.
        """
        return pulumi.get(self, "monitor_account_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DataCollectionRuleDestinationsStorageBlob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"
        elif key == "storageAccountId":
            suggest = "storage_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDestinationsStorageBlob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDestinationsStorageBlob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDestinationsStorageBlob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: str,
                 name: str,
                 storage_account_id: str):
        """
        :param str container_name: The Storage Container name.
        :param str name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        :param str storage_account_id: The resource ID of the Storage Account.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        The Storage Container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> str:
        """
        The resource ID of the Storage Account.
        """
        return pulumi.get(self, "storage_account_id")


@pulumi.output_type
class DataCollectionRuleDestinationsStorageBlobDirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"
        elif key == "storageAccountId":
            suggest = "storage_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDestinationsStorageBlobDirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDestinationsStorageBlobDirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDestinationsStorageBlobDirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: str,
                 name: str,
                 storage_account_id: str):
        """
        :param str container_name: The Storage Container name.
        :param str name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        :param str storage_account_id: The resource ID of the Storage Account.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        The Storage Container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> str:
        """
        The resource ID of the Storage Account.
        """
        return pulumi.get(self, "storage_account_id")


@pulumi.output_type
class DataCollectionRuleDestinationsStorageTableDirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountId":
            suggest = "storage_account_id"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleDestinationsStorageTableDirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleDestinationsStorageTableDirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleDestinationsStorageTableDirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 storage_account_id: str,
                 table_name: str):
        """
        :param str name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        :param str storage_account_id: The resource ID of the Storage Account.
        :param str table_name: The Storage Table name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> str:
        """
        The resource ID of the Storage Account.
        """
        return pulumi.get(self, "storage_account_id")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The Storage Table name.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class DataCollectionRuleIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Data Collection Rule. Currently, up to 1 identity is supported.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Data Collection Rule. Currently, up to 1 identity is supported.

        > **NOTE:** This is required when `type` is set to `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class DataCollectionRuleStreamDeclaration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectionRuleStreamDeclaration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectionRuleStreamDeclaration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectionRuleStreamDeclaration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.DataCollectionRuleStreamDeclarationColumn'],
                 stream_name: str):
        """
        :param Sequence['DataCollectionRuleStreamDeclarationColumnArgs'] columns: One or more `column` blocks as defined above.
        :param str stream_name: The name of the custom stream. This name should be unique across all `stream_declaration` blocks and must begin with a prefix of `Custom-`.
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.DataCollectionRuleStreamDeclarationColumn']:
        """
        One or more `column` blocks as defined above.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        The name of the custom stream. This name should be unique across all `stream_declaration` blocks and must begin with a prefix of `Custom-`.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class DataCollectionRuleStreamDeclarationColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: The name of the column.
        :param str type: The type of the column data. Possible values are `string`, `int`, `long`, `real`, `boolean`, `datetime`,and `dynamic`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the column data. Possible values are `string`, `int`, `long`, `real`, `boolean`, `datetime`,and `dynamic`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DiagnosticSettingEnabledLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryGroup":
            suggest = "category_group"
        elif key == "retentionPolicy":
            suggest = "retention_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiagnosticSettingEnabledLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiagnosticSettingEnabledLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiagnosticSettingEnabledLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[str] = None,
                 category_group: Optional[str] = None,
                 retention_policy: Optional['outputs.DiagnosticSettingEnabledLogRetentionPolicy'] = None):
        """
        :param str category: The name of a Diagnostic Log Category for this Resource.
               
               > **NOTE:** The Log Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source or [list of service specific schemas](https://docs.microsoft.com/azure/azure-monitor/platform/resource-logs-schema#service-specific-schemas) to identify which categories are available for a given Resource.
        :param str category_group: The name of a Diagnostic Log Category Group for this Resource.
               
               > **NOTE:** Not all resources have category groups available.
               
               > **NOTE:** Exactly one of `category` or `category_group` must be specified.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if category_group is not None:
            pulumi.set(__self__, "category_group", category_group)
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The name of a Diagnostic Log Category for this Resource.

        > **NOTE:** The Log Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source or [list of service specific schemas](https://docs.microsoft.com/azure/azure-monitor/platform/resource-logs-schema#service-specific-schemas) to identify which categories are available for a given Resource.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="categoryGroup")
    def category_group(self) -> Optional[str]:
        """
        The name of a Diagnostic Log Category Group for this Resource.

        > **NOTE:** Not all resources have category groups available.

        > **NOTE:** Exactly one of `category` or `category_group` must be specified.
        """
        return pulumi.get(self, "category_group")

    @property
    @pulumi.getter(name="retentionPolicy")
    @_utilities.deprecated("""`retention_policy` has been deprecated in favor of `storage.ManagementPolicy` resource - to learn more https://aka.ms/diagnostic_settings_log_retention""")
    def retention_policy(self) -> Optional['outputs.DiagnosticSettingEnabledLogRetentionPolicy']:
        return pulumi.get(self, "retention_policy")


@pulumi.output_type
class DiagnosticSettingEnabledLogRetentionPolicy(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 days: Optional[int] = None):
        """
        :param bool enabled: Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        return pulumi.get(self, "days")


@pulumi.output_type
class DiagnosticSettingMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionPolicy":
            suggest = "retention_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiagnosticSettingMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiagnosticSettingMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiagnosticSettingMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: str,
                 enabled: Optional[bool] = None,
                 retention_policy: Optional['outputs.DiagnosticSettingMetricRetentionPolicy'] = None):
        """
        :param str category: The name of a Diagnostic Metric Category for this Resource.
               
               > **NOTE:** The Metric Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source to identify which categories are available for a given Resource.
        :param bool enabled: Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "category", category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The name of a Diagnostic Metric Category for this Resource.

        > **NOTE:** The Metric Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source to identify which categories are available for a given Resource.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="retentionPolicy")
    @_utilities.deprecated("""`retention_policy` has been deprecated in favor of `storage.ManagementPolicy` resource - to learn more https://aka.ms/diagnostic_settings_log_retention""")
    def retention_policy(self) -> Optional['outputs.DiagnosticSettingMetricRetentionPolicy']:
        return pulumi.get(self, "retention_policy")


@pulumi.output_type
class DiagnosticSettingMetricRetentionPolicy(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 days: Optional[int] = None):
        """
        :param bool enabled: Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        return pulumi.get(self, "days")


@pulumi.output_type
class MetricAlertAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroupId":
            suggest = "action_group_id"
        elif key == "webhookProperties":
            suggest = "webhook_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricAlertAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricAlertAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricAlertAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_group_id: str,
                 webhook_properties: Optional[Mapping[str, str]] = None):
        """
        :param str action_group_id: The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource
        :param Mapping[str, str] webhook_properties: The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
        pulumi.set(__self__, "action_group_id", action_group_id)
        if webhook_properties is not None:
            pulumi.set(__self__, "webhook_properties", webhook_properties)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> str:
        """
        The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource
        """
        return pulumi.get(self, "action_group_id")

    @property
    @pulumi.getter(name="webhookProperties")
    def webhook_properties(self) -> Optional[Mapping[str, str]]:
        """
        The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
        return pulumi.get(self, "webhook_properties")


@pulumi.output_type
class MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentId":
            suggest = "component_id"
        elif key == "failedLocationCount":
            suggest = "failed_location_count"
        elif key == "webTestId":
            suggest = "web_test_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_id: str,
                 failed_location_count: int,
                 web_test_id: str):
        """
        :param str component_id: The ID of the Application Insights Resource.
        :param int failed_location_count: The number of failed locations.
        :param str web_test_id: The ID of the Application Insights Web Test.
        """
        pulumi.set(__self__, "component_id", component_id)
        pulumi.set(__self__, "failed_location_count", failed_location_count)
        pulumi.set(__self__, "web_test_id", web_test_id)

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> str:
        """
        The ID of the Application Insights Resource.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter(name="failedLocationCount")
    def failed_location_count(self) -> int:
        """
        The number of failed locations.
        """
        return pulumi.get(self, "failed_location_count")

    @property
    @pulumi.getter(name="webTestId")
    def web_test_id(self) -> str:
        """
        The ID of the Application Insights Web Test.
        """
        return pulumi.get(self, "web_test_id")


@pulumi.output_type
class MetricAlertCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "skipMetricValidation":
            suggest = "skip_metric_validation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricAlertCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricAlertCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricAlertCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 metric_name: str,
                 metric_namespace: str,
                 operator: str,
                 threshold: float,
                 dimensions: Optional[Sequence['outputs.MetricAlertCriteriaDimension']] = None,
                 skip_metric_validation: Optional[bool] = None):
        """
        :param str aggregation: The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        :param str metric_name: One of the metric names to be monitored.
        :param str metric_namespace: One of the metric namespaces to be monitored.
        :param str operator: The criteria operator. Possible values are `Equals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param float threshold: The criteria threshold value that activates the alert.
        :param Sequence['MetricAlertCriteriaDimensionArgs'] dimensions: One or more `dimension` blocks as defined below.
        :param bool skip_metric_validation: Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted? Defaults to `false`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if skip_metric_validation is not None:
            pulumi.set(__self__, "skip_metric_validation", skip_metric_validation)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        One of the metric names to be monitored.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> str:
        """
        One of the metric namespaces to be monitored.
        """
        return pulumi.get(self, "metric_namespace")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The criteria operator. Possible values are `Equals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The criteria threshold value that activates the alert.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.MetricAlertCriteriaDimension']]:
        """
        One or more `dimension` blocks as defined below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="skipMetricValidation")
    def skip_metric_validation(self) -> Optional[bool]:
        """
        Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted? Defaults to `false`.
        """
        return pulumi.get(self, "skip_metric_validation")


@pulumi.output_type
class MetricAlertCriteriaDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str name: One of the dimension names.
        :param str operator: The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        :param Sequence[str] values: The list of dimension values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        One of the dimension names.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The list of dimension values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MetricAlertDynamicCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertSensitivity":
            suggest = "alert_sensitivity"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "evaluationFailureCount":
            suggest = "evaluation_failure_count"
        elif key == "evaluationTotalCount":
            suggest = "evaluation_total_count"
        elif key == "ignoreDataBefore":
            suggest = "ignore_data_before"
        elif key == "skipMetricValidation":
            suggest = "skip_metric_validation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricAlertDynamicCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricAlertDynamicCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricAlertDynamicCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 alert_sensitivity: str,
                 metric_name: str,
                 metric_namespace: str,
                 operator: str,
                 dimensions: Optional[Sequence['outputs.MetricAlertDynamicCriteriaDimension']] = None,
                 evaluation_failure_count: Optional[int] = None,
                 evaluation_total_count: Optional[int] = None,
                 ignore_data_before: Optional[str] = None,
                 skip_metric_validation: Optional[bool] = None):
        """
        :param str aggregation: The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        :param str alert_sensitivity: The extent of deviation required to trigger an alert. Possible values are `Low`, `Medium` and `High`.
        :param str metric_name: One of the metric names to be monitored.
        :param str metric_namespace: One of the metric namespaces to be monitored.
        :param str operator: The criteria operator. Possible values are `LessThan`, `GreaterThan` and `GreaterOrLessThan`.
        :param Sequence['MetricAlertDynamicCriteriaDimensionArgs'] dimensions: One or more `dimension` blocks as defined below.
        :param int evaluation_failure_count: The number of violations to trigger an alert. Should be smaller or equal to `evaluation_total_count`. Defaults to `4`.
        :param int evaluation_total_count: The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (`window_size`) and the selected number of aggregated points. Defaults to `4`.
        :param str ignore_data_before: The [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date from which to start learning the metric historical data and calculate the dynamic thresholds.
        :param bool skip_metric_validation: Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted?
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "alert_sensitivity", alert_sensitivity)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "operator", operator)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_failure_count is not None:
            pulumi.set(__self__, "evaluation_failure_count", evaluation_failure_count)
        if evaluation_total_count is not None:
            pulumi.set(__self__, "evaluation_total_count", evaluation_total_count)
        if ignore_data_before is not None:
            pulumi.set(__self__, "ignore_data_before", ignore_data_before)
        if skip_metric_validation is not None:
            pulumi.set(__self__, "skip_metric_validation", skip_metric_validation)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="alertSensitivity")
    def alert_sensitivity(self) -> str:
        """
        The extent of deviation required to trigger an alert. Possible values are `Low`, `Medium` and `High`.
        """
        return pulumi.get(self, "alert_sensitivity")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        One of the metric names to be monitored.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> str:
        """
        One of the metric namespaces to be monitored.
        """
        return pulumi.get(self, "metric_namespace")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The criteria operator. Possible values are `LessThan`, `GreaterThan` and `GreaterOrLessThan`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.MetricAlertDynamicCriteriaDimension']]:
        """
        One or more `dimension` blocks as defined below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationFailureCount")
    def evaluation_failure_count(self) -> Optional[int]:
        """
        The number of violations to trigger an alert. Should be smaller or equal to `evaluation_total_count`. Defaults to `4`.
        """
        return pulumi.get(self, "evaluation_failure_count")

    @property
    @pulumi.getter(name="evaluationTotalCount")
    def evaluation_total_count(self) -> Optional[int]:
        """
        The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (`window_size`) and the selected number of aggregated points. Defaults to `4`.
        """
        return pulumi.get(self, "evaluation_total_count")

    @property
    @pulumi.getter(name="ignoreDataBefore")
    def ignore_data_before(self) -> Optional[str]:
        """
        The [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date from which to start learning the metric historical data and calculate the dynamic thresholds.
        """
        return pulumi.get(self, "ignore_data_before")

    @property
    @pulumi.getter(name="skipMetricValidation")
    def skip_metric_validation(self) -> Optional[bool]:
        """
        Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted?
        """
        return pulumi.get(self, "skip_metric_validation")


@pulumi.output_type
class MetricAlertDynamicCriteriaDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str name: One of the dimension names.
        :param str operator: The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        :param Sequence[str] values: The list of dimension values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        One of the dimension names.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The list of dimension values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ScheduledQueryRulesAlertAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroups":
            suggest = "action_groups"
        elif key == "customWebhookPayload":
            suggest = "custom_webhook_payload"
        elif key == "emailSubject":
            suggest = "email_subject"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRulesAlertAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRulesAlertAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRulesAlertAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_groups: Sequence[str],
                 custom_webhook_payload: Optional[str] = None,
                 email_subject: Optional[str] = None):
        """
        :param Sequence[str] action_groups: List of action group reference resource IDs.
        :param str custom_webhook_payload: Custom payload to be sent for all webhook payloads in alerting action.
        :param str email_subject: Custom subject override for all email ids in Azure action group.
        """
        pulumi.set(__self__, "action_groups", action_groups)
        if custom_webhook_payload is not None:
            pulumi.set(__self__, "custom_webhook_payload", custom_webhook_payload)
        if email_subject is not None:
            pulumi.set(__self__, "email_subject", email_subject)

    @property
    @pulumi.getter(name="actionGroups")
    def action_groups(self) -> Sequence[str]:
        """
        List of action group reference resource IDs.
        """
        return pulumi.get(self, "action_groups")

    @property
    @pulumi.getter(name="customWebhookPayload")
    def custom_webhook_payload(self) -> Optional[str]:
        """
        Custom payload to be sent for all webhook payloads in alerting action.
        """
        return pulumi.get(self, "custom_webhook_payload")

    @property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> Optional[str]:
        """
        Custom subject override for all email ids in Azure action group.
        """
        return pulumi.get(self, "email_subject")


@pulumi.output_type
class ScheduledQueryRulesAlertTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricTrigger":
            suggest = "metric_trigger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRulesAlertTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRulesAlertTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRulesAlertTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 threshold: float,
                 metric_trigger: Optional['outputs.ScheduledQueryRulesAlertTriggerMetricTrigger'] = None):
        """
        :param str operator: Evaluation operation for rule - 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        :param float threshold: Result or count threshold based on which rule should be triggered. Values must be between 0 and 10000 inclusive.
        :param 'ScheduledQueryRulesAlertTriggerMetricTriggerArgs' metric_trigger: A `metric_trigger` block as defined above. Trigger condition for metric query rule.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        if metric_trigger is not None:
            pulumi.set(__self__, "metric_trigger", metric_trigger)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Evaluation operation for rule - 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Result or count threshold based on which rule should be triggered. Values must be between 0 and 10000 inclusive.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="metricTrigger")
    def metric_trigger(self) -> Optional['outputs.ScheduledQueryRulesAlertTriggerMetricTrigger']:
        """
        A `metric_trigger` block as defined above. Trigger condition for metric query rule.
        """
        return pulumi.get(self, "metric_trigger")


@pulumi.output_type
class ScheduledQueryRulesAlertTriggerMetricTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricTriggerType":
            suggest = "metric_trigger_type"
        elif key == "metricColumn":
            suggest = "metric_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRulesAlertTriggerMetricTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRulesAlertTriggerMetricTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRulesAlertTriggerMetricTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_trigger_type: str,
                 operator: str,
                 threshold: float,
                 metric_column: Optional[str] = None):
        """
        :param str metric_trigger_type: Metric Trigger Type - 'Consecutive' or 'Total'.
        :param str operator: Evaluation operation for rule - 'Equal', 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        :param float threshold: The threshold of the metric trigger. Values must be between 0 and 10000 inclusive.
        :param str metric_column: Evaluation of metric on a particular column.
        """
        pulumi.set(__self__, "metric_trigger_type", metric_trigger_type)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        if metric_column is not None:
            pulumi.set(__self__, "metric_column", metric_column)

    @property
    @pulumi.getter(name="metricTriggerType")
    def metric_trigger_type(self) -> str:
        """
        Metric Trigger Type - 'Consecutive' or 'Total'.
        """
        return pulumi.get(self, "metric_trigger_type")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Evaluation operation for rule - 'Equal', 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The threshold of the metric trigger. Values must be between 0 and 10000 inclusive.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="metricColumn")
    def metric_column(self) -> Optional[str]:
        """
        Evaluation of metric on a particular column.
        """
        return pulumi.get(self, "metric_column")


@pulumi.output_type
class ScheduledQueryRulesAlertV2Action(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroups":
            suggest = "action_groups"
        elif key == "customProperties":
            suggest = "custom_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRulesAlertV2Action. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRulesAlertV2Action.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRulesAlertV2Action.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_groups: Optional[Sequence[str]] = None,
                 custom_properties: Optional[Mapping[str, str]] = None):
        """
        :param Sequence[str] action_groups: List of Action Group resource IDs to invoke when the alert fires.
        :param Mapping[str, str] custom_properties: Specifies the properties of an alert payload.
        """
        if action_groups is not None:
            pulumi.set(__self__, "action_groups", action_groups)
        if custom_properties is not None:
            pulumi.set(__self__, "custom_properties", custom_properties)

    @property
    @pulumi.getter(name="actionGroups")
    def action_groups(self) -> Optional[Sequence[str]]:
        """
        List of Action Group resource IDs to invoke when the alert fires.
        """
        return pulumi.get(self, "action_groups")

    @property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[Mapping[str, str]]:
        """
        Specifies the properties of an alert payload.
        """
        return pulumi.get(self, "custom_properties")


@pulumi.output_type
class ScheduledQueryRulesAlertV2Criteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeAggregationMethod":
            suggest = "time_aggregation_method"
        elif key == "failingPeriods":
            suggest = "failing_periods"
        elif key == "metricMeasureColumn":
            suggest = "metric_measure_column"
        elif key == "resourceIdColumn":
            suggest = "resource_id_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRulesAlertV2Criteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRulesAlertV2Criteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRulesAlertV2Criteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 query: str,
                 threshold: float,
                 time_aggregation_method: str,
                 dimensions: Optional[Sequence['outputs.ScheduledQueryRulesAlertV2CriteriaDimension']] = None,
                 failing_periods: Optional['outputs.ScheduledQueryRulesAlertV2CriteriaFailingPeriods'] = None,
                 metric_measure_column: Optional[str] = None,
                 resource_id_column: Optional[str] = None):
        """
        :param str operator: Specifies the criteria operator. Possible values are `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`,and `LessThanOrEqual`.
        :param str query: The query to run on logs. The results returned by this query are used to populate the alert.
        :param float threshold: Specifies the criteria threshold value that activates the alert.
        :param str time_aggregation_method: The type of aggregation to apply to the data points in aggregation granularity. Possible values are `Average`, `Count`, `Maximum`, `Minimum`,and `Total`.
        :param Sequence['ScheduledQueryRulesAlertV2CriteriaDimensionArgs'] dimensions: A `dimension` block as defined below.
        :param 'ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgs' failing_periods: A `failing_periods` block as defined below.
        :param str metric_measure_column: Specifies the column containing the metric measure number.
               
               > **Note** `metric_measure_column` is required if `time_aggregation_method` is `Average`, `Maximum`, `Minimum`, or `Total`. And `metric_measure_column` can not be specified if `time_aggregation_method` is `Count`.
        :param str resource_id_column: Specifies the column containing the resource ID. The content of the column must be an uri formatted as resource ID.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "time_aggregation_method", time_aggregation_method)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if failing_periods is not None:
            pulumi.set(__self__, "failing_periods", failing_periods)
        if metric_measure_column is not None:
            pulumi.set(__self__, "metric_measure_column", metric_measure_column)
        if resource_id_column is not None:
            pulumi.set(__self__, "resource_id_column", resource_id_column)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Specifies the criteria operator. Possible values are `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`,and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query to run on logs. The results returned by this query are used to populate the alert.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Specifies the criteria threshold value that activates the alert.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="timeAggregationMethod")
    def time_aggregation_method(self) -> str:
        """
        The type of aggregation to apply to the data points in aggregation granularity. Possible values are `Average`, `Count`, `Maximum`, `Minimum`,and `Total`.
        """
        return pulumi.get(self, "time_aggregation_method")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ScheduledQueryRulesAlertV2CriteriaDimension']]:
        """
        A `dimension` block as defined below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="failingPeriods")
    def failing_periods(self) -> Optional['outputs.ScheduledQueryRulesAlertV2CriteriaFailingPeriods']:
        """
        A `failing_periods` block as defined below.
        """
        return pulumi.get(self, "failing_periods")

    @property
    @pulumi.getter(name="metricMeasureColumn")
    def metric_measure_column(self) -> Optional[str]:
        """
        Specifies the column containing the metric measure number.

        > **Note** `metric_measure_column` is required if `time_aggregation_method` is `Average`, `Maximum`, `Minimum`, or `Total`. And `metric_measure_column` can not be specified if `time_aggregation_method` is `Count`.
        """
        return pulumi.get(self, "metric_measure_column")

    @property
    @pulumi.getter(name="resourceIdColumn")
    def resource_id_column(self) -> Optional[str]:
        """
        Specifies the column containing the resource ID. The content of the column must be an uri formatted as resource ID.
        """
        return pulumi.get(self, "resource_id_column")


@pulumi.output_type
class ScheduledQueryRulesAlertV2CriteriaDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the dimension.
        :param str operator: Operator for dimension values. Possible values are `Exclude`,and `Include`.
        :param Sequence[str] values: List of dimension values. Use a wildcard `*` to collect all.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator for dimension values. Possible values are `Exclude`,and `Include`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of dimension values. Use a wildcard `*` to collect all.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ScheduledQueryRulesAlertV2CriteriaFailingPeriods(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumFailingPeriodsToTriggerAlert":
            suggest = "minimum_failing_periods_to_trigger_alert"
        elif key == "numberOfEvaluationPeriods":
            suggest = "number_of_evaluation_periods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRulesAlertV2CriteriaFailingPeriods. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRulesAlertV2CriteriaFailingPeriods.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRulesAlertV2CriteriaFailingPeriods.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_failing_periods_to_trigger_alert: int,
                 number_of_evaluation_periods: int):
        """
        :param int minimum_failing_periods_to_trigger_alert: Specifies the number of violations to trigger an alert. Should be smaller or equal to `number_of_evaluation_periods`. Possible value is integer between 1 and 6.
        :param int number_of_evaluation_periods: Specifies the number of aggregated look-back points. The look-back time window is calculated based on the aggregation granularity `window_duration` and the selected number of aggregated points. Possible value is integer between 1 and 6.
               
               > **Note** The query look back which is `window_duration`*`number_of_evaluation_periods` cannot exceed 48 hours.
               
               > **Note** `number_of_evaluation_periods` must be `1` for queries that do not project timestamp column
        """
        pulumi.set(__self__, "minimum_failing_periods_to_trigger_alert", minimum_failing_periods_to_trigger_alert)
        pulumi.set(__self__, "number_of_evaluation_periods", number_of_evaluation_periods)

    @property
    @pulumi.getter(name="minimumFailingPeriodsToTriggerAlert")
    def minimum_failing_periods_to_trigger_alert(self) -> int:
        """
        Specifies the number of violations to trigger an alert. Should be smaller or equal to `number_of_evaluation_periods`. Possible value is integer between 1 and 6.
        """
        return pulumi.get(self, "minimum_failing_periods_to_trigger_alert")

    @property
    @pulumi.getter(name="numberOfEvaluationPeriods")
    def number_of_evaluation_periods(self) -> int:
        """
        Specifies the number of aggregated look-back points. The look-back time window is calculated based on the aggregation granularity `window_duration` and the selected number of aggregated points. Possible value is integer between 1 and 6.

        > **Note** The query look back which is `window_duration`*`number_of_evaluation_periods` cannot exceed 48 hours.

        > **Note** `number_of_evaluation_periods` must be `1` for queries that do not project timestamp column
        """
        return pulumi.get(self, "number_of_evaluation_periods")


@pulumi.output_type
class ScheduledQueryRulesAlertV2Identity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRulesAlertV2Identity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRulesAlertV2Identity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRulesAlertV2Identity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Scheduled Query Rule. Possible values are `SystemAssigned`, `UserAssigned`.
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Scheduled Query Rule.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`. The identity associated must have required roles, read the [Azure documentation](https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/alerts-create-log-alert-rule#configure-the-alert-rule-details) for more information.
        :param str principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        :param str tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Scheduled Query Rule. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Scheduled Query Rule.

        > **NOTE:** This is required when `type` is set to `UserAssigned`. The identity associated must have required roles, read the [Azure documentation](https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/alerts-create-log-alert-rule#configure-the-alert-rule-details) for more information.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ScheduledQueryRulesLogCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledQueryRulesLogCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledQueryRulesLogCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledQueryRulesLogCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Sequence['outputs.ScheduledQueryRulesLogCriteriaDimension'],
                 metric_name: str):
        """
        :param Sequence['ScheduledQueryRulesLogCriteriaDimensionArgs'] dimensions: A `dimension` block as defined below.
        :param str metric_name: Name of the metric. Supported metrics are listed in the Azure Monitor [Microsoft.OperationalInsights/workspaces](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported#microsoftoperationalinsightsworkspaces) metrics namespace.
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metric_name", metric_name)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.ScheduledQueryRulesLogCriteriaDimension']:
        """
        A `dimension` block as defined below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric. Supported metrics are listed in the Azure Monitor [Microsoft.OperationalInsights/workspaces](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported#microsoftoperationalinsightsworkspaces) metrics namespace.
        """
        return pulumi.get(self, "metric_name")


@pulumi.output_type
class ScheduledQueryRulesLogCriteriaDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 operator: Optional[str] = None):
        """
        :param str name: Name of the dimension.
        :param Sequence[str] values: List of dimension values.
        :param str operator: Operator for dimension values, - 'Include'. Defaults to `Include`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of dimension values.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator for dimension values, - 'Include'. Defaults to `Include`.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class SmartDetectorAlertRuleActionGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailSubject":
            suggest = "email_subject"
        elif key == "webhookPayload":
            suggest = "webhook_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartDetectorAlertRuleActionGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartDetectorAlertRuleActionGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartDetectorAlertRuleActionGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ids: Sequence[str],
                 email_subject: Optional[str] = None,
                 webhook_payload: Optional[str] = None):
        """
        :param Sequence[str] ids: Specifies the action group ids.
        :param str email_subject: Specifies a custom email subject if Email Receiver is specified in Monitor Action Group resource.
        :param str webhook_payload: A JSON String which Specifies the custom webhook payload if Webhook Receiver is specified in Monitor Action Group resource.
        """
        pulumi.set(__self__, "ids", ids)
        if email_subject is not None:
            pulumi.set(__self__, "email_subject", email_subject)
        if webhook_payload is not None:
            pulumi.set(__self__, "webhook_payload", webhook_payload)

    @property
    @pulumi.getter
    def ids(self) -> Sequence[str]:
        """
        Specifies the action group ids.
        """
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> Optional[str]:
        """
        Specifies a custom email subject if Email Receiver is specified in Monitor Action Group resource.
        """
        return pulumi.get(self, "email_subject")

    @property
    @pulumi.getter(name="webhookPayload")
    def webhook_payload(self) -> Optional[str]:
        """
        A JSON String which Specifies the custom webhook payload if Webhook Receiver is specified in Monitor Action Group resource.
        """
        return pulumi.get(self, "webhook_payload")


@pulumi.output_type
class GetActionGroupArmRoleReceiverResult(dict):
    def __init__(__self__, *,
                 name: str,
                 role_id: str,
                 use_common_alert_schema: bool):
        """
        :param str name: Specifies the name of the Action Group.
        :param str role_id: The arm role id.
        :param bool use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        The arm role id.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> bool:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class GetActionGroupAutomationRunbookReceiverResult(dict):
    def __init__(__self__, *,
                 automation_account_id: str,
                 is_global_runbook: bool,
                 name: str,
                 runbook_name: str,
                 service_uri: str,
                 use_common_alert_schema: bool,
                 webhook_resource_id: str):
        """
        :param str automation_account_id: The automation account ID which holds this runbook and authenticates to Azure resources.
        :param bool is_global_runbook: Indicates whether this instance is global runbook.
        :param str name: Specifies the name of the Action Group.
        :param str runbook_name: The name for this runbook.
        :param str service_uri: The URI where webhooks should be sent.
        :param bool use_common_alert_schema: Indicates whether to use common alert schema.
        :param str webhook_resource_id: The resource id for webhook linked to this runbook.
        """
        pulumi.set(__self__, "automation_account_id", automation_account_id)
        pulumi.set(__self__, "is_global_runbook", is_global_runbook)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "runbook_name", runbook_name)
        pulumi.set(__self__, "service_uri", service_uri)
        pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)
        pulumi.set(__self__, "webhook_resource_id", webhook_resource_id)

    @property
    @pulumi.getter(name="automationAccountId")
    def automation_account_id(self) -> str:
        """
        The automation account ID which holds this runbook and authenticates to Azure resources.
        """
        return pulumi.get(self, "automation_account_id")

    @property
    @pulumi.getter(name="isGlobalRunbook")
    def is_global_runbook(self) -> bool:
        """
        Indicates whether this instance is global runbook.
        """
        return pulumi.get(self, "is_global_runbook")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="runbookName")
    def runbook_name(self) -> str:
        """
        The name for this runbook.
        """
        return pulumi.get(self, "runbook_name")

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> str:
        """
        The URI where webhooks should be sent.
        """
        return pulumi.get(self, "service_uri")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> bool:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @property
    @pulumi.getter(name="webhookResourceId")
    def webhook_resource_id(self) -> str:
        """
        The resource id for webhook linked to this runbook.
        """
        return pulumi.get(self, "webhook_resource_id")


@pulumi.output_type
class GetActionGroupAzureAppPushReceiverResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 name: str):
        """
        :param str email_address: The email address of this receiver.
        :param str name: Specifies the name of the Action Group.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        The email address of this receiver.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetActionGroupAzureFunctionReceiverResult(dict):
    def __init__(__self__, *,
                 function_app_resource_id: str,
                 function_name: str,
                 http_trigger_url: str,
                 name: str,
                 use_common_alert_schema: bool):
        """
        :param str function_app_resource_id: The Azure resource ID of the function app.
        :param str function_name: The function name in the function app.
        :param str http_trigger_url: The HTTP trigger url where HTTP request sent to.
        :param str name: Specifies the name of the Action Group.
        :param bool use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "function_app_resource_id", function_app_resource_id)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "http_trigger_url", http_trigger_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="functionAppResourceId")
    def function_app_resource_id(self) -> str:
        """
        The Azure resource ID of the function app.
        """
        return pulumi.get(self, "function_app_resource_id")

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> str:
        """
        The function name in the function app.
        """
        return pulumi.get(self, "function_name")

    @property
    @pulumi.getter(name="httpTriggerUrl")
    def http_trigger_url(self) -> str:
        """
        The HTTP trigger url where HTTP request sent to.
        """
        return pulumi.get(self, "http_trigger_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> bool:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class GetActionGroupEmailReceiverResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 name: str,
                 use_common_alert_schema: bool):
        """
        :param str email_address: The email address of this receiver.
        :param str name: Specifies the name of the Action Group.
        :param bool use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        The email address of this receiver.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> bool:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class GetActionGroupEventHubReceiverResult(dict):
    def __init__(__self__, *,
                 event_hub_name: str,
                 event_hub_namespace: str,
                 name: str,
                 subscription_id: str,
                 tenant_id: str,
                 use_common_alert_schema: Optional[bool] = None):
        """
        :param str event_hub_name: The name of the specific Event Hub queue.
        :param str event_hub_namespace: The namespace name of the Event Hub.
        :param str name: Specifies the name of the Action Group.
        :param str subscription_id: The ID for the subscription containing this Event Hub. Default to the subscription ID of the Action Group.
        :param str tenant_id: The Tenant ID for the subscription containing this Event Hub.
        :param bool use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "event_hub_name", event_hub_name)
        pulumi.set(__self__, "event_hub_namespace", event_hub_namespace)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> str:
        """
        The name of the specific Event Hub queue.
        """
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="eventHubNamespace")
    def event_hub_namespace(self) -> str:
        """
        The namespace name of the Event Hub.
        """
        return pulumi.get(self, "event_hub_namespace")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        The ID for the subscription containing this Event Hub. Default to the subscription ID of the Action Group.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID for the subscription containing this Event Hub.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[bool]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class GetActionGroupItsmReceiverResult(dict):
    def __init__(__self__, *,
                 connection_id: str,
                 name: str,
                 region: str,
                 ticket_configuration: str,
                 workspace_id: str):
        """
        :param str connection_id: The unique connection identifier of the ITSM connection.
        :param str name: Specifies the name of the Action Group.
        :param str region: The region of the workspace.
        :param str ticket_configuration: A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        :param str workspace_id: The Azure Log Analytics workspace ID where this connection is defined.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "ticket_configuration", ticket_configuration)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> str:
        """
        The unique connection identifier of the ITSM connection.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The region of the workspace.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="ticketConfiguration")
    def ticket_configuration(self) -> str:
        """
        A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        """
        return pulumi.get(self, "ticket_configuration")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        The Azure Log Analytics workspace ID where this connection is defined.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetActionGroupLogicAppReceiverResult(dict):
    def __init__(__self__, *,
                 callback_url: str,
                 name: str,
                 resource_id: str,
                 use_common_alert_schema: bool):
        """
        :param str callback_url: The callback url where HTTP request sent to.
        :param str name: Specifies the name of the Action Group.
        :param str resource_id: The Azure resource ID of the logic app.
        :param bool use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "callback_url", callback_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="callbackUrl")
    def callback_url(self) -> str:
        """
        The callback url where HTTP request sent to.
        """
        return pulumi.get(self, "callback_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The Azure resource ID of the logic app.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> bool:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class GetActionGroupSmsReceiverResult(dict):
    def __init__(__self__, *,
                 country_code: str,
                 name: str,
                 phone_number: str):
        """
        :param str country_code: The country code of the voice receiver.
        :param str name: Specifies the name of the Action Group.
        :param str phone_number: The phone number of the voice receiver.
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code of the voice receiver.
        """
        return pulumi.get(self, "country_code")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        The phone number of the voice receiver.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class GetActionGroupVoiceReceiverResult(dict):
    def __init__(__self__, *,
                 country_code: str,
                 name: str,
                 phone_number: str):
        """
        :param str country_code: The country code of the voice receiver.
        :param str name: Specifies the name of the Action Group.
        :param str phone_number: The phone number of the voice receiver.
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        The country code of the voice receiver.
        """
        return pulumi.get(self, "country_code")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        The phone number of the voice receiver.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class GetActionGroupWebhookReceiverResult(dict):
    def __init__(__self__, *,
                 aad_auths: Sequence['outputs.GetActionGroupWebhookReceiverAadAuthResult'],
                 name: str,
                 service_uri: str,
                 use_common_alert_schema: bool):
        """
        :param str name: Specifies the name of the Action Group.
        :param str service_uri: The URI where webhooks should be sent.
        :param bool use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "aad_auths", aad_auths)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_uri", service_uri)
        pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="aadAuths")
    def aad_auths(self) -> Sequence['outputs.GetActionGroupWebhookReceiverAadAuthResult']:
        return pulumi.get(self, "aad_auths")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Action Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> str:
        """
        The URI where webhooks should be sent.
        """
        return pulumi.get(self, "service_uri")

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> bool:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")


@pulumi.output_type
class GetActionGroupWebhookReceiverAadAuthResult(dict):
    def __init__(__self__, *,
                 identifier_uri: str,
                 object_id: str,
                 tenant_id: str):
        """
        :param str tenant_id: The Tenant ID for the subscription containing this Event Hub.
        """
        pulumi.set(__self__, "identifier_uri", identifier_uri)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="identifierUri")
    def identifier_uri(self) -> str:
        return pulumi.get(self, "identifier_uri")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID for the subscription containing this Event Hub.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetDataCollectionRuleDataFlowResult(dict):
    def __init__(__self__, *,
                 built_in_transform: str,
                 destinations: Sequence[str],
                 output_stream: str,
                 streams: Sequence[str],
                 transform_kql: str):
        """
        :param str built_in_transform: The built-in transform to transform stream data.
        :param Sequence[str] destinations: Specifies a list of destination names. A `azure_monitor_metrics` data source only allows for stream of kind `Microsoft-InsightsMetrics`.
        :param str output_stream: The output stream of the transform. Only required if the data flow changes data to a different stream.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        :param str transform_kql: The KQL query to transform stream data.
        """
        pulumi.set(__self__, "built_in_transform", built_in_transform)
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "output_stream", output_stream)
        pulumi.set(__self__, "streams", streams)
        pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter(name="builtInTransform")
    def built_in_transform(self) -> str:
        """
        The built-in transform to transform stream data.
        """
        return pulumi.get(self, "built_in_transform")

    @property
    @pulumi.getter
    def destinations(self) -> Sequence[str]:
        """
        Specifies a list of destination names. A `azure_monitor_metrics` data source only allows for stream of kind `Microsoft-InsightsMetrics`.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="outputStream")
    def output_stream(self) -> str:
        """
        The output stream of the transform. Only required if the data flow changes data to a different stream.
        """
        return pulumi.get(self, "output_stream")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> str:
        """
        The KQL query to transform stream data.
        """
        return pulumi.get(self, "transform_kql")


@pulumi.output_type
class GetDataCollectionRuleDataSourceResult(dict):
    def __init__(__self__, *,
                 data_imports: Sequence['outputs.GetDataCollectionRuleDataSourceDataImportResult'],
                 extensions: Sequence['outputs.GetDataCollectionRuleDataSourceExtensionResult'],
                 iis_logs: Sequence['outputs.GetDataCollectionRuleDataSourceIisLogResult'],
                 performance_counters: Sequence['outputs.GetDataCollectionRuleDataSourcePerformanceCounterResult'],
                 prometheus_forwarders: Sequence['outputs.GetDataCollectionRuleDataSourcePrometheusForwarderResult'],
                 syslogs: Sequence['outputs.GetDataCollectionRuleDataSourceSyslogResult'],
                 windows_event_logs: Sequence['outputs.GetDataCollectionRuleDataSourceWindowsEventLogResult'],
                 windows_firewall_logs: Sequence['outputs.GetDataCollectionRuleDataSourceWindowsFirewallLogResult'],
                 log_files: Optional[Sequence['outputs.GetDataCollectionRuleDataSourceLogFileResult']] = None,
                 platform_telemetries: Optional[Sequence['outputs.GetDataCollectionRuleDataSourcePlatformTelemetryResult']] = None):
        """
        :param Sequence['GetDataCollectionRuleDataSourceDataImportArgs'] data_imports: A `data_import` block as defined above.
        :param Sequence['GetDataCollectionRuleDataSourceExtensionArgs'] extensions: One or more `extension` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDataSourceIisLogArgs'] iis_logs: One or more `iis_log` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDataSourcePerformanceCounterArgs'] performance_counters: One or more `performance_counter` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDataSourcePrometheusForwarderArgs'] prometheus_forwarders: One or more `prometheus_forwarder` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDataSourceSyslogArgs'] syslogs: One or more `syslog` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDataSourceWindowsEventLogArgs'] windows_event_logs: One or more `windows_event_log` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDataSourceWindowsFirewallLogArgs'] windows_firewall_logs: One or more `windows_firewall_log` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDataSourceLogFileArgs'] log_files: One or more `log_file` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDataSourcePlatformTelemetryArgs'] platform_telemetries: One or more `platform_telemetry` blocks as defined below.
        """
        pulumi.set(__self__, "data_imports", data_imports)
        pulumi.set(__self__, "extensions", extensions)
        pulumi.set(__self__, "iis_logs", iis_logs)
        pulumi.set(__self__, "performance_counters", performance_counters)
        pulumi.set(__self__, "prometheus_forwarders", prometheus_forwarders)
        pulumi.set(__self__, "syslogs", syslogs)
        pulumi.set(__self__, "windows_event_logs", windows_event_logs)
        pulumi.set(__self__, "windows_firewall_logs", windows_firewall_logs)
        if log_files is not None:
            pulumi.set(__self__, "log_files", log_files)
        if platform_telemetries is not None:
            pulumi.set(__self__, "platform_telemetries", platform_telemetries)

    @property
    @pulumi.getter(name="dataImports")
    def data_imports(self) -> Sequence['outputs.GetDataCollectionRuleDataSourceDataImportResult']:
        """
        A `data_import` block as defined above.
        """
        return pulumi.get(self, "data_imports")

    @property
    @pulumi.getter
    def extensions(self) -> Sequence['outputs.GetDataCollectionRuleDataSourceExtensionResult']:
        """
        One or more `extension` blocks as defined below.
        """
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter(name="iisLogs")
    def iis_logs(self) -> Sequence['outputs.GetDataCollectionRuleDataSourceIisLogResult']:
        """
        One or more `iis_log` blocks as defined below.
        """
        return pulumi.get(self, "iis_logs")

    @property
    @pulumi.getter(name="performanceCounters")
    def performance_counters(self) -> Sequence['outputs.GetDataCollectionRuleDataSourcePerformanceCounterResult']:
        """
        One or more `performance_counter` blocks as defined below.
        """
        return pulumi.get(self, "performance_counters")

    @property
    @pulumi.getter(name="prometheusForwarders")
    def prometheus_forwarders(self) -> Sequence['outputs.GetDataCollectionRuleDataSourcePrometheusForwarderResult']:
        """
        One or more `prometheus_forwarder` blocks as defined below.
        """
        return pulumi.get(self, "prometheus_forwarders")

    @property
    @pulumi.getter
    def syslogs(self) -> Sequence['outputs.GetDataCollectionRuleDataSourceSyslogResult']:
        """
        One or more `syslog` blocks as defined below.
        """
        return pulumi.get(self, "syslogs")

    @property
    @pulumi.getter(name="windowsEventLogs")
    def windows_event_logs(self) -> Sequence['outputs.GetDataCollectionRuleDataSourceWindowsEventLogResult']:
        """
        One or more `windows_event_log` blocks as defined below.
        """
        return pulumi.get(self, "windows_event_logs")

    @property
    @pulumi.getter(name="windowsFirewallLogs")
    def windows_firewall_logs(self) -> Sequence['outputs.GetDataCollectionRuleDataSourceWindowsFirewallLogResult']:
        """
        One or more `windows_firewall_log` blocks as defined below.
        """
        return pulumi.get(self, "windows_firewall_logs")

    @property
    @pulumi.getter(name="logFiles")
    def log_files(self) -> Optional[Sequence['outputs.GetDataCollectionRuleDataSourceLogFileResult']]:
        """
        One or more `log_file` blocks as defined below.
        """
        return pulumi.get(self, "log_files")

    @property
    @pulumi.getter(name="platformTelemetries")
    def platform_telemetries(self) -> Optional[Sequence['outputs.GetDataCollectionRuleDataSourcePlatformTelemetryResult']]:
        """
        One or more `platform_telemetry` blocks as defined below.
        """
        return pulumi.get(self, "platform_telemetries")


@pulumi.output_type
class GetDataCollectionRuleDataSourceDataImportResult(dict):
    def __init__(__self__, *,
                 event_hub_data_sources: Sequence['outputs.GetDataCollectionRuleDataSourceDataImportEventHubDataSourceResult']):
        """
        :param Sequence['GetDataCollectionRuleDataSourceDataImportEventHubDataSourceArgs'] event_hub_data_sources: An `event_hub_data_source` block as defined below.
        """
        pulumi.set(__self__, "event_hub_data_sources", event_hub_data_sources)

    @property
    @pulumi.getter(name="eventHubDataSources")
    def event_hub_data_sources(self) -> Sequence['outputs.GetDataCollectionRuleDataSourceDataImportEventHubDataSourceResult']:
        """
        An `event_hub_data_source` block as defined below.
        """
        return pulumi.get(self, "event_hub_data_sources")


@pulumi.output_type
class GetDataCollectionRuleDataSourceDataImportEventHubDataSourceResult(dict):
    def __init__(__self__, *,
                 consumer_group: str,
                 name: str,
                 stream: str):
        """
        :param str consumer_group: The Event Hub consumer group name.
        :param str name: Specifies the name of the Data Collection Rule.
        :param str stream: The stream to collect from Event Hub. Possible value should be a custom stream name.
        """
        pulumi.set(__self__, "consumer_group", consumer_group)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stream", stream)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> str:
        """
        The Event Hub consumer group name.
        """
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def stream(self) -> str:
        """
        The stream to collect from Event Hub. Possible value should be a custom stream name.
        """
        return pulumi.get(self, "stream")


@pulumi.output_type
class GetDataCollectionRuleDataSourceExtensionResult(dict):
    def __init__(__self__, *,
                 extension_json: str,
                 extension_name: str,
                 input_data_sources: Sequence[str],
                 name: str,
                 streams: Sequence[str]):
        """
        :param str extension_json: A JSON String which specifies the extension setting.
        :param str extension_name: The name of the VM extension.
        :param Sequence[str] input_data_sources: Specifies a list of data sources this extension needs data from. An item should be a name of a supported data source which produces only one stream. Supported data sources type: `performance_counter`, `windows_event_log`,and `syslog`.
        :param str name: Specifies the name of the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "extension_json", extension_json)
        pulumi.set(__self__, "extension_name", extension_name)
        pulumi.set(__self__, "input_data_sources", input_data_sources)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="extensionJson")
    def extension_json(self) -> str:
        """
        A JSON String which specifies the extension setting.
        """
        return pulumi.get(self, "extension_json")

    @property
    @pulumi.getter(name="extensionName")
    def extension_name(self) -> str:
        """
        The name of the VM extension.
        """
        return pulumi.get(self, "extension_name")

    @property
    @pulumi.getter(name="inputDataSources")
    def input_data_sources(self) -> Sequence[str]:
        """
        Specifies a list of data sources this extension needs data from. An item should be a name of a supported data source which produces only one stream. Supported data sources type: `performance_counter`, `windows_event_log`,and `syslog`.
        """
        return pulumi.get(self, "input_data_sources")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class GetDataCollectionRuleDataSourceIisLogResult(dict):
    def __init__(__self__, *,
                 log_directories: Sequence[str],
                 name: str,
                 streams: Sequence[str]):
        """
        :param Sequence[str] log_directories: Specifies a list of absolute paths where the log files are located.
        :param str name: Specifies the name of the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "log_directories", log_directories)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="logDirectories")
    def log_directories(self) -> Sequence[str]:
        """
        Specifies a list of absolute paths where the log files are located.
        """
        return pulumi.get(self, "log_directories")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class GetDataCollectionRuleDataSourceLogFileResult(dict):
    def __init__(__self__, *,
                 file_patterns: Sequence[str],
                 format: str,
                 name: str,
                 settings: Sequence['outputs.GetDataCollectionRuleDataSourceLogFileSettingResult'],
                 streams: Sequence[str]):
        """
        :param Sequence[str] file_patterns: Specifies a list of file patterns where the log files are located. For example, `C:\\\\JavaLogs\\\\*.log`.
        :param str format: The data format of the log files. possible value is `text`.
        :param str name: Specifies the name of the Data Collection Rule.
        :param Sequence['GetDataCollectionRuleDataSourceLogFileSettingArgs'] settings: A `settings` block as defined below.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "file_patterns", file_patterns)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="filePatterns")
    def file_patterns(self) -> Sequence[str]:
        """
        Specifies a list of file patterns where the log files are located. For example, `C:\\\\JavaLogs\\\\*.log`.
        """
        return pulumi.get(self, "file_patterns")

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        The data format of the log files. possible value is `text`.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def settings(self) -> Sequence['outputs.GetDataCollectionRuleDataSourceLogFileSettingResult']:
        """
        A `settings` block as defined below.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class GetDataCollectionRuleDataSourceLogFileSettingResult(dict):
    def __init__(__self__, *,
                 texts: Sequence['outputs.GetDataCollectionRuleDataSourceLogFileSettingTextResult']):
        """
        :param Sequence['GetDataCollectionRuleDataSourceLogFileSettingTextArgs'] texts: A `text` block as defined below.
        """
        pulumi.set(__self__, "texts", texts)

    @property
    @pulumi.getter
    def texts(self) -> Sequence['outputs.GetDataCollectionRuleDataSourceLogFileSettingTextResult']:
        """
        A `text` block as defined below.
        """
        return pulumi.get(self, "texts")


@pulumi.output_type
class GetDataCollectionRuleDataSourceLogFileSettingTextResult(dict):
    def __init__(__self__, *,
                 record_start_timestamp_format: str):
        """
        :param str record_start_timestamp_format: The timestamp format of the text log files. Possible values are `ISO 8601`, `YYYY-MM-DD HH:MM:SS`, `M/D/YYYY HH:MM:SS AM/PM`, `Mon DD, YYYY HH:MM:SS`, `yyMMdd HH:mm:ss`, `ddMMyy HH:mm:ss`, `MMM d hh:mm:ss`, `dd/MMM/yyyy:HH:mm:ss zzz`,and `yyyy-MM-ddTHH:mm:ssK`.
        """
        pulumi.set(__self__, "record_start_timestamp_format", record_start_timestamp_format)

    @property
    @pulumi.getter(name="recordStartTimestampFormat")
    def record_start_timestamp_format(self) -> str:
        """
        The timestamp format of the text log files. Possible values are `ISO 8601`, `YYYY-MM-DD HH:MM:SS`, `M/D/YYYY HH:MM:SS AM/PM`, `Mon DD, YYYY HH:MM:SS`, `yyMMdd HH:mm:ss`, `ddMMyy HH:mm:ss`, `MMM d hh:mm:ss`, `dd/MMM/yyyy:HH:mm:ss zzz`,and `yyyy-MM-ddTHH:mm:ssK`.
        """
        return pulumi.get(self, "record_start_timestamp_format")


@pulumi.output_type
class GetDataCollectionRuleDataSourcePerformanceCounterResult(dict):
    def __init__(__self__, *,
                 counter_specifiers: Sequence[str],
                 name: str,
                 sampling_frequency_in_seconds: int,
                 streams: Sequence[str]):
        """
        :param Sequence[str] counter_specifiers: Specifies a list of specifier names of the performance counters you want to collect. Use a wildcard `*` to collect counters for all instances. To get a list of performance counters on Windows, run the command `typeperf`.
        :param str name: Specifies the name of the Data Collection Rule.
        :param int sampling_frequency_in_seconds: The number of seconds between consecutive counter measurements (samples). The value should be integer between `1` and `1800` inclusive.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "counter_specifiers", counter_specifiers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sampling_frequency_in_seconds", sampling_frequency_in_seconds)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="counterSpecifiers")
    def counter_specifiers(self) -> Sequence[str]:
        """
        Specifies a list of specifier names of the performance counters you want to collect. Use a wildcard `*` to collect counters for all instances. To get a list of performance counters on Windows, run the command `typeperf`.
        """
        return pulumi.get(self, "counter_specifiers")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="samplingFrequencyInSeconds")
    def sampling_frequency_in_seconds(self) -> int:
        """
        The number of seconds between consecutive counter measurements (samples). The value should be integer between `1` and `1800` inclusive.
        """
        return pulumi.get(self, "sampling_frequency_in_seconds")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class GetDataCollectionRuleDataSourcePlatformTelemetryResult(dict):
    def __init__(__self__, *,
                 name: str,
                 streams: Sequence[str]):
        """
        :param str name: Specifies the name of the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class GetDataCollectionRuleDataSourcePrometheusForwarderResult(dict):
    def __init__(__self__, *,
                 label_include_filters: Sequence['outputs.GetDataCollectionRuleDataSourcePrometheusForwarderLabelIncludeFilterResult'],
                 name: str,
                 streams: Sequence[str]):
        """
        :param Sequence['GetDataCollectionRuleDataSourcePrometheusForwarderLabelIncludeFilterArgs'] label_include_filters: One or more `label_include_filter` blocks as defined above.
        :param str name: Specifies the name of the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "label_include_filters", label_include_filters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="labelIncludeFilters")
    def label_include_filters(self) -> Sequence['outputs.GetDataCollectionRuleDataSourcePrometheusForwarderLabelIncludeFilterResult']:
        """
        One or more `label_include_filter` blocks as defined above.
        """
        return pulumi.get(self, "label_include_filters")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class GetDataCollectionRuleDataSourcePrometheusForwarderLabelIncludeFilterResult(dict):
    def __init__(__self__, *,
                 label: str,
                 value: str):
        """
        :param str label: The label of the filter. This label should be unique across all `label_include_fileter` block. Possible value is `microsoft_metrics_include_label`.
        :param str value: The value of the filter.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The label of the filter. This label should be unique across all `label_include_fileter` block. Possible value is `microsoft_metrics_include_label`.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the filter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDataCollectionRuleDataSourceSyslogResult(dict):
    def __init__(__self__, *,
                 facility_names: Sequence[str],
                 log_levels: Sequence[str],
                 name: str,
                 streams: Sequence[str]):
        """
        :param Sequence[str] facility_names: Specifies a list of facility names. Use a wildcard `*` to collect logs for all facility names. Possible values are `auth`, `authpriv`, `cron`, `daemon`, `kern`, `lpr`, `mail`, `mark`, `news`, `syslog`, `user`, `uucp`, `local0`, `local1`, `local2`, `local3`, `local4`, `local5`, `local6`, `local7`,and `*`.
        :param Sequence[str] log_levels: Specifies a list of log levels. Use a wildcard `*` to collect logs for all log levels. Possible values are `Debug`,  `Info`, `Notice`, `Warning`, `Error`, `Critical`, `Alert`, `Emergency`,and `*`.
        :param str name: Specifies the name of the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "facility_names", facility_names)
        pulumi.set(__self__, "log_levels", log_levels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="facilityNames")
    def facility_names(self) -> Sequence[str]:
        """
        Specifies a list of facility names. Use a wildcard `*` to collect logs for all facility names. Possible values are `auth`, `authpriv`, `cron`, `daemon`, `kern`, `lpr`, `mail`, `mark`, `news`, `syslog`, `user`, `uucp`, `local0`, `local1`, `local2`, `local3`, `local4`, `local5`, `local6`, `local7`,and `*`.
        """
        return pulumi.get(self, "facility_names")

    @property
    @pulumi.getter(name="logLevels")
    def log_levels(self) -> Sequence[str]:
        """
        Specifies a list of log levels. Use a wildcard `*` to collect logs for all log levels. Possible values are `Debug`,  `Info`, `Notice`, `Warning`, `Error`, `Critical`, `Alert`, `Emergency`,and `*`.
        """
        return pulumi.get(self, "log_levels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class GetDataCollectionRuleDataSourceWindowsEventLogResult(dict):
    def __init__(__self__, *,
                 name: str,
                 streams: Sequence[str],
                 x_path_queries: Sequence[str]):
        """
        :param str name: Specifies the name of the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        :param Sequence[str] x_path_queries: Specifies a list of Windows Event Log queries in XPath expression.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        pulumi.set(__self__, "x_path_queries", x_path_queries)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="xPathQueries")
    def x_path_queries(self) -> Sequence[str]:
        """
        Specifies a list of Windows Event Log queries in XPath expression.
        """
        return pulumi.get(self, "x_path_queries")


@pulumi.output_type
class GetDataCollectionRuleDataSourceWindowsFirewallLogResult(dict):
    def __init__(__self__, *,
                 name: str,
                 streams: Sequence[str]):
        """
        :param str name: Specifies the name of the Data Collection Rule.
        :param Sequence[str] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def streams(self) -> Sequence[str]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class GetDataCollectionRuleDestinationResult(dict):
    def __init__(__self__, *,
                 azure_monitor_metrics: Sequence['outputs.GetDataCollectionRuleDestinationAzureMonitorMetricResult'],
                 log_analytics: Sequence['outputs.GetDataCollectionRuleDestinationLogAnalyticResult'],
                 monitor_accounts: Sequence['outputs.GetDataCollectionRuleDestinationMonitorAccountResult'],
                 storage_blob_directs: Sequence['outputs.GetDataCollectionRuleDestinationStorageBlobDirectResult'],
                 storage_blobs: Sequence['outputs.GetDataCollectionRuleDestinationStorageBlobResult'],
                 storage_table_directs: Sequence['outputs.GetDataCollectionRuleDestinationStorageTableDirectResult'],
                 event_hub: Optional['outputs.GetDataCollectionRuleDestinationEventHubResult'] = None,
                 event_hub_direct: Optional['outputs.GetDataCollectionRuleDestinationEventHubDirectResult'] = None):
        """
        :param Sequence['GetDataCollectionRuleDestinationAzureMonitorMetricArgs'] azure_monitor_metrics: A `azure_monitor_metrics` block as defined above.
        :param Sequence['GetDataCollectionRuleDestinationLogAnalyticArgs'] log_analytics: One or more `log_analytics` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDestinationMonitorAccountArgs'] monitor_accounts: One or more `monitor_account` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDestinationStorageBlobDirectArgs'] storage_blob_directs: One or more `storage_blob_direct` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDestinationStorageBlobArgs'] storage_blobs: One or more `storage_blob` blocks as defined below.
        :param Sequence['GetDataCollectionRuleDestinationStorageTableDirectArgs'] storage_table_directs: One or more `storage_table_direct` blocks as defined below.
        :param 'GetDataCollectionRuleDestinationEventHubArgs' event_hub: One or more `event_hub` blocks as defined below.
        :param 'GetDataCollectionRuleDestinationEventHubDirectArgs' event_hub_direct: One or more `event_hub_direct` blocks as defined below.
        """
        pulumi.set(__self__, "azure_monitor_metrics", azure_monitor_metrics)
        pulumi.set(__self__, "log_analytics", log_analytics)
        pulumi.set(__self__, "monitor_accounts", monitor_accounts)
        pulumi.set(__self__, "storage_blob_directs", storage_blob_directs)
        pulumi.set(__self__, "storage_blobs", storage_blobs)
        pulumi.set(__self__, "storage_table_directs", storage_table_directs)
        if event_hub is not None:
            pulumi.set(__self__, "event_hub", event_hub)
        if event_hub_direct is not None:
            pulumi.set(__self__, "event_hub_direct", event_hub_direct)

    @property
    @pulumi.getter(name="azureMonitorMetrics")
    def azure_monitor_metrics(self) -> Sequence['outputs.GetDataCollectionRuleDestinationAzureMonitorMetricResult']:
        """
        A `azure_monitor_metrics` block as defined above.
        """
        return pulumi.get(self, "azure_monitor_metrics")

    @property
    @pulumi.getter(name="logAnalytics")
    def log_analytics(self) -> Sequence['outputs.GetDataCollectionRuleDestinationLogAnalyticResult']:
        """
        One or more `log_analytics` blocks as defined below.
        """
        return pulumi.get(self, "log_analytics")

    @property
    @pulumi.getter(name="monitorAccounts")
    def monitor_accounts(self) -> Sequence['outputs.GetDataCollectionRuleDestinationMonitorAccountResult']:
        """
        One or more `monitor_account` blocks as defined below.
        """
        return pulumi.get(self, "monitor_accounts")

    @property
    @pulumi.getter(name="storageBlobDirects")
    def storage_blob_directs(self) -> Sequence['outputs.GetDataCollectionRuleDestinationStorageBlobDirectResult']:
        """
        One or more `storage_blob_direct` blocks as defined below.
        """
        return pulumi.get(self, "storage_blob_directs")

    @property
    @pulumi.getter(name="storageBlobs")
    def storage_blobs(self) -> Sequence['outputs.GetDataCollectionRuleDestinationStorageBlobResult']:
        """
        One or more `storage_blob` blocks as defined below.
        """
        return pulumi.get(self, "storage_blobs")

    @property
    @pulumi.getter(name="storageTableDirects")
    def storage_table_directs(self) -> Sequence['outputs.GetDataCollectionRuleDestinationStorageTableDirectResult']:
        """
        One or more `storage_table_direct` blocks as defined below.
        """
        return pulumi.get(self, "storage_table_directs")

    @property
    @pulumi.getter(name="eventHub")
    def event_hub(self) -> Optional['outputs.GetDataCollectionRuleDestinationEventHubResult']:
        """
        One or more `event_hub` blocks as defined below.
        """
        return pulumi.get(self, "event_hub")

    @property
    @pulumi.getter(name="eventHubDirect")
    def event_hub_direct(self) -> Optional['outputs.GetDataCollectionRuleDestinationEventHubDirectResult']:
        """
        One or more `event_hub_direct` blocks as defined below.
        """
        return pulumi.get(self, "event_hub_direct")


@pulumi.output_type
class GetDataCollectionRuleDestinationAzureMonitorMetricResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specifies the name of the Data Collection Rule.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataCollectionRuleDestinationEventHubResult(dict):
    def __init__(__self__, *,
                 event_hub_id: str,
                 name: str):
        """
        :param str event_hub_id: The resource ID of the Event Hub.
        :param str name: Specifies the name of the Data Collection Rule.
        """
        pulumi.set(__self__, "event_hub_id", event_hub_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubId")
    def event_hub_id(self) -> str:
        """
        The resource ID of the Event Hub.
        """
        return pulumi.get(self, "event_hub_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataCollectionRuleDestinationEventHubDirectResult(dict):
    def __init__(__self__, *,
                 event_hub_id: str,
                 name: str):
        """
        :param str event_hub_id: The resource ID of the Event Hub.
        :param str name: Specifies the name of the Data Collection Rule.
        """
        pulumi.set(__self__, "event_hub_id", event_hub_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubId")
    def event_hub_id(self) -> str:
        """
        The resource ID of the Event Hub.
        """
        return pulumi.get(self, "event_hub_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataCollectionRuleDestinationLogAnalyticResult(dict):
    def __init__(__self__, *,
                 name: str,
                 workspace_resource_id: str):
        """
        :param str name: Specifies the name of the Data Collection Rule.
        :param str workspace_resource_id: The ID of a Log Analytic Workspace resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> str:
        """
        The ID of a Log Analytic Workspace resource.
        """
        return pulumi.get(self, "workspace_resource_id")


@pulumi.output_type
class GetDataCollectionRuleDestinationMonitorAccountResult(dict):
    def __init__(__self__, *,
                 monitor_account_id: str,
                 name: str):
        """
        :param str monitor_account_id: The resource ID of the Monitor Account.
        :param str name: Specifies the name of the Data Collection Rule.
        """
        pulumi.set(__self__, "monitor_account_id", monitor_account_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="monitorAccountId")
    def monitor_account_id(self) -> str:
        """
        The resource ID of the Monitor Account.
        """
        return pulumi.get(self, "monitor_account_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataCollectionRuleDestinationStorageBlobResult(dict):
    def __init__(__self__, *,
                 container_name: str,
                 name: str,
                 storage_account_id: str):
        """
        :param str container_name: The Storage Container name.
        :param str name: Specifies the name of the Data Collection Rule.
        :param str storage_account_id: The resource ID of the Storage Account.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        The Storage Container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> str:
        """
        The resource ID of the Storage Account.
        """
        return pulumi.get(self, "storage_account_id")


@pulumi.output_type
class GetDataCollectionRuleDestinationStorageBlobDirectResult(dict):
    def __init__(__self__, *,
                 container_name: str,
                 name: str,
                 storage_account_id: str):
        """
        :param str container_name: The Storage Container name.
        :param str name: Specifies the name of the Data Collection Rule.
        :param str storage_account_id: The resource ID of the Storage Account.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        The Storage Container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> str:
        """
        The resource ID of the Storage Account.
        """
        return pulumi.get(self, "storage_account_id")


@pulumi.output_type
class GetDataCollectionRuleDestinationStorageTableDirectResult(dict):
    def __init__(__self__, *,
                 name: str,
                 storage_account_id: str,
                 table_name: str):
        """
        :param str name: Specifies the name of the Data Collection Rule.
        :param str storage_account_id: The resource ID of the Storage Account.
        :param str table_name: The Storage Table name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> str:
        """
        The resource ID of the Storage Account.
        """
        return pulumi.get(self, "storage_account_id")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The Storage Table name.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class GetDataCollectionRuleIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Data Collection Rule. Currently, up to 1 identity is supported.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        :param str type: cSpecifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Data Collection Rule. Currently, up to 1 identity is supported.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        cSpecifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataCollectionRuleStreamDeclarationResult(dict):
    def __init__(__self__, *,
                 columns: Sequence['outputs.GetDataCollectionRuleStreamDeclarationColumnResult'],
                 stream_name: str):
        """
        :param Sequence['GetDataCollectionRuleStreamDeclarationColumnArgs'] columns: One or more `column` blocks as defined above.
        :param str stream_name: The name of the custom stream. This name should be unique across all `stream_declaration` blocks.
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.GetDataCollectionRuleStreamDeclarationColumnResult']:
        """
        One or more `column` blocks as defined above.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        The name of the custom stream. This name should be unique across all `stream_declaration` blocks.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class GetDataCollectionRuleStreamDeclarationColumnResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Specifies the name of the Data Collection Rule.
        :param str type: cSpecifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        cSpecifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetScheduledQueryRulesAlertActionResult(dict):
    def __init__(__self__, *,
                 action_groups: Sequence[str],
                 custom_webhook_payload: str,
                 email_subject: str):
        """
        :param Sequence[str] action_groups: List of action group reference resource IDs.
        :param str custom_webhook_payload: Custom payload to be sent for all webhook URI in Azure action group.
        :param str email_subject: Custom subject override for all email IDs in Azure action group.
        """
        pulumi.set(__self__, "action_groups", action_groups)
        pulumi.set(__self__, "custom_webhook_payload", custom_webhook_payload)
        pulumi.set(__self__, "email_subject", email_subject)

    @property
    @pulumi.getter(name="actionGroups")
    def action_groups(self) -> Sequence[str]:
        """
        List of action group reference resource IDs.
        """
        return pulumi.get(self, "action_groups")

    @property
    @pulumi.getter(name="customWebhookPayload")
    def custom_webhook_payload(self) -> str:
        """
        Custom payload to be sent for all webhook URI in Azure action group.
        """
        return pulumi.get(self, "custom_webhook_payload")

    @property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> str:
        """
        Custom subject override for all email IDs in Azure action group.
        """
        return pulumi.get(self, "email_subject")


@pulumi.output_type
class GetScheduledQueryRulesAlertTriggerResult(dict):
    def __init__(__self__, *,
                 metric_triggers: Sequence['outputs.GetScheduledQueryRulesAlertTriggerMetricTriggerResult'],
                 operator: str,
                 threshold: float):
        """
        :param str operator: Evaluation operation for rule.
        :param float threshold: Result or count threshold based on which rule should be triggered.
        """
        pulumi.set(__self__, "metric_triggers", metric_triggers)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="metricTriggers")
    def metric_triggers(self) -> Sequence['outputs.GetScheduledQueryRulesAlertTriggerMetricTriggerResult']:
        return pulumi.get(self, "metric_triggers")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Evaluation operation for rule.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Result or count threshold based on which rule should be triggered.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetScheduledQueryRulesAlertTriggerMetricTriggerResult(dict):
    def __init__(__self__, *,
                 metric_column: str,
                 metric_trigger_type: str,
                 operator: str,
                 threshold: float):
        """
        :param str operator: Evaluation operation for rule.
        :param float threshold: Result or count threshold based on which rule should be triggered.
        """
        pulumi.set(__self__, "metric_column", metric_column)
        pulumi.set(__self__, "metric_trigger_type", metric_trigger_type)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="metricColumn")
    def metric_column(self) -> str:
        return pulumi.get(self, "metric_column")

    @property
    @pulumi.getter(name="metricTriggerType")
    def metric_trigger_type(self) -> str:
        return pulumi.get(self, "metric_trigger_type")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Evaluation operation for rule.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Result or count threshold based on which rule should be triggered.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetScheduledQueryRulesLogCriteriaResult(dict):
    def __init__(__self__, *,
                 dimensions: Sequence['outputs.GetScheduledQueryRulesLogCriteriaDimensionResult'],
                 metric_name: str):
        """
        :param Sequence['GetScheduledQueryRulesLogCriteriaDimensionArgs'] dimensions: A `dimension` block as defined below.
        :param str metric_name: Name of the metric.
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metric_name", metric_name)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetScheduledQueryRulesLogCriteriaDimensionResult']:
        """
        A `dimension` block as defined below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric.
        """
        return pulumi.get(self, "metric_name")


@pulumi.output_type
class GetScheduledQueryRulesLogCriteriaDimensionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 operator: str,
                 values: Sequence[str]):
        """
        :param str name: Specifies the name of the scheduled query rule.
        :param str operator: Operator for dimension values.
        :param Sequence[str] values: List of dimension values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the scheduled query rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator for dimension values.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of dimension values.
        """
        return pulumi.get(self, "values")


