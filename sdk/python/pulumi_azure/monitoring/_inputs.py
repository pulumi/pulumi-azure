# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AadDiagnosticSettingEnabledLogArgs',
    'AadDiagnosticSettingEnabledLogArgsDict',
    'AadDiagnosticSettingEnabledLogRetentionPolicyArgs',
    'AadDiagnosticSettingEnabledLogRetentionPolicyArgsDict',
    'ActionGroupArmRoleReceiverArgs',
    'ActionGroupArmRoleReceiverArgsDict',
    'ActionGroupAutomationRunbookReceiverArgs',
    'ActionGroupAutomationRunbookReceiverArgsDict',
    'ActionGroupAzureAppPushReceiverArgs',
    'ActionGroupAzureAppPushReceiverArgsDict',
    'ActionGroupAzureFunctionReceiverArgs',
    'ActionGroupAzureFunctionReceiverArgsDict',
    'ActionGroupEmailReceiverArgs',
    'ActionGroupEmailReceiverArgsDict',
    'ActionGroupEventHubReceiverArgs',
    'ActionGroupEventHubReceiverArgsDict',
    'ActionGroupItsmReceiverArgs',
    'ActionGroupItsmReceiverArgsDict',
    'ActionGroupLogicAppReceiverArgs',
    'ActionGroupLogicAppReceiverArgsDict',
    'ActionGroupSmsReceiverArgs',
    'ActionGroupSmsReceiverArgsDict',
    'ActionGroupVoiceReceiverArgs',
    'ActionGroupVoiceReceiverArgsDict',
    'ActionGroupWebhookReceiverArgs',
    'ActionGroupWebhookReceiverArgsDict',
    'ActionGroupWebhookReceiverAadAuthArgs',
    'ActionGroupWebhookReceiverAadAuthArgsDict',
    'ActivityLogAlertActionArgs',
    'ActivityLogAlertActionArgsDict',
    'ActivityLogAlertCriteriaArgs',
    'ActivityLogAlertCriteriaArgsDict',
    'ActivityLogAlertCriteriaResourceHealthArgs',
    'ActivityLogAlertCriteriaResourceHealthArgsDict',
    'ActivityLogAlertCriteriaServiceHealthArgs',
    'ActivityLogAlertCriteriaServiceHealthArgsDict',
    'AlertProcessingRuleActionGroupConditionArgs',
    'AlertProcessingRuleActionGroupConditionArgsDict',
    'AlertProcessingRuleActionGroupConditionAlertContextArgs',
    'AlertProcessingRuleActionGroupConditionAlertContextArgsDict',
    'AlertProcessingRuleActionGroupConditionAlertRuleIdArgs',
    'AlertProcessingRuleActionGroupConditionAlertRuleIdArgsDict',
    'AlertProcessingRuleActionGroupConditionAlertRuleNameArgs',
    'AlertProcessingRuleActionGroupConditionAlertRuleNameArgsDict',
    'AlertProcessingRuleActionGroupConditionDescriptionArgs',
    'AlertProcessingRuleActionGroupConditionDescriptionArgsDict',
    'AlertProcessingRuleActionGroupConditionMonitorConditionArgs',
    'AlertProcessingRuleActionGroupConditionMonitorConditionArgsDict',
    'AlertProcessingRuleActionGroupConditionMonitorServiceArgs',
    'AlertProcessingRuleActionGroupConditionMonitorServiceArgsDict',
    'AlertProcessingRuleActionGroupConditionSeverityArgs',
    'AlertProcessingRuleActionGroupConditionSeverityArgsDict',
    'AlertProcessingRuleActionGroupConditionSignalTypeArgs',
    'AlertProcessingRuleActionGroupConditionSignalTypeArgsDict',
    'AlertProcessingRuleActionGroupConditionTargetResourceArgs',
    'AlertProcessingRuleActionGroupConditionTargetResourceArgsDict',
    'AlertProcessingRuleActionGroupConditionTargetResourceGroupArgs',
    'AlertProcessingRuleActionGroupConditionTargetResourceGroupArgsDict',
    'AlertProcessingRuleActionGroupConditionTargetResourceTypeArgs',
    'AlertProcessingRuleActionGroupConditionTargetResourceTypeArgsDict',
    'AlertProcessingRuleActionGroupScheduleArgs',
    'AlertProcessingRuleActionGroupScheduleArgsDict',
    'AlertProcessingRuleActionGroupScheduleRecurrenceArgs',
    'AlertProcessingRuleActionGroupScheduleRecurrenceArgsDict',
    'AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgs',
    'AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgsDict',
    'AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgs',
    'AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgsDict',
    'AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgs',
    'AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgsDict',
    'AlertProcessingRuleSuppressionConditionArgs',
    'AlertProcessingRuleSuppressionConditionArgsDict',
    'AlertProcessingRuleSuppressionConditionAlertContextArgs',
    'AlertProcessingRuleSuppressionConditionAlertContextArgsDict',
    'AlertProcessingRuleSuppressionConditionAlertRuleIdArgs',
    'AlertProcessingRuleSuppressionConditionAlertRuleIdArgsDict',
    'AlertProcessingRuleSuppressionConditionAlertRuleNameArgs',
    'AlertProcessingRuleSuppressionConditionAlertRuleNameArgsDict',
    'AlertProcessingRuleSuppressionConditionDescriptionArgs',
    'AlertProcessingRuleSuppressionConditionDescriptionArgsDict',
    'AlertProcessingRuleSuppressionConditionMonitorConditionArgs',
    'AlertProcessingRuleSuppressionConditionMonitorConditionArgsDict',
    'AlertProcessingRuleSuppressionConditionMonitorServiceArgs',
    'AlertProcessingRuleSuppressionConditionMonitorServiceArgsDict',
    'AlertProcessingRuleSuppressionConditionSeverityArgs',
    'AlertProcessingRuleSuppressionConditionSeverityArgsDict',
    'AlertProcessingRuleSuppressionConditionSignalTypeArgs',
    'AlertProcessingRuleSuppressionConditionSignalTypeArgsDict',
    'AlertProcessingRuleSuppressionConditionTargetResourceArgs',
    'AlertProcessingRuleSuppressionConditionTargetResourceArgsDict',
    'AlertProcessingRuleSuppressionConditionTargetResourceGroupArgs',
    'AlertProcessingRuleSuppressionConditionTargetResourceGroupArgsDict',
    'AlertProcessingRuleSuppressionConditionTargetResourceTypeArgs',
    'AlertProcessingRuleSuppressionConditionTargetResourceTypeArgsDict',
    'AlertProcessingRuleSuppressionScheduleArgs',
    'AlertProcessingRuleSuppressionScheduleArgsDict',
    'AlertProcessingRuleSuppressionScheduleRecurrenceArgs',
    'AlertProcessingRuleSuppressionScheduleRecurrenceArgsDict',
    'AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgs',
    'AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgsDict',
    'AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgs',
    'AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgsDict',
    'AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgs',
    'AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgsDict',
    'AlertPrometheusRuleGroupRuleArgs',
    'AlertPrometheusRuleGroupRuleArgsDict',
    'AlertPrometheusRuleGroupRuleActionArgs',
    'AlertPrometheusRuleGroupRuleActionArgsDict',
    'AlertPrometheusRuleGroupRuleAlertResolutionArgs',
    'AlertPrometheusRuleGroupRuleAlertResolutionArgsDict',
    'AutoscaleSettingNotificationArgs',
    'AutoscaleSettingNotificationArgsDict',
    'AutoscaleSettingNotificationEmailArgs',
    'AutoscaleSettingNotificationEmailArgsDict',
    'AutoscaleSettingNotificationWebhookArgs',
    'AutoscaleSettingNotificationWebhookArgsDict',
    'AutoscaleSettingPredictiveArgs',
    'AutoscaleSettingPredictiveArgsDict',
    'AutoscaleSettingProfileArgs',
    'AutoscaleSettingProfileArgsDict',
    'AutoscaleSettingProfileCapacityArgs',
    'AutoscaleSettingProfileCapacityArgsDict',
    'AutoscaleSettingProfileFixedDateArgs',
    'AutoscaleSettingProfileFixedDateArgsDict',
    'AutoscaleSettingProfileRecurrenceArgs',
    'AutoscaleSettingProfileRecurrenceArgsDict',
    'AutoscaleSettingProfileRuleArgs',
    'AutoscaleSettingProfileRuleArgsDict',
    'AutoscaleSettingProfileRuleMetricTriggerArgs',
    'AutoscaleSettingProfileRuleMetricTriggerArgsDict',
    'AutoscaleSettingProfileRuleMetricTriggerDimensionArgs',
    'AutoscaleSettingProfileRuleMetricTriggerDimensionArgsDict',
    'AutoscaleSettingProfileRuleScaleActionArgs',
    'AutoscaleSettingProfileRuleScaleActionArgsDict',
    'DataCollectionRuleDataFlowArgs',
    'DataCollectionRuleDataFlowArgsDict',
    'DataCollectionRuleDataSourcesArgs',
    'DataCollectionRuleDataSourcesArgsDict',
    'DataCollectionRuleDataSourcesDataImportArgs',
    'DataCollectionRuleDataSourcesDataImportArgsDict',
    'DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgs',
    'DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgsDict',
    'DataCollectionRuleDataSourcesExtensionArgs',
    'DataCollectionRuleDataSourcesExtensionArgsDict',
    'DataCollectionRuleDataSourcesIisLogArgs',
    'DataCollectionRuleDataSourcesIisLogArgsDict',
    'DataCollectionRuleDataSourcesLogFileArgs',
    'DataCollectionRuleDataSourcesLogFileArgsDict',
    'DataCollectionRuleDataSourcesLogFileSettingsArgs',
    'DataCollectionRuleDataSourcesLogFileSettingsArgsDict',
    'DataCollectionRuleDataSourcesLogFileSettingsTextArgs',
    'DataCollectionRuleDataSourcesLogFileSettingsTextArgsDict',
    'DataCollectionRuleDataSourcesPerformanceCounterArgs',
    'DataCollectionRuleDataSourcesPerformanceCounterArgsDict',
    'DataCollectionRuleDataSourcesPlatformTelemetryArgs',
    'DataCollectionRuleDataSourcesPlatformTelemetryArgsDict',
    'DataCollectionRuleDataSourcesPrometheusForwarderArgs',
    'DataCollectionRuleDataSourcesPrometheusForwarderArgsDict',
    'DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgs',
    'DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgsDict',
    'DataCollectionRuleDataSourcesSyslogArgs',
    'DataCollectionRuleDataSourcesSyslogArgsDict',
    'DataCollectionRuleDataSourcesWindowsEventLogArgs',
    'DataCollectionRuleDataSourcesWindowsEventLogArgsDict',
    'DataCollectionRuleDataSourcesWindowsFirewallLogArgs',
    'DataCollectionRuleDataSourcesWindowsFirewallLogArgsDict',
    'DataCollectionRuleDestinationsArgs',
    'DataCollectionRuleDestinationsArgsDict',
    'DataCollectionRuleDestinationsAzureMonitorMetricsArgs',
    'DataCollectionRuleDestinationsAzureMonitorMetricsArgsDict',
    'DataCollectionRuleDestinationsEventHubArgs',
    'DataCollectionRuleDestinationsEventHubArgsDict',
    'DataCollectionRuleDestinationsEventHubDirectArgs',
    'DataCollectionRuleDestinationsEventHubDirectArgsDict',
    'DataCollectionRuleDestinationsLogAnalyticArgs',
    'DataCollectionRuleDestinationsLogAnalyticArgsDict',
    'DataCollectionRuleDestinationsMonitorAccountArgs',
    'DataCollectionRuleDestinationsMonitorAccountArgsDict',
    'DataCollectionRuleDestinationsStorageBlobArgs',
    'DataCollectionRuleDestinationsStorageBlobArgsDict',
    'DataCollectionRuleDestinationsStorageBlobDirectArgs',
    'DataCollectionRuleDestinationsStorageBlobDirectArgsDict',
    'DataCollectionRuleDestinationsStorageTableDirectArgs',
    'DataCollectionRuleDestinationsStorageTableDirectArgsDict',
    'DataCollectionRuleIdentityArgs',
    'DataCollectionRuleIdentityArgsDict',
    'DataCollectionRuleStreamDeclarationArgs',
    'DataCollectionRuleStreamDeclarationArgsDict',
    'DataCollectionRuleStreamDeclarationColumnArgs',
    'DataCollectionRuleStreamDeclarationColumnArgsDict',
    'DiagnosticSettingEnabledLogArgs',
    'DiagnosticSettingEnabledLogArgsDict',
    'DiagnosticSettingEnabledLogRetentionPolicyArgs',
    'DiagnosticSettingEnabledLogRetentionPolicyArgsDict',
    'DiagnosticSettingMetricArgs',
    'DiagnosticSettingMetricArgsDict',
    'DiagnosticSettingMetricRetentionPolicyArgs',
    'DiagnosticSettingMetricRetentionPolicyArgsDict',
    'MetricAlertActionArgs',
    'MetricAlertActionArgsDict',
    'MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteriaArgs',
    'MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteriaArgsDict',
    'MetricAlertCriteriaArgs',
    'MetricAlertCriteriaArgsDict',
    'MetricAlertCriteriaDimensionArgs',
    'MetricAlertCriteriaDimensionArgsDict',
    'MetricAlertDynamicCriteriaArgs',
    'MetricAlertDynamicCriteriaArgsDict',
    'MetricAlertDynamicCriteriaDimensionArgs',
    'MetricAlertDynamicCriteriaDimensionArgsDict',
    'ScheduledQueryRulesAlertActionArgs',
    'ScheduledQueryRulesAlertActionArgsDict',
    'ScheduledQueryRulesAlertTriggerArgs',
    'ScheduledQueryRulesAlertTriggerArgsDict',
    'ScheduledQueryRulesAlertTriggerMetricTriggerArgs',
    'ScheduledQueryRulesAlertTriggerMetricTriggerArgsDict',
    'ScheduledQueryRulesAlertV2ActionArgs',
    'ScheduledQueryRulesAlertV2ActionArgsDict',
    'ScheduledQueryRulesAlertV2CriteriaArgs',
    'ScheduledQueryRulesAlertV2CriteriaArgsDict',
    'ScheduledQueryRulesAlertV2CriteriaDimensionArgs',
    'ScheduledQueryRulesAlertV2CriteriaDimensionArgsDict',
    'ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgs',
    'ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgsDict',
    'ScheduledQueryRulesAlertV2IdentityArgs',
    'ScheduledQueryRulesAlertV2IdentityArgsDict',
    'ScheduledQueryRulesLogCriteriaArgs',
    'ScheduledQueryRulesLogCriteriaArgsDict',
    'ScheduledQueryRulesLogCriteriaDimensionArgs',
    'ScheduledQueryRulesLogCriteriaDimensionArgsDict',
    'SmartDetectorAlertRuleActionGroupArgs',
    'SmartDetectorAlertRuleActionGroupArgsDict',
]

MYPY = False

if not MYPY:
    class AadDiagnosticSettingEnabledLogArgsDict(TypedDict):
        category: pulumi.Input[str]
        """
        The log category for the Azure Active Directory Diagnostic.
        """
        retention_policy: pulumi.Input['AadDiagnosticSettingEnabledLogRetentionPolicyArgsDict']
        """
        A `retention_policy` block as defined below.
        """
elif False:
    AadDiagnosticSettingEnabledLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AadDiagnosticSettingEnabledLogArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[str],
                 retention_policy: pulumi.Input['AadDiagnosticSettingEnabledLogRetentionPolicyArgs']):
        """
        :param pulumi.Input[str] category: The log category for the Azure Active Directory Diagnostic.
        :param pulumi.Input['AadDiagnosticSettingEnabledLogRetentionPolicyArgs'] retention_policy: A `retention_policy` block as defined below.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[str]:
        """
        The log category for the Azure Active Directory Diagnostic.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> pulumi.Input['AadDiagnosticSettingEnabledLogRetentionPolicyArgs']:
        """
        A `retention_policy` block as defined below.
        """
        return pulumi.get(self, "retention_policy")

    @retention_policy.setter
    def retention_policy(self, value: pulumi.Input['AadDiagnosticSettingEnabledLogRetentionPolicyArgs']):
        pulumi.set(self, "retention_policy", value)


if not MYPY:
    class AadDiagnosticSettingEnabledLogRetentionPolicyArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[int]]
        """
        The number of days for which this Retention Policy should apply. Defaults to `0`.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is this Retention Policy enabled? Defaults to `false`.
        """
elif False:
    AadDiagnosticSettingEnabledLogRetentionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AadDiagnosticSettingEnabledLogRetentionPolicyArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] days: The number of days for which this Retention Policy should apply. Defaults to `0`.
        :param pulumi.Input[bool] enabled: Is this Retention Policy enabled? Defaults to `false`.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days for which this Retention Policy should apply. Defaults to `0`.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this Retention Policy enabled? Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ActionGroupArmRoleReceiverArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the ARM role receiver.
        """
        role_id: pulumi.Input[str]
        """
        The arm role id.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the common alert schema.
        """
elif False:
    ActionGroupArmRoleReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupArmRoleReceiverArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 role_id: pulumi.Input[str],
                 use_common_alert_schema: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name of the ARM role receiver.
        :param pulumi.Input[str] role_id: The arm role id.
        :param pulumi.Input[bool] use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role_id", role_id)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the ARM role receiver.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> pulumi.Input[str]:
        """
        The arm role id.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_id", value)

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class ActionGroupAutomationRunbookReceiverArgsDict(TypedDict):
        automation_account_id: pulumi.Input[str]
        """
        The automation account ID which holds this runbook and authenticates to Azure resources.
        """
        is_global_runbook: pulumi.Input[bool]
        """
        Indicates whether this instance is global runbook.
        """
        name: pulumi.Input[str]
        """
        The name of the automation runbook receiver.
        """
        runbook_name: pulumi.Input[str]
        """
        The name for this runbook.
        """
        service_uri: pulumi.Input[str]
        """
        The URI where webhooks should be sent.
        """
        webhook_resource_id: pulumi.Input[str]
        """
        The resource id for webhook linked to this runbook.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the common alert schema.
        """
elif False:
    ActionGroupAutomationRunbookReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupAutomationRunbookReceiverArgs:
    def __init__(__self__, *,
                 automation_account_id: pulumi.Input[str],
                 is_global_runbook: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 runbook_name: pulumi.Input[str],
                 service_uri: pulumi.Input[str],
                 webhook_resource_id: pulumi.Input[str],
                 use_common_alert_schema: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] automation_account_id: The automation account ID which holds this runbook and authenticates to Azure resources.
        :param pulumi.Input[bool] is_global_runbook: Indicates whether this instance is global runbook.
        :param pulumi.Input[str] name: The name of the automation runbook receiver.
        :param pulumi.Input[str] runbook_name: The name for this runbook.
        :param pulumi.Input[str] service_uri: The URI where webhooks should be sent.
        :param pulumi.Input[str] webhook_resource_id: The resource id for webhook linked to this runbook.
        :param pulumi.Input[bool] use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "automation_account_id", automation_account_id)
        pulumi.set(__self__, "is_global_runbook", is_global_runbook)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "runbook_name", runbook_name)
        pulumi.set(__self__, "service_uri", service_uri)
        pulumi.set(__self__, "webhook_resource_id", webhook_resource_id)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="automationAccountId")
    def automation_account_id(self) -> pulumi.Input[str]:
        """
        The automation account ID which holds this runbook and authenticates to Azure resources.
        """
        return pulumi.get(self, "automation_account_id")

    @automation_account_id.setter
    def automation_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "automation_account_id", value)

    @property
    @pulumi.getter(name="isGlobalRunbook")
    def is_global_runbook(self) -> pulumi.Input[bool]:
        """
        Indicates whether this instance is global runbook.
        """
        return pulumi.get(self, "is_global_runbook")

    @is_global_runbook.setter
    def is_global_runbook(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_global_runbook", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the automation runbook receiver.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="runbookName")
    def runbook_name(self) -> pulumi.Input[str]:
        """
        The name for this runbook.
        """
        return pulumi.get(self, "runbook_name")

    @runbook_name.setter
    def runbook_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "runbook_name", value)

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> pulumi.Input[str]:
        """
        The URI where webhooks should be sent.
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_uri", value)

    @property
    @pulumi.getter(name="webhookResourceId")
    def webhook_resource_id(self) -> pulumi.Input[str]:
        """
        The resource id for webhook linked to this runbook.
        """
        return pulumi.get(self, "webhook_resource_id")

    @webhook_resource_id.setter
    def webhook_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "webhook_resource_id", value)

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class ActionGroupAzureAppPushReceiverArgsDict(TypedDict):
        email_address: pulumi.Input[str]
        """
        The email address of the user signed into the mobile app who will receive push notifications from this receiver.
        """
        name: pulumi.Input[str]
        """
        The name of the Azure app push receiver.
        """
elif False:
    ActionGroupAzureAppPushReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupAzureAppPushReceiverArgs:
    def __init__(__self__, *,
                 email_address: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email_address: The email address of the user signed into the mobile app who will receive push notifications from this receiver.
        :param pulumi.Input[str] name: The name of the Azure app push receiver.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> pulumi.Input[str]:
        """
        The email address of the user signed into the mobile app who will receive push notifications from this receiver.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Azure app push receiver.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ActionGroupAzureFunctionReceiverArgsDict(TypedDict):
        function_app_resource_id: pulumi.Input[str]
        """
        The Azure resource ID of the function app.
        """
        function_name: pulumi.Input[str]
        """
        The function name in the function app.
        """
        http_trigger_url: pulumi.Input[str]
        """
        The HTTP trigger url where HTTP request sent to.
        """
        name: pulumi.Input[str]
        """
        The name of the Azure Function receiver.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the common alert schema.
        """
elif False:
    ActionGroupAzureFunctionReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupAzureFunctionReceiverArgs:
    def __init__(__self__, *,
                 function_app_resource_id: pulumi.Input[str],
                 function_name: pulumi.Input[str],
                 http_trigger_url: pulumi.Input[str],
                 name: pulumi.Input[str],
                 use_common_alert_schema: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] function_app_resource_id: The Azure resource ID of the function app.
        :param pulumi.Input[str] function_name: The function name in the function app.
        :param pulumi.Input[str] http_trigger_url: The HTTP trigger url where HTTP request sent to.
        :param pulumi.Input[str] name: The name of the Azure Function receiver.
        :param pulumi.Input[bool] use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "function_app_resource_id", function_app_resource_id)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "http_trigger_url", http_trigger_url)
        pulumi.set(__self__, "name", name)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="functionAppResourceId")
    def function_app_resource_id(self) -> pulumi.Input[str]:
        """
        The Azure resource ID of the function app.
        """
        return pulumi.get(self, "function_app_resource_id")

    @function_app_resource_id.setter
    def function_app_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_app_resource_id", value)

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> pulumi.Input[str]:
        """
        The function name in the function app.
        """
        return pulumi.get(self, "function_name")

    @function_name.setter
    def function_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_name", value)

    @property
    @pulumi.getter(name="httpTriggerUrl")
    def http_trigger_url(self) -> pulumi.Input[str]:
        """
        The HTTP trigger url where HTTP request sent to.
        """
        return pulumi.get(self, "http_trigger_url")

    @http_trigger_url.setter
    def http_trigger_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_trigger_url", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Azure Function receiver.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class ActionGroupEmailReceiverArgsDict(TypedDict):
        email_address: pulumi.Input[str]
        """
        The email address of this receiver.
        """
        name: pulumi.Input[str]
        """
        The name of the email receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the common alert schema.
        """
elif False:
    ActionGroupEmailReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupEmailReceiverArgs:
    def __init__(__self__, *,
                 email_address: pulumi.Input[str],
                 name: pulumi.Input[str],
                 use_common_alert_schema: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] email_address: The email address of this receiver.
        :param pulumi.Input[str] name: The name of the email receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        :param pulumi.Input[bool] use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "name", name)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> pulumi.Input[str]:
        """
        The email address of this receiver.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the email receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class ActionGroupEventHubReceiverArgsDict(TypedDict):
        event_hub_name: pulumi.Input[str]
        """
        The name of the specific Event Hub queue.
        """
        event_hub_namespace: pulumi.Input[str]
        """
        The namespace name of the Event Hub.
        """
        name: pulumi.Input[str]
        """
        The name of the EventHub Receiver, must be unique within action group.
        """
        subscription_id: NotRequired[pulumi.Input[str]]
        """
        The ID for the subscription containing this Event Hub. Default to the subscription ID of the Action Group.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID for the subscription containing this Event Hub.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to use common alert schema.
        """
elif False:
    ActionGroupEventHubReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupEventHubReceiverArgs:
    def __init__(__self__, *,
                 event_hub_name: pulumi.Input[str],
                 event_hub_namespace: pulumi.Input[str],
                 name: pulumi.Input[str],
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 use_common_alert_schema: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] event_hub_name: The name of the specific Event Hub queue.
        :param pulumi.Input[str] event_hub_namespace: The namespace name of the Event Hub.
        :param pulumi.Input[str] name: The name of the EventHub Receiver, must be unique within action group.
        :param pulumi.Input[str] subscription_id: The ID for the subscription containing this Event Hub. Default to the subscription ID of the Action Group.
        :param pulumi.Input[str] tenant_id: The Tenant ID for the subscription containing this Event Hub.
        :param pulumi.Input[bool] use_common_alert_schema: Indicates whether to use common alert schema.
        """
        pulumi.set(__self__, "event_hub_name", event_hub_name)
        pulumi.set(__self__, "event_hub_namespace", event_hub_namespace)
        pulumi.set(__self__, "name", name)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> pulumi.Input[str]:
        """
        The name of the specific Event Hub queue.
        """
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="eventHubNamespace")
    def event_hub_namespace(self) -> pulumi.Input[str]:
        """
        The namespace name of the Event Hub.
        """
        return pulumi.get(self, "event_hub_namespace")

    @event_hub_namespace.setter
    def event_hub_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_hub_namespace", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the EventHub Receiver, must be unique within action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID for the subscription containing this Event Hub. Default to the subscription ID of the Action Group.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID for the subscription containing this Event Hub.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to use common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class ActionGroupItsmReceiverArgsDict(TypedDict):
        connection_id: pulumi.Input[str]
        """
        The unique connection identifier of the ITSM connection.
        """
        name: pulumi.Input[str]
        """
        The name of the ITSM receiver.
        """
        region: pulumi.Input[str]
        """
        The region of the workspace.

        > **NOTE** `ticket_configuration` should be JSON blob with `PayloadRevision` and `WorkItemType` keys (e.g., `ticket_configuration="{\\"PayloadRevision\\":0,\\"WorkItemType\\":\\"Incident\\"}"`), and `ticket_configuration="{}"` will return an error, see more at this [REST API issue](https://github.com/Azure/azure-rest-api-specs/issues/20488)
        """
        ticket_configuration: pulumi.Input[str]
        """
        A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        """
        workspace_id: pulumi.Input[str]
        """
        The Azure Log Analytics workspace ID where this connection is defined. Format is `<subscription id>|<workspace id>`, for example `00000000-0000-0000-0000-000000000000|00000000-0000-0000-0000-000000000000`.
        """
elif False:
    ActionGroupItsmReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupItsmReceiverArgs:
    def __init__(__self__, *,
                 connection_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 region: pulumi.Input[str],
                 ticket_configuration: pulumi.Input[str],
                 workspace_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] connection_id: The unique connection identifier of the ITSM connection.
        :param pulumi.Input[str] name: The name of the ITSM receiver.
        :param pulumi.Input[str] region: The region of the workspace.
               
               > **NOTE** `ticket_configuration` should be JSON blob with `PayloadRevision` and `WorkItemType` keys (e.g., `ticket_configuration="{\\"PayloadRevision\\":0,\\"WorkItemType\\":\\"Incident\\"}"`), and `ticket_configuration="{}"` will return an error, see more at this [REST API issue](https://github.com/Azure/azure-rest-api-specs/issues/20488)
        :param pulumi.Input[str] ticket_configuration: A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        :param pulumi.Input[str] workspace_id: The Azure Log Analytics workspace ID where this connection is defined. Format is `<subscription id>|<workspace id>`, for example `00000000-0000-0000-0000-000000000000|00000000-0000-0000-0000-000000000000`.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "ticket_configuration", ticket_configuration)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> pulumi.Input[str]:
        """
        The unique connection identifier of the ITSM connection.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the ITSM receiver.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the workspace.

        > **NOTE** `ticket_configuration` should be JSON blob with `PayloadRevision` and `WorkItemType` keys (e.g., `ticket_configuration="{\\"PayloadRevision\\":0,\\"WorkItemType\\":\\"Incident\\"}"`), and `ticket_configuration="{}"` will return an error, see more at this [REST API issue](https://github.com/Azure/azure-rest-api-specs/issues/20488)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="ticketConfiguration")
    def ticket_configuration(self) -> pulumi.Input[str]:
        """
        A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
        """
        return pulumi.get(self, "ticket_configuration")

    @ticket_configuration.setter
    def ticket_configuration(self, value: pulumi.Input[str]):
        pulumi.set(self, "ticket_configuration", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> pulumi.Input[str]:
        """
        The Azure Log Analytics workspace ID where this connection is defined. Format is `<subscription id>|<workspace id>`, for example `00000000-0000-0000-0000-000000000000|00000000-0000-0000-0000-000000000000`.
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_id", value)


if not MYPY:
    class ActionGroupLogicAppReceiverArgsDict(TypedDict):
        callback_url: pulumi.Input[str]
        """
        The callback url where HTTP request sent to.
        """
        name: pulumi.Input[str]
        """
        The name of the logic app receiver.
        """
        resource_id: pulumi.Input[str]
        """
        The Azure resource ID of the logic app.
        """
        use_common_alert_schema: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the common alert schema.
        """
elif False:
    ActionGroupLogicAppReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupLogicAppReceiverArgs:
    def __init__(__self__, *,
                 callback_url: pulumi.Input[str],
                 name: pulumi.Input[str],
                 resource_id: pulumi.Input[str],
                 use_common_alert_schema: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] callback_url: The callback url where HTTP request sent to.
        :param pulumi.Input[str] name: The name of the logic app receiver.
        :param pulumi.Input[str] resource_id: The Azure resource ID of the logic app.
        :param pulumi.Input[bool] use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "callback_url", callback_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_id", resource_id)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter(name="callbackUrl")
    def callback_url(self) -> pulumi.Input[str]:
        """
        The callback url where HTTP request sent to.
        """
        return pulumi.get(self, "callback_url")

    @callback_url.setter
    def callback_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "callback_url", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the logic app receiver.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        The Azure resource ID of the logic app.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class ActionGroupSmsReceiverArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code of the SMS receiver.
        """
        name: pulumi.Input[str]
        """
        The name of the SMS receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        """
        phone_number: pulumi.Input[str]
        """
        The phone number of the SMS receiver.
        """
elif False:
    ActionGroupSmsReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupSmsReceiverArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str],
                 name: pulumi.Input[str],
                 phone_number: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code of the SMS receiver.
        :param pulumi.Input[str] name: The name of the SMS receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        :param pulumi.Input[str] phone_number: The phone number of the SMS receiver.
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code of the SMS receiver.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the SMS receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[str]:
        """
        The phone number of the SMS receiver.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ActionGroupVoiceReceiverArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code of the voice receiver.
        """
        name: pulumi.Input[str]
        """
        The name of the voice receiver.
        """
        phone_number: pulumi.Input[str]
        """
        The phone number of the voice receiver.
        """
elif False:
    ActionGroupVoiceReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupVoiceReceiverArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str],
                 name: pulumi.Input[str],
                 phone_number: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code of the voice receiver.
        :param pulumi.Input[str] name: The name of the voice receiver.
        :param pulumi.Input[str] phone_number: The phone number of the voice receiver.
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code of the voice receiver.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the voice receiver.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[str]:
        """
        The phone number of the voice receiver.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ActionGroupWebhookReceiverArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        """
        service_uri: pulumi.Input[str]
        """
        The URI where webhooks should be sent.
        """
        aad_auth: NotRequired[pulumi.Input['ActionGroupWebhookReceiverAadAuthArgsDict']]
        """
        The `aad_auth` block as defined below.

        > **NOTE:** Before adding a secure webhook receiver by setting `aad_auth`, please read [the configuration instruction of the AAD application](https://docs.microsoft.com/azure/azure-monitor/platform/action-groups#secure-webhook).
        """
        use_common_alert_schema: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables the common alert schema.
        """
elif False:
    ActionGroupWebhookReceiverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupWebhookReceiverArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 service_uri: pulumi.Input[str],
                 aad_auth: Optional[pulumi.Input['ActionGroupWebhookReceiverAadAuthArgs']] = None,
                 use_common_alert_schema: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        :param pulumi.Input[str] service_uri: The URI where webhooks should be sent.
        :param pulumi.Input['ActionGroupWebhookReceiverAadAuthArgs'] aad_auth: The `aad_auth` block as defined below.
               
               > **NOTE:** Before adding a secure webhook receiver by setting `aad_auth`, please read [the configuration instruction of the AAD application](https://docs.microsoft.com/azure/azure-monitor/platform/action-groups#secure-webhook).
        :param pulumi.Input[bool] use_common_alert_schema: Enables or disables the common alert schema.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_uri", service_uri)
        if aad_auth is not None:
            pulumi.set(__self__, "aad_auth", aad_auth)
        if use_common_alert_schema is not None:
            pulumi.set(__self__, "use_common_alert_schema", use_common_alert_schema)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> pulumi.Input[str]:
        """
        The URI where webhooks should be sent.
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_uri", value)

    @property
    @pulumi.getter(name="aadAuth")
    def aad_auth(self) -> Optional[pulumi.Input['ActionGroupWebhookReceiverAadAuthArgs']]:
        """
        The `aad_auth` block as defined below.

        > **NOTE:** Before adding a secure webhook receiver by setting `aad_auth`, please read [the configuration instruction of the AAD application](https://docs.microsoft.com/azure/azure-monitor/platform/action-groups#secure-webhook).
        """
        return pulumi.get(self, "aad_auth")

    @aad_auth.setter
    def aad_auth(self, value: Optional[pulumi.Input['ActionGroupWebhookReceiverAadAuthArgs']]):
        pulumi.set(self, "aad_auth", value)

    @property
    @pulumi.getter(name="useCommonAlertSchema")
    def use_common_alert_schema(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables the common alert schema.
        """
        return pulumi.get(self, "use_common_alert_schema")

    @use_common_alert_schema.setter
    def use_common_alert_schema(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_common_alert_schema", value)


if not MYPY:
    class ActionGroupWebhookReceiverAadAuthArgsDict(TypedDict):
        object_id: pulumi.Input[str]
        """
        The webhook application object Id for AAD auth.
        """
        identifier_uri: NotRequired[pulumi.Input[str]]
        """
        The identifier URI for AAD auth.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The tenant id for AAD auth.
        """
elif False:
    ActionGroupWebhookReceiverAadAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupWebhookReceiverAadAuthArgs:
    def __init__(__self__, *,
                 object_id: pulumi.Input[str],
                 identifier_uri: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] object_id: The webhook application object Id for AAD auth.
        :param pulumi.Input[str] identifier_uri: The identifier URI for AAD auth.
        :param pulumi.Input[str] tenant_id: The tenant id for AAD auth.
        """
        pulumi.set(__self__, "object_id", object_id)
        if identifier_uri is not None:
            pulumi.set(__self__, "identifier_uri", identifier_uri)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> pulumi.Input[str]:
        """
        The webhook application object Id for AAD auth.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="identifierUri")
    def identifier_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier URI for AAD auth.
        """
        return pulumi.get(self, "identifier_uri")

    @identifier_uri.setter
    def identifier_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identifier_uri", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant id for AAD auth.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ActivityLogAlertActionArgsDict(TypedDict):
        action_group_id: pulumi.Input[str]
        """
        The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource.
        """
        webhook_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
elif False:
    ActivityLogAlertActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActivityLogAlertActionArgs:
    def __init__(__self__, *,
                 action_group_id: pulumi.Input[str],
                 webhook_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] action_group_id: The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] webhook_properties: The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
        pulumi.set(__self__, "action_group_id", action_group_id)
        if webhook_properties is not None:
            pulumi.set(__self__, "webhook_properties", webhook_properties)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> pulumi.Input[str]:
        """
        The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource.
        """
        return pulumi.get(self, "action_group_id")

    @action_group_id.setter
    def action_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_group_id", value)

    @property
    @pulumi.getter(name="webhookProperties")
    def webhook_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
        return pulumi.get(self, "webhook_properties")

    @webhook_properties.setter
    def webhook_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "webhook_properties", value)


if not MYPY:
    class ActivityLogAlertCriteriaArgsDict(TypedDict):
        category: pulumi.Input[str]
        """
        The category of the operation. Possible values are `Administrative`, `Autoscale`, `Policy`, `Recommendation`, `ResourceHealth`, `Security` and `ServiceHealth`.
        """
        caller: NotRequired[pulumi.Input[str]]
        """
        The email address or Azure Active Directory identifier of the user who performed the operation.
        """
        level: NotRequired[pulumi.Input[str]]
        """
        The severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
        """
        levels: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.

        > **NOTE:** `level` and `levels` are mutually exclusive.
        """
        operation_name: NotRequired[pulumi.Input[str]]
        """
        The Resource Manager Role-Based Access Control operation name. Supported operation should be of the form: `<resourceProvider>/<resourceType>/<operation>`.
        """
        recommendation_category: NotRequired[pulumi.Input[str]]
        """
        The recommendation category of the event. Possible values are `Cost`, `Reliability`, `OperationalExcellence`, `HighAvailability` and `Performance`. It is only allowed when `category` is `Recommendation`.
        """
        recommendation_impact: NotRequired[pulumi.Input[str]]
        """
        The recommendation impact of the event. Possible values are `High`, `Medium` and `Low`. It is only allowed when `category` is `Recommendation`.
        """
        recommendation_type: NotRequired[pulumi.Input[str]]
        """
        The recommendation type of the event. It is only allowed when `category` is `Recommendation`.
        """
        resource_group: NotRequired[pulumi.Input[str]]
        """
        The name of resource group monitored by the activity log alert.
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of names of resource groups monitored by the activity log alert.

        > **NOTE:** `resource_group` and `resource_groups` are mutually exclusive.
        """
        resource_health: NotRequired[pulumi.Input['ActivityLogAlertCriteriaResourceHealthArgsDict']]
        """
        A block to define fine grain resource health settings.
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        The specific resource monitored by the activity log alert. It should be within one of the `scopes`.
        """
        resource_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of specific resources monitored by the activity log alert. It should be within one of the `scopes`.

        > **NOTE:** `resource_id` and `resource_ids` are mutually exclusive.
        """
        resource_provider: NotRequired[pulumi.Input[str]]
        """
        The name of the resource provider monitored by the activity log alert.
        """
        resource_providers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of names of resource providers monitored by the activity log alert.

        > **NOTE:** `resource_provider` and `resource_providers` are mutually exclusive.
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        The resource type monitored by the activity log alert.
        """
        resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of resource types monitored by the activity log alert.

        > **NOTE:** `resource_type` and `resource_types` are mutually exclusive.
        """
        service_health: NotRequired[pulumi.Input['ActivityLogAlertCriteriaServiceHealthArgsDict']]
        """
        A block to define fine grain service health settings.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        The status of the event. For example, `Started`, `Failed`, or `Succeeded`.
        """
        statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of status of the event. For example, `Started`, `Failed`, or `Succeeded`.

        > **NOTE:** `status` and `statuses` are mutually exclusive.
        """
        sub_status: NotRequired[pulumi.Input[str]]
        """
        The sub status of the event.
        """
        sub_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of sub status of the event.

        > **NOTE:** `sub_status` and `sub_statuses` are mutually exclusive.
        """
elif False:
    ActivityLogAlertCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActivityLogAlertCriteriaArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[str],
                 caller: Optional[pulumi.Input[str]] = None,
                 level: Optional[pulumi.Input[str]] = None,
                 levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 recommendation_category: Optional[pulumi.Input[str]] = None,
                 recommendation_impact: Optional[pulumi.Input[str]] = None,
                 recommendation_type: Optional[pulumi.Input[str]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_health: Optional[pulumi.Input['ActivityLogAlertCriteriaResourceHealthArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None,
                 resource_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_provider: Optional[pulumi.Input[str]] = None,
                 resource_providers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_health: Optional[pulumi.Input['ActivityLogAlertCriteriaServiceHealthArgs']] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sub_status: Optional[pulumi.Input[str]] = None,
                 sub_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] category: The category of the operation. Possible values are `Administrative`, `Autoscale`, `Policy`, `Recommendation`, `ResourceHealth`, `Security` and `ServiceHealth`.
        :param pulumi.Input[str] caller: The email address or Azure Active Directory identifier of the user who performed the operation.
        :param pulumi.Input[str] level: The severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] levels: A list of severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
               
               > **NOTE:** `level` and `levels` are mutually exclusive.
        :param pulumi.Input[str] operation_name: The Resource Manager Role-Based Access Control operation name. Supported operation should be of the form: `<resourceProvider>/<resourceType>/<operation>`.
        :param pulumi.Input[str] recommendation_category: The recommendation category of the event. Possible values are `Cost`, `Reliability`, `OperationalExcellence`, `HighAvailability` and `Performance`. It is only allowed when `category` is `Recommendation`.
        :param pulumi.Input[str] recommendation_impact: The recommendation impact of the event. Possible values are `High`, `Medium` and `Low`. It is only allowed when `category` is `Recommendation`.
        :param pulumi.Input[str] recommendation_type: The recommendation type of the event. It is only allowed when `category` is `Recommendation`.
        :param pulumi.Input[str] resource_group: The name of resource group monitored by the activity log alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: A list of names of resource groups monitored by the activity log alert.
               
               > **NOTE:** `resource_group` and `resource_groups` are mutually exclusive.
        :param pulumi.Input['ActivityLogAlertCriteriaResourceHealthArgs'] resource_health: A block to define fine grain resource health settings.
        :param pulumi.Input[str] resource_id: The specific resource monitored by the activity log alert. It should be within one of the `scopes`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_ids: A list of specific resources monitored by the activity log alert. It should be within one of the `scopes`.
               
               > **NOTE:** `resource_id` and `resource_ids` are mutually exclusive.
        :param pulumi.Input[str] resource_provider: The name of the resource provider monitored by the activity log alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_providers: A list of names of resource providers monitored by the activity log alert.
               
               > **NOTE:** `resource_provider` and `resource_providers` are mutually exclusive.
        :param pulumi.Input[str] resource_type: The resource type monitored by the activity log alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_types: A list of resource types monitored by the activity log alert.
               
               > **NOTE:** `resource_type` and `resource_types` are mutually exclusive.
        :param pulumi.Input['ActivityLogAlertCriteriaServiceHealthArgs'] service_health: A block to define fine grain service health settings.
        :param pulumi.Input[str] status: The status of the event. For example, `Started`, `Failed`, or `Succeeded`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] statuses: A list of status of the event. For example, `Started`, `Failed`, or `Succeeded`.
               
               > **NOTE:** `status` and `statuses` are mutually exclusive.
        :param pulumi.Input[str] sub_status: The sub status of the event.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sub_statuses: A list of sub status of the event.
               
               > **NOTE:** `sub_status` and `sub_statuses` are mutually exclusive.
        """
        pulumi.set(__self__, "category", category)
        if caller is not None:
            pulumi.set(__self__, "caller", caller)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if levels is not None:
            pulumi.set(__self__, "levels", levels)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if recommendation_category is not None:
            pulumi.set(__self__, "recommendation_category", recommendation_category)
        if recommendation_impact is not None:
            pulumi.set(__self__, "recommendation_impact", recommendation_impact)
        if recommendation_type is not None:
            pulumi.set(__self__, "recommendation_type", recommendation_type)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)
        if resource_health is not None:
            pulumi.set(__self__, "resource_health", resource_health)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_ids is not None:
            pulumi.set(__self__, "resource_ids", resource_ids)
        if resource_provider is not None:
            pulumi.set(__self__, "resource_provider", resource_provider)
        if resource_providers is not None:
            pulumi.set(__self__, "resource_providers", resource_providers)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if service_health is not None:
            pulumi.set(__self__, "service_health", service_health)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if sub_statuses is not None:
            pulumi.set(__self__, "sub_statuses", sub_statuses)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[str]:
        """
        The category of the operation. Possible values are `Administrative`, `Autoscale`, `Policy`, `Recommendation`, `ResourceHealth`, `Security` and `ServiceHealth`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def caller(self) -> Optional[pulumi.Input[str]]:
        """
        The email address or Azure Active Directory identifier of the user who performed the operation.
        """
        return pulumi.get(self, "caller")

    @caller.setter
    def caller(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caller", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        The severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.

        > **NOTE:** `level` and `levels` are mutually exclusive.
        """
        return pulumi.get(self, "levels")

    @levels.setter
    def levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "levels", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Resource Manager Role-Based Access Control operation name. Supported operation should be of the form: `<resourceProvider>/<resourceType>/<operation>`.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="recommendationCategory")
    def recommendation_category(self) -> Optional[pulumi.Input[str]]:
        """
        The recommendation category of the event. Possible values are `Cost`, `Reliability`, `OperationalExcellence`, `HighAvailability` and `Performance`. It is only allowed when `category` is `Recommendation`.
        """
        return pulumi.get(self, "recommendation_category")

    @recommendation_category.setter
    def recommendation_category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation_category", value)

    @property
    @pulumi.getter(name="recommendationImpact")
    def recommendation_impact(self) -> Optional[pulumi.Input[str]]:
        """
        The recommendation impact of the event. Possible values are `High`, `Medium` and `Low`. It is only allowed when `category` is `Recommendation`.
        """
        return pulumi.get(self, "recommendation_impact")

    @recommendation_impact.setter
    def recommendation_impact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation_impact", value)

    @property
    @pulumi.getter(name="recommendationType")
    def recommendation_type(self) -> Optional[pulumi.Input[str]]:
        """
        The recommendation type of the event. It is only allowed when `category` is `Recommendation`.
        """
        return pulumi.get(self, "recommendation_type")

    @recommendation_type.setter
    def recommendation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation_type", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        The name of resource group monitored by the activity log alert.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of names of resource groups monitored by the activity log alert.

        > **NOTE:** `resource_group` and `resource_groups` are mutually exclusive.
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)

    @property
    @pulumi.getter(name="resourceHealth")
    def resource_health(self) -> Optional[pulumi.Input['ActivityLogAlertCriteriaResourceHealthArgs']]:
        """
        A block to define fine grain resource health settings.
        """
        return pulumi.get(self, "resource_health")

    @resource_health.setter
    def resource_health(self, value: Optional[pulumi.Input['ActivityLogAlertCriteriaResourceHealthArgs']]):
        pulumi.set(self, "resource_health", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The specific resource monitored by the activity log alert. It should be within one of the `scopes`.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of specific resources monitored by the activity log alert. It should be within one of the `scopes`.

        > **NOTE:** `resource_id` and `resource_ids` are mutually exclusive.
        """
        return pulumi.get(self, "resource_ids")

    @resource_ids.setter
    def resource_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_ids", value)

    @property
    @pulumi.getter(name="resourceProvider")
    def resource_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the resource provider monitored by the activity log alert.
        """
        return pulumi.get(self, "resource_provider")

    @resource_provider.setter
    def resource_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_provider", value)

    @property
    @pulumi.getter(name="resourceProviders")
    def resource_providers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of names of resource providers monitored by the activity log alert.

        > **NOTE:** `resource_provider` and `resource_providers` are mutually exclusive.
        """
        return pulumi.get(self, "resource_providers")

    @resource_providers.setter
    def resource_providers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_providers", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        The resource type monitored by the activity log alert.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of resource types monitored by the activity log alert.

        > **NOTE:** `resource_type` and `resource_types` are mutually exclusive.
        """
        return pulumi.get(self, "resource_types")

    @resource_types.setter
    def resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_types", value)

    @property
    @pulumi.getter(name="serviceHealth")
    def service_health(self) -> Optional[pulumi.Input['ActivityLogAlertCriteriaServiceHealthArgs']]:
        """
        A block to define fine grain service health settings.
        """
        return pulumi.get(self, "service_health")

    @service_health.setter
    def service_health(self, value: Optional[pulumi.Input['ActivityLogAlertCriteriaServiceHealthArgs']]):
        pulumi.set(self, "service_health", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the event. For example, `Started`, `Failed`, or `Succeeded`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of status of the event. For example, `Started`, `Failed`, or `Succeeded`.

        > **NOTE:** `status` and `statuses` are mutually exclusive.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statuses", value)

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[pulumi.Input[str]]:
        """
        The sub status of the event.
        """
        return pulumi.get(self, "sub_status")

    @sub_status.setter
    def sub_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_status", value)

    @property
    @pulumi.getter(name="subStatuses")
    def sub_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of sub status of the event.

        > **NOTE:** `sub_status` and `sub_statuses` are mutually exclusive.
        """
        return pulumi.get(self, "sub_statuses")

    @sub_statuses.setter
    def sub_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sub_statuses", value)


if not MYPY:
    class ActivityLogAlertCriteriaResourceHealthArgsDict(TypedDict):
        currents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The current resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        """
        previouses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The previous resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        """
        reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The reason that will log an alert. Possible values are `PlatformInitiated` (such as a problem with the resource in an affected region of an Azure incident), `UserInitiated` (such as a shutdown request of a VM) and `Unknown`.
        """
elif False:
    ActivityLogAlertCriteriaResourceHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActivityLogAlertCriteriaResourceHealthArgs:
    def __init__(__self__, *,
                 currents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 previouses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 reasons: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] currents: The current resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] previouses: The previous resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] reasons: The reason that will log an alert. Possible values are `PlatformInitiated` (such as a problem with the resource in an affected region of an Azure incident), `UserInitiated` (such as a shutdown request of a VM) and `Unknown`.
        """
        if currents is not None:
            pulumi.set(__self__, "currents", currents)
        if previouses is not None:
            pulumi.set(__self__, "previouses", previouses)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)

    @property
    @pulumi.getter
    def currents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The current resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        """
        return pulumi.get(self, "currents")

    @currents.setter
    def currents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "currents", value)

    @property
    @pulumi.getter
    def previouses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The previous resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
        """
        return pulumi.get(self, "previouses")

    @previouses.setter
    def previouses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "previouses", value)

    @property
    @pulumi.getter
    def reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The reason that will log an alert. Possible values are `PlatformInitiated` (such as a problem with the resource in an affected region of an Azure incident), `UserInitiated` (such as a shutdown request of a VM) and `Unknown`.
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "reasons", value)


if not MYPY:
    class ActivityLogAlertCriteriaServiceHealthArgsDict(TypedDict):
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Events this alert will monitor Possible values are `Incident`, `Maintenance`, `Informational`, `ActionRequired` and `Security`.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Locations this alert will monitor. For example, `West Europe`.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Services this alert will monitor. For example, `Activity Logs & Alerts`, `Action Groups`. Defaults to all Services.
        """
elif False:
    ActivityLogAlertCriteriaServiceHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActivityLogAlertCriteriaServiceHealthArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events: Events this alert will monitor Possible values are `Incident`, `Maintenance`, `Informational`, `ActionRequired` and `Security`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: Locations this alert will monitor. For example, `West Europe`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: Services this alert will monitor. For example, `Activity Logs & Alerts`, `Action Groups`. Defaults to all Services.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Events this alert will monitor Possible values are `Incident`, `Maintenance`, `Informational`, `ActionRequired` and `Security`.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Locations this alert will monitor. For example, `West Europe`.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Services this alert will monitor. For example, `Activity Logs & Alerts`, `Action Groups`. Defaults to all Services.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionArgsDict(TypedDict):
        alert_context: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertContextArgsDict']]
        """
        A `alert_context` block as defined above.
        """
        alert_rule_id: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleIdArgsDict']]
        """
        A `alert_rule_id` block as defined above.
        """
        alert_rule_name: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleNameArgsDict']]
        """
        A `alert_rule_name` block as defined above.
        """
        description: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionDescriptionArgsDict']]
        """
        A `description` block as defined below.
        """
        monitor_condition: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorConditionArgsDict']]
        """
        A `monitor_condition` block as defined below.
        """
        monitor_service: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorServiceArgsDict']]
        """
        A `monitor_service` block as defined below.
        """
        severity: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionSeverityArgsDict']]
        """
        A `severity` block as defined below.
        """
        signal_type: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionSignalTypeArgsDict']]
        """
        A `signal_type` block as defined below.
        """
        target_resource: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceArgsDict']]
        """
        A `target_resource` block as defined below.
        """
        target_resource_group: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceGroupArgsDict']]
        """
        A `target_resource_group` block as defined below.
        """
        target_resource_type: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceTypeArgsDict']]
        """
        A `target_resource_type` block as defined below.

        > **Note:** At least one of the `alert_context`, `alert_rule_id`, `alert_rule_name`, `description`, `monitor_condition`, `monitor_service`, `severity`, `signal_type`, `target_resource`, `target_resource_group`, `target_resource_type` must be specified.
        """
elif False:
    AlertProcessingRuleActionGroupConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionArgs:
    def __init__(__self__, *,
                 alert_context: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertContextArgs']] = None,
                 alert_rule_id: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleIdArgs']] = None,
                 alert_rule_name: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleNameArgs']] = None,
                 description: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionDescriptionArgs']] = None,
                 monitor_condition: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorConditionArgs']] = None,
                 monitor_service: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorServiceArgs']] = None,
                 severity: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionSeverityArgs']] = None,
                 signal_type: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionSignalTypeArgs']] = None,
                 target_resource: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceArgs']] = None,
                 target_resource_group: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceGroupArgs']] = None,
                 target_resource_type: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceTypeArgs']] = None):
        """
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionAlertContextArgs'] alert_context: A `alert_context` block as defined above.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleIdArgs'] alert_rule_id: A `alert_rule_id` block as defined above.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleNameArgs'] alert_rule_name: A `alert_rule_name` block as defined above.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionDescriptionArgs'] description: A `description` block as defined below.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorConditionArgs'] monitor_condition: A `monitor_condition` block as defined below.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorServiceArgs'] monitor_service: A `monitor_service` block as defined below.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionSeverityArgs'] severity: A `severity` block as defined below.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionSignalTypeArgs'] signal_type: A `signal_type` block as defined below.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceArgs'] target_resource: A `target_resource` block as defined below.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceGroupArgs'] target_resource_group: A `target_resource_group` block as defined below.
        :param pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceTypeArgs'] target_resource_type: A `target_resource_type` block as defined below.
               
               > **Note:** At least one of the `alert_context`, `alert_rule_id`, `alert_rule_name`, `description`, `monitor_condition`, `monitor_service`, `severity`, `signal_type`, `target_resource`, `target_resource_group`, `target_resource_type` must be specified.
        """
        if alert_context is not None:
            pulumi.set(__self__, "alert_context", alert_context)
        if alert_rule_id is not None:
            pulumi.set(__self__, "alert_rule_id", alert_rule_id)
        if alert_rule_name is not None:
            pulumi.set(__self__, "alert_rule_name", alert_rule_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if monitor_condition is not None:
            pulumi.set(__self__, "monitor_condition", monitor_condition)
        if monitor_service is not None:
            pulumi.set(__self__, "monitor_service", monitor_service)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if signal_type is not None:
            pulumi.set(__self__, "signal_type", signal_type)
        if target_resource is not None:
            pulumi.set(__self__, "target_resource", target_resource)
        if target_resource_group is not None:
            pulumi.set(__self__, "target_resource_group", target_resource_group)
        if target_resource_type is not None:
            pulumi.set(__self__, "target_resource_type", target_resource_type)

    @property
    @pulumi.getter(name="alertContext")
    def alert_context(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertContextArgs']]:
        """
        A `alert_context` block as defined above.
        """
        return pulumi.get(self, "alert_context")

    @alert_context.setter
    def alert_context(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertContextArgs']]):
        pulumi.set(self, "alert_context", value)

    @property
    @pulumi.getter(name="alertRuleId")
    def alert_rule_id(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleIdArgs']]:
        """
        A `alert_rule_id` block as defined above.
        """
        return pulumi.get(self, "alert_rule_id")

    @alert_rule_id.setter
    def alert_rule_id(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleIdArgs']]):
        pulumi.set(self, "alert_rule_id", value)

    @property
    @pulumi.getter(name="alertRuleName")
    def alert_rule_name(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleNameArgs']]:
        """
        A `alert_rule_name` block as defined above.
        """
        return pulumi.get(self, "alert_rule_name")

    @alert_rule_name.setter
    def alert_rule_name(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionAlertRuleNameArgs']]):
        pulumi.set(self, "alert_rule_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionDescriptionArgs']]:
        """
        A `description` block as defined below.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionDescriptionArgs']]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="monitorCondition")
    def monitor_condition(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorConditionArgs']]:
        """
        A `monitor_condition` block as defined below.
        """
        return pulumi.get(self, "monitor_condition")

    @monitor_condition.setter
    def monitor_condition(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorConditionArgs']]):
        pulumi.set(self, "monitor_condition", value)

    @property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorServiceArgs']]:
        """
        A `monitor_service` block as defined below.
        """
        return pulumi.get(self, "monitor_service")

    @monitor_service.setter
    def monitor_service(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionMonitorServiceArgs']]):
        pulumi.set(self, "monitor_service", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionSeverityArgs']]:
        """
        A `severity` block as defined below.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionSeverityArgs']]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter(name="signalType")
    def signal_type(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionSignalTypeArgs']]:
        """
        A `signal_type` block as defined below.
        """
        return pulumi.get(self, "signal_type")

    @signal_type.setter
    def signal_type(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionSignalTypeArgs']]):
        pulumi.set(self, "signal_type", value)

    @property
    @pulumi.getter(name="targetResource")
    def target_resource(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceArgs']]:
        """
        A `target_resource` block as defined below.
        """
        return pulumi.get(self, "target_resource")

    @target_resource.setter
    def target_resource(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceArgs']]):
        pulumi.set(self, "target_resource", value)

    @property
    @pulumi.getter(name="targetResourceGroup")
    def target_resource_group(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceGroupArgs']]:
        """
        A `target_resource_group` block as defined below.
        """
        return pulumi.get(self, "target_resource_group")

    @target_resource_group.setter
    def target_resource_group(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceGroupArgs']]):
        pulumi.set(self, "target_resource_group", value)

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceTypeArgs']]:
        """
        A `target_resource_type` block as defined below.

        > **Note:** At least one of the `alert_context`, `alert_rule_id`, `alert_rule_name`, `description`, `monitor_condition`, `monitor_service`, `severity`, `signal_type`, `target_resource`, `target_resource_group`, `target_resource_type` must be specified.
        """
        return pulumi.get(self, "target_resource_type")

    @target_resource_type.setter
    def target_resource_type(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupConditionTargetResourceTypeArgs']]):
        pulumi.set(self, "target_resource_type", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionAlertContextArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition.
        """
elif False:
    AlertProcessingRuleActionGroupConditionAlertContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionAlertContextArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionAlertRuleIdArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition.
        """
elif False:
    AlertProcessingRuleActionGroupConditionAlertRuleIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionAlertRuleIdArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionAlertRuleNameArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition.
        """
elif False:
    AlertProcessingRuleActionGroupConditionAlertRuleNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionAlertRuleNameArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionDescriptionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition.
        """
elif False:
    AlertProcessingRuleActionGroupConditionDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionDescriptionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionMonitorConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
elif False:
    AlertProcessingRuleActionGroupConditionMonitorConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionMonitorConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionMonitorServiceArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
elif False:
    AlertProcessingRuleActionGroupConditionMonitorServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionMonitorServiceArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionSeverityArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
elif False:
    AlertProcessingRuleActionGroupConditionSeverityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionSeverityArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionSignalTypeArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
elif False:
    AlertProcessingRuleActionGroupConditionSignalTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionSignalTypeArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionTargetResourceArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of values to match for a given condition. The values should be valid resource IDs.
        """
elif False:
    AlertProcessingRuleActionGroupConditionTargetResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionTargetResourceArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to match for a given condition. The values should be valid resource IDs.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to match for a given condition. The values should be valid resource IDs.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionTargetResourceGroupArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of values to match for a given condition. The values should be valid resource group IDs.
        """
elif False:
    AlertProcessingRuleActionGroupConditionTargetResourceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionTargetResourceGroupArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to match for a given condition. The values should be valid resource group IDs.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to match for a given condition. The values should be valid resource group IDs.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupConditionTargetResourceTypeArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
elif False:
    AlertProcessingRuleActionGroupConditionTargetResourceTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupConditionTargetResourceTypeArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleActionGroupScheduleArgsDict(TypedDict):
        effective_from: NotRequired[pulumi.Input[str]]
        """
        Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        """
        effective_until: NotRequired[pulumi.Input[str]]
        """
        Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        """
        recurrence: NotRequired[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceArgsDict']]
        """
        A `recurrence` block as defined above.
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
elif False:
    AlertProcessingRuleActionGroupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupScheduleArgs:
    def __init__(__self__, *,
                 effective_from: Optional[pulumi.Input[str]] = None,
                 effective_until: Optional[pulumi.Input[str]] = None,
                 recurrence: Optional[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceArgs']] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective_from: Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        :param pulumi.Input[str] effective_until: Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        :param pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceArgs'] recurrence: A `recurrence` block as defined above.
        :param pulumi.Input[str] time_zone: The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
        if effective_from is not None:
            pulumi.set(__self__, "effective_from", effective_from)
        if effective_until is not None:
            pulumi.set(__self__, "effective_until", effective_until)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="effectiveFrom")
    def effective_from(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        """
        return pulumi.get(self, "effective_from")

    @effective_from.setter
    def effective_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_from", value)

    @property
    @pulumi.getter(name="effectiveUntil")
    def effective_until(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        """
        return pulumi.get(self, "effective_until")

    @effective_until.setter
    def effective_until(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_until", value)

    @property
    @pulumi.getter
    def recurrence(self) -> Optional[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceArgs']]:
        """
        A `recurrence` block as defined above.
        """
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: Optional[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceArgs']]):
        pulumi.set(self, "recurrence", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class AlertProcessingRuleActionGroupScheduleRecurrenceArgsDict(TypedDict):
        dailies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgsDict']]]]
        """
        One or more `daily` blocks as defined above.
        """
        monthlies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgsDict']]]]
        """
        One or more `monthly` blocks as defined above.
        """
        weeklies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgsDict']]]]
        """
        One or more `weekly` blocks as defined below.
        """
elif False:
    AlertProcessingRuleActionGroupScheduleRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupScheduleRecurrenceArgs:
    def __init__(__self__, *,
                 dailies: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgs']]]] = None,
                 monthlies: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgs']]]] = None,
                 weeklies: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgs']]] dailies: One or more `daily` blocks as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgs']]] monthlies: One or more `monthly` blocks as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgs']]] weeklies: One or more `weekly` blocks as defined below.
        """
        if dailies is not None:
            pulumi.set(__self__, "dailies", dailies)
        if monthlies is not None:
            pulumi.set(__self__, "monthlies", monthlies)
        if weeklies is not None:
            pulumi.set(__self__, "weeklies", weeklies)

    @property
    @pulumi.getter
    def dailies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgs']]]]:
        """
        One or more `daily` blocks as defined above.
        """
        return pulumi.get(self, "dailies")

    @dailies.setter
    def dailies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgs']]]]):
        pulumi.set(self, "dailies", value)

    @property
    @pulumi.getter
    def monthlies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgs']]]]:
        """
        One or more `monthly` blocks as defined above.
        """
        return pulumi.get(self, "monthlies")

    @monthlies.setter
    def monthlies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgs']]]]):
        pulumi.set(self, "monthlies", value)

    @property
    @pulumi.getter
    def weeklies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgs']]]]:
        """
        One or more `weekly` blocks as defined below.
        """
        return pulumi.get(self, "weeklies")

    @weeklies.setter
    def weeklies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgs']]]]):
        pulumi.set(self, "weeklies", value)


if not MYPY:
    class AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgsDict(TypedDict):
        end_time: pulumi.Input[str]
        """
        Specifies the recurrence end time (H:M:S).
        """
        start_time: pulumi.Input[str]
        """
        Specifies the recurrence start time (H:M:S).
        """
elif False:
    AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupScheduleRecurrenceDailyArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[str],
                 start_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_time: Specifies the recurrence end time (H:M:S).
        :param pulumi.Input[str] start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgsDict(TypedDict):
        days_of_months: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the recurrence end time (H:M:S).
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the recurrence start time (H:M:S).
        """
elif False:
    AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupScheduleRecurrenceMonthlyArgs:
    def __init__(__self__, *,
                 days_of_months: pulumi.Input[Sequence[pulumi.Input[int]]],
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] days_of_months: Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        :param pulumi.Input[str] end_time: Specifies the recurrence end time (H:M:S).
        :param pulumi.Input[str] start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "days_of_months", days_of_months)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        """
        return pulumi.get(self, "days_of_months")

    @days_of_months.setter
    def days_of_months(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "days_of_months", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgsDict(TypedDict):
        days_of_weeks: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the recurrence end time (H:M:S).
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the recurrence start time (H:M:S).
        """
elif False:
    AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleActionGroupScheduleRecurrenceWeeklyArgs:
    def __init__(__self__, *,
                 days_of_weeks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_of_weeks: Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        :param pulumi.Input[str] end_time: Specifies the recurrence end time (H:M:S).
        :param pulumi.Input[str] start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionArgsDict(TypedDict):
        alert_context: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertContextArgsDict']]
        """
        A `alert_context` block as defined above.
        """
        alert_rule_id: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleIdArgsDict']]
        """
        A `alert_rule_id` block as defined above.
        """
        alert_rule_name: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleNameArgsDict']]
        """
        A `alert_rule_name` block as defined above.
        """
        description: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionDescriptionArgsDict']]
        """
        A `description` block as defined below.
        """
        monitor_condition: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorConditionArgsDict']]
        """
        A `monitor_condition` block as defined below.
        """
        monitor_service: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorServiceArgsDict']]
        """
        A `monitor_service` block as defined below.
        """
        severity: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionSeverityArgsDict']]
        """
        A `severity` block as defined below.
        """
        signal_type: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionSignalTypeArgsDict']]
        """
        A `signal_type` block as defined below.
        """
        target_resource: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceArgsDict']]
        """
        A `target_resource` block as defined below.
        """
        target_resource_group: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceGroupArgsDict']]
        """
        A `target_resource_group` block as defined below.
        """
        target_resource_type: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceTypeArgsDict']]
        """
        A `target_resource_type` block as defined below.
        """
elif False:
    AlertProcessingRuleSuppressionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionArgs:
    def __init__(__self__, *,
                 alert_context: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertContextArgs']] = None,
                 alert_rule_id: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleIdArgs']] = None,
                 alert_rule_name: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleNameArgs']] = None,
                 description: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionDescriptionArgs']] = None,
                 monitor_condition: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorConditionArgs']] = None,
                 monitor_service: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorServiceArgs']] = None,
                 severity: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionSeverityArgs']] = None,
                 signal_type: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionSignalTypeArgs']] = None,
                 target_resource: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceArgs']] = None,
                 target_resource_group: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceGroupArgs']] = None,
                 target_resource_type: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceTypeArgs']] = None):
        """
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionAlertContextArgs'] alert_context: A `alert_context` block as defined above.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleIdArgs'] alert_rule_id: A `alert_rule_id` block as defined above.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleNameArgs'] alert_rule_name: A `alert_rule_name` block as defined above.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionDescriptionArgs'] description: A `description` block as defined below.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorConditionArgs'] monitor_condition: A `monitor_condition` block as defined below.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorServiceArgs'] monitor_service: A `monitor_service` block as defined below.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionSeverityArgs'] severity: A `severity` block as defined below.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionSignalTypeArgs'] signal_type: A `signal_type` block as defined below.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceArgs'] target_resource: A `target_resource` block as defined below.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceGroupArgs'] target_resource_group: A `target_resource_group` block as defined below.
        :param pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceTypeArgs'] target_resource_type: A `target_resource_type` block as defined below.
        """
        if alert_context is not None:
            pulumi.set(__self__, "alert_context", alert_context)
        if alert_rule_id is not None:
            pulumi.set(__self__, "alert_rule_id", alert_rule_id)
        if alert_rule_name is not None:
            pulumi.set(__self__, "alert_rule_name", alert_rule_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if monitor_condition is not None:
            pulumi.set(__self__, "monitor_condition", monitor_condition)
        if monitor_service is not None:
            pulumi.set(__self__, "monitor_service", monitor_service)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if signal_type is not None:
            pulumi.set(__self__, "signal_type", signal_type)
        if target_resource is not None:
            pulumi.set(__self__, "target_resource", target_resource)
        if target_resource_group is not None:
            pulumi.set(__self__, "target_resource_group", target_resource_group)
        if target_resource_type is not None:
            pulumi.set(__self__, "target_resource_type", target_resource_type)

    @property
    @pulumi.getter(name="alertContext")
    def alert_context(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertContextArgs']]:
        """
        A `alert_context` block as defined above.
        """
        return pulumi.get(self, "alert_context")

    @alert_context.setter
    def alert_context(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertContextArgs']]):
        pulumi.set(self, "alert_context", value)

    @property
    @pulumi.getter(name="alertRuleId")
    def alert_rule_id(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleIdArgs']]:
        """
        A `alert_rule_id` block as defined above.
        """
        return pulumi.get(self, "alert_rule_id")

    @alert_rule_id.setter
    def alert_rule_id(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleIdArgs']]):
        pulumi.set(self, "alert_rule_id", value)

    @property
    @pulumi.getter(name="alertRuleName")
    def alert_rule_name(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleNameArgs']]:
        """
        A `alert_rule_name` block as defined above.
        """
        return pulumi.get(self, "alert_rule_name")

    @alert_rule_name.setter
    def alert_rule_name(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionAlertRuleNameArgs']]):
        pulumi.set(self, "alert_rule_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionDescriptionArgs']]:
        """
        A `description` block as defined below.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionDescriptionArgs']]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="monitorCondition")
    def monitor_condition(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorConditionArgs']]:
        """
        A `monitor_condition` block as defined below.
        """
        return pulumi.get(self, "monitor_condition")

    @monitor_condition.setter
    def monitor_condition(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorConditionArgs']]):
        pulumi.set(self, "monitor_condition", value)

    @property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorServiceArgs']]:
        """
        A `monitor_service` block as defined below.
        """
        return pulumi.get(self, "monitor_service")

    @monitor_service.setter
    def monitor_service(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionMonitorServiceArgs']]):
        pulumi.set(self, "monitor_service", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionSeverityArgs']]:
        """
        A `severity` block as defined below.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionSeverityArgs']]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter(name="signalType")
    def signal_type(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionSignalTypeArgs']]:
        """
        A `signal_type` block as defined below.
        """
        return pulumi.get(self, "signal_type")

    @signal_type.setter
    def signal_type(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionSignalTypeArgs']]):
        pulumi.set(self, "signal_type", value)

    @property
    @pulumi.getter(name="targetResource")
    def target_resource(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceArgs']]:
        """
        A `target_resource` block as defined below.
        """
        return pulumi.get(self, "target_resource")

    @target_resource.setter
    def target_resource(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceArgs']]):
        pulumi.set(self, "target_resource", value)

    @property
    @pulumi.getter(name="targetResourceGroup")
    def target_resource_group(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceGroupArgs']]:
        """
        A `target_resource_group` block as defined below.
        """
        return pulumi.get(self, "target_resource_group")

    @target_resource_group.setter
    def target_resource_group(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceGroupArgs']]):
        pulumi.set(self, "target_resource_group", value)

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceTypeArgs']]:
        """
        A `target_resource_type` block as defined below.
        """
        return pulumi.get(self, "target_resource_type")

    @target_resource_type.setter
    def target_resource_type(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionConditionTargetResourceTypeArgs']]):
        pulumi.set(self, "target_resource_type", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionAlertContextArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition.
        """
elif False:
    AlertProcessingRuleSuppressionConditionAlertContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionAlertContextArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionAlertRuleIdArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition.
        """
elif False:
    AlertProcessingRuleSuppressionConditionAlertRuleIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionAlertRuleIdArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionAlertRuleNameArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition.
        """
elif False:
    AlertProcessingRuleSuppressionConditionAlertRuleNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionAlertRuleNameArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionDescriptionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition.
        """
elif False:
    AlertProcessingRuleSuppressionConditionDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionDescriptionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionMonitorConditionArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
elif False:
    AlertProcessingRuleSuppressionConditionMonitorConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionMonitorConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionMonitorServiceArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
elif False:
    AlertProcessingRuleSuppressionConditionMonitorServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionMonitorServiceArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionSeverityArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
elif False:
    AlertProcessingRuleSuppressionConditionSeverityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionSeverityArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionSignalTypeArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
elif False:
    AlertProcessingRuleSuppressionConditionSignalTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionSignalTypeArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals` and `NotEquals`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionTargetResourceArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of values to match for a given condition. The values should be valid resource IDs.
        """
elif False:
    AlertProcessingRuleSuppressionConditionTargetResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionTargetResourceArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to match for a given condition. The values should be valid resource IDs.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to match for a given condition. The values should be valid resource IDs.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionTargetResourceGroupArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of values to match for a given condition. The values should be valid resource group IDs.
        """
elif False:
    AlertProcessingRuleSuppressionConditionTargetResourceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionTargetResourceGroupArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to match for a given condition. The values should be valid resource group IDs.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to match for a given condition. The values should be valid resource group IDs.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionConditionTargetResourceTypeArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
elif False:
    AlertProcessingRuleSuppressionConditionTargetResourceTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionConditionTargetResourceTypeArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] operator: The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlertProcessingRuleSuppressionScheduleArgsDict(TypedDict):
        effective_from: NotRequired[pulumi.Input[str]]
        """
        Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        """
        effective_until: NotRequired[pulumi.Input[str]]
        """
        Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        """
        recurrence: NotRequired[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceArgsDict']]
        """
        A `recurrence` block as defined above.
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
elif False:
    AlertProcessingRuleSuppressionScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionScheduleArgs:
    def __init__(__self__, *,
                 effective_from: Optional[pulumi.Input[str]] = None,
                 effective_until: Optional[pulumi.Input[str]] = None,
                 recurrence: Optional[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceArgs']] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective_from: Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        :param pulumi.Input[str] effective_until: Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        :param pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceArgs'] recurrence: A `recurrence` block as defined above.
        :param pulumi.Input[str] time_zone: The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
        if effective_from is not None:
            pulumi.set(__self__, "effective_from", effective_from)
        if effective_until is not None:
            pulumi.set(__self__, "effective_until", effective_until)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="effectiveFrom")
    def effective_from(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
        """
        return pulumi.get(self, "effective_from")

    @effective_from.setter
    def effective_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_from", value)

    @property
    @pulumi.getter(name="effectiveUntil")
    def effective_until(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
        """
        return pulumi.get(self, "effective_until")

    @effective_until.setter
    def effective_until(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_until", value)

    @property
    @pulumi.getter
    def recurrence(self) -> Optional[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceArgs']]:
        """
        A `recurrence` block as defined above.
        """
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: Optional[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceArgs']]):
        pulumi.set(self, "recurrence", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class AlertProcessingRuleSuppressionScheduleRecurrenceArgsDict(TypedDict):
        dailies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgsDict']]]]
        """
        One or more `daily` blocks as defined above.
        """
        monthlies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgsDict']]]]
        """
        One or more `monthly` blocks as defined above.
        """
        weeklies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgsDict']]]]
        """
        One or more `weekly` blocks as defined below.
        """
elif False:
    AlertProcessingRuleSuppressionScheduleRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionScheduleRecurrenceArgs:
    def __init__(__self__, *,
                 dailies: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgs']]]] = None,
                 monthlies: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgs']]]] = None,
                 weeklies: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgs']]] dailies: One or more `daily` blocks as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgs']]] monthlies: One or more `monthly` blocks as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgs']]] weeklies: One or more `weekly` blocks as defined below.
        """
        if dailies is not None:
            pulumi.set(__self__, "dailies", dailies)
        if monthlies is not None:
            pulumi.set(__self__, "monthlies", monthlies)
        if weeklies is not None:
            pulumi.set(__self__, "weeklies", weeklies)

    @property
    @pulumi.getter
    def dailies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgs']]]]:
        """
        One or more `daily` blocks as defined above.
        """
        return pulumi.get(self, "dailies")

    @dailies.setter
    def dailies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgs']]]]):
        pulumi.set(self, "dailies", value)

    @property
    @pulumi.getter
    def monthlies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgs']]]]:
        """
        One or more `monthly` blocks as defined above.
        """
        return pulumi.get(self, "monthlies")

    @monthlies.setter
    def monthlies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgs']]]]):
        pulumi.set(self, "monthlies", value)

    @property
    @pulumi.getter
    def weeklies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgs']]]]:
        """
        One or more `weekly` blocks as defined below.
        """
        return pulumi.get(self, "weeklies")

    @weeklies.setter
    def weeklies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgs']]]]):
        pulumi.set(self, "weeklies", value)


if not MYPY:
    class AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgsDict(TypedDict):
        end_time: pulumi.Input[str]
        """
        Specifies the recurrence end time (H:M:S).
        """
        start_time: pulumi.Input[str]
        """
        Specifies the recurrence start time (H:M:S).
        """
elif False:
    AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionScheduleRecurrenceDailyArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[str],
                 start_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_time: Specifies the recurrence end time (H:M:S).
        :param pulumi.Input[str] start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgsDict(TypedDict):
        days_of_months: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the recurrence end time (H:M:S).
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the recurrence start time (H:M:S).
        """
elif False:
    AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionScheduleRecurrenceMonthlyArgs:
    def __init__(__self__, *,
                 days_of_months: pulumi.Input[Sequence[pulumi.Input[int]]],
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] days_of_months: Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        :param pulumi.Input[str] end_time: Specifies the recurrence end time (H:M:S).
        :param pulumi.Input[str] start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "days_of_months", days_of_months)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
        """
        return pulumi.get(self, "days_of_months")

    @days_of_months.setter
    def days_of_months(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "days_of_months", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgsDict(TypedDict):
        days_of_weeks: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the recurrence end time (H:M:S).
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the recurrence start time (H:M:S).
        """
elif False:
    AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRuleSuppressionScheduleRecurrenceWeeklyArgs:
    def __init__(__self__, *,
                 days_of_weeks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_of_weeks: Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        :param pulumi.Input[str] end_time: Specifies the recurrence end time (H:M:S).
        :param pulumi.Input[str] start_time: Specifies the recurrence start time (H:M:S).
        """
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recurrence end time (H:M:S).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recurrence start time (H:M:S).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class AlertPrometheusRuleGroupRuleArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        Specifies the Prometheus Query Language expression to evaluate. For more details see [this doc](https://prometheus.io/docs/prometheus/latest/querying/basics). Evaluate at the period given by `interval` and record the result as a new set of time series with the metric name given by `record`.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertPrometheusRuleGroupRuleActionArgsDict']]]]
        """
        An `action` block as defined below.
        """
        alert: NotRequired[pulumi.Input[str]]
        """
        Specifies the Alert rule name.
        """
        alert_resolution: NotRequired[pulumi.Input['AlertPrometheusRuleGroupRuleAlertResolutionArgsDict']]
        """
        An `alert_resolution` block as defined below.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is this rule enabled? Possible values are `true` and `false`.
        """
        for_: NotRequired[pulumi.Input[str]]
        """
        Specifies the amount of time alert must be active before firing, represented in ISO 8601 duration format.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies the labels to add or overwrite before storing the result.
        """
        record: NotRequired[pulumi.Input[str]]
        """
        Specifies the recorded metrics name.
        """
        severity: NotRequired[pulumi.Input[int]]
        """
        Specifies the severity of the alerts fired by the rule. Possible values are between 0 and 4.
        """
elif False:
    AlertPrometheusRuleGroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPrometheusRuleGroupRuleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPrometheusRuleGroupRuleActionArgs']]]] = None,
                 alert: Optional[pulumi.Input[str]] = None,
                 alert_resolution: Optional[pulumi.Input['AlertPrometheusRuleGroupRuleAlertResolutionArgs']] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 for_: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 record: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] expression: Specifies the Prometheus Query Language expression to evaluate. For more details see [this doc](https://prometheus.io/docs/prometheus/latest/querying/basics). Evaluate at the period given by `interval` and record the result as a new set of time series with the metric name given by `record`.
        :param pulumi.Input[Sequence[pulumi.Input['AlertPrometheusRuleGroupRuleActionArgs']]] actions: An `action` block as defined below.
        :param pulumi.Input[str] alert: Specifies the Alert rule name.
        :param pulumi.Input['AlertPrometheusRuleGroupRuleAlertResolutionArgs'] alert_resolution: An `alert_resolution` block as defined below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links.
        :param pulumi.Input[bool] enabled: Is this rule enabled? Possible values are `true` and `false`.
        :param pulumi.Input[str] for_: Specifies the amount of time alert must be active before firing, represented in ISO 8601 duration format.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Specifies the labels to add or overwrite before storing the result.
        :param pulumi.Input[str] record: Specifies the recorded metrics name.
        :param pulumi.Input[int] severity: Specifies the severity of the alerts fired by the rule. Possible values are between 0 and 4.
        """
        pulumi.set(__self__, "expression", expression)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if alert_resolution is not None:
            pulumi.set(__self__, "alert_resolution", alert_resolution)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if record is not None:
            pulumi.set(__self__, "record", record)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Specifies the Prometheus Query Language expression to evaluate. For more details see [this doc](https://prometheus.io/docs/prometheus/latest/querying/basics). Evaluate at the period given by `interval` and record the result as a new set of time series with the metric name given by `record`.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPrometheusRuleGroupRuleActionArgs']]]]:
        """
        An `action` block as defined below.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPrometheusRuleGroupRuleActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Alert rule name.
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter(name="alertResolution")
    def alert_resolution(self) -> Optional[pulumi.Input['AlertPrometheusRuleGroupRuleAlertResolutionArgs']]:
        """
        An `alert_resolution` block as defined below.
        """
        return pulumi.get(self, "alert_resolution")

    @alert_resolution.setter
    def alert_resolution(self, value: Optional[pulumi.Input['AlertPrometheusRuleGroupRuleAlertResolutionArgs']]):
        pulumi.set(self, "alert_resolution", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this rule enabled? Possible values are `true` and `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the amount of time alert must be active before firing, represented in ISO 8601 duration format.
        """
        return pulumi.get(self, "for_")

    @for_.setter
    def for_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "for_", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies the labels to add or overwrite before storing the result.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def record(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recorded metrics name.
        """
        return pulumi.get(self, "record")

    @record.setter
    def record(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the severity of the alerts fired by the rule. Possible values are between 0 and 4.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class AlertPrometheusRuleGroupRuleActionArgsDict(TypedDict):
        action_group_id: pulumi.Input[str]
        """
        Specifies the resource id of the monitor action group.
        """
        action_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies the properties of an action group object.

        > **Note:** `action_properties` can only be configured for IcM Connector Action Groups for now. Other public features will be supported in the future.
        """
elif False:
    AlertPrometheusRuleGroupRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPrometheusRuleGroupRuleActionArgs:
    def __init__(__self__, *,
                 action_group_id: pulumi.Input[str],
                 action_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] action_group_id: Specifies the resource id of the monitor action group.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] action_properties: Specifies the properties of an action group object.
               
               > **Note:** `action_properties` can only be configured for IcM Connector Action Groups for now. Other public features will be supported in the future.
        """
        pulumi.set(__self__, "action_group_id", action_group_id)
        if action_properties is not None:
            pulumi.set(__self__, "action_properties", action_properties)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> pulumi.Input[str]:
        """
        Specifies the resource id of the monitor action group.
        """
        return pulumi.get(self, "action_group_id")

    @action_group_id.setter
    def action_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_group_id", value)

    @property
    @pulumi.getter(name="actionProperties")
    def action_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies the properties of an action group object.

        > **Note:** `action_properties` can only be configured for IcM Connector Action Groups for now. Other public features will be supported in the future.
        """
        return pulumi.get(self, "action_properties")

    @action_properties.setter
    def action_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "action_properties", value)


if not MYPY:
    class AlertPrometheusRuleGroupRuleAlertResolutionArgsDict(TypedDict):
        auto_resolved: NotRequired[pulumi.Input[bool]]
        """
        Is the alert auto-resolution? Possible values are `true` and `false`.
        """
        time_to_resolve: NotRequired[pulumi.Input[str]]
        """
        Specifies the alert auto-resolution interval, represented in ISO 8601 duration format.
        """
elif False:
    AlertPrometheusRuleGroupRuleAlertResolutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPrometheusRuleGroupRuleAlertResolutionArgs:
    def __init__(__self__, *,
                 auto_resolved: Optional[pulumi.Input[bool]] = None,
                 time_to_resolve: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] auto_resolved: Is the alert auto-resolution? Possible values are `true` and `false`.
        :param pulumi.Input[str] time_to_resolve: Specifies the alert auto-resolution interval, represented in ISO 8601 duration format.
        """
        if auto_resolved is not None:
            pulumi.set(__self__, "auto_resolved", auto_resolved)
        if time_to_resolve is not None:
            pulumi.set(__self__, "time_to_resolve", time_to_resolve)

    @property
    @pulumi.getter(name="autoResolved")
    def auto_resolved(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the alert auto-resolution? Possible values are `true` and `false`.
        """
        return pulumi.get(self, "auto_resolved")

    @auto_resolved.setter
    def auto_resolved(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_resolved", value)

    @property
    @pulumi.getter(name="timeToResolve")
    def time_to_resolve(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the alert auto-resolution interval, represented in ISO 8601 duration format.
        """
        return pulumi.get(self, "time_to_resolve")

    @time_to_resolve.setter
    def time_to_resolve(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_to_resolve", value)


if not MYPY:
    class AutoscaleSettingNotificationArgsDict(TypedDict):
        email: NotRequired[pulumi.Input['AutoscaleSettingNotificationEmailArgsDict']]
        """
        A `email` block as defined below.
        """
        webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingNotificationWebhookArgsDict']]]]
        """
        One or more `webhook` blocks as defined below.
        """
elif False:
    AutoscaleSettingNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingNotificationArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input['AutoscaleSettingNotificationEmailArgs']] = None,
                 webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingNotificationWebhookArgs']]]] = None):
        """
        :param pulumi.Input['AutoscaleSettingNotificationEmailArgs'] email: A `email` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingNotificationWebhookArgs']]] webhooks: One or more `webhook` blocks as defined below.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AutoscaleSettingNotificationEmailArgs']]:
        """
        A `email` block as defined below.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AutoscaleSettingNotificationEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingNotificationWebhookArgs']]]]:
        """
        One or more `webhook` blocks as defined below.
        """
        return pulumi.get(self, "webhooks")

    @webhooks.setter
    def webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingNotificationWebhookArgs']]]]):
        pulumi.set(self, "webhooks", value)


if not MYPY:
    class AutoscaleSettingNotificationEmailArgsDict(TypedDict):
        custom_emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of custom email addresses to which the email notifications will be sent.
        """
        send_to_subscription_administrator: NotRequired[pulumi.Input[bool]]
        """
        Should email notifications be sent to the subscription administrator? Defaults to `false`.
        """
        send_to_subscription_co_administrator: NotRequired[pulumi.Input[bool]]
        """
        Should email notifications be sent to the subscription co-administrator? Defaults to `false`.
        """
elif False:
    AutoscaleSettingNotificationEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingNotificationEmailArgs:
    def __init__(__self__, *,
                 custom_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 send_to_subscription_administrator: Optional[pulumi.Input[bool]] = None,
                 send_to_subscription_co_administrator: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_emails: Specifies a list of custom email addresses to which the email notifications will be sent.
        :param pulumi.Input[bool] send_to_subscription_administrator: Should email notifications be sent to the subscription administrator? Defaults to `false`.
        :param pulumi.Input[bool] send_to_subscription_co_administrator: Should email notifications be sent to the subscription co-administrator? Defaults to `false`.
        """
        if custom_emails is not None:
            pulumi.set(__self__, "custom_emails", custom_emails)
        if send_to_subscription_administrator is not None:
            pulumi.set(__self__, "send_to_subscription_administrator", send_to_subscription_administrator)
        if send_to_subscription_co_administrator is not None:
            pulumi.set(__self__, "send_to_subscription_co_administrator", send_to_subscription_co_administrator)

    @property
    @pulumi.getter(name="customEmails")
    def custom_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of custom email addresses to which the email notifications will be sent.
        """
        return pulumi.get(self, "custom_emails")

    @custom_emails.setter
    def custom_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "custom_emails", value)

    @property
    @pulumi.getter(name="sendToSubscriptionAdministrator")
    def send_to_subscription_administrator(self) -> Optional[pulumi.Input[bool]]:
        """
        Should email notifications be sent to the subscription administrator? Defaults to `false`.
        """
        return pulumi.get(self, "send_to_subscription_administrator")

    @send_to_subscription_administrator.setter
    def send_to_subscription_administrator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "send_to_subscription_administrator", value)

    @property
    @pulumi.getter(name="sendToSubscriptionCoAdministrator")
    def send_to_subscription_co_administrator(self) -> Optional[pulumi.Input[bool]]:
        """
        Should email notifications be sent to the subscription co-administrator? Defaults to `false`.
        """
        return pulumi.get(self, "send_to_subscription_co_administrator")

    @send_to_subscription_co_administrator.setter
    def send_to_subscription_co_administrator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "send_to_subscription_co_administrator", value)


if not MYPY:
    class AutoscaleSettingNotificationWebhookArgsDict(TypedDict):
        service_uri: pulumi.Input[str]
        """
        The HTTPS URI which should receive scale notifications.
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of settings.
        """
elif False:
    AutoscaleSettingNotificationWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingNotificationWebhookArgs:
    def __init__(__self__, *,
                 service_uri: pulumi.Input[str],
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] service_uri: The HTTPS URI which should receive scale notifications.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: A map of settings.
        """
        pulumi.set(__self__, "service_uri", service_uri)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> pulumi.Input[str]:
        """
        The HTTPS URI which should receive scale notifications.
        """
        return pulumi.get(self, "service_uri")

    @service_uri.setter
    def service_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_uri", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of settings.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class AutoscaleSettingPredictiveArgsDict(TypedDict):
        scale_mode: pulumi.Input[str]
        """
        Specifies the predictive scale mode. Possible values are `Enabled` or `ForecastOnly`.
        """
        look_ahead_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the amount of time by which instances are launched in advance. It must be between `PT1M` and `PT1H` in ISO 8601 format.
        """
elif False:
    AutoscaleSettingPredictiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingPredictiveArgs:
    def __init__(__self__, *,
                 scale_mode: pulumi.Input[str],
                 look_ahead_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] scale_mode: Specifies the predictive scale mode. Possible values are `Enabled` or `ForecastOnly`.
        :param pulumi.Input[str] look_ahead_time: Specifies the amount of time by which instances are launched in advance. It must be between `PT1M` and `PT1H` in ISO 8601 format.
        """
        pulumi.set(__self__, "scale_mode", scale_mode)
        if look_ahead_time is not None:
            pulumi.set(__self__, "look_ahead_time", look_ahead_time)

    @property
    @pulumi.getter(name="scaleMode")
    def scale_mode(self) -> pulumi.Input[str]:
        """
        Specifies the predictive scale mode. Possible values are `Enabled` or `ForecastOnly`.
        """
        return pulumi.get(self, "scale_mode")

    @scale_mode.setter
    def scale_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "scale_mode", value)

    @property
    @pulumi.getter(name="lookAheadTime")
    def look_ahead_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the amount of time by which instances are launched in advance. It must be between `PT1M` and `PT1H` in ISO 8601 format.
        """
        return pulumi.get(self, "look_ahead_time")

    @look_ahead_time.setter
    def look_ahead_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "look_ahead_time", value)


if not MYPY:
    class AutoscaleSettingProfileArgsDict(TypedDict):
        capacity: pulumi.Input['AutoscaleSettingProfileCapacityArgsDict']
        """
        A `capacity` block as defined below.
        """
        name: pulumi.Input[str]
        """
        Specifies the name of the profile.
        """
        fixed_date: NotRequired[pulumi.Input['AutoscaleSettingProfileFixedDateArgsDict']]
        """
        A `fixed_date` block as defined below. This cannot be specified if a `recurrence` block is specified.
        """
        recurrence: NotRequired[pulumi.Input['AutoscaleSettingProfileRecurrenceArgsDict']]
        """
        A `recurrence` block as defined below. This cannot be specified if a `fixed_date` block is specified.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleArgsDict']]]]
        """
        One or more (up to 10) `rule` blocks as defined below.
        """
elif False:
    AutoscaleSettingProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingProfileArgs:
    def __init__(__self__, *,
                 capacity: pulumi.Input['AutoscaleSettingProfileCapacityArgs'],
                 name: pulumi.Input[str],
                 fixed_date: Optional[pulumi.Input['AutoscaleSettingProfileFixedDateArgs']] = None,
                 recurrence: Optional[pulumi.Input['AutoscaleSettingProfileRecurrenceArgs']] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleArgs']]]] = None):
        """
        :param pulumi.Input['AutoscaleSettingProfileCapacityArgs'] capacity: A `capacity` block as defined below.
        :param pulumi.Input[str] name: Specifies the name of the profile.
        :param pulumi.Input['AutoscaleSettingProfileFixedDateArgs'] fixed_date: A `fixed_date` block as defined below. This cannot be specified if a `recurrence` block is specified.
        :param pulumi.Input['AutoscaleSettingProfileRecurrenceArgs'] recurrence: A `recurrence` block as defined below. This cannot be specified if a `fixed_date` block is specified.
        :param pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleArgs']]] rules: One or more (up to 10) `rule` blocks as defined below.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        if fixed_date is not None:
            pulumi.set(__self__, "fixed_date", fixed_date)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def capacity(self) -> pulumi.Input['AutoscaleSettingProfileCapacityArgs']:
        """
        A `capacity` block as defined below.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: pulumi.Input['AutoscaleSettingProfileCapacityArgs']):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the profile.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="fixedDate")
    def fixed_date(self) -> Optional[pulumi.Input['AutoscaleSettingProfileFixedDateArgs']]:
        """
        A `fixed_date` block as defined below. This cannot be specified if a `recurrence` block is specified.
        """
        return pulumi.get(self, "fixed_date")

    @fixed_date.setter
    def fixed_date(self, value: Optional[pulumi.Input['AutoscaleSettingProfileFixedDateArgs']]):
        pulumi.set(self, "fixed_date", value)

    @property
    @pulumi.getter
    def recurrence(self) -> Optional[pulumi.Input['AutoscaleSettingProfileRecurrenceArgs']]:
        """
        A `recurrence` block as defined below. This cannot be specified if a `fixed_date` block is specified.
        """
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: Optional[pulumi.Input['AutoscaleSettingProfileRecurrenceArgs']]):
        pulumi.set(self, "recurrence", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleArgs']]]]:
        """
        One or more (up to 10) `rule` blocks as defined below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AutoscaleSettingProfileCapacityArgsDict(TypedDict):
        default: pulumi.Input[int]
        """
        The number of instances that are available for scaling if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default. Valid values are between `0` and `1000`.
        """
        maximum: pulumi.Input[int]
        """
        The maximum number of instances for this resource. Valid values are between `0` and `1000`.

        > **NOTE:** The maximum number of instances is also limited by the amount of Cores available in the subscription.
        """
        minimum: pulumi.Input[int]
        """
        The minimum number of instances for this resource. Valid values are between `0` and `1000`.
        """
elif False:
    AutoscaleSettingProfileCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingProfileCapacityArgs:
    def __init__(__self__, *,
                 default: pulumi.Input[int],
                 maximum: pulumi.Input[int],
                 minimum: pulumi.Input[int]):
        """
        :param pulumi.Input[int] default: The number of instances that are available for scaling if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default. Valid values are between `0` and `1000`.
        :param pulumi.Input[int] maximum: The maximum number of instances for this resource. Valid values are between `0` and `1000`.
               
               > **NOTE:** The maximum number of instances is also limited by the amount of Cores available in the subscription.
        :param pulumi.Input[int] minimum: The minimum number of instances for this resource. Valid values are between `0` and `1000`.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "maximum", maximum)
        pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def default(self) -> pulumi.Input[int]:
        """
        The number of instances that are available for scaling if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default. Valid values are between `0` and `1000`.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: pulumi.Input[int]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def maximum(self) -> pulumi.Input[int]:
        """
        The maximum number of instances for this resource. Valid values are between `0` and `1000`.

        > **NOTE:** The maximum number of instances is also limited by the amount of Cores available in the subscription.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: pulumi.Input[int]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> pulumi.Input[int]:
        """
        The minimum number of instances for this resource. Valid values are between `0` and `1000`.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: pulumi.Input[int]):
        pulumi.set(self, "minimum", value)


if not MYPY:
    class AutoscaleSettingProfileFixedDateArgsDict(TypedDict):
        end: pulumi.Input[str]
        """
        Specifies the end date for the profile, formatted as an RFC3339 date string.
        """
        start: pulumi.Input[str]
        """
        Specifies the start date for the profile, formatted as an RFC3339 date string.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        The Time Zone of the `start` and `end` times. A list of [possible values can be found here](https://learn.microsoft.com/en-us/rest/api/monitor/autoscale-settings/create-or-update?view=rest-monitor-2022-10-01&tabs=HTTP#recurrentschedule). Defaults to `UTC`.
        """
elif False:
    AutoscaleSettingProfileFixedDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingProfileFixedDateArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str],
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end: Specifies the end date for the profile, formatted as an RFC3339 date string.
        :param pulumi.Input[str] start: Specifies the start date for the profile, formatted as an RFC3339 date string.
        :param pulumi.Input[str] timezone: The Time Zone of the `start` and `end` times. A list of [possible values can be found here](https://learn.microsoft.com/en-us/rest/api/monitor/autoscale-settings/create-or-update?view=rest-monitor-2022-10-01&tabs=HTTP#recurrentschedule). Defaults to `UTC`.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        Specifies the end date for the profile, formatted as an RFC3339 date string.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        Specifies the start date for the profile, formatted as an RFC3339 date string.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        The Time Zone of the `start` and `end` times. A list of [possible values can be found here](https://learn.microsoft.com/en-us/rest/api/monitor/autoscale-settings/create-or-update?view=rest-monitor-2022-10-01&tabs=HTTP#recurrentschedule). Defaults to `UTC`.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class AutoscaleSettingProfileRecurrenceArgsDict(TypedDict):
        days: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of days that this profile takes effect on. Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        """
        hours: pulumi.Input[int]
        """
        A list containing a single item, which specifies the Hour interval at which this recurrence should be triggered (in 24-hour time). Possible values are from `0` to `23`.
        """
        minutes: pulumi.Input[int]
        """
        A list containing a single item which specifies the Minute interval at which this recurrence should be triggered.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        The Time Zone used for the `hours` field. A list of possible values can be found here). Defaults to `UTC`.
        """
elif False:
    AutoscaleSettingProfileRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingProfileRecurrenceArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[Sequence[pulumi.Input[str]]],
                 hours: pulumi.Input[int],
                 minutes: pulumi.Input[int],
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days: A list of days that this profile takes effect on. Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        :param pulumi.Input[int] hours: A list containing a single item, which specifies the Hour interval at which this recurrence should be triggered (in 24-hour time). Possible values are from `0` to `23`.
        :param pulumi.Input[int] minutes: A list containing a single item which specifies the Minute interval at which this recurrence should be triggered.
        :param pulumi.Input[str] timezone: The Time Zone used for the `hours` field. A list of possible values can be found here). Defaults to `UTC`.
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of days that this profile takes effect on. Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[int]:
        """
        A list containing a single item, which specifies the Hour interval at which this recurrence should be triggered (in 24-hour time). Possible values are from `0` to `23`.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[int]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[int]:
        """
        A list containing a single item which specifies the Minute interval at which this recurrence should be triggered.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        The Time Zone used for the `hours` field. A list of possible values can be found here). Defaults to `UTC`.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class AutoscaleSettingProfileRuleArgsDict(TypedDict):
        metric_trigger: pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerArgsDict']
        """
        A `metric_trigger` block as defined below.
        """
        scale_action: pulumi.Input['AutoscaleSettingProfileRuleScaleActionArgsDict']
        """
        A `scale_action` block as defined below.
        """
elif False:
    AutoscaleSettingProfileRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingProfileRuleArgs:
    def __init__(__self__, *,
                 metric_trigger: pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerArgs'],
                 scale_action: pulumi.Input['AutoscaleSettingProfileRuleScaleActionArgs']):
        """
        :param pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerArgs'] metric_trigger: A `metric_trigger` block as defined below.
        :param pulumi.Input['AutoscaleSettingProfileRuleScaleActionArgs'] scale_action: A `scale_action` block as defined below.
        """
        pulumi.set(__self__, "metric_trigger", metric_trigger)
        pulumi.set(__self__, "scale_action", scale_action)

    @property
    @pulumi.getter(name="metricTrigger")
    def metric_trigger(self) -> pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerArgs']:
        """
        A `metric_trigger` block as defined below.
        """
        return pulumi.get(self, "metric_trigger")

    @metric_trigger.setter
    def metric_trigger(self, value: pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerArgs']):
        pulumi.set(self, "metric_trigger", value)

    @property
    @pulumi.getter(name="scaleAction")
    def scale_action(self) -> pulumi.Input['AutoscaleSettingProfileRuleScaleActionArgs']:
        """
        A `scale_action` block as defined below.
        """
        return pulumi.get(self, "scale_action")

    @scale_action.setter
    def scale_action(self, value: pulumi.Input['AutoscaleSettingProfileRuleScaleActionArgs']):
        pulumi.set(self, "scale_action", value)


if not MYPY:
    class AutoscaleSettingProfileRuleMetricTriggerArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        """
        The name of the metric that defines what the rule monitors, such as `Percentage CPU` for `Virtual Machine Scale Sets` and `CpuPercentage` for `App Service Plan`.

        > **NOTE:** The allowed value of `metric_name` highly depends on the targeting resource type, please visit [Supported metrics with Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported) for more details.
        """
        metric_resource_id: pulumi.Input[str]
        """
        The ID of the Resource which the Rule monitors.
        """
        operator: pulumi.Input[str]
        """
        Specifies the operator used to compare the metric data and threshold. Possible values are: `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`.
        """
        statistic: pulumi.Input[str]
        """
        Specifies how the metrics from multiple instances are combined. Possible values are `Average`, `Max`, `Min` and `Sum`.
        """
        threshold: pulumi.Input[float]
        """
        Specifies the threshold of the metric that triggers the scale action.
        """
        time_aggregation: pulumi.Input[str]
        """
        Specifies how the data that's collected should be combined over time. Possible values include `Average`, `Count`, `Maximum`, `Minimum`, `Last` and `Total`.
        """
        time_grain: pulumi.Input[str]
        """
        Specifies the granularity of metrics that the rule monitors, which must be one of the pre-defined values returned from the metric definitions for the metric. This value must be between 1 minute and 12 hours an be formatted as an ISO 8601 string.
        """
        time_window: pulumi.Input[str]
        """
        Specifies the time range for which data is collected, which must be greater than the delay in metric collection (which varies from resource to resource). This value must be between 5 minutes and 12 hours and be formatted as an ISO 8601 string.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerDimensionArgsDict']]]]
        """
        One or more `dimensions` block as defined below.
        """
        divide_by_instance_count: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable metric divide by instance count.
        """
        metric_namespace: NotRequired[pulumi.Input[str]]
        """
        The namespace of the metric that defines what the rule monitors, such as `microsoft.compute/virtualmachinescalesets` for `Virtual Machine Scale Sets`.
        """
elif False:
    AutoscaleSettingProfileRuleMetricTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingProfileRuleMetricTriggerArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 metric_resource_id: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 statistic: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 time_aggregation: pulumi.Input[str],
                 time_grain: pulumi.Input[str],
                 time_window: pulumi.Input[str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerDimensionArgs']]]] = None,
                 divide_by_instance_count: Optional[pulumi.Input[bool]] = None,
                 metric_namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: The name of the metric that defines what the rule monitors, such as `Percentage CPU` for `Virtual Machine Scale Sets` and `CpuPercentage` for `App Service Plan`.
               
               > **NOTE:** The allowed value of `metric_name` highly depends on the targeting resource type, please visit [Supported metrics with Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported) for more details.
        :param pulumi.Input[str] metric_resource_id: The ID of the Resource which the Rule monitors.
        :param pulumi.Input[str] operator: Specifies the operator used to compare the metric data and threshold. Possible values are: `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`.
        :param pulumi.Input[str] statistic: Specifies how the metrics from multiple instances are combined. Possible values are `Average`, `Max`, `Min` and `Sum`.
        :param pulumi.Input[float] threshold: Specifies the threshold of the metric that triggers the scale action.
        :param pulumi.Input[str] time_aggregation: Specifies how the data that's collected should be combined over time. Possible values include `Average`, `Count`, `Maximum`, `Minimum`, `Last` and `Total`.
        :param pulumi.Input[str] time_grain: Specifies the granularity of metrics that the rule monitors, which must be one of the pre-defined values returned from the metric definitions for the metric. This value must be between 1 minute and 12 hours an be formatted as an ISO 8601 string.
        :param pulumi.Input[str] time_window: Specifies the time range for which data is collected, which must be greater than the delay in metric collection (which varies from resource to resource). This value must be between 5 minutes and 12 hours and be formatted as an ISO 8601 string.
        :param pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerDimensionArgs']]] dimensions: One or more `dimensions` block as defined below.
        :param pulumi.Input[bool] divide_by_instance_count: Whether to enable metric divide by instance count.
        :param pulumi.Input[str] metric_namespace: The namespace of the metric that defines what the rule monitors, such as `microsoft.compute/virtualmachinescalesets` for `Virtual Machine Scale Sets`.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_resource_id", metric_resource_id)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "statistic", statistic)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "time_aggregation", time_aggregation)
        pulumi.set(__self__, "time_grain", time_grain)
        pulumi.set(__self__, "time_window", time_window)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if divide_by_instance_count is not None:
            pulumi.set(__self__, "divide_by_instance_count", divide_by_instance_count)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The name of the metric that defines what the rule monitors, such as `Percentage CPU` for `Virtual Machine Scale Sets` and `CpuPercentage` for `App Service Plan`.

        > **NOTE:** The allowed value of `metric_name` highly depends on the targeting resource type, please visit [Supported metrics with Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported) for more details.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="metricResourceId")
    def metric_resource_id(self) -> pulumi.Input[str]:
        """
        The ID of the Resource which the Rule monitors.
        """
        return pulumi.get(self, "metric_resource_id")

    @metric_resource_id.setter
    def metric_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_resource_id", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Specifies the operator used to compare the metric data and threshold. Possible values are: `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def statistic(self) -> pulumi.Input[str]:
        """
        Specifies how the metrics from multiple instances are combined. Possible values are `Average`, `Max`, `Min` and `Sum`.
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: pulumi.Input[str]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        Specifies the threshold of the metric that triggers the scale action.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="timeAggregation")
    def time_aggregation(self) -> pulumi.Input[str]:
        """
        Specifies how the data that's collected should be combined over time. Possible values include `Average`, `Count`, `Maximum`, `Minimum`, `Last` and `Total`.
        """
        return pulumi.get(self, "time_aggregation")

    @time_aggregation.setter
    def time_aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_aggregation", value)

    @property
    @pulumi.getter(name="timeGrain")
    def time_grain(self) -> pulumi.Input[str]:
        """
        Specifies the granularity of metrics that the rule monitors, which must be one of the pre-defined values returned from the metric definitions for the metric. This value must be between 1 minute and 12 hours an be formatted as an ISO 8601 string.
        """
        return pulumi.get(self, "time_grain")

    @time_grain.setter
    def time_grain(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_grain", value)

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> pulumi.Input[str]:
        """
        Specifies the time range for which data is collected, which must be greater than the delay in metric collection (which varies from resource to resource). This value must be between 5 minutes and 12 hours and be formatted as an ISO 8601 string.
        """
        return pulumi.get(self, "time_window")

    @time_window.setter
    def time_window(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_window", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerDimensionArgs']]]]:
        """
        One or more `dimensions` block as defined below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleSettingProfileRuleMetricTriggerDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="divideByInstanceCount")
    def divide_by_instance_count(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable metric divide by instance count.
        """
        return pulumi.get(self, "divide_by_instance_count")

    @divide_by_instance_count.setter
    def divide_by_instance_count(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "divide_by_instance_count", value)

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace of the metric that defines what the rule monitors, such as `microsoft.compute/virtualmachinescalesets` for `Virtual Machine Scale Sets`.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_namespace", value)


if not MYPY:
    class AutoscaleSettingProfileRuleMetricTriggerDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the dimension.
        """
        operator: pulumi.Input[str]
        """
        The dimension operator. Possible values are `Equals` and `NotEquals`. `Equals` means being equal to any of the values. `NotEquals` means being not equal to any of the values.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of dimension values.
        """
elif False:
    AutoscaleSettingProfileRuleMetricTriggerDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingProfileRuleMetricTriggerDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The name of the dimension.
        :param pulumi.Input[str] operator: The dimension operator. Possible values are `Equals` and `NotEquals`. `Equals` means being equal to any of the values. `NotEquals` means being not equal to any of the values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of dimension values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the dimension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The dimension operator. Possible values are `Equals` and `NotEquals`. `Equals` means being equal to any of the values. `NotEquals` means being not equal to any of the values.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of dimension values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AutoscaleSettingProfileRuleScaleActionArgsDict(TypedDict):
        cooldown: pulumi.Input[str]
        """
        The amount of time to wait since the last scaling action before this action occurs. Must be between 1 minute and 1 week and formatted as a ISO 8601 string.
        """
        direction: pulumi.Input[str]
        """
        The scale direction. Possible values are `Increase` and `Decrease`.
        """
        type: pulumi.Input[str]
        """
        The type of action that should occur. Possible values are `ChangeCount`, `ExactCount`, `PercentChangeCount` and `ServiceAllowedNextValue`.
        """
        value: pulumi.Input[int]
        """
        The number of instances involved in the scaling action.
        """
elif False:
    AutoscaleSettingProfileRuleScaleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingProfileRuleScaleActionArgs:
    def __init__(__self__, *,
                 cooldown: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] cooldown: The amount of time to wait since the last scaling action before this action occurs. Must be between 1 minute and 1 week and formatted as a ISO 8601 string.
        :param pulumi.Input[str] direction: The scale direction. Possible values are `Increase` and `Decrease`.
        :param pulumi.Input[str] type: The type of action that should occur. Possible values are `ChangeCount`, `ExactCount`, `PercentChangeCount` and `ServiceAllowedNextValue`.
        :param pulumi.Input[int] value: The number of instances involved in the scaling action.
        """
        pulumi.set(__self__, "cooldown", cooldown)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def cooldown(self) -> pulumi.Input[str]:
        """
        The amount of time to wait since the last scaling action before this action occurs. Must be between 1 minute and 1 week and formatted as a ISO 8601 string.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: pulumi.Input[str]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        The scale direction. Possible values are `Increase` and `Decrease`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action that should occur. Possible values are `ChangeCount`, `ExactCount`, `PercentChangeCount` and `ServiceAllowedNextValue`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        The number of instances involved in the scaling action.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DataCollectionRuleDataFlowArgsDict(TypedDict):
        destinations: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of destination names. A `azure_monitor_metrics` data source only allows for stream of kind `Microsoft-InsightsMetrics`.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`, and `Microsoft-PrometheusMetrics`.
        """
        built_in_transform: NotRequired[pulumi.Input[str]]
        """
        The built-in transform to transform stream data.
        """
        output_stream: NotRequired[pulumi.Input[str]]
        """
        The output stream of the transform. Only required if the data flow changes data to a different stream.
        """
        transform_kql: NotRequired[pulumi.Input[str]]
        """
        The KQL query to transform stream data.
        """
elif False:
    DataCollectionRuleDataFlowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataFlowArgs:
    def __init__(__self__, *,
                 destinations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 built_in_transform: Optional[pulumi.Input[str]] = None,
                 output_stream: Optional[pulumi.Input[str]] = None,
                 transform_kql: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destinations: Specifies a list of destination names. A `azure_monitor_metrics` data source only allows for stream of kind `Microsoft-InsightsMetrics`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`, and `Microsoft-PrometheusMetrics`.
        :param pulumi.Input[str] built_in_transform: The built-in transform to transform stream data.
        :param pulumi.Input[str] output_stream: The output stream of the transform. Only required if the data flow changes data to a different stream.
        :param pulumi.Input[str] transform_kql: The KQL query to transform stream data.
        """
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "streams", streams)
        if built_in_transform is not None:
            pulumi.set(__self__, "built_in_transform", built_in_transform)
        if output_stream is not None:
            pulumi.set(__self__, "output_stream", output_stream)
        if transform_kql is not None:
            pulumi.set(__self__, "transform_kql", transform_kql)

    @property
    @pulumi.getter
    def destinations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of destination names. A `azure_monitor_metrics` data source only allows for stream of kind `Microsoft-InsightsMetrics`.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`, and `Microsoft-PrometheusMetrics`.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="builtInTransform")
    def built_in_transform(self) -> Optional[pulumi.Input[str]]:
        """
        The built-in transform to transform stream data.
        """
        return pulumi.get(self, "built_in_transform")

    @built_in_transform.setter
    def built_in_transform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "built_in_transform", value)

    @property
    @pulumi.getter(name="outputStream")
    def output_stream(self) -> Optional[pulumi.Input[str]]:
        """
        The output stream of the transform. Only required if the data flow changes data to a different stream.
        """
        return pulumi.get(self, "output_stream")

    @output_stream.setter
    def output_stream(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_stream", value)

    @property
    @pulumi.getter(name="transformKql")
    def transform_kql(self) -> Optional[pulumi.Input[str]]:
        """
        The KQL query to transform stream data.
        """
        return pulumi.get(self, "transform_kql")

    @transform_kql.setter
    def transform_kql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_kql", value)


if not MYPY:
    class DataCollectionRuleDataSourcesArgsDict(TypedDict):
        data_import: NotRequired[pulumi.Input['DataCollectionRuleDataSourcesDataImportArgsDict']]
        """
        A `data_import` block as defined above.
        """
        extensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesExtensionArgsDict']]]]
        """
        One or more `extension` blocks as defined below.
        """
        iis_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesIisLogArgsDict']]]]
        """
        One or more `iis_log` blocks as defined below.
        """
        log_files: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesLogFileArgsDict']]]]
        """
        One or more `log_file` blocks as defined below.
        """
        performance_counters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPerformanceCounterArgsDict']]]]
        """
        One or more `performance_counter` blocks as defined below.
        """
        platform_telemetries: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPlatformTelemetryArgsDict']]]]
        """
        One or more `platform_telemetry` blocks as defined below.
        """
        prometheus_forwarders: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderArgsDict']]]]
        """
        One or more `prometheus_forwarder` blocks as defined below.
        """
        syslogs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesSyslogArgsDict']]]]
        """
        One or more `syslog` blocks as defined below.
        """
        windows_event_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsEventLogArgsDict']]]]
        """
        One or more `windows_event_log` blocks as defined below.
        """
        windows_firewall_logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsFirewallLogArgsDict']]]]
        """
        One or more `windows_firewall_log` blocks as defined below.
        """
elif False:
    DataCollectionRuleDataSourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesArgs:
    def __init__(__self__, *,
                 data_import: Optional[pulumi.Input['DataCollectionRuleDataSourcesDataImportArgs']] = None,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesExtensionArgs']]]] = None,
                 iis_logs: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesIisLogArgs']]]] = None,
                 log_files: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesLogFileArgs']]]] = None,
                 performance_counters: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPerformanceCounterArgs']]]] = None,
                 platform_telemetries: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPlatformTelemetryArgs']]]] = None,
                 prometheus_forwarders: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderArgs']]]] = None,
                 syslogs: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesSyslogArgs']]]] = None,
                 windows_event_logs: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsEventLogArgs']]]] = None,
                 windows_firewall_logs: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsFirewallLogArgs']]]] = None):
        """
        :param pulumi.Input['DataCollectionRuleDataSourcesDataImportArgs'] data_import: A `data_import` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesExtensionArgs']]] extensions: One or more `extension` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesIisLogArgs']]] iis_logs: One or more `iis_log` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesLogFileArgs']]] log_files: One or more `log_file` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPerformanceCounterArgs']]] performance_counters: One or more `performance_counter` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPlatformTelemetryArgs']]] platform_telemetries: One or more `platform_telemetry` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderArgs']]] prometheus_forwarders: One or more `prometheus_forwarder` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesSyslogArgs']]] syslogs: One or more `syslog` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsEventLogArgs']]] windows_event_logs: One or more `windows_event_log` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsFirewallLogArgs']]] windows_firewall_logs: One or more `windows_firewall_log` blocks as defined below.
        """
        if data_import is not None:
            pulumi.set(__self__, "data_import", data_import)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if iis_logs is not None:
            pulumi.set(__self__, "iis_logs", iis_logs)
        if log_files is not None:
            pulumi.set(__self__, "log_files", log_files)
        if performance_counters is not None:
            pulumi.set(__self__, "performance_counters", performance_counters)
        if platform_telemetries is not None:
            pulumi.set(__self__, "platform_telemetries", platform_telemetries)
        if prometheus_forwarders is not None:
            pulumi.set(__self__, "prometheus_forwarders", prometheus_forwarders)
        if syslogs is not None:
            pulumi.set(__self__, "syslogs", syslogs)
        if windows_event_logs is not None:
            pulumi.set(__self__, "windows_event_logs", windows_event_logs)
        if windows_firewall_logs is not None:
            pulumi.set(__self__, "windows_firewall_logs", windows_firewall_logs)

    @property
    @pulumi.getter(name="dataImport")
    def data_import(self) -> Optional[pulumi.Input['DataCollectionRuleDataSourcesDataImportArgs']]:
        """
        A `data_import` block as defined above.
        """
        return pulumi.get(self, "data_import")

    @data_import.setter
    def data_import(self, value: Optional[pulumi.Input['DataCollectionRuleDataSourcesDataImportArgs']]):
        pulumi.set(self, "data_import", value)

    @property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesExtensionArgs']]]]:
        """
        One or more `extension` blocks as defined below.
        """
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesExtensionArgs']]]]):
        pulumi.set(self, "extensions", value)

    @property
    @pulumi.getter(name="iisLogs")
    def iis_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesIisLogArgs']]]]:
        """
        One or more `iis_log` blocks as defined below.
        """
        return pulumi.get(self, "iis_logs")

    @iis_logs.setter
    def iis_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesIisLogArgs']]]]):
        pulumi.set(self, "iis_logs", value)

    @property
    @pulumi.getter(name="logFiles")
    def log_files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesLogFileArgs']]]]:
        """
        One or more `log_file` blocks as defined below.
        """
        return pulumi.get(self, "log_files")

    @log_files.setter
    def log_files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesLogFileArgs']]]]):
        pulumi.set(self, "log_files", value)

    @property
    @pulumi.getter(name="performanceCounters")
    def performance_counters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPerformanceCounterArgs']]]]:
        """
        One or more `performance_counter` blocks as defined below.
        """
        return pulumi.get(self, "performance_counters")

    @performance_counters.setter
    def performance_counters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPerformanceCounterArgs']]]]):
        pulumi.set(self, "performance_counters", value)

    @property
    @pulumi.getter(name="platformTelemetries")
    def platform_telemetries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPlatformTelemetryArgs']]]]:
        """
        One or more `platform_telemetry` blocks as defined below.
        """
        return pulumi.get(self, "platform_telemetries")

    @platform_telemetries.setter
    def platform_telemetries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPlatformTelemetryArgs']]]]):
        pulumi.set(self, "platform_telemetries", value)

    @property
    @pulumi.getter(name="prometheusForwarders")
    def prometheus_forwarders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderArgs']]]]:
        """
        One or more `prometheus_forwarder` blocks as defined below.
        """
        return pulumi.get(self, "prometheus_forwarders")

    @prometheus_forwarders.setter
    def prometheus_forwarders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderArgs']]]]):
        pulumi.set(self, "prometheus_forwarders", value)

    @property
    @pulumi.getter
    def syslogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesSyslogArgs']]]]:
        """
        One or more `syslog` blocks as defined below.
        """
        return pulumi.get(self, "syslogs")

    @syslogs.setter
    def syslogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesSyslogArgs']]]]):
        pulumi.set(self, "syslogs", value)

    @property
    @pulumi.getter(name="windowsEventLogs")
    def windows_event_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsEventLogArgs']]]]:
        """
        One or more `windows_event_log` blocks as defined below.
        """
        return pulumi.get(self, "windows_event_logs")

    @windows_event_logs.setter
    def windows_event_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsEventLogArgs']]]]):
        pulumi.set(self, "windows_event_logs", value)

    @property
    @pulumi.getter(name="windowsFirewallLogs")
    def windows_firewall_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsFirewallLogArgs']]]]:
        """
        One or more `windows_firewall_log` blocks as defined below.
        """
        return pulumi.get(self, "windows_firewall_logs")

    @windows_firewall_logs.setter
    def windows_firewall_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesWindowsFirewallLogArgs']]]]):
        pulumi.set(self, "windows_firewall_logs", value)


if not MYPY:
    class DataCollectionRuleDataSourcesDataImportArgsDict(TypedDict):
        event_hub_data_sources: pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgsDict']]]
        """
        An `event_hub_data_source` block as defined below.
        """
elif False:
    DataCollectionRuleDataSourcesDataImportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesDataImportArgs:
    def __init__(__self__, *,
                 event_hub_data_sources: pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgs']]] event_hub_data_sources: An `event_hub_data_source` block as defined below.
        """
        pulumi.set(__self__, "event_hub_data_sources", event_hub_data_sources)

    @property
    @pulumi.getter(name="eventHubDataSources")
    def event_hub_data_sources(self) -> pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgs']]]:
        """
        An `event_hub_data_source` block as defined below.
        """
        return pulumi.get(self, "event_hub_data_sources")

    @event_hub_data_sources.setter
    def event_hub_data_sources(self, value: pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgs']]]):
        pulumi.set(self, "event_hub_data_sources", value)


if not MYPY:
    class DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        stream: pulumi.Input[str]
        """
        The stream to collect from Event Hub. Possible value should be a custom stream name.
        """
        consumer_group: NotRequired[pulumi.Input[str]]
        """
        The Event Hub consumer group name.
        """
elif False:
    DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesDataImportEventHubDataSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 stream: pulumi.Input[str],
                 consumer_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[str] stream: The stream to collect from Event Hub. Possible value should be a custom stream name.
        :param pulumi.Input[str] consumer_group: The Event Hub consumer group name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stream", stream)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def stream(self) -> pulumi.Input[str]:
        """
        The stream to collect from Event Hub. Possible value should be a custom stream name.
        """
        return pulumi.get(self, "stream")

    @stream.setter
    def stream(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        """
        The Event Hub consumer group name.
        """
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)


if not MYPY:
    class DataCollectionRuleDataSourcesExtensionArgsDict(TypedDict):
        extension_name: pulumi.Input[str]
        """
        The name of the VM extension.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`.
        """
        extension_json: NotRequired[pulumi.Input[str]]
        """
        A JSON String which specifies the extension setting.
        """
        input_data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of data sources this extension needs data from. An item should be a name of a supported data source which produces only one stream. Supported data sources type: `performance_counter`, `windows_event_log`,and `syslog`.
        """
elif False:
    DataCollectionRuleDataSourcesExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesExtensionArgs:
    def __init__(__self__, *,
                 extension_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 extension_json: Optional[pulumi.Input[str]] = None,
                 input_data_sources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] extension_name: The name of the VM extension.
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`.
        :param pulumi.Input[str] extension_json: A JSON String which specifies the extension setting.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_data_sources: Specifies a list of data sources this extension needs data from. An item should be a name of a supported data source which produces only one stream. Supported data sources type: `performance_counter`, `windows_event_log`,and `syslog`.
        """
        pulumi.set(__self__, "extension_name", extension_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        if extension_json is not None:
            pulumi.set(__self__, "extension_json", extension_json)
        if input_data_sources is not None:
            pulumi.set(__self__, "input_data_sources", input_data_sources)

    @property
    @pulumi.getter(name="extensionName")
    def extension_name(self) -> pulumi.Input[str]:
        """
        The name of the VM extension.
        """
        return pulumi.get(self, "extension_name")

    @extension_name.setter
    def extension_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "extension_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="extensionJson")
    def extension_json(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON String which specifies the extension setting.
        """
        return pulumi.get(self, "extension_json")

    @extension_json.setter
    def extension_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extension_json", value)

    @property
    @pulumi.getter(name="inputDataSources")
    def input_data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of data sources this extension needs data from. An item should be a name of a supported data source which produces only one stream. Supported data sources type: `performance_counter`, `windows_event_log`,and `syslog`.
        """
        return pulumi.get(self, "input_data_sources")

    @input_data_sources.setter
    def input_data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_data_sources", value)


if not MYPY:
    class DataCollectionRuleDataSourcesIisLogArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-W3CIISLog`.
        """
        log_directories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of absolute paths where the log files are located.
        """
elif False:
    DataCollectionRuleDataSourcesIisLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesIisLogArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 log_directories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-W3CIISLog`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] log_directories: Specifies a list of absolute paths where the log files are located.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        if log_directories is not None:
            pulumi.set(__self__, "log_directories", log_directories)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-W3CIISLog`.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="logDirectories")
    def log_directories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of absolute paths where the log files are located.
        """
        return pulumi.get(self, "log_directories")

    @log_directories.setter
    def log_directories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "log_directories", value)


if not MYPY:
    class DataCollectionRuleDataSourcesLogFileArgsDict(TypedDict):
        file_patterns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of file patterns where the log files are located. For example, `C:\\\\JavaLogs\\\\*.log`.
        """
        format: pulumi.Input[str]
        """
        The data format of the log files. possible value is `text`.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value should be custom stream names.
        """
        settings: NotRequired[pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsArgsDict']]
        """
        A `settings` block as defined below.
        """
elif False:
    DataCollectionRuleDataSourcesLogFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesLogFileArgs:
    def __init__(__self__, *,
                 file_patterns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 format: pulumi.Input[str],
                 name: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 settings: Optional[pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_patterns: Specifies a list of file patterns where the log files are located. For example, `C:\\\\JavaLogs\\\\*.log`.
        :param pulumi.Input[str] format: The data format of the log files. possible value is `text`.
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value should be custom stream names.
        :param pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsArgs'] settings: A `settings` block as defined below.
        """
        pulumi.set(__self__, "file_patterns", file_patterns)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter(name="filePatterns")
    def file_patterns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of file patterns where the log files are located. For example, `C:\\\\JavaLogs\\\\*.log`.
        """
        return pulumi.get(self, "file_patterns")

    @file_patterns.setter
    def file_patterns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "file_patterns", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        The data format of the log files. possible value is `text`.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value should be custom stream names.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsArgs']]:
        """
        A `settings` block as defined below.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsArgs']]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class DataCollectionRuleDataSourcesLogFileSettingsArgsDict(TypedDict):
        text: pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsTextArgsDict']
        """
        A `text` block as defined below.
        """
elif False:
    DataCollectionRuleDataSourcesLogFileSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesLogFileSettingsArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsTextArgs']):
        """
        :param pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsTextArgs'] text: A `text` block as defined below.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsTextArgs']:
        """
        A `text` block as defined below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['DataCollectionRuleDataSourcesLogFileSettingsTextArgs']):
        pulumi.set(self, "text", value)


if not MYPY:
    class DataCollectionRuleDataSourcesLogFileSettingsTextArgsDict(TypedDict):
        record_start_timestamp_format: pulumi.Input[str]
        """
        The timestamp format of the text log files. Possible values are `ISO 8601`, `YYYY-MM-DD HH:MM:SS`, `M/D/YYYY HH:MM:SS AM/PM`, `Mon DD, YYYY HH:MM:SS`, `yyMMdd HH:mm:ss`, `ddMMyy HH:mm:ss`, `MMM d hh:mm:ss`, `dd/MMM/yyyy:HH:mm:ss zzz`,and `yyyy-MM-ddTHH:mm:ssK`.
        """
elif False:
    DataCollectionRuleDataSourcesLogFileSettingsTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesLogFileSettingsTextArgs:
    def __init__(__self__, *,
                 record_start_timestamp_format: pulumi.Input[str]):
        """
        :param pulumi.Input[str] record_start_timestamp_format: The timestamp format of the text log files. Possible values are `ISO 8601`, `YYYY-MM-DD HH:MM:SS`, `M/D/YYYY HH:MM:SS AM/PM`, `Mon DD, YYYY HH:MM:SS`, `yyMMdd HH:mm:ss`, `ddMMyy HH:mm:ss`, `MMM d hh:mm:ss`, `dd/MMM/yyyy:HH:mm:ss zzz`,and `yyyy-MM-ddTHH:mm:ssK`.
        """
        pulumi.set(__self__, "record_start_timestamp_format", record_start_timestamp_format)

    @property
    @pulumi.getter(name="recordStartTimestampFormat")
    def record_start_timestamp_format(self) -> pulumi.Input[str]:
        """
        The timestamp format of the text log files. Possible values are `ISO 8601`, `YYYY-MM-DD HH:MM:SS`, `M/D/YYYY HH:MM:SS AM/PM`, `Mon DD, YYYY HH:MM:SS`, `yyMMdd HH:mm:ss`, `ddMMyy HH:mm:ss`, `MMM d hh:mm:ss`, `dd/MMM/yyyy:HH:mm:ss zzz`,and `yyyy-MM-ddTHH:mm:ssK`.
        """
        return pulumi.get(self, "record_start_timestamp_format")

    @record_start_timestamp_format.setter
    def record_start_timestamp_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "record_start_timestamp_format", value)


if not MYPY:
    class DataCollectionRuleDataSourcesPerformanceCounterArgsDict(TypedDict):
        counter_specifiers: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of specifier names of the performance counters you want to collect. To get a list of performance counters on Windows, run the command `typeperf`. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-sources-performance-counters#configure-performance-counters) for more information.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        sampling_frequency_in_seconds: pulumi.Input[int]
        """
        The number of seconds between consecutive counter measurements (samples). The value should be integer between `1` and `1800` inclusive. `sampling_frequency_in_seconds` must be equal to `60` seconds for counters collected with `Microsoft-InsightsMetrics` stream.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-InsightsMetrics`,and `Microsoft-Perf`.
        """
elif False:
    DataCollectionRuleDataSourcesPerformanceCounterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesPerformanceCounterArgs:
    def __init__(__self__, *,
                 counter_specifiers: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 sampling_frequency_in_seconds: pulumi.Input[int],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] counter_specifiers: Specifies a list of specifier names of the performance counters you want to collect. To get a list of performance counters on Windows, run the command `typeperf`. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-sources-performance-counters#configure-performance-counters) for more information.
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[int] sampling_frequency_in_seconds: The number of seconds between consecutive counter measurements (samples). The value should be integer between `1` and `1800` inclusive. `sampling_frequency_in_seconds` must be equal to `60` seconds for counters collected with `Microsoft-InsightsMetrics` stream.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-InsightsMetrics`,and `Microsoft-Perf`.
        """
        pulumi.set(__self__, "counter_specifiers", counter_specifiers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sampling_frequency_in_seconds", sampling_frequency_in_seconds)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="counterSpecifiers")
    def counter_specifiers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of specifier names of the performance counters you want to collect. To get a list of performance counters on Windows, run the command `typeperf`. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-sources-performance-counters#configure-performance-counters) for more information.
        """
        return pulumi.get(self, "counter_specifiers")

    @counter_specifiers.setter
    def counter_specifiers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "counter_specifiers", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="samplingFrequencyInSeconds")
    def sampling_frequency_in_seconds(self) -> pulumi.Input[int]:
        """
        The number of seconds between consecutive counter measurements (samples). The value should be integer between `1` and `1800` inclusive. `sampling_frequency_in_seconds` must be equal to `60` seconds for counters collected with `Microsoft-InsightsMetrics` stream.
        """
        return pulumi.get(self, "sampling_frequency_in_seconds")

    @sampling_frequency_in_seconds.setter
    def sampling_frequency_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "sampling_frequency_in_seconds", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-InsightsMetrics`,and `Microsoft-Perf`.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class DataCollectionRuleDataSourcesPlatformTelemetryArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft.Cache/redis:Metrics-Group-All`.
        """
elif False:
    DataCollectionRuleDataSourcesPlatformTelemetryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesPlatformTelemetryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft.Cache/redis:Metrics-Group-All`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft.Cache/redis:Metrics-Group-All`.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class DataCollectionRuleDataSourcesPrometheusForwarderArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-PrometheusMetrics`.
        """
        label_include_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgsDict']]]]
        """
        One or more `label_include_filter` blocks as defined above.
        """
elif False:
    DataCollectionRuleDataSourcesPrometheusForwarderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesPrometheusForwarderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 label_include_filters: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-PrometheusMetrics`.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgs']]] label_include_filters: One or more `label_include_filter` blocks as defined above.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        if label_include_filters is not None:
            pulumi.set(__self__, "label_include_filters", label_include_filters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-PrometheusMetrics`.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="labelIncludeFilters")
    def label_include_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgs']]]]:
        """
        One or more `label_include_filter` blocks as defined above.
        """
        return pulumi.get(self, "label_include_filters")

    @label_include_filters.setter
    def label_include_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgs']]]]):
        pulumi.set(self, "label_include_filters", value)


if not MYPY:
    class DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgsDict(TypedDict):
        label: pulumi.Input[str]
        """
        The label of the filter. This label should be unique across all `label_include_fileter` block. Possible value is `microsoft_metrics_include_label`.
        """
        value: pulumi.Input[str]
        """
        The value of the filter.
        """
elif False:
    DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilterArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] label: The label of the filter. This label should be unique across all `label_include_fileter` block. Possible value is `microsoft_metrics_include_label`.
        :param pulumi.Input[str] value: The value of the filter.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        The label of the filter. This label should be unique across all `label_include_fileter` block. Possible value is `microsoft_metrics_include_label`.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the filter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DataCollectionRuleDataSourcesSyslogArgsDict(TypedDict):
        facility_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of facility names. Use a wildcard `*` to collect logs for all facility names. Possible values are `alert`, `*`, `audit`, `auth`, `authpriv`, `clock`, `cron`, `daemon`, `ftp`, `kern`, `local5`, `local4`, `local1`, `local7`, `local6`, `local3`, `local2`, `local0`, `lpr`, `mail`, `mark`, `news`, `nopri`, `ntp`, `syslog`, `user` and `uucp`.
        """
        log_levels: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of log levels. Use a wildcard `*` to collect logs for all log levels. Possible values are `Debug`, `Info`, `Notice`, `Warning`, `Error`, `Critical`, `Alert`, `Emergency`,and `*`.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Syslog`,and `Microsoft-CiscoAsa`, and `Microsoft-CommonSecurityLog`.
        """
elif False:
    DataCollectionRuleDataSourcesSyslogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesSyslogArgs:
    def __init__(__self__, *,
                 facility_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 log_levels: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] facility_names: Specifies a list of facility names. Use a wildcard `*` to collect logs for all facility names. Possible values are `alert`, `*`, `audit`, `auth`, `authpriv`, `clock`, `cron`, `daemon`, `ftp`, `kern`, `local5`, `local4`, `local1`, `local7`, `local6`, `local3`, `local2`, `local0`, `lpr`, `mail`, `mark`, `news`, `nopri`, `ntp`, `syslog`, `user` and `uucp`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] log_levels: Specifies a list of log levels. Use a wildcard `*` to collect logs for all log levels. Possible values are `Debug`, `Info`, `Notice`, `Warning`, `Error`, `Critical`, `Alert`, `Emergency`,and `*`.
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Syslog`,and `Microsoft-CiscoAsa`, and `Microsoft-CommonSecurityLog`.
        """
        pulumi.set(__self__, "facility_names", facility_names)
        pulumi.set(__self__, "log_levels", log_levels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter(name="facilityNames")
    def facility_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of facility names. Use a wildcard `*` to collect logs for all facility names. Possible values are `alert`, `*`, `audit`, `auth`, `authpriv`, `clock`, `cron`, `daemon`, `ftp`, `kern`, `local5`, `local4`, `local1`, `local7`, `local6`, `local3`, `local2`, `local0`, `lpr`, `mail`, `mark`, `news`, `nopri`, `ntp`, `syslog`, `user` and `uucp`.
        """
        return pulumi.get(self, "facility_names")

    @facility_names.setter
    def facility_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "facility_names", value)

    @property
    @pulumi.getter(name="logLevels")
    def log_levels(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of log levels. Use a wildcard `*` to collect logs for all log levels. Possible values are `Debug`, `Info`, `Notice`, `Warning`, `Error`, `Critical`, `Alert`, `Emergency`,and `*`.
        """
        return pulumi.get(self, "log_levels")

    @log_levels.setter
    def log_levels(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "log_levels", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Syslog`,and `Microsoft-CiscoAsa`, and `Microsoft-CommonSecurityLog`.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class DataCollectionRuleDataSourcesWindowsEventLogArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`,and `Microsoft-WindowsEvent`, `Microsoft-RomeDetectionEvent`, and `Microsoft-SecurityEvent`.
        """
        x_path_queries: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of Windows Event Log queries in XPath expression. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-collection-rule-azure-monitor-agent?tabs=cli#filter-events-using-xpath-queries) for more information.
        """
elif False:
    DataCollectionRuleDataSourcesWindowsEventLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesWindowsEventLogArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]],
                 x_path_queries: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`,and `Microsoft-WindowsEvent`, `Microsoft-RomeDetectionEvent`, and `Microsoft-SecurityEvent`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_path_queries: Specifies a list of Windows Event Log queries in XPath expression. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-collection-rule-azure-monitor-agent?tabs=cli#filter-events-using-xpath-queries) for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)
        pulumi.set(__self__, "x_path_queries", x_path_queries)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`,and `Microsoft-WindowsEvent`, `Microsoft-RomeDetectionEvent`, and `Microsoft-SecurityEvent`.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="xPathQueries")
    def x_path_queries(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of Windows Event Log queries in XPath expression. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-collection-rule-azure-monitor-agent?tabs=cli#filter-events-using-xpath-queries) for more information.
        """
        return pulumi.get(self, "x_path_queries")

    @x_path_queries.setter
    def x_path_queries(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "x_path_queries", value)


if not MYPY:
    class DataCollectionRuleDataSourcesWindowsFirewallLogArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        streams: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
elif False:
    DataCollectionRuleDataSourcesWindowsFirewallLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDataSourcesWindowsFirewallLogArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streams: Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streams", value)


if not MYPY:
    class DataCollectionRuleDestinationsArgsDict(TypedDict):
        azure_monitor_metrics: NotRequired[pulumi.Input['DataCollectionRuleDestinationsAzureMonitorMetricsArgsDict']]
        """
        A `azure_monitor_metrics` block as defined above.
        """
        event_hub: NotRequired[pulumi.Input['DataCollectionRuleDestinationsEventHubArgsDict']]
        """
        One or more `event_hub` blocks as defined below.
        """
        event_hub_direct: NotRequired[pulumi.Input['DataCollectionRuleDestinationsEventHubDirectArgsDict']]
        """
        One or more `event_hub` blocks as defined below.
        """
        log_analytics: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsLogAnalyticArgsDict']]]]
        """
        One or more `log_analytics` blocks as defined below.
        """
        monitor_accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsMonitorAccountArgsDict']]]]
        """
        One or more `monitor_account` blocks as defined below.
        """
        storage_blob_directs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobDirectArgsDict']]]]
        """
        One or more `storage_blob_direct` blocks as defined below.
        """
        storage_blobs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobArgsDict']]]]
        """
        One or more `storage_blob` blocks as defined below.
        """
        storage_table_directs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageTableDirectArgsDict']]]]
        """
        One or more `storage_table_direct` blocks as defined below.

        > **NOTE** `event_hub_direct`, `storage_blob_direct`, and `storage_table_direct` are only available for rules of kind `AgentDirectToStore`.

        > **NOTE** At least one of `azure_monitor_metrics`, `event_hub`, `event_hub_direct`, `log_analytics`, `monitor_account`, `storage_blob`, `storage_blob_direct`,and `storage_table_direct` blocks must be specified.
        """
elif False:
    DataCollectionRuleDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsArgs:
    def __init__(__self__, *,
                 azure_monitor_metrics: Optional[pulumi.Input['DataCollectionRuleDestinationsAzureMonitorMetricsArgs']] = None,
                 event_hub: Optional[pulumi.Input['DataCollectionRuleDestinationsEventHubArgs']] = None,
                 event_hub_direct: Optional[pulumi.Input['DataCollectionRuleDestinationsEventHubDirectArgs']] = None,
                 log_analytics: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsLogAnalyticArgs']]]] = None,
                 monitor_accounts: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsMonitorAccountArgs']]]] = None,
                 storage_blob_directs: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobDirectArgs']]]] = None,
                 storage_blobs: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobArgs']]]] = None,
                 storage_table_directs: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageTableDirectArgs']]]] = None):
        """
        :param pulumi.Input['DataCollectionRuleDestinationsAzureMonitorMetricsArgs'] azure_monitor_metrics: A `azure_monitor_metrics` block as defined above.
        :param pulumi.Input['DataCollectionRuleDestinationsEventHubArgs'] event_hub: One or more `event_hub` blocks as defined below.
        :param pulumi.Input['DataCollectionRuleDestinationsEventHubDirectArgs'] event_hub_direct: One or more `event_hub` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsLogAnalyticArgs']]] log_analytics: One or more `log_analytics` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsMonitorAccountArgs']]] monitor_accounts: One or more `monitor_account` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobDirectArgs']]] storage_blob_directs: One or more `storage_blob_direct` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobArgs']]] storage_blobs: One or more `storage_blob` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageTableDirectArgs']]] storage_table_directs: One or more `storage_table_direct` blocks as defined below.
               
               > **NOTE** `event_hub_direct`, `storage_blob_direct`, and `storage_table_direct` are only available for rules of kind `AgentDirectToStore`.
               
               > **NOTE** At least one of `azure_monitor_metrics`, `event_hub`, `event_hub_direct`, `log_analytics`, `monitor_account`, `storage_blob`, `storage_blob_direct`,and `storage_table_direct` blocks must be specified.
        """
        if azure_monitor_metrics is not None:
            pulumi.set(__self__, "azure_monitor_metrics", azure_monitor_metrics)
        if event_hub is not None:
            pulumi.set(__self__, "event_hub", event_hub)
        if event_hub_direct is not None:
            pulumi.set(__self__, "event_hub_direct", event_hub_direct)
        if log_analytics is not None:
            pulumi.set(__self__, "log_analytics", log_analytics)
        if monitor_accounts is not None:
            pulumi.set(__self__, "monitor_accounts", monitor_accounts)
        if storage_blob_directs is not None:
            pulumi.set(__self__, "storage_blob_directs", storage_blob_directs)
        if storage_blobs is not None:
            pulumi.set(__self__, "storage_blobs", storage_blobs)
        if storage_table_directs is not None:
            pulumi.set(__self__, "storage_table_directs", storage_table_directs)

    @property
    @pulumi.getter(name="azureMonitorMetrics")
    def azure_monitor_metrics(self) -> Optional[pulumi.Input['DataCollectionRuleDestinationsAzureMonitorMetricsArgs']]:
        """
        A `azure_monitor_metrics` block as defined above.
        """
        return pulumi.get(self, "azure_monitor_metrics")

    @azure_monitor_metrics.setter
    def azure_monitor_metrics(self, value: Optional[pulumi.Input['DataCollectionRuleDestinationsAzureMonitorMetricsArgs']]):
        pulumi.set(self, "azure_monitor_metrics", value)

    @property
    @pulumi.getter(name="eventHub")
    def event_hub(self) -> Optional[pulumi.Input['DataCollectionRuleDestinationsEventHubArgs']]:
        """
        One or more `event_hub` blocks as defined below.
        """
        return pulumi.get(self, "event_hub")

    @event_hub.setter
    def event_hub(self, value: Optional[pulumi.Input['DataCollectionRuleDestinationsEventHubArgs']]):
        pulumi.set(self, "event_hub", value)

    @property
    @pulumi.getter(name="eventHubDirect")
    def event_hub_direct(self) -> Optional[pulumi.Input['DataCollectionRuleDestinationsEventHubDirectArgs']]:
        """
        One or more `event_hub` blocks as defined below.
        """
        return pulumi.get(self, "event_hub_direct")

    @event_hub_direct.setter
    def event_hub_direct(self, value: Optional[pulumi.Input['DataCollectionRuleDestinationsEventHubDirectArgs']]):
        pulumi.set(self, "event_hub_direct", value)

    @property
    @pulumi.getter(name="logAnalytics")
    def log_analytics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsLogAnalyticArgs']]]]:
        """
        One or more `log_analytics` blocks as defined below.
        """
        return pulumi.get(self, "log_analytics")

    @log_analytics.setter
    def log_analytics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsLogAnalyticArgs']]]]):
        pulumi.set(self, "log_analytics", value)

    @property
    @pulumi.getter(name="monitorAccounts")
    def monitor_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsMonitorAccountArgs']]]]:
        """
        One or more `monitor_account` blocks as defined below.
        """
        return pulumi.get(self, "monitor_accounts")

    @monitor_accounts.setter
    def monitor_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsMonitorAccountArgs']]]]):
        pulumi.set(self, "monitor_accounts", value)

    @property
    @pulumi.getter(name="storageBlobDirects")
    def storage_blob_directs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobDirectArgs']]]]:
        """
        One or more `storage_blob_direct` blocks as defined below.
        """
        return pulumi.get(self, "storage_blob_directs")

    @storage_blob_directs.setter
    def storage_blob_directs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobDirectArgs']]]]):
        pulumi.set(self, "storage_blob_directs", value)

    @property
    @pulumi.getter(name="storageBlobs")
    def storage_blobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobArgs']]]]:
        """
        One or more `storage_blob` blocks as defined below.
        """
        return pulumi.get(self, "storage_blobs")

    @storage_blobs.setter
    def storage_blobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageBlobArgs']]]]):
        pulumi.set(self, "storage_blobs", value)

    @property
    @pulumi.getter(name="storageTableDirects")
    def storage_table_directs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageTableDirectArgs']]]]:
        """
        One or more `storage_table_direct` blocks as defined below.

        > **NOTE** `event_hub_direct`, `storage_blob_direct`, and `storage_table_direct` are only available for rules of kind `AgentDirectToStore`.

        > **NOTE** At least one of `azure_monitor_metrics`, `event_hub`, `event_hub_direct`, `log_analytics`, `monitor_account`, `storage_blob`, `storage_blob_direct`,and `storage_table_direct` blocks must be specified.
        """
        return pulumi.get(self, "storage_table_directs")

    @storage_table_directs.setter
    def storage_table_directs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleDestinationsStorageTableDirectArgs']]]]):
        pulumi.set(self, "storage_table_directs", value)


if not MYPY:
    class DataCollectionRuleDestinationsAzureMonitorMetricsArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
elif False:
    DataCollectionRuleDestinationsAzureMonitorMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsAzureMonitorMetricsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DataCollectionRuleDestinationsEventHubArgsDict(TypedDict):
        event_hub_id: pulumi.Input[str]
        """
        The resource ID of the Event Hub.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
elif False:
    DataCollectionRuleDestinationsEventHubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsEventHubArgs:
    def __init__(__self__, *,
                 event_hub_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] event_hub_id: The resource ID of the Event Hub.
        :param pulumi.Input[str] name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        pulumi.set(__self__, "event_hub_id", event_hub_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubId")
    def event_hub_id(self) -> pulumi.Input[str]:
        """
        The resource ID of the Event Hub.
        """
        return pulumi.get(self, "event_hub_id")

    @event_hub_id.setter
    def event_hub_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_hub_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DataCollectionRuleDestinationsEventHubDirectArgsDict(TypedDict):
        event_hub_id: pulumi.Input[str]
        """
        The resource ID of the Event Hub.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
elif False:
    DataCollectionRuleDestinationsEventHubDirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsEventHubDirectArgs:
    def __init__(__self__, *,
                 event_hub_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] event_hub_id: The resource ID of the Event Hub.
        :param pulumi.Input[str] name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        pulumi.set(__self__, "event_hub_id", event_hub_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="eventHubId")
    def event_hub_id(self) -> pulumi.Input[str]:
        """
        The resource ID of the Event Hub.
        """
        return pulumi.get(self, "event_hub_id")

    @event_hub_id.setter
    def event_hub_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_hub_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DataCollectionRuleDestinationsLogAnalyticArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        workspace_resource_id: pulumi.Input[str]
        """
        The ID of a Log Analytic Workspace resource.
        """
elif False:
    DataCollectionRuleDestinationsLogAnalyticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsLogAnalyticArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 workspace_resource_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        :param pulumi.Input[str] workspace_resource_id: The ID of a Log Analytic Workspace resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "workspace_resource_id", workspace_resource_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="workspaceResourceId")
    def workspace_resource_id(self) -> pulumi.Input[str]:
        """
        The ID of a Log Analytic Workspace resource.
        """
        return pulumi.get(self, "workspace_resource_id")

    @workspace_resource_id.setter
    def workspace_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_resource_id", value)


if not MYPY:
    class DataCollectionRuleDestinationsMonitorAccountArgsDict(TypedDict):
        monitor_account_id: pulumi.Input[str]
        """
        The resource ID of the Monitor Account.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
elif False:
    DataCollectionRuleDestinationsMonitorAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsMonitorAccountArgs:
    def __init__(__self__, *,
                 monitor_account_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] monitor_account_id: The resource ID of the Monitor Account.
        :param pulumi.Input[str] name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        pulumi.set(__self__, "monitor_account_id", monitor_account_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="monitorAccountId")
    def monitor_account_id(self) -> pulumi.Input[str]:
        """
        The resource ID of the Monitor Account.
        """
        return pulumi.get(self, "monitor_account_id")

    @monitor_account_id.setter
    def monitor_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "monitor_account_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DataCollectionRuleDestinationsStorageBlobArgsDict(TypedDict):
        container_name: pulumi.Input[str]
        """
        The Storage Container name.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        storage_account_id: pulumi.Input[str]
        """
        The resource ID of the Storage Account.
        """
elif False:
    DataCollectionRuleDestinationsStorageBlobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsStorageBlobArgs:
    def __init__(__self__, *,
                 container_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 storage_account_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] container_name: The Storage Container name.
        :param pulumi.Input[str] name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        :param pulumi.Input[str] storage_account_id: The resource ID of the Storage Account.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[str]:
        """
        The Storage Container name.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        The resource ID of the Storage Account.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)


if not MYPY:
    class DataCollectionRuleDestinationsStorageBlobDirectArgsDict(TypedDict):
        container_name: pulumi.Input[str]
        """
        The Storage Container name.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        storage_account_id: pulumi.Input[str]
        """
        The resource ID of the Storage Account.
        """
elif False:
    DataCollectionRuleDestinationsStorageBlobDirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsStorageBlobDirectArgs:
    def __init__(__self__, *,
                 container_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 storage_account_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] container_name: The Storage Container name.
        :param pulumi.Input[str] name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        :param pulumi.Input[str] storage_account_id: The resource ID of the Storage Account.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[str]:
        """
        The Storage Container name.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        The resource ID of the Storage Account.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)


if not MYPY:
    class DataCollectionRuleDestinationsStorageTableDirectArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        storage_account_id: pulumi.Input[str]
        """
        The resource ID of the Storage Account.
        """
        table_name: pulumi.Input[str]
        """
        The Storage Table name.
        """
elif False:
    DataCollectionRuleDestinationsStorageTableDirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleDestinationsStorageTableDirectArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 storage_account_id: pulumi.Input[str],
                 table_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        :param pulumi.Input[str] storage_account_id: The resource ID of the Storage Account.
        :param pulumi.Input[str] table_name: The Storage Table name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        The resource ID of the Storage Account.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The Storage Table name.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class DataCollectionRuleIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Data Collection Rule. Currently, up to 1 identity is supported.

        > **NOTE:** This is required when `type` is set to `UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    DataCollectionRuleIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Data Collection Rule. Currently, up to 1 identity is supported.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Data Collection Rule. Currently, up to 1 identity is supported.

        > **NOTE:** This is required when `type` is set to `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class DataCollectionRuleStreamDeclarationArgsDict(TypedDict):
        columns: pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleStreamDeclarationColumnArgsDict']]]
        """
        One or more `column` blocks as defined above.
        """
        stream_name: pulumi.Input[str]
        """
        The name of the custom stream. This name should be unique across all `stream_declaration` blocks and must begin with a prefix of `Custom-`.
        """
elif False:
    DataCollectionRuleStreamDeclarationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleStreamDeclarationArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleStreamDeclarationColumnArgs']]],
                 stream_name: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleStreamDeclarationColumnArgs']]] columns: One or more `column` blocks as defined above.
        :param pulumi.Input[str] stream_name: The name of the custom stream. This name should be unique across all `stream_declaration` blocks and must begin with a prefix of `Custom-`.
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleStreamDeclarationColumnArgs']]]:
        """
        One or more `column` blocks as defined above.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input['DataCollectionRuleStreamDeclarationColumnArgs']]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        The name of the custom stream. This name should be unique across all `stream_declaration` blocks and must begin with a prefix of `Custom-`.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)


if not MYPY:
    class DataCollectionRuleStreamDeclarationColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        type: pulumi.Input[str]
        """
        The type of the column data. Possible values are `string`, `int`, `long`, `real`, `boolean`, `datetime`,and `dynamic`.
        """
elif False:
    DataCollectionRuleStreamDeclarationColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCollectionRuleStreamDeclarationColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] type: The type of the column data. Possible values are `string`, `int`, `long`, `real`, `boolean`, `datetime`,and `dynamic`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the column data. Possible values are `string`, `int`, `long`, `real`, `boolean`, `datetime`,and `dynamic`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DiagnosticSettingEnabledLogArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[str]]
        """
        The name of a Diagnostic Log Category for this Resource.

        > **NOTE:** The Log Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source or [list of service specific schemas](https://docs.microsoft.com/azure/azure-monitor/platform/resource-logs-schema#service-specific-schemas) to identify which categories are available for a given Resource.
        """
        category_group: NotRequired[pulumi.Input[str]]
        """
        The name of a Diagnostic Log Category Group for this Resource.

        > **NOTE:** Not all resources have category groups available.

        > **NOTE:** Exactly one of `category` or `category_group` must be specified.
        """
        retention_policy: NotRequired[pulumi.Input['DiagnosticSettingEnabledLogRetentionPolicyArgsDict']]
elif False:
    DiagnosticSettingEnabledLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosticSettingEnabledLogArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[str]] = None,
                 category_group: Optional[pulumi.Input[str]] = None,
                 retention_policy: Optional[pulumi.Input['DiagnosticSettingEnabledLogRetentionPolicyArgs']] = None):
        """
        :param pulumi.Input[str] category: The name of a Diagnostic Log Category for this Resource.
               
               > **NOTE:** The Log Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source or [list of service specific schemas](https://docs.microsoft.com/azure/azure-monitor/platform/resource-logs-schema#service-specific-schemas) to identify which categories are available for a given Resource.
        :param pulumi.Input[str] category_group: The name of a Diagnostic Log Category Group for this Resource.
               
               > **NOTE:** Not all resources have category groups available.
               
               > **NOTE:** Exactly one of `category` or `category_group` must be specified.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if category_group is not None:
            pulumi.set(__self__, "category_group", category_group)
        if retention_policy is not None:
            warnings.warn("""`retention_policy` has been deprecated in favor of `storage.ManagementPolicy` resource - to learn more https://aka.ms/diagnostic_settings_log_retention""", DeprecationWarning)
            pulumi.log.warn("""retention_policy is deprecated: `retention_policy` has been deprecated in favor of `storage.ManagementPolicy` resource - to learn more https://aka.ms/diagnostic_settings_log_retention""")
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a Diagnostic Log Category for this Resource.

        > **NOTE:** The Log Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source or [list of service specific schemas](https://docs.microsoft.com/azure/azure-monitor/platform/resource-logs-schema#service-specific-schemas) to identify which categories are available for a given Resource.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter(name="categoryGroup")
    def category_group(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a Diagnostic Log Category Group for this Resource.

        > **NOTE:** Not all resources have category groups available.

        > **NOTE:** Exactly one of `category` or `category_group` must be specified.
        """
        return pulumi.get(self, "category_group")

    @category_group.setter
    def category_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category_group", value)

    @property
    @pulumi.getter(name="retentionPolicy")
    @_utilities.deprecated("""`retention_policy` has been deprecated in favor of `storage.ManagementPolicy` resource - to learn more https://aka.ms/diagnostic_settings_log_retention""")
    def retention_policy(self) -> Optional[pulumi.Input['DiagnosticSettingEnabledLogRetentionPolicyArgs']]:
        return pulumi.get(self, "retention_policy")

    @retention_policy.setter
    def retention_policy(self, value: Optional[pulumi.Input['DiagnosticSettingEnabledLogRetentionPolicyArgs']]):
        pulumi.set(self, "retention_policy", value)


if not MYPY:
    class DiagnosticSettingEnabledLogRetentionPolicyArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        days: NotRequired[pulumi.Input[int]]
elif False:
    DiagnosticSettingEnabledLogRetentionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosticSettingEnabledLogRetentionPolicyArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class DiagnosticSettingMetricArgsDict(TypedDict):
        category: pulumi.Input[str]
        """
        The name of a Diagnostic Metric Category for this Resource.

        > **NOTE:** The Metric Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source to identify which categories are available for a given Resource.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        retention_policy: NotRequired[pulumi.Input['DiagnosticSettingMetricRetentionPolicyArgsDict']]
elif False:
    DiagnosticSettingMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosticSettingMetricArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 retention_policy: Optional[pulumi.Input['DiagnosticSettingMetricRetentionPolicyArgs']] = None):
        """
        :param pulumi.Input[str] category: The name of a Diagnostic Metric Category for this Resource.
               
               > **NOTE:** The Metric Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source to identify which categories are available for a given Resource.
        :param pulumi.Input[bool] enabled: Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "category", category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if retention_policy is not None:
            warnings.warn("""`retention_policy` has been deprecated in favor of `storage.ManagementPolicy` resource - to learn more https://aka.ms/diagnostic_settings_log_retention""", DeprecationWarning)
            pulumi.log.warn("""retention_policy is deprecated: `retention_policy` has been deprecated in favor of `storage.ManagementPolicy` resource - to learn more https://aka.ms/diagnostic_settings_log_retention""")
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[str]:
        """
        The name of a Diagnostic Metric Category for this Resource.

        > **NOTE:** The Metric Categories available vary depending on the Resource being used. You may wish to use the `monitoring_get_diagnostic_categories` Data Source to identify which categories are available for a given Resource.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="retentionPolicy")
    @_utilities.deprecated("""`retention_policy` has been deprecated in favor of `storage.ManagementPolicy` resource - to learn more https://aka.ms/diagnostic_settings_log_retention""")
    def retention_policy(self) -> Optional[pulumi.Input['DiagnosticSettingMetricRetentionPolicyArgs']]:
        return pulumi.get(self, "retention_policy")

    @retention_policy.setter
    def retention_policy(self, value: Optional[pulumi.Input['DiagnosticSettingMetricRetentionPolicyArgs']]):
        pulumi.set(self, "retention_policy", value)


if not MYPY:
    class DiagnosticSettingMetricRetentionPolicyArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        days: NotRequired[pulumi.Input[int]]
elif False:
    DiagnosticSettingMetricRetentionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosticSettingMetricRetentionPolicyArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Is this Diagnostic Metric enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class MetricAlertActionArgsDict(TypedDict):
        action_group_id: pulumi.Input[str]
        """
        The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource
        """
        webhook_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
elif False:
    MetricAlertActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlertActionArgs:
    def __init__(__self__, *,
                 action_group_id: pulumi.Input[str],
                 webhook_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] action_group_id: The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] webhook_properties: The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
        pulumi.set(__self__, "action_group_id", action_group_id)
        if webhook_properties is not None:
            pulumi.set(__self__, "webhook_properties", webhook_properties)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> pulumi.Input[str]:
        """
        The ID of the Action Group can be sourced from the `monitoring.ActionGroup` resource
        """
        return pulumi.get(self, "action_group_id")

    @action_group_id.setter
    def action_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_group_id", value)

    @property
    @pulumi.getter(name="webhookProperties")
    def webhook_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
        """
        return pulumi.get(self, "webhook_properties")

    @webhook_properties.setter
    def webhook_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "webhook_properties", value)


if not MYPY:
    class MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteriaArgsDict(TypedDict):
        component_id: pulumi.Input[str]
        """
        The ID of the Application Insights Resource.
        """
        failed_location_count: pulumi.Input[int]
        """
        The number of failed locations.
        """
        web_test_id: pulumi.Input[str]
        """
        The ID of the Application Insights Web Test.
        """
elif False:
    MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteriaArgs:
    def __init__(__self__, *,
                 component_id: pulumi.Input[str],
                 failed_location_count: pulumi.Input[int],
                 web_test_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] component_id: The ID of the Application Insights Resource.
        :param pulumi.Input[int] failed_location_count: The number of failed locations.
        :param pulumi.Input[str] web_test_id: The ID of the Application Insights Web Test.
        """
        pulumi.set(__self__, "component_id", component_id)
        pulumi.set(__self__, "failed_location_count", failed_location_count)
        pulumi.set(__self__, "web_test_id", web_test_id)

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> pulumi.Input[str]:
        """
        The ID of the Application Insights Resource.
        """
        return pulumi.get(self, "component_id")

    @component_id.setter
    def component_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "component_id", value)

    @property
    @pulumi.getter(name="failedLocationCount")
    def failed_location_count(self) -> pulumi.Input[int]:
        """
        The number of failed locations.
        """
        return pulumi.get(self, "failed_location_count")

    @failed_location_count.setter
    def failed_location_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "failed_location_count", value)

    @property
    @pulumi.getter(name="webTestId")
    def web_test_id(self) -> pulumi.Input[str]:
        """
        The ID of the Application Insights Web Test.
        """
        return pulumi.get(self, "web_test_id")

    @web_test_id.setter
    def web_test_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "web_test_id", value)


if not MYPY:
    class MetricAlertCriteriaArgsDict(TypedDict):
        aggregation: pulumi.Input[str]
        """
        The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        """
        metric_name: pulumi.Input[str]
        """
        One of the metric names to be monitored.
        """
        metric_namespace: pulumi.Input[str]
        """
        One of the metric namespaces to be monitored.
        """
        operator: pulumi.Input[str]
        """
        The criteria operator. Possible values are `Equals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        threshold: pulumi.Input[float]
        """
        The criteria threshold value that activates the alert.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricAlertCriteriaDimensionArgsDict']]]]
        """
        One or more `dimension` blocks as defined below.
        """
        skip_metric_validation: NotRequired[pulumi.Input[bool]]
        """
        Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted? Defaults to `false`.
        """
elif False:
    MetricAlertCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlertCriteriaArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric_name: pulumi.Input[str],
                 metric_namespace: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['MetricAlertCriteriaDimensionArgs']]]] = None,
                 skip_metric_validation: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] aggregation: The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        :param pulumi.Input[str] metric_name: One of the metric names to be monitored.
        :param pulumi.Input[str] metric_namespace: One of the metric namespaces to be monitored.
        :param pulumi.Input[str] operator: The criteria operator. Possible values are `Equals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        :param pulumi.Input[float] threshold: The criteria threshold value that activates the alert.
        :param pulumi.Input[Sequence[pulumi.Input['MetricAlertCriteriaDimensionArgs']]] dimensions: One or more `dimension` blocks as defined below.
        :param pulumi.Input[bool] skip_metric_validation: Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted? Defaults to `false`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if skip_metric_validation is not None:
            pulumi.set(__self__, "skip_metric_validation", skip_metric_validation)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        One of the metric names to be monitored.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[str]:
        """
        One of the metric namespaces to be monitored.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_namespace", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The criteria operator. Possible values are `Equals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The criteria threshold value that activates the alert.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricAlertCriteriaDimensionArgs']]]]:
        """
        One or more `dimension` blocks as defined below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricAlertCriteriaDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="skipMetricValidation")
    def skip_metric_validation(self) -> Optional[pulumi.Input[bool]]:
        """
        Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted? Defaults to `false`.
        """
        return pulumi.get(self, "skip_metric_validation")

    @skip_metric_validation.setter
    def skip_metric_validation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_metric_validation", value)


if not MYPY:
    class MetricAlertCriteriaDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        One of the dimension names.
        """
        operator: pulumi.Input[str]
        """
        The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of dimension values.
        """
elif False:
    MetricAlertCriteriaDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlertCriteriaDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: One of the dimension names.
        :param pulumi.Input[str] operator: The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The list of dimension values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        One of the dimension names.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of dimension values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MetricAlertDynamicCriteriaArgsDict(TypedDict):
        aggregation: pulumi.Input[str]
        """
        The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        """
        alert_sensitivity: pulumi.Input[str]
        """
        The extent of deviation required to trigger an alert. Possible values are `Low`, `Medium` and `High`.
        """
        metric_name: pulumi.Input[str]
        """
        One of the metric names to be monitored.
        """
        metric_namespace: pulumi.Input[str]
        """
        One of the metric namespaces to be monitored.
        """
        operator: pulumi.Input[str]
        """
        The criteria operator. Possible values are `LessThan`, `GreaterThan` and `GreaterOrLessThan`.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricAlertDynamicCriteriaDimensionArgsDict']]]]
        """
        One or more `dimension` blocks as defined below.
        """
        evaluation_failure_count: NotRequired[pulumi.Input[int]]
        """
        The number of violations to trigger an alert. Should be smaller or equal to `evaluation_total_count`. Defaults to `4`.
        """
        evaluation_total_count: NotRequired[pulumi.Input[int]]
        """
        The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (`window_size`) and the selected number of aggregated points. Defaults to `4`.
        """
        ignore_data_before: NotRequired[pulumi.Input[str]]
        """
        The [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date from which to start learning the metric historical data and calculate the dynamic thresholds.
        """
        skip_metric_validation: NotRequired[pulumi.Input[bool]]
        """
        Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted?
        """
elif False:
    MetricAlertDynamicCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlertDynamicCriteriaArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 alert_sensitivity: pulumi.Input[str],
                 metric_name: pulumi.Input[str],
                 metric_namespace: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['MetricAlertDynamicCriteriaDimensionArgs']]]] = None,
                 evaluation_failure_count: Optional[pulumi.Input[int]] = None,
                 evaluation_total_count: Optional[pulumi.Input[int]] = None,
                 ignore_data_before: Optional[pulumi.Input[str]] = None,
                 skip_metric_validation: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] aggregation: The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        :param pulumi.Input[str] alert_sensitivity: The extent of deviation required to trigger an alert. Possible values are `Low`, `Medium` and `High`.
        :param pulumi.Input[str] metric_name: One of the metric names to be monitored.
        :param pulumi.Input[str] metric_namespace: One of the metric namespaces to be monitored.
        :param pulumi.Input[str] operator: The criteria operator. Possible values are `LessThan`, `GreaterThan` and `GreaterOrLessThan`.
        :param pulumi.Input[Sequence[pulumi.Input['MetricAlertDynamicCriteriaDimensionArgs']]] dimensions: One or more `dimension` blocks as defined below.
        :param pulumi.Input[int] evaluation_failure_count: The number of violations to trigger an alert. Should be smaller or equal to `evaluation_total_count`. Defaults to `4`.
        :param pulumi.Input[int] evaluation_total_count: The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (`window_size`) and the selected number of aggregated points. Defaults to `4`.
        :param pulumi.Input[str] ignore_data_before: The [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date from which to start learning the metric historical data and calculate the dynamic thresholds.
        :param pulumi.Input[bool] skip_metric_validation: Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted?
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "alert_sensitivity", alert_sensitivity)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "operator", operator)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_failure_count is not None:
            pulumi.set(__self__, "evaluation_failure_count", evaluation_failure_count)
        if evaluation_total_count is not None:
            pulumi.set(__self__, "evaluation_total_count", evaluation_total_count)
        if ignore_data_before is not None:
            pulumi.set(__self__, "ignore_data_before", ignore_data_before)
        if skip_metric_validation is not None:
            pulumi.set(__self__, "skip_metric_validation", skip_metric_validation)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter(name="alertSensitivity")
    def alert_sensitivity(self) -> pulumi.Input[str]:
        """
        The extent of deviation required to trigger an alert. Possible values are `Low`, `Medium` and `High`.
        """
        return pulumi.get(self, "alert_sensitivity")

    @alert_sensitivity.setter
    def alert_sensitivity(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_sensitivity", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        One of the metric names to be monitored.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[str]:
        """
        One of the metric namespaces to be monitored.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_namespace", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The criteria operator. Possible values are `LessThan`, `GreaterThan` and `GreaterOrLessThan`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricAlertDynamicCriteriaDimensionArgs']]]]:
        """
        One or more `dimension` blocks as defined below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricAlertDynamicCriteriaDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationFailureCount")
    def evaluation_failure_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of violations to trigger an alert. Should be smaller or equal to `evaluation_total_count`. Defaults to `4`.
        """
        return pulumi.get(self, "evaluation_failure_count")

    @evaluation_failure_count.setter
    def evaluation_failure_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_failure_count", value)

    @property
    @pulumi.getter(name="evaluationTotalCount")
    def evaluation_total_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (`window_size`) and the selected number of aggregated points. Defaults to `4`.
        """
        return pulumi.get(self, "evaluation_total_count")

    @evaluation_total_count.setter
    def evaluation_total_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_total_count", value)

    @property
    @pulumi.getter(name="ignoreDataBefore")
    def ignore_data_before(self) -> Optional[pulumi.Input[str]]:
        """
        The [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date from which to start learning the metric historical data and calculate the dynamic thresholds.
        """
        return pulumi.get(self, "ignore_data_before")

    @ignore_data_before.setter
    def ignore_data_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ignore_data_before", value)

    @property
    @pulumi.getter(name="skipMetricValidation")
    def skip_metric_validation(self) -> Optional[pulumi.Input[bool]]:
        """
        Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted?
        """
        return pulumi.get(self, "skip_metric_validation")

    @skip_metric_validation.setter
    def skip_metric_validation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_metric_validation", value)


if not MYPY:
    class MetricAlertDynamicCriteriaDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        One of the dimension names.
        """
        operator: pulumi.Input[str]
        """
        The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of dimension values.
        """
elif False:
    MetricAlertDynamicCriteriaDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlertDynamicCriteriaDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: One of the dimension names.
        :param pulumi.Input[str] operator: The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The list of dimension values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        One of the dimension names.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of dimension values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ScheduledQueryRulesAlertActionArgsDict(TypedDict):
        action_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of action group reference resource IDs.
        """
        custom_webhook_payload: NotRequired[pulumi.Input[str]]
        """
        Custom payload to be sent for all webhook payloads in alerting action.
        """
        email_subject: NotRequired[pulumi.Input[str]]
        """
        Custom subject override for all email ids in Azure action group.
        """
elif False:
    ScheduledQueryRulesAlertActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesAlertActionArgs:
    def __init__(__self__, *,
                 action_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 custom_webhook_payload: Optional[pulumi.Input[str]] = None,
                 email_subject: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] action_groups: List of action group reference resource IDs.
        :param pulumi.Input[str] custom_webhook_payload: Custom payload to be sent for all webhook payloads in alerting action.
        :param pulumi.Input[str] email_subject: Custom subject override for all email ids in Azure action group.
        """
        pulumi.set(__self__, "action_groups", action_groups)
        if custom_webhook_payload is not None:
            pulumi.set(__self__, "custom_webhook_payload", custom_webhook_payload)
        if email_subject is not None:
            pulumi.set(__self__, "email_subject", email_subject)

    @property
    @pulumi.getter(name="actionGroups")
    def action_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of action group reference resource IDs.
        """
        return pulumi.get(self, "action_groups")

    @action_groups.setter
    def action_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "action_groups", value)

    @property
    @pulumi.getter(name="customWebhookPayload")
    def custom_webhook_payload(self) -> Optional[pulumi.Input[str]]:
        """
        Custom payload to be sent for all webhook payloads in alerting action.
        """
        return pulumi.get(self, "custom_webhook_payload")

    @custom_webhook_payload.setter
    def custom_webhook_payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_webhook_payload", value)

    @property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Custom subject override for all email ids in Azure action group.
        """
        return pulumi.get(self, "email_subject")

    @email_subject.setter
    def email_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_subject", value)


if not MYPY:
    class ScheduledQueryRulesAlertTriggerArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Evaluation operation for rule - 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        """
        threshold: pulumi.Input[float]
        """
        Result or count threshold based on which rule should be triggered. Values must be between 0 and 10000 inclusive.
        """
        metric_trigger: NotRequired[pulumi.Input['ScheduledQueryRulesAlertTriggerMetricTriggerArgsDict']]
        """
        A `metric_trigger` block as defined above. Trigger condition for metric query rule.
        """
elif False:
    ScheduledQueryRulesAlertTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesAlertTriggerArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 metric_trigger: Optional[pulumi.Input['ScheduledQueryRulesAlertTriggerMetricTriggerArgs']] = None):
        """
        :param pulumi.Input[str] operator: Evaluation operation for rule - 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        :param pulumi.Input[float] threshold: Result or count threshold based on which rule should be triggered. Values must be between 0 and 10000 inclusive.
        :param pulumi.Input['ScheduledQueryRulesAlertTriggerMetricTriggerArgs'] metric_trigger: A `metric_trigger` block as defined above. Trigger condition for metric query rule.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        if metric_trigger is not None:
            pulumi.set(__self__, "metric_trigger", metric_trigger)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Evaluation operation for rule - 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        Result or count threshold based on which rule should be triggered. Values must be between 0 and 10000 inclusive.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="metricTrigger")
    def metric_trigger(self) -> Optional[pulumi.Input['ScheduledQueryRulesAlertTriggerMetricTriggerArgs']]:
        """
        A `metric_trigger` block as defined above. Trigger condition for metric query rule.
        """
        return pulumi.get(self, "metric_trigger")

    @metric_trigger.setter
    def metric_trigger(self, value: Optional[pulumi.Input['ScheduledQueryRulesAlertTriggerMetricTriggerArgs']]):
        pulumi.set(self, "metric_trigger", value)


if not MYPY:
    class ScheduledQueryRulesAlertTriggerMetricTriggerArgsDict(TypedDict):
        metric_trigger_type: pulumi.Input[str]
        """
        Metric Trigger Type - 'Consecutive' or 'Total'.
        """
        operator: pulumi.Input[str]
        """
        Evaluation operation for rule - 'Equal', 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        """
        threshold: pulumi.Input[float]
        """
        The threshold of the metric trigger. Values must be between 0 and 10000 inclusive.
        """
        metric_column: NotRequired[pulumi.Input[str]]
        """
        Evaluation of metric on a particular column.
        """
elif False:
    ScheduledQueryRulesAlertTriggerMetricTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesAlertTriggerMetricTriggerArgs:
    def __init__(__self__, *,
                 metric_trigger_type: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 metric_column: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_trigger_type: Metric Trigger Type - 'Consecutive' or 'Total'.
        :param pulumi.Input[str] operator: Evaluation operation for rule - 'Equal', 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        :param pulumi.Input[float] threshold: The threshold of the metric trigger. Values must be between 0 and 10000 inclusive.
        :param pulumi.Input[str] metric_column: Evaluation of metric on a particular column.
        """
        pulumi.set(__self__, "metric_trigger_type", metric_trigger_type)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        if metric_column is not None:
            pulumi.set(__self__, "metric_column", metric_column)

    @property
    @pulumi.getter(name="metricTriggerType")
    def metric_trigger_type(self) -> pulumi.Input[str]:
        """
        Metric Trigger Type - 'Consecutive' or 'Total'.
        """
        return pulumi.get(self, "metric_trigger_type")

    @metric_trigger_type.setter
    def metric_trigger_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_trigger_type", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Evaluation operation for rule - 'Equal', 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The threshold of the metric trigger. Values must be between 0 and 10000 inclusive.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="metricColumn")
    def metric_column(self) -> Optional[pulumi.Input[str]]:
        """
        Evaluation of metric on a particular column.
        """
        return pulumi.get(self, "metric_column")

    @metric_column.setter
    def metric_column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_column", value)


if not MYPY:
    class ScheduledQueryRulesAlertV2ActionArgsDict(TypedDict):
        action_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Action Group resource IDs to invoke when the alert fires.
        """
        custom_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies the properties of an alert payload.
        """
elif False:
    ScheduledQueryRulesAlertV2ActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesAlertV2ActionArgs:
    def __init__(__self__, *,
                 action_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 custom_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] action_groups: List of Action Group resource IDs to invoke when the alert fires.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_properties: Specifies the properties of an alert payload.
        """
        if action_groups is not None:
            pulumi.set(__self__, "action_groups", action_groups)
        if custom_properties is not None:
            pulumi.set(__self__, "custom_properties", custom_properties)

    @property
    @pulumi.getter(name="actionGroups")
    def action_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Action Group resource IDs to invoke when the alert fires.
        """
        return pulumi.get(self, "action_groups")

    @action_groups.setter
    def action_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "action_groups", value)

    @property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies the properties of an alert payload.
        """
        return pulumi.get(self, "custom_properties")

    @custom_properties.setter
    def custom_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_properties", value)


if not MYPY:
    class ScheduledQueryRulesAlertV2CriteriaArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Specifies the criteria operator. Possible values are `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`,and `LessThanOrEqual`.
        """
        query: pulumi.Input[str]
        """
        The query to run on logs. The results returned by this query are used to populate the alert.
        """
        threshold: pulumi.Input[float]
        """
        Specifies the criteria threshold value that activates the alert.
        """
        time_aggregation_method: pulumi.Input[str]
        """
        The type of aggregation to apply to the data points in aggregation granularity. Possible values are `Average`, `Count`, `Maximum`, `Minimum`,and `Total`.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesAlertV2CriteriaDimensionArgsDict']]]]
        """
        A `dimension` block as defined below.
        """
        failing_periods: NotRequired[pulumi.Input['ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgsDict']]
        """
        A `failing_periods` block as defined below.
        """
        metric_measure_column: NotRequired[pulumi.Input[str]]
        """
        Specifies the column containing the metric measure number.

        > **Note** `metric_measure_column` is required if `time_aggregation_method` is `Average`, `Maximum`, `Minimum`, or `Total`. And `metric_measure_column` can not be specified if `time_aggregation_method` is `Count`.
        """
        resource_id_column: NotRequired[pulumi.Input[str]]
        """
        Specifies the column containing the resource ID. The content of the column must be an uri formatted as resource ID.
        """
elif False:
    ScheduledQueryRulesAlertV2CriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesAlertV2CriteriaArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 query: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 time_aggregation_method: pulumi.Input[str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesAlertV2CriteriaDimensionArgs']]]] = None,
                 failing_periods: Optional[pulumi.Input['ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgs']] = None,
                 metric_measure_column: Optional[pulumi.Input[str]] = None,
                 resource_id_column: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: Specifies the criteria operator. Possible values are `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`,and `LessThanOrEqual`.
        :param pulumi.Input[str] query: The query to run on logs. The results returned by this query are used to populate the alert.
        :param pulumi.Input[float] threshold: Specifies the criteria threshold value that activates the alert.
        :param pulumi.Input[str] time_aggregation_method: The type of aggregation to apply to the data points in aggregation granularity. Possible values are `Average`, `Count`, `Maximum`, `Minimum`,and `Total`.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesAlertV2CriteriaDimensionArgs']]] dimensions: A `dimension` block as defined below.
        :param pulumi.Input['ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgs'] failing_periods: A `failing_periods` block as defined below.
        :param pulumi.Input[str] metric_measure_column: Specifies the column containing the metric measure number.
               
               > **Note** `metric_measure_column` is required if `time_aggregation_method` is `Average`, `Maximum`, `Minimum`, or `Total`. And `metric_measure_column` can not be specified if `time_aggregation_method` is `Count`.
        :param pulumi.Input[str] resource_id_column: Specifies the column containing the resource ID. The content of the column must be an uri formatted as resource ID.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "time_aggregation_method", time_aggregation_method)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if failing_periods is not None:
            pulumi.set(__self__, "failing_periods", failing_periods)
        if metric_measure_column is not None:
            pulumi.set(__self__, "metric_measure_column", metric_measure_column)
        if resource_id_column is not None:
            pulumi.set(__self__, "resource_id_column", resource_id_column)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Specifies the criteria operator. Possible values are `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`,and `LessThanOrEqual`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query to run on logs. The results returned by this query are used to populate the alert.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        Specifies the criteria threshold value that activates the alert.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="timeAggregationMethod")
    def time_aggregation_method(self) -> pulumi.Input[str]:
        """
        The type of aggregation to apply to the data points in aggregation granularity. Possible values are `Average`, `Count`, `Maximum`, `Minimum`,and `Total`.
        """
        return pulumi.get(self, "time_aggregation_method")

    @time_aggregation_method.setter
    def time_aggregation_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_aggregation_method", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesAlertV2CriteriaDimensionArgs']]]]:
        """
        A `dimension` block as defined below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesAlertV2CriteriaDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="failingPeriods")
    def failing_periods(self) -> Optional[pulumi.Input['ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgs']]:
        """
        A `failing_periods` block as defined below.
        """
        return pulumi.get(self, "failing_periods")

    @failing_periods.setter
    def failing_periods(self, value: Optional[pulumi.Input['ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgs']]):
        pulumi.set(self, "failing_periods", value)

    @property
    @pulumi.getter(name="metricMeasureColumn")
    def metric_measure_column(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the column containing the metric measure number.

        > **Note** `metric_measure_column` is required if `time_aggregation_method` is `Average`, `Maximum`, `Minimum`, or `Total`. And `metric_measure_column` can not be specified if `time_aggregation_method` is `Count`.
        """
        return pulumi.get(self, "metric_measure_column")

    @metric_measure_column.setter
    def metric_measure_column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_measure_column", value)

    @property
    @pulumi.getter(name="resourceIdColumn")
    def resource_id_column(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the column containing the resource ID. The content of the column must be an uri formatted as resource ID.
        """
        return pulumi.get(self, "resource_id_column")

    @resource_id_column.setter
    def resource_id_column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id_column", value)


if not MYPY:
    class ScheduledQueryRulesAlertV2CriteriaDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the dimension.
        """
        operator: pulumi.Input[str]
        """
        Operator for dimension values. Possible values are `Exclude`,and `Include`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of dimension values. Use a wildcard `*` to collect all.
        """
elif False:
    ScheduledQueryRulesAlertV2CriteriaDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesAlertV2CriteriaDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of the dimension.
        :param pulumi.Input[str] operator: Operator for dimension values. Possible values are `Exclude`,and `Include`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of dimension values. Use a wildcard `*` to collect all.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Operator for dimension values. Possible values are `Exclude`,and `Include`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of dimension values. Use a wildcard `*` to collect all.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgsDict(TypedDict):
        minimum_failing_periods_to_trigger_alert: pulumi.Input[int]
        """
        Specifies the number of violations to trigger an alert. Should be smaller or equal to `number_of_evaluation_periods`. Possible value is integer between 1 and 6.
        """
        number_of_evaluation_periods: pulumi.Input[int]
        """
        Specifies the number of aggregated look-back points. The look-back time window is calculated based on the aggregation granularity `window_duration` and the selected number of aggregated points. Possible value is integer between 1 and 6.

        > **Note** The query look back which is `window_duration`*`number_of_evaluation_periods` cannot exceed 48 hours.

        > **Note** `number_of_evaluation_periods` must be `1` for queries that do not project timestamp column
        """
elif False:
    ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesAlertV2CriteriaFailingPeriodsArgs:
    def __init__(__self__, *,
                 minimum_failing_periods_to_trigger_alert: pulumi.Input[int],
                 number_of_evaluation_periods: pulumi.Input[int]):
        """
        :param pulumi.Input[int] minimum_failing_periods_to_trigger_alert: Specifies the number of violations to trigger an alert. Should be smaller or equal to `number_of_evaluation_periods`. Possible value is integer between 1 and 6.
        :param pulumi.Input[int] number_of_evaluation_periods: Specifies the number of aggregated look-back points. The look-back time window is calculated based on the aggregation granularity `window_duration` and the selected number of aggregated points. Possible value is integer between 1 and 6.
               
               > **Note** The query look back which is `window_duration`*`number_of_evaluation_periods` cannot exceed 48 hours.
               
               > **Note** `number_of_evaluation_periods` must be `1` for queries that do not project timestamp column
        """
        pulumi.set(__self__, "minimum_failing_periods_to_trigger_alert", minimum_failing_periods_to_trigger_alert)
        pulumi.set(__self__, "number_of_evaluation_periods", number_of_evaluation_periods)

    @property
    @pulumi.getter(name="minimumFailingPeriodsToTriggerAlert")
    def minimum_failing_periods_to_trigger_alert(self) -> pulumi.Input[int]:
        """
        Specifies the number of violations to trigger an alert. Should be smaller or equal to `number_of_evaluation_periods`. Possible value is integer between 1 and 6.
        """
        return pulumi.get(self, "minimum_failing_periods_to_trigger_alert")

    @minimum_failing_periods_to_trigger_alert.setter
    def minimum_failing_periods_to_trigger_alert(self, value: pulumi.Input[int]):
        pulumi.set(self, "minimum_failing_periods_to_trigger_alert", value)

    @property
    @pulumi.getter(name="numberOfEvaluationPeriods")
    def number_of_evaluation_periods(self) -> pulumi.Input[int]:
        """
        Specifies the number of aggregated look-back points. The look-back time window is calculated based on the aggregation granularity `window_duration` and the selected number of aggregated points. Possible value is integer between 1 and 6.

        > **Note** The query look back which is `window_duration`*`number_of_evaluation_periods` cannot exceed 48 hours.

        > **Note** `number_of_evaluation_periods` must be `1` for queries that do not project timestamp column
        """
        return pulumi.get(self, "number_of_evaluation_periods")

    @number_of_evaluation_periods.setter
    def number_of_evaluation_periods(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_evaluation_periods", value)


if not MYPY:
    class ScheduledQueryRulesAlertV2IdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Scheduled Query Rule. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Scheduled Query Rule.

        > **NOTE:** This is required when `type` is set to `UserAssigned`. The identity associated must have required roles, read the [Azure documentation](https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/alerts-create-log-alert-rule#configure-the-alert-rule-details) for more information.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
elif False:
    ScheduledQueryRulesAlertV2IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesAlertV2IdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Scheduled Query Rule. Possible values are `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Scheduled Query Rule.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`. The identity associated must have required roles, read the [Azure documentation](https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/alerts-create-log-alert-rule#configure-the-alert-rule-details) for more information.
        :param pulumi.Input[str] principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        :param pulumi.Input[str] tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Scheduled Query Rule. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Scheduled Query Rule.

        > **NOTE:** This is required when `type` is set to `UserAssigned`. The identity associated must have required roles, read the [Azure documentation](https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/alerts-create-log-alert-rule#configure-the-alert-rule-details) for more information.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ScheduledQueryRulesLogCriteriaArgsDict(TypedDict):
        dimensions: pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesLogCriteriaDimensionArgsDict']]]
        """
        A `dimension` block as defined below.
        """
        metric_name: pulumi.Input[str]
        """
        Name of the metric. Supported metrics are listed in the Azure Monitor [Microsoft.OperationalInsights/workspaces](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported#microsoftoperationalinsightsworkspaces) metrics namespace.
        """
elif False:
    ScheduledQueryRulesLogCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesLogCriteriaArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesLogCriteriaDimensionArgs']]],
                 metric_name: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesLogCriteriaDimensionArgs']]] dimensions: A `dimension` block as defined below.
        :param pulumi.Input[str] metric_name: Name of the metric. Supported metrics are listed in the Azure Monitor [Microsoft.OperationalInsights/workspaces](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported#microsoftoperationalinsightsworkspaces) metrics namespace.
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metric_name", metric_name)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesLogCriteriaDimensionArgs']]]:
        """
        A `dimension` block as defined below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['ScheduledQueryRulesLogCriteriaDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        Name of the metric. Supported metrics are listed in the Azure Monitor [Microsoft.OperationalInsights/workspaces](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported#microsoftoperationalinsightsworkspaces) metrics namespace.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)


if not MYPY:
    class ScheduledQueryRulesLogCriteriaDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the dimension.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of dimension values.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Operator for dimension values, - 'Include'. Defaults to `Include`.
        """
elif False:
    ScheduledQueryRulesLogCriteriaDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledQueryRulesLogCriteriaDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the dimension.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of dimension values.
        :param pulumi.Input[str] operator: Operator for dimension values, - 'Include'. Defaults to `Include`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of dimension values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator for dimension values, - 'Include'. Defaults to `Include`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class SmartDetectorAlertRuleActionGroupArgsDict(TypedDict):
        ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies the action group ids.
        """
        email_subject: NotRequired[pulumi.Input[str]]
        """
        Specifies a custom email subject if Email Receiver is specified in Monitor Action Group resource.
        """
        webhook_payload: NotRequired[pulumi.Input[str]]
        """
        A JSON String which Specifies the custom webhook payload if Webhook Receiver is specified in Monitor Action Group resource.
        """
elif False:
    SmartDetectorAlertRuleActionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmartDetectorAlertRuleActionGroupArgs:
    def __init__(__self__, *,
                 ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 email_subject: Optional[pulumi.Input[str]] = None,
                 webhook_payload: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: Specifies the action group ids.
        :param pulumi.Input[str] email_subject: Specifies a custom email subject if Email Receiver is specified in Monitor Action Group resource.
        :param pulumi.Input[str] webhook_payload: A JSON String which Specifies the custom webhook payload if Webhook Receiver is specified in Monitor Action Group resource.
        """
        pulumi.set(__self__, "ids", ids)
        if email_subject is not None:
            pulumi.set(__self__, "email_subject", email_subject)
        if webhook_payload is not None:
            pulumi.set(__self__, "webhook_payload", webhook_payload)

    @property
    @pulumi.getter
    def ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies the action group ids.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ids", value)

    @property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a custom email subject if Email Receiver is specified in Monitor Action Group resource.
        """
        return pulumi.get(self, "email_subject")

    @email_subject.setter
    def email_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_subject", value)

    @property
    @pulumi.getter(name="webhookPayload")
    def webhook_payload(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON String which Specifies the custom webhook payload if Webhook Receiver is specified in Monitor Action Group resource.
        """
        return pulumi.get(self, "webhook_payload")

    @webhook_payload.setter
    def webhook_payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_payload", value)


