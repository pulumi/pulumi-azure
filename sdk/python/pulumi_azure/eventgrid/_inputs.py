# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DomainIdentityArgs',
    'DomainIdentityArgsDict',
    'DomainInboundIpRuleArgs',
    'DomainInboundIpRuleArgsDict',
    'DomainInputMappingDefaultValuesArgs',
    'DomainInputMappingDefaultValuesArgsDict',
    'DomainInputMappingFieldsArgs',
    'DomainInputMappingFieldsArgsDict',
    'EventSubscriptionAdvancedFilterArgs',
    'EventSubscriptionAdvancedFilterArgsDict',
    'EventSubscriptionAdvancedFilterBoolEqualArgs',
    'EventSubscriptionAdvancedFilterBoolEqualArgsDict',
    'EventSubscriptionAdvancedFilterIsNotNullArgs',
    'EventSubscriptionAdvancedFilterIsNotNullArgsDict',
    'EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs',
    'EventSubscriptionAdvancedFilterIsNullOrUndefinedArgsDict',
    'EventSubscriptionAdvancedFilterNumberGreaterThanArgs',
    'EventSubscriptionAdvancedFilterNumberGreaterThanArgsDict',
    'EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs',
    'EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgsDict',
    'EventSubscriptionAdvancedFilterNumberInArgs',
    'EventSubscriptionAdvancedFilterNumberInArgsDict',
    'EventSubscriptionAdvancedFilterNumberInRangeArgs',
    'EventSubscriptionAdvancedFilterNumberInRangeArgsDict',
    'EventSubscriptionAdvancedFilterNumberLessThanArgs',
    'EventSubscriptionAdvancedFilterNumberLessThanArgsDict',
    'EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs',
    'EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgsDict',
    'EventSubscriptionAdvancedFilterNumberNotInArgs',
    'EventSubscriptionAdvancedFilterNumberNotInArgsDict',
    'EventSubscriptionAdvancedFilterNumberNotInRangeArgs',
    'EventSubscriptionAdvancedFilterNumberNotInRangeArgsDict',
    'EventSubscriptionAdvancedFilterStringBeginsWithArgs',
    'EventSubscriptionAdvancedFilterStringBeginsWithArgsDict',
    'EventSubscriptionAdvancedFilterStringContainArgs',
    'EventSubscriptionAdvancedFilterStringContainArgsDict',
    'EventSubscriptionAdvancedFilterStringEndsWithArgs',
    'EventSubscriptionAdvancedFilterStringEndsWithArgsDict',
    'EventSubscriptionAdvancedFilterStringInArgs',
    'EventSubscriptionAdvancedFilterStringInArgsDict',
    'EventSubscriptionAdvancedFilterStringNotBeginsWithArgs',
    'EventSubscriptionAdvancedFilterStringNotBeginsWithArgsDict',
    'EventSubscriptionAdvancedFilterStringNotContainArgs',
    'EventSubscriptionAdvancedFilterStringNotContainArgsDict',
    'EventSubscriptionAdvancedFilterStringNotEndsWithArgs',
    'EventSubscriptionAdvancedFilterStringNotEndsWithArgsDict',
    'EventSubscriptionAdvancedFilterStringNotInArgs',
    'EventSubscriptionAdvancedFilterStringNotInArgsDict',
    'EventSubscriptionAzureFunctionEndpointArgs',
    'EventSubscriptionAzureFunctionEndpointArgsDict',
    'EventSubscriptionDeadLetterIdentityArgs',
    'EventSubscriptionDeadLetterIdentityArgsDict',
    'EventSubscriptionDeliveryIdentityArgs',
    'EventSubscriptionDeliveryIdentityArgsDict',
    'EventSubscriptionDeliveryPropertyArgs',
    'EventSubscriptionDeliveryPropertyArgsDict',
    'EventSubscriptionRetryPolicyArgs',
    'EventSubscriptionRetryPolicyArgsDict',
    'EventSubscriptionStorageBlobDeadLetterDestinationArgs',
    'EventSubscriptionStorageBlobDeadLetterDestinationArgsDict',
    'EventSubscriptionStorageQueueEndpointArgs',
    'EventSubscriptionStorageQueueEndpointArgsDict',
    'EventSubscriptionSubjectFilterArgs',
    'EventSubscriptionSubjectFilterArgsDict',
    'EventSubscriptionWebhookEndpointArgs',
    'EventSubscriptionWebhookEndpointArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterArgs',
    'SystemTopicEventSubscriptionAdvancedFilterArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgs',
    'SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgs',
    'SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgs',
    'SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgs',
    'SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs',
    'SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterNumberInArgs',
    'SystemTopicEventSubscriptionAdvancedFilterNumberInArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgs',
    'SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgs',
    'SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs',
    'SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgs',
    'SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgs',
    'SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgs',
    'SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterStringContainArgs',
    'SystemTopicEventSubscriptionAdvancedFilterStringContainArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgs',
    'SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterStringInArgs',
    'SystemTopicEventSubscriptionAdvancedFilterStringInArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgs',
    'SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgs',
    'SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgs',
    'SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgsDict',
    'SystemTopicEventSubscriptionAdvancedFilterStringNotInArgs',
    'SystemTopicEventSubscriptionAdvancedFilterStringNotInArgsDict',
    'SystemTopicEventSubscriptionAzureFunctionEndpointArgs',
    'SystemTopicEventSubscriptionAzureFunctionEndpointArgsDict',
    'SystemTopicEventSubscriptionDeadLetterIdentityArgs',
    'SystemTopicEventSubscriptionDeadLetterIdentityArgsDict',
    'SystemTopicEventSubscriptionDeliveryIdentityArgs',
    'SystemTopicEventSubscriptionDeliveryIdentityArgsDict',
    'SystemTopicEventSubscriptionDeliveryPropertyArgs',
    'SystemTopicEventSubscriptionDeliveryPropertyArgsDict',
    'SystemTopicEventSubscriptionRetryPolicyArgs',
    'SystemTopicEventSubscriptionRetryPolicyArgsDict',
    'SystemTopicEventSubscriptionStorageBlobDeadLetterDestinationArgs',
    'SystemTopicEventSubscriptionStorageBlobDeadLetterDestinationArgsDict',
    'SystemTopicEventSubscriptionStorageQueueEndpointArgs',
    'SystemTopicEventSubscriptionStorageQueueEndpointArgsDict',
    'SystemTopicEventSubscriptionSubjectFilterArgs',
    'SystemTopicEventSubscriptionSubjectFilterArgsDict',
    'SystemTopicEventSubscriptionWebhookEndpointArgs',
    'SystemTopicEventSubscriptionWebhookEndpointArgsDict',
    'SystemTopicIdentityArgs',
    'SystemTopicIdentityArgsDict',
    'TopicIdentityArgs',
    'TopicIdentityArgsDict',
    'TopicInboundIpRuleArgs',
    'TopicInboundIpRuleArgsDict',
    'TopicInputMappingDefaultValuesArgs',
    'TopicInputMappingDefaultValuesArgsDict',
    'TopicInputMappingFieldsArgs',
    'TopicInputMappingFieldsArgsDict',
]

MYPY = False

if not MYPY:
    class DomainIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Event Grid Domain. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Domain.

        > **NOTE:** This is required when `type` is set to `UserAssigned`

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Domain has been created. More details are available below.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    DomainIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Event Grid Domain. Possible values are `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Domain.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Domain has been created. More details are available below.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Event Grid Domain. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Domain.

        > **NOTE:** This is required when `type` is set to `UserAssigned`

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Domain has been created. More details are available below.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class DomainInboundIpRuleArgsDict(TypedDict):
        ip_mask: pulumi.Input[str]
        """
        The IP mask (CIDR) to match on.
        """
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
elif False:
    DomainInboundIpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainInboundIpRuleArgs:
    def __init__(__self__, *,
                 ip_mask: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_mask: The IP mask (CIDR) to match on.
        :param pulumi.Input[str] action: The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        pulumi.set(__self__, "ip_mask", ip_mask)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> pulumi.Input[str]:
        """
        The IP mask (CIDR) to match on.
        """
        return pulumi.get(self, "ip_mask")

    @ip_mask.setter
    def ip_mask(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_mask", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class DomainInputMappingDefaultValuesArgsDict(TypedDict):
        data_version: NotRequired[pulumi.Input[str]]
        """
        Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        event_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
elif False:
    DomainInputMappingDefaultValuesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainInputMappingDefaultValuesArgs:
    def __init__(__self__, *,
                 data_version: Optional[pulumi.Input[str]] = None,
                 event_type: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_version: Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_type: Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subject: Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        if data_version is not None:
            pulumi.set(__self__, "data_version", data_version)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "data_version")

    @data_version.setter
    def data_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_version", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class DomainInputMappingFieldsArgsDict(TypedDict):
        data_version: NotRequired[pulumi.Input[str]]
        """
        Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        event_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        event_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        topic: NotRequired[pulumi.Input[str]]
        """
        Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
elif False:
    DomainInputMappingFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainInputMappingFieldsArgs:
    def __init__(__self__, *,
                 data_version: Optional[pulumi.Input[str]] = None,
                 event_time: Optional[pulumi.Input[str]] = None,
                 event_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 topic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_version: Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_time: Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_type: Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] id: Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subject: Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] topic: Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        if data_version is not None:
            pulumi.set(__self__, "data_version", data_version)
        if event_time is not None:
            pulumi.set(__self__, "event_time", event_time)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "data_version")

    @data_version.setter
    def data_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_version", value)

    @property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_time")

    @event_time.setter
    def event_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_time", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterArgsDict(TypedDict):
        bool_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterBoolEqualArgsDict']]]]
        """
        Compares a value of an event using a single boolean value.
        """
        is_not_nulls: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNotNullArgsDict']]]]
        """
        Evaluates if a value of an event isn't NULL or undefined.
        """
        is_null_or_undefineds: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNullOrUndefinedArgsDict']]]]
        """
        Evaluates if a value of an event is NULL or undefined.

        Each nested block consists of a key and a value(s) element.
        """
        number_greater_than_or_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgsDict']]]]
        """
        Compares a value of an event using a single floating point number.
        """
        number_greater_thans: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanArgsDict']]]]
        """
        Compares a value of an event using a single floating point number.
        """
        number_in_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInRangeArgsDict']]]]
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        number_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInArgsDict']]]]
        """
        Compares a value of an event using multiple floating point numbers.
        """
        number_less_than_or_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgsDict']]]]
        """
        Compares a value of an event using a single floating point number.
        """
        number_less_thans: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanArgsDict']]]]
        """
        Compares a value of an event using a single floating point number.
        """
        number_not_in_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInRangeArgsDict']]]]
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        number_not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInArgsDict']]]]
        """
        Compares a value of an event using multiple floating point numbers.
        """
        string_begins_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringBeginsWithArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_contains: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringContainArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_ends_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringEndsWithArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringInArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_not_begins_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotBeginsWithArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_not_contains: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotContainArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_not_ends_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotEndsWithArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotInArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
elif False:
    EventSubscriptionAdvancedFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterArgs:
    def __init__(__self__, *,
                 bool_equals: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterBoolEqualArgs']]]] = None,
                 is_not_nulls: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNotNullArgs']]]] = None,
                 is_null_or_undefineds: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]]] = None,
                 number_greater_than_or_equals: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]]] = None,
                 number_greater_thans: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanArgs']]]] = None,
                 number_in_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInRangeArgs']]]] = None,
                 number_ins: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInArgs']]]] = None,
                 number_less_than_or_equals: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]]] = None,
                 number_less_thans: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanArgs']]]] = None,
                 number_not_in_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInRangeArgs']]]] = None,
                 number_not_ins: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInArgs']]]] = None,
                 string_begins_withs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringBeginsWithArgs']]]] = None,
                 string_contains: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringContainArgs']]]] = None,
                 string_ends_withs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringEndsWithArgs']]]] = None,
                 string_ins: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringInArgs']]]] = None,
                 string_not_begins_withs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]]] = None,
                 string_not_contains: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotContainArgs']]]] = None,
                 string_not_ends_withs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotEndsWithArgs']]]] = None,
                 string_not_ins: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotInArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterBoolEqualArgs']]] bool_equals: Compares a value of an event using a single boolean value.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNotNullArgs']]] is_not_nulls: Evaluates if a value of an event isn't NULL or undefined.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]] is_null_or_undefineds: Evaluates if a value of an event is NULL or undefined.
               
               Each nested block consists of a key and a value(s) element.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]] number_greater_than_or_equals: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanArgs']]] number_greater_thans: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInRangeArgs']]] number_in_ranges: Compares a value of an event using multiple floating point number ranges.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInArgs']]] number_ins: Compares a value of an event using multiple floating point numbers.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]] number_less_than_or_equals: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanArgs']]] number_less_thans: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInRangeArgs']]] number_not_in_ranges: Compares a value of an event using multiple floating point number ranges.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInArgs']]] number_not_ins: Compares a value of an event using multiple floating point numbers.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringBeginsWithArgs']]] string_begins_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringContainArgs']]] string_contains: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringEndsWithArgs']]] string_ends_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringInArgs']]] string_ins: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]] string_not_begins_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotContainArgs']]] string_not_contains: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotEndsWithArgs']]] string_not_ends_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotInArgs']]] string_not_ins: Compares a value of an event using multiple string values.
        """
        if bool_equals is not None:
            pulumi.set(__self__, "bool_equals", bool_equals)
        if is_not_nulls is not None:
            pulumi.set(__self__, "is_not_nulls", is_not_nulls)
        if is_null_or_undefineds is not None:
            pulumi.set(__self__, "is_null_or_undefineds", is_null_or_undefineds)
        if number_greater_than_or_equals is not None:
            pulumi.set(__self__, "number_greater_than_or_equals", number_greater_than_or_equals)
        if number_greater_thans is not None:
            pulumi.set(__self__, "number_greater_thans", number_greater_thans)
        if number_in_ranges is not None:
            pulumi.set(__self__, "number_in_ranges", number_in_ranges)
        if number_ins is not None:
            pulumi.set(__self__, "number_ins", number_ins)
        if number_less_than_or_equals is not None:
            pulumi.set(__self__, "number_less_than_or_equals", number_less_than_or_equals)
        if number_less_thans is not None:
            pulumi.set(__self__, "number_less_thans", number_less_thans)
        if number_not_in_ranges is not None:
            pulumi.set(__self__, "number_not_in_ranges", number_not_in_ranges)
        if number_not_ins is not None:
            pulumi.set(__self__, "number_not_ins", number_not_ins)
        if string_begins_withs is not None:
            pulumi.set(__self__, "string_begins_withs", string_begins_withs)
        if string_contains is not None:
            pulumi.set(__self__, "string_contains", string_contains)
        if string_ends_withs is not None:
            pulumi.set(__self__, "string_ends_withs", string_ends_withs)
        if string_ins is not None:
            pulumi.set(__self__, "string_ins", string_ins)
        if string_not_begins_withs is not None:
            pulumi.set(__self__, "string_not_begins_withs", string_not_begins_withs)
        if string_not_contains is not None:
            pulumi.set(__self__, "string_not_contains", string_not_contains)
        if string_not_ends_withs is not None:
            pulumi.set(__self__, "string_not_ends_withs", string_not_ends_withs)
        if string_not_ins is not None:
            pulumi.set(__self__, "string_not_ins", string_not_ins)

    @property
    @pulumi.getter(name="boolEquals")
    def bool_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterBoolEqualArgs']]]]:
        """
        Compares a value of an event using a single boolean value.
        """
        return pulumi.get(self, "bool_equals")

    @bool_equals.setter
    def bool_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterBoolEqualArgs']]]]):
        pulumi.set(self, "bool_equals", value)

    @property
    @pulumi.getter(name="isNotNulls")
    def is_not_nulls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNotNullArgs']]]]:
        """
        Evaluates if a value of an event isn't NULL or undefined.
        """
        return pulumi.get(self, "is_not_nulls")

    @is_not_nulls.setter
    def is_not_nulls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNotNullArgs']]]]):
        pulumi.set(self, "is_not_nulls", value)

    @property
    @pulumi.getter(name="isNullOrUndefineds")
    def is_null_or_undefineds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]]]:
        """
        Evaluates if a value of an event is NULL or undefined.

        Each nested block consists of a key and a value(s) element.
        """
        return pulumi.get(self, "is_null_or_undefineds")

    @is_null_or_undefineds.setter
    def is_null_or_undefineds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]]]):
        pulumi.set(self, "is_null_or_undefineds", value)

    @property
    @pulumi.getter(name="numberGreaterThanOrEquals")
    def number_greater_than_or_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_greater_than_or_equals")

    @number_greater_than_or_equals.setter
    def number_greater_than_or_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]]]):
        pulumi.set(self, "number_greater_than_or_equals", value)

    @property
    @pulumi.getter(name="numberGreaterThans")
    def number_greater_thans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_greater_thans")

    @number_greater_thans.setter
    def number_greater_thans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberGreaterThanArgs']]]]):
        pulumi.set(self, "number_greater_thans", value)

    @property
    @pulumi.getter(name="numberInRanges")
    def number_in_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInRangeArgs']]]]:
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        return pulumi.get(self, "number_in_ranges")

    @number_in_ranges.setter
    def number_in_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInRangeArgs']]]]):
        pulumi.set(self, "number_in_ranges", value)

    @property
    @pulumi.getter(name="numberIns")
    def number_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInArgs']]]]:
        """
        Compares a value of an event using multiple floating point numbers.
        """
        return pulumi.get(self, "number_ins")

    @number_ins.setter
    def number_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberInArgs']]]]):
        pulumi.set(self, "number_ins", value)

    @property
    @pulumi.getter(name="numberLessThanOrEquals")
    def number_less_than_or_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_less_than_or_equals")

    @number_less_than_or_equals.setter
    def number_less_than_or_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]]]):
        pulumi.set(self, "number_less_than_or_equals", value)

    @property
    @pulumi.getter(name="numberLessThans")
    def number_less_thans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_less_thans")

    @number_less_thans.setter
    def number_less_thans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberLessThanArgs']]]]):
        pulumi.set(self, "number_less_thans", value)

    @property
    @pulumi.getter(name="numberNotInRanges")
    def number_not_in_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInRangeArgs']]]]:
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        return pulumi.get(self, "number_not_in_ranges")

    @number_not_in_ranges.setter
    def number_not_in_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInRangeArgs']]]]):
        pulumi.set(self, "number_not_in_ranges", value)

    @property
    @pulumi.getter(name="numberNotIns")
    def number_not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInArgs']]]]:
        """
        Compares a value of an event using multiple floating point numbers.
        """
        return pulumi.get(self, "number_not_ins")

    @number_not_ins.setter
    def number_not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterNumberNotInArgs']]]]):
        pulumi.set(self, "number_not_ins", value)

    @property
    @pulumi.getter(name="stringBeginsWiths")
    def string_begins_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringBeginsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_begins_withs")

    @string_begins_withs.setter
    def string_begins_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringBeginsWithArgs']]]]):
        pulumi.set(self, "string_begins_withs", value)

    @property
    @pulumi.getter(name="stringContains")
    def string_contains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringContainArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_contains")

    @string_contains.setter
    def string_contains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringContainArgs']]]]):
        pulumi.set(self, "string_contains", value)

    @property
    @pulumi.getter(name="stringEndsWiths")
    def string_ends_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringEndsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_ends_withs")

    @string_ends_withs.setter
    def string_ends_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringEndsWithArgs']]]]):
        pulumi.set(self, "string_ends_withs", value)

    @property
    @pulumi.getter(name="stringIns")
    def string_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringInArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_ins")

    @string_ins.setter
    def string_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringInArgs']]]]):
        pulumi.set(self, "string_ins", value)

    @property
    @pulumi.getter(name="stringNotBeginsWiths")
    def string_not_begins_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_begins_withs")

    @string_not_begins_withs.setter
    def string_not_begins_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]]]):
        pulumi.set(self, "string_not_begins_withs", value)

    @property
    @pulumi.getter(name="stringNotContains")
    def string_not_contains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotContainArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_contains")

    @string_not_contains.setter
    def string_not_contains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotContainArgs']]]]):
        pulumi.set(self, "string_not_contains", value)

    @property
    @pulumi.getter(name="stringNotEndsWiths")
    def string_not_ends_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotEndsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_ends_withs")

    @string_not_ends_withs.setter
    def string_not_ends_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotEndsWithArgs']]]]):
        pulumi.set(self, "string_not_ends_withs", value)

    @property
    @pulumi.getter(name="stringNotIns")
    def string_not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotInArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_ins")

    @string_not_ins.setter
    def string_not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSubscriptionAdvancedFilterStringNotInArgs']]]]):
        pulumi.set(self, "string_not_ins", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterBoolEqualArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[bool]
elif False:
    EventSubscriptionAdvancedFilterBoolEqualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterBoolEqualArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[bool]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterIsNotNullArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
elif False:
    EventSubscriptionAdvancedFilterIsNotNullArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterIsNotNullArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterIsNullOrUndefinedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
elif False:
    EventSubscriptionAdvancedFilterIsNullOrUndefinedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterIsNullOrUndefinedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterNumberGreaterThanArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[float]
elif False:
    EventSubscriptionAdvancedFilterNumberGreaterThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberGreaterThanArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[float]
elif False:
    EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterNumberInArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[float]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterNumberInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[float]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[float]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[float]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterNumberInRangeArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterNumberInRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberInRangeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterNumberLessThanArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[float]
elif False:
    EventSubscriptionAdvancedFilterNumberLessThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberLessThanArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[float]
elif False:
    EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterNumberNotInArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[float]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterNumberNotInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberNotInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[float]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[float]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[float]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterNumberNotInRangeArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterNumberNotInRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterNumberNotInRangeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterStringBeginsWithArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterStringBeginsWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterStringBeginsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterStringContainArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterStringContainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterStringContainArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterStringEndsWithArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterStringEndsWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterStringEndsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterStringInArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterStringInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterStringInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterStringNotBeginsWithArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterStringNotBeginsWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterStringNotBeginsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterStringNotContainArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterStringNotContainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterStringNotContainArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterStringNotEndsWithArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterStringNotEndsWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterStringNotEndsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAdvancedFilterStringNotInArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    EventSubscriptionAdvancedFilterStringNotInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAdvancedFilterStringNotInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventSubscriptionAzureFunctionEndpointArgsDict(TypedDict):
        function_id: pulumi.Input[str]
        """
        Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
        """
        max_events_per_batch: NotRequired[pulumi.Input[int]]
        """
        Maximum number of events per batch.
        """
        preferred_batch_size_in_kilobytes: NotRequired[pulumi.Input[int]]
        """
        Preferred batch size in Kilobytes.
        """
elif False:
    EventSubscriptionAzureFunctionEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionAzureFunctionEndpointArgs:
    def __init__(__self__, *,
                 function_id: pulumi.Input[str],
                 max_events_per_batch: Optional[pulumi.Input[int]] = None,
                 preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] function_id: Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
        :param pulumi.Input[int] max_events_per_batch: Maximum number of events per batch.
        :param pulumi.Input[int] preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        """
        pulumi.set(__self__, "function_id", function_id)
        if max_events_per_batch is not None:
            pulumi.set(__self__, "max_events_per_batch", max_events_per_batch)
        if preferred_batch_size_in_kilobytes is not None:
            pulumi.set(__self__, "preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> pulumi.Input[str]:
        """
        Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_id", value)

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @max_events_per_batch.setter
    def max_events_per_batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_events_per_batch", value)

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[pulumi.Input[int]]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")

    @preferred_batch_size_in_kilobytes.setter
    def preferred_batch_size_in_kilobytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preferred_batch_size_in_kilobytes", value)


if not MYPY:
    class EventSubscriptionDeadLetterIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        user_assigned_identity: NotRequired[pulumi.Input[str]]
        """
        The user identity associated with the resource.
        """
elif False:
    EventSubscriptionDeadLetterIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionDeadLetterIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[str] user_assigned_identity: The user identity associated with the resource.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The user identity associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


if not MYPY:
    class EventSubscriptionDeliveryIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        user_assigned_identity: NotRequired[pulumi.Input[str]]
        """
        The user identity associated with the resource.
        """
elif False:
    EventSubscriptionDeliveryIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionDeliveryIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[str] user_assigned_identity: The user identity associated with the resource.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The user identity associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


if not MYPY:
    class EventSubscriptionDeliveryPropertyArgsDict(TypedDict):
        header_name: pulumi.Input[str]
        """
        The name of the header to send on to the destination
        """
        type: pulumi.Input[str]
        """
        Either `Static` or `Dynamic`
        """
        secret: NotRequired[pulumi.Input[bool]]
        """
        True if the `value` is a secret and should be protected, otherwise false. If True, then this value won't be returned from Azure API calls
        """
        source_field: NotRequired[pulumi.Input[str]]
        """
        If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        If the `type` is `Static`, then provide the value to use
        """
elif False:
    EventSubscriptionDeliveryPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionDeliveryPropertyArgs:
    def __init__(__self__, *,
                 header_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 secret: Optional[pulumi.Input[bool]] = None,
                 source_field: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] header_name: The name of the header to send on to the destination
        :param pulumi.Input[str] type: Either `Static` or `Dynamic`
        :param pulumi.Input[bool] secret: True if the `value` is a secret and should be protected, otherwise false. If True, then this value won't be returned from Azure API calls
        :param pulumi.Input[str] source_field: If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
        :param pulumi.Input[str] value: If the `type` is `Static`, then provide the value to use
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "type", type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if source_field is not None:
            pulumi.set(__self__, "source_field", source_field)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the header to send on to the destination
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Either `Static` or `Dynamic`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the `value` is a secret and should be protected, otherwise false. If True, then this value won't be returned from Azure API calls
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[pulumi.Input[str]]:
        """
        If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
        """
        return pulumi.get(self, "source_field")

    @source_field.setter
    def source_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_field", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        If the `type` is `Static`, then provide the value to use
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventSubscriptionRetryPolicyArgsDict(TypedDict):
        event_time_to_live: pulumi.Input[int]
        """
        Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
        """
        max_delivery_attempts: pulumi.Input[int]
        """
        Specifies the maximum number of delivery retry attempts for events.
        """
elif False:
    EventSubscriptionRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionRetryPolicyArgs:
    def __init__(__self__, *,
                 event_time_to_live: pulumi.Input[int],
                 max_delivery_attempts: pulumi.Input[int]):
        """
        :param pulumi.Input[int] event_time_to_live: Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
        :param pulumi.Input[int] max_delivery_attempts: Specifies the maximum number of delivery retry attempts for events.
        """
        pulumi.set(__self__, "event_time_to_live", event_time_to_live)
        pulumi.set(__self__, "max_delivery_attempts", max_delivery_attempts)

    @property
    @pulumi.getter(name="eventTimeToLive")
    def event_time_to_live(self) -> pulumi.Input[int]:
        """
        Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
        """
        return pulumi.get(self, "event_time_to_live")

    @event_time_to_live.setter
    def event_time_to_live(self, value: pulumi.Input[int]):
        pulumi.set(self, "event_time_to_live", value)

    @property
    @pulumi.getter(name="maxDeliveryAttempts")
    def max_delivery_attempts(self) -> pulumi.Input[int]:
        """
        Specifies the maximum number of delivery retry attempts for events.
        """
        return pulumi.get(self, "max_delivery_attempts")

    @max_delivery_attempts.setter
    def max_delivery_attempts(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_delivery_attempts", value)


if not MYPY:
    class EventSubscriptionStorageBlobDeadLetterDestinationArgsDict(TypedDict):
        storage_account_id: pulumi.Input[str]
        """
        Specifies the id of the storage account id where the storage blob is located.
        """
        storage_blob_container_name: pulumi.Input[str]
        """
        Specifies the name of the Storage blob container that is the destination of the deadletter events.
        """
elif False:
    EventSubscriptionStorageBlobDeadLetterDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionStorageBlobDeadLetterDestinationArgs:
    def __init__(__self__, *,
                 storage_account_id: pulumi.Input[str],
                 storage_blob_container_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] storage_account_id: Specifies the id of the storage account id where the storage blob is located.
        :param pulumi.Input[str] storage_blob_container_name: Specifies the name of the Storage blob container that is the destination of the deadletter events.
        """
        pulumi.set(__self__, "storage_account_id", storage_account_id)
        pulumi.set(__self__, "storage_blob_container_name", storage_blob_container_name)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        Specifies the id of the storage account id where the storage blob is located.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="storageBlobContainerName")
    def storage_blob_container_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Storage blob container that is the destination of the deadletter events.
        """
        return pulumi.get(self, "storage_blob_container_name")

    @storage_blob_container_name.setter
    def storage_blob_container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_blob_container_name", value)


if not MYPY:
    class EventSubscriptionStorageQueueEndpointArgsDict(TypedDict):
        queue_name: pulumi.Input[str]
        """
        Specifies the name of the storage queue where the Event Subscription will receive events.
        """
        storage_account_id: pulumi.Input[str]
        """
        Specifies the id of the storage account id where the storage queue is located.
        """
        queue_message_time_to_live_in_seconds: NotRequired[pulumi.Input[int]]
        """
        Storage queue message time to live in seconds.
        """
elif False:
    EventSubscriptionStorageQueueEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionStorageQueueEndpointArgs:
    def __init__(__self__, *,
                 queue_name: pulumi.Input[str],
                 storage_account_id: pulumi.Input[str],
                 queue_message_time_to_live_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] queue_name: Specifies the name of the storage queue where the Event Subscription will receive events.
        :param pulumi.Input[str] storage_account_id: Specifies the id of the storage account id where the storage queue is located.
        :param pulumi.Input[int] queue_message_time_to_live_in_seconds: Storage queue message time to live in seconds.
        """
        pulumi.set(__self__, "queue_name", queue_name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)
        if queue_message_time_to_live_in_seconds is not None:
            pulumi.set(__self__, "queue_message_time_to_live_in_seconds", queue_message_time_to_live_in_seconds)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the storage queue where the Event Subscription will receive events.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_name", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        Specifies the id of the storage account id where the storage queue is located.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="queueMessageTimeToLiveInSeconds")
    def queue_message_time_to_live_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Storage queue message time to live in seconds.
        """
        return pulumi.get(self, "queue_message_time_to_live_in_seconds")

    @queue_message_time_to_live_in_seconds.setter
    def queue_message_time_to_live_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queue_message_time_to_live_in_seconds", value)


if not MYPY:
    class EventSubscriptionSubjectFilterArgsDict(TypedDict):
        case_sensitive: NotRequired[pulumi.Input[bool]]
        """
        Specifies if `subject_begins_with` and `subject_ends_with` case sensitive. This value
        """
        subject_begins_with: NotRequired[pulumi.Input[str]]
        """
        A string to filter events for an event subscription based on a resource path prefix.
        """
        subject_ends_with: NotRequired[pulumi.Input[str]]
        """
        A string to filter events for an event subscription based on a resource path suffix.
        """
elif False:
    EventSubscriptionSubjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionSubjectFilterArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 subject_begins_with: Optional[pulumi.Input[str]] = None,
                 subject_ends_with: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] case_sensitive: Specifies if `subject_begins_with` and `subject_ends_with` case sensitive. This value
        :param pulumi.Input[str] subject_begins_with: A string to filter events for an event subscription based on a resource path prefix.
        :param pulumi.Input[str] subject_ends_with: A string to filter events for an event subscription based on a resource path suffix.
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if subject_begins_with is not None:
            pulumi.set(__self__, "subject_begins_with", subject_begins_with)
        if subject_ends_with is not None:
            pulumi.set(__self__, "subject_ends_with", subject_ends_with)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if `subject_begins_with` and `subject_ends_with` case sensitive. This value
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="subjectBeginsWith")
    def subject_begins_with(self) -> Optional[pulumi.Input[str]]:
        """
        A string to filter events for an event subscription based on a resource path prefix.
        """
        return pulumi.get(self, "subject_begins_with")

    @subject_begins_with.setter
    def subject_begins_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_begins_with", value)

    @property
    @pulumi.getter(name="subjectEndsWith")
    def subject_ends_with(self) -> Optional[pulumi.Input[str]]:
        """
        A string to filter events for an event subscription based on a resource path suffix.
        """
        return pulumi.get(self, "subject_ends_with")

    @subject_ends_with.setter
    def subject_ends_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_ends_with", value)


if not MYPY:
    class EventSubscriptionWebhookEndpointArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        Specifies the url of the webhook where the Event Subscription will receive events.
        """
        active_directory_app_id_or_uri: NotRequired[pulumi.Input[str]]
        """
        The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        """
        active_directory_tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        """
        base_url: NotRequired[pulumi.Input[str]]
        """
        The base url of the webhook where the Event Subscription will receive events.
        """
        max_events_per_batch: NotRequired[pulumi.Input[int]]
        """
        Maximum number of events per batch.
        """
        preferred_batch_size_in_kilobytes: NotRequired[pulumi.Input[int]]
        """
        Preferred batch size in Kilobytes.
        """
elif False:
    EventSubscriptionWebhookEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionWebhookEndpointArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 active_directory_app_id_or_uri: Optional[pulumi.Input[str]] = None,
                 active_directory_tenant_id: Optional[pulumi.Input[str]] = None,
                 base_url: Optional[pulumi.Input[str]] = None,
                 max_events_per_batch: Optional[pulumi.Input[int]] = None,
                 preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] url: Specifies the url of the webhook where the Event Subscription will receive events.
        :param pulumi.Input[str] active_directory_app_id_or_uri: The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        :param pulumi.Input[str] active_directory_tenant_id: The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        :param pulumi.Input[str] base_url: The base url of the webhook where the Event Subscription will receive events.
        :param pulumi.Input[int] max_events_per_batch: Maximum number of events per batch.
        :param pulumi.Input[int] preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        """
        pulumi.set(__self__, "url", url)
        if active_directory_app_id_or_uri is not None:
            pulumi.set(__self__, "active_directory_app_id_or_uri", active_directory_app_id_or_uri)
        if active_directory_tenant_id is not None:
            pulumi.set(__self__, "active_directory_tenant_id", active_directory_tenant_id)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if max_events_per_batch is not None:
            pulumi.set(__self__, "max_events_per_batch", max_events_per_batch)
        if preferred_batch_size_in_kilobytes is not None:
            pulumi.set(__self__, "preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the url of the webhook where the Event Subscription will receive events.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="activeDirectoryAppIdOrUri")
    def active_directory_app_id_or_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "active_directory_app_id_or_uri")

    @active_directory_app_id_or_uri.setter
    def active_directory_app_id_or_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_directory_app_id_or_uri", value)

    @property
    @pulumi.getter(name="activeDirectoryTenantId")
    def active_directory_tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "active_directory_tenant_id")

    @active_directory_tenant_id.setter
    def active_directory_tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_directory_tenant_id", value)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[str]]:
        """
        The base url of the webhook where the Event Subscription will receive events.
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @max_events_per_batch.setter
    def max_events_per_batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_events_per_batch", value)

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[pulumi.Input[int]]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")

    @preferred_batch_size_in_kilobytes.setter
    def preferred_batch_size_in_kilobytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preferred_batch_size_in_kilobytes", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterArgsDict(TypedDict):
        bool_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgsDict']]]]
        """
        Compares a value of an event using a single boolean value.
        """
        is_not_nulls: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgsDict']]]]
        """
        Evaluates if a value of an event isn't NULL or undefined.
        """
        is_null_or_undefineds: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgsDict']]]]
        """
        Evaluates if a value of an event is NULL or undefined.

        Each nested block consists of a key and a value(s) element.
        """
        number_greater_than_or_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgsDict']]]]
        """
        Compares a value of an event using a single floating point number.
        """
        number_greater_thans: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgsDict']]]]
        """
        Compares a value of an event using a single floating point number.
        """
        number_in_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgsDict']]]]
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        number_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInArgsDict']]]]
        """
        Compares a value of an event using multiple floating point numbers.
        """
        number_less_than_or_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgsDict']]]]
        """
        Compares a value of an event using a single floating point number.
        """
        number_less_thans: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgsDict']]]]
        """
        Compares a value of an event using a single floating point number.
        """
        number_not_in_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgsDict']]]]
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        number_not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgsDict']]]]
        """
        Compares a value of an event using multiple floating point numbers.
        """
        string_begins_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_contains: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringContainArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_ends_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringInArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_not_begins_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_not_contains: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_not_ends_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
        string_not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotInArgsDict']]]]
        """
        Compares a value of an event using multiple string values.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterArgs:
    def __init__(__self__, *,
                 bool_equals: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgs']]]] = None,
                 is_not_nulls: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgs']]]] = None,
                 is_null_or_undefineds: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]]] = None,
                 number_greater_than_or_equals: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]]] = None,
                 number_greater_thans: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgs']]]] = None,
                 number_in_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgs']]]] = None,
                 number_ins: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInArgs']]]] = None,
                 number_less_than_or_equals: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]]] = None,
                 number_less_thans: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgs']]]] = None,
                 number_not_in_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgs']]]] = None,
                 number_not_ins: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgs']]]] = None,
                 string_begins_withs: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgs']]]] = None,
                 string_contains: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringContainArgs']]]] = None,
                 string_ends_withs: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgs']]]] = None,
                 string_ins: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringInArgs']]]] = None,
                 string_not_begins_withs: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]]] = None,
                 string_not_contains: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgs']]]] = None,
                 string_not_ends_withs: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgs']]]] = None,
                 string_not_ins: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotInArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgs']]] bool_equals: Compares a value of an event using a single boolean value.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgs']]] is_not_nulls: Evaluates if a value of an event isn't NULL or undefined.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]] is_null_or_undefineds: Evaluates if a value of an event is NULL or undefined.
               
               Each nested block consists of a key and a value(s) element.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]] number_greater_than_or_equals: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgs']]] number_greater_thans: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgs']]] number_in_ranges: Compares a value of an event using multiple floating point number ranges.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInArgs']]] number_ins: Compares a value of an event using multiple floating point numbers.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]] number_less_than_or_equals: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgs']]] number_less_thans: Compares a value of an event using a single floating point number.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgs']]] number_not_in_ranges: Compares a value of an event using multiple floating point number ranges.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgs']]] number_not_ins: Compares a value of an event using multiple floating point numbers.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgs']]] string_begins_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringContainArgs']]] string_contains: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgs']]] string_ends_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringInArgs']]] string_ins: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]] string_not_begins_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgs']]] string_not_contains: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgs']]] string_not_ends_withs: Compares a value of an event using multiple string values.
        :param pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotInArgs']]] string_not_ins: Compares a value of an event using multiple string values.
        """
        if bool_equals is not None:
            pulumi.set(__self__, "bool_equals", bool_equals)
        if is_not_nulls is not None:
            pulumi.set(__self__, "is_not_nulls", is_not_nulls)
        if is_null_or_undefineds is not None:
            pulumi.set(__self__, "is_null_or_undefineds", is_null_or_undefineds)
        if number_greater_than_or_equals is not None:
            pulumi.set(__self__, "number_greater_than_or_equals", number_greater_than_or_equals)
        if number_greater_thans is not None:
            pulumi.set(__self__, "number_greater_thans", number_greater_thans)
        if number_in_ranges is not None:
            pulumi.set(__self__, "number_in_ranges", number_in_ranges)
        if number_ins is not None:
            pulumi.set(__self__, "number_ins", number_ins)
        if number_less_than_or_equals is not None:
            pulumi.set(__self__, "number_less_than_or_equals", number_less_than_or_equals)
        if number_less_thans is not None:
            pulumi.set(__self__, "number_less_thans", number_less_thans)
        if number_not_in_ranges is not None:
            pulumi.set(__self__, "number_not_in_ranges", number_not_in_ranges)
        if number_not_ins is not None:
            pulumi.set(__self__, "number_not_ins", number_not_ins)
        if string_begins_withs is not None:
            pulumi.set(__self__, "string_begins_withs", string_begins_withs)
        if string_contains is not None:
            pulumi.set(__self__, "string_contains", string_contains)
        if string_ends_withs is not None:
            pulumi.set(__self__, "string_ends_withs", string_ends_withs)
        if string_ins is not None:
            pulumi.set(__self__, "string_ins", string_ins)
        if string_not_begins_withs is not None:
            pulumi.set(__self__, "string_not_begins_withs", string_not_begins_withs)
        if string_not_contains is not None:
            pulumi.set(__self__, "string_not_contains", string_not_contains)
        if string_not_ends_withs is not None:
            pulumi.set(__self__, "string_not_ends_withs", string_not_ends_withs)
        if string_not_ins is not None:
            pulumi.set(__self__, "string_not_ins", string_not_ins)

    @property
    @pulumi.getter(name="boolEquals")
    def bool_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgs']]]]:
        """
        Compares a value of an event using a single boolean value.
        """
        return pulumi.get(self, "bool_equals")

    @bool_equals.setter
    def bool_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgs']]]]):
        pulumi.set(self, "bool_equals", value)

    @property
    @pulumi.getter(name="isNotNulls")
    def is_not_nulls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgs']]]]:
        """
        Evaluates if a value of an event isn't NULL or undefined.
        """
        return pulumi.get(self, "is_not_nulls")

    @is_not_nulls.setter
    def is_not_nulls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgs']]]]):
        pulumi.set(self, "is_not_nulls", value)

    @property
    @pulumi.getter(name="isNullOrUndefineds")
    def is_null_or_undefineds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]]]:
        """
        Evaluates if a value of an event is NULL or undefined.

        Each nested block consists of a key and a value(s) element.
        """
        return pulumi.get(self, "is_null_or_undefineds")

    @is_null_or_undefineds.setter
    def is_null_or_undefineds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgs']]]]):
        pulumi.set(self, "is_null_or_undefineds", value)

    @property
    @pulumi.getter(name="numberGreaterThanOrEquals")
    def number_greater_than_or_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_greater_than_or_equals")

    @number_greater_than_or_equals.setter
    def number_greater_than_or_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs']]]]):
        pulumi.set(self, "number_greater_than_or_equals", value)

    @property
    @pulumi.getter(name="numberGreaterThans")
    def number_greater_thans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_greater_thans")

    @number_greater_thans.setter
    def number_greater_thans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgs']]]]):
        pulumi.set(self, "number_greater_thans", value)

    @property
    @pulumi.getter(name="numberInRanges")
    def number_in_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgs']]]]:
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        return pulumi.get(self, "number_in_ranges")

    @number_in_ranges.setter
    def number_in_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgs']]]]):
        pulumi.set(self, "number_in_ranges", value)

    @property
    @pulumi.getter(name="numberIns")
    def number_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInArgs']]]]:
        """
        Compares a value of an event using multiple floating point numbers.
        """
        return pulumi.get(self, "number_ins")

    @number_ins.setter
    def number_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberInArgs']]]]):
        pulumi.set(self, "number_ins", value)

    @property
    @pulumi.getter(name="numberLessThanOrEquals")
    def number_less_than_or_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_less_than_or_equals")

    @number_less_than_or_equals.setter
    def number_less_than_or_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs']]]]):
        pulumi.set(self, "number_less_than_or_equals", value)

    @property
    @pulumi.getter(name="numberLessThans")
    def number_less_thans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgs']]]]:
        """
        Compares a value of an event using a single floating point number.
        """
        return pulumi.get(self, "number_less_thans")

    @number_less_thans.setter
    def number_less_thans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgs']]]]):
        pulumi.set(self, "number_less_thans", value)

    @property
    @pulumi.getter(name="numberNotInRanges")
    def number_not_in_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgs']]]]:
        """
        Compares a value of an event using multiple floating point number ranges.
        """
        return pulumi.get(self, "number_not_in_ranges")

    @number_not_in_ranges.setter
    def number_not_in_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgs']]]]):
        pulumi.set(self, "number_not_in_ranges", value)

    @property
    @pulumi.getter(name="numberNotIns")
    def number_not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgs']]]]:
        """
        Compares a value of an event using multiple floating point numbers.
        """
        return pulumi.get(self, "number_not_ins")

    @number_not_ins.setter
    def number_not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgs']]]]):
        pulumi.set(self, "number_not_ins", value)

    @property
    @pulumi.getter(name="stringBeginsWiths")
    def string_begins_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_begins_withs")

    @string_begins_withs.setter
    def string_begins_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgs']]]]):
        pulumi.set(self, "string_begins_withs", value)

    @property
    @pulumi.getter(name="stringContains")
    def string_contains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringContainArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_contains")

    @string_contains.setter
    def string_contains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringContainArgs']]]]):
        pulumi.set(self, "string_contains", value)

    @property
    @pulumi.getter(name="stringEndsWiths")
    def string_ends_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_ends_withs")

    @string_ends_withs.setter
    def string_ends_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgs']]]]):
        pulumi.set(self, "string_ends_withs", value)

    @property
    @pulumi.getter(name="stringIns")
    def string_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringInArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_ins")

    @string_ins.setter
    def string_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringInArgs']]]]):
        pulumi.set(self, "string_ins", value)

    @property
    @pulumi.getter(name="stringNotBeginsWiths")
    def string_not_begins_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_begins_withs")

    @string_not_begins_withs.setter
    def string_not_begins_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgs']]]]):
        pulumi.set(self, "string_not_begins_withs", value)

    @property
    @pulumi.getter(name="stringNotContains")
    def string_not_contains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_contains")

    @string_not_contains.setter
    def string_not_contains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgs']]]]):
        pulumi.set(self, "string_not_contains", value)

    @property
    @pulumi.getter(name="stringNotEndsWiths")
    def string_not_ends_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_ends_withs")

    @string_not_ends_withs.setter
    def string_not_ends_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgs']]]]):
        pulumi.set(self, "string_not_ends_withs", value)

    @property
    @pulumi.getter(name="stringNotIns")
    def string_not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotInArgs']]]]:
        """
        Compares a value of an event using multiple string values.
        """
        return pulumi.get(self, "string_not_ins")

    @string_not_ins.setter
    def string_not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SystemTopicEventSubscriptionAdvancedFilterStringNotInArgs']]]]):
        pulumi.set(self, "string_not_ins", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[bool]
elif False:
    SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterBoolEqualArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[bool]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterIsNotNullArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefinedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[float]
elif False:
    SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[float]
elif False:
    SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqualArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterNumberInArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[float]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterNumberInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterNumberInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[float]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[float]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[float]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterNumberInRangeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[float]
elif False:
    SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterNumberLessThanArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        value: pulumi.Input[float]
elif False:
    SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqualArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[float]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterNumberNotInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[float]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[float]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[float]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterNumberNotInRangeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterStringBeginsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterStringContainArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterStringContainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterStringContainArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterStringEndsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterStringInArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterStringInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterStringInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterStringNotContainArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWithArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAdvancedFilterStringNotInArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
elif False:
    SystemTopicEventSubscriptionAdvancedFilterStringNotInArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAdvancedFilterStringNotInArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies an array of values to compare to when using a multiple values operator.
               
               > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of values to compare to when using a multiple values operator.

        > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SystemTopicEventSubscriptionAzureFunctionEndpointArgsDict(TypedDict):
        function_id: pulumi.Input[str]
        """
        Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
        """
        max_events_per_batch: NotRequired[pulumi.Input[int]]
        """
        Maximum number of events per batch.
        """
        preferred_batch_size_in_kilobytes: NotRequired[pulumi.Input[int]]
        """
        Preferred batch size in Kilobytes.
        """
elif False:
    SystemTopicEventSubscriptionAzureFunctionEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionAzureFunctionEndpointArgs:
    def __init__(__self__, *,
                 function_id: pulumi.Input[str],
                 max_events_per_batch: Optional[pulumi.Input[int]] = None,
                 preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] function_id: Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
        :param pulumi.Input[int] max_events_per_batch: Maximum number of events per batch.
        :param pulumi.Input[int] preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        """
        pulumi.set(__self__, "function_id", function_id)
        if max_events_per_batch is not None:
            pulumi.set(__self__, "max_events_per_batch", max_events_per_batch)
        if preferred_batch_size_in_kilobytes is not None:
            pulumi.set(__self__, "preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> pulumi.Input[str]:
        """
        Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_id", value)

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @max_events_per_batch.setter
    def max_events_per_batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_events_per_batch", value)

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[pulumi.Input[int]]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")

    @preferred_batch_size_in_kilobytes.setter
    def preferred_batch_size_in_kilobytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preferred_batch_size_in_kilobytes", value)


if not MYPY:
    class SystemTopicEventSubscriptionDeadLetterIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        user_assigned_identity: NotRequired[pulumi.Input[str]]
        """
        The user identity associated with the resource.
        """
elif False:
    SystemTopicEventSubscriptionDeadLetterIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionDeadLetterIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[str] user_assigned_identity: The user identity associated with the resource.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The user identity associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


if not MYPY:
    class SystemTopicEventSubscriptionDeliveryIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        user_assigned_identity: NotRequired[pulumi.Input[str]]
        """
        The user identity associated with the resource.
        """
elif False:
    SystemTopicEventSubscriptionDeliveryIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionDeliveryIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[str] user_assigned_identity: The user identity associated with the resource.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The user identity associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


if not MYPY:
    class SystemTopicEventSubscriptionDeliveryPropertyArgsDict(TypedDict):
        header_name: pulumi.Input[str]
        """
        The name of the header to send on to the destination.
        """
        type: pulumi.Input[str]
        """
        Either `Static` or `Dynamic`.
        """
        secret: NotRequired[pulumi.Input[bool]]
        """
        Set to `true` if the `value` is a secret and should be protected, otherwise `false`. If `true` then this value won't be returned from Azure API calls.
        """
        source_field: NotRequired[pulumi.Input[str]]
        """
        If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        If the `type` is `Static`, then provide the value to use.
        """
elif False:
    SystemTopicEventSubscriptionDeliveryPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionDeliveryPropertyArgs:
    def __init__(__self__, *,
                 header_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 secret: Optional[pulumi.Input[bool]] = None,
                 source_field: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] header_name: The name of the header to send on to the destination.
        :param pulumi.Input[str] type: Either `Static` or `Dynamic`.
        :param pulumi.Input[bool] secret: Set to `true` if the `value` is a secret and should be protected, otherwise `false`. If `true` then this value won't be returned from Azure API calls.
        :param pulumi.Input[str] source_field: If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
        :param pulumi.Input[str] value: If the `type` is `Static`, then provide the value to use.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "type", type)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if source_field is not None:
            pulumi.set(__self__, "source_field", source_field)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the header to send on to the destination.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Either `Static` or `Dynamic`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to `true` if the `value` is a secret and should be protected, otherwise `false`. If `true` then this value won't be returned from Azure API calls.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[pulumi.Input[str]]:
        """
        If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
        """
        return pulumi.get(self, "source_field")

    @source_field.setter
    def source_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_field", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        If the `type` is `Static`, then provide the value to use.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SystemTopicEventSubscriptionRetryPolicyArgsDict(TypedDict):
        event_time_to_live: pulumi.Input[int]
        """
        Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
        """
        max_delivery_attempts: pulumi.Input[int]
        """
        Specifies the maximum number of delivery retry attempts for events.
        """
elif False:
    SystemTopicEventSubscriptionRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionRetryPolicyArgs:
    def __init__(__self__, *,
                 event_time_to_live: pulumi.Input[int],
                 max_delivery_attempts: pulumi.Input[int]):
        """
        :param pulumi.Input[int] event_time_to_live: Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
        :param pulumi.Input[int] max_delivery_attempts: Specifies the maximum number of delivery retry attempts for events.
        """
        pulumi.set(__self__, "event_time_to_live", event_time_to_live)
        pulumi.set(__self__, "max_delivery_attempts", max_delivery_attempts)

    @property
    @pulumi.getter(name="eventTimeToLive")
    def event_time_to_live(self) -> pulumi.Input[int]:
        """
        Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
        """
        return pulumi.get(self, "event_time_to_live")

    @event_time_to_live.setter
    def event_time_to_live(self, value: pulumi.Input[int]):
        pulumi.set(self, "event_time_to_live", value)

    @property
    @pulumi.getter(name="maxDeliveryAttempts")
    def max_delivery_attempts(self) -> pulumi.Input[int]:
        """
        Specifies the maximum number of delivery retry attempts for events.
        """
        return pulumi.get(self, "max_delivery_attempts")

    @max_delivery_attempts.setter
    def max_delivery_attempts(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_delivery_attempts", value)


if not MYPY:
    class SystemTopicEventSubscriptionStorageBlobDeadLetterDestinationArgsDict(TypedDict):
        storage_account_id: pulumi.Input[str]
        """
        Specifies the id of the storage account id where the storage blob is located.
        """
        storage_blob_container_name: pulumi.Input[str]
        """
        Specifies the name of the Storage blob container that is the destination of the deadletter events.
        """
elif False:
    SystemTopicEventSubscriptionStorageBlobDeadLetterDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionStorageBlobDeadLetterDestinationArgs:
    def __init__(__self__, *,
                 storage_account_id: pulumi.Input[str],
                 storage_blob_container_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] storage_account_id: Specifies the id of the storage account id where the storage blob is located.
        :param pulumi.Input[str] storage_blob_container_name: Specifies the name of the Storage blob container that is the destination of the deadletter events.
        """
        pulumi.set(__self__, "storage_account_id", storage_account_id)
        pulumi.set(__self__, "storage_blob_container_name", storage_blob_container_name)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        Specifies the id of the storage account id where the storage blob is located.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="storageBlobContainerName")
    def storage_blob_container_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Storage blob container that is the destination of the deadletter events.
        """
        return pulumi.get(self, "storage_blob_container_name")

    @storage_blob_container_name.setter
    def storage_blob_container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_blob_container_name", value)


if not MYPY:
    class SystemTopicEventSubscriptionStorageQueueEndpointArgsDict(TypedDict):
        queue_name: pulumi.Input[str]
        """
        Specifies the name of the storage queue where the Event Subscription will receive events.
        """
        storage_account_id: pulumi.Input[str]
        """
        Specifies the id of the storage account id where the storage queue is located.
        """
        queue_message_time_to_live_in_seconds: NotRequired[pulumi.Input[int]]
        """
        Storage queue message time to live in seconds.
        """
elif False:
    SystemTopicEventSubscriptionStorageQueueEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionStorageQueueEndpointArgs:
    def __init__(__self__, *,
                 queue_name: pulumi.Input[str],
                 storage_account_id: pulumi.Input[str],
                 queue_message_time_to_live_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] queue_name: Specifies the name of the storage queue where the Event Subscription will receive events.
        :param pulumi.Input[str] storage_account_id: Specifies the id of the storage account id where the storage queue is located.
        :param pulumi.Input[int] queue_message_time_to_live_in_seconds: Storage queue message time to live in seconds.
        """
        pulumi.set(__self__, "queue_name", queue_name)
        pulumi.set(__self__, "storage_account_id", storage_account_id)
        if queue_message_time_to_live_in_seconds is not None:
            pulumi.set(__self__, "queue_message_time_to_live_in_seconds", queue_message_time_to_live_in_seconds)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the storage queue where the Event Subscription will receive events.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_name", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> pulumi.Input[str]:
        """
        Specifies the id of the storage account id where the storage queue is located.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="queueMessageTimeToLiveInSeconds")
    def queue_message_time_to_live_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Storage queue message time to live in seconds.
        """
        return pulumi.get(self, "queue_message_time_to_live_in_seconds")

    @queue_message_time_to_live_in_seconds.setter
    def queue_message_time_to_live_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queue_message_time_to_live_in_seconds", value)


if not MYPY:
    class SystemTopicEventSubscriptionSubjectFilterArgsDict(TypedDict):
        case_sensitive: NotRequired[pulumi.Input[bool]]
        """
        Specifies if `subject_begins_with` and `subject_ends_with` case sensitive. This value
        """
        subject_begins_with: NotRequired[pulumi.Input[str]]
        """
        A string to filter events for an event subscription based on a resource path prefix.
        """
        subject_ends_with: NotRequired[pulumi.Input[str]]
        """
        A string to filter events for an event subscription based on a resource path suffix.
        """
elif False:
    SystemTopicEventSubscriptionSubjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionSubjectFilterArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 subject_begins_with: Optional[pulumi.Input[str]] = None,
                 subject_ends_with: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] case_sensitive: Specifies if `subject_begins_with` and `subject_ends_with` case sensitive. This value
        :param pulumi.Input[str] subject_begins_with: A string to filter events for an event subscription based on a resource path prefix.
        :param pulumi.Input[str] subject_ends_with: A string to filter events for an event subscription based on a resource path suffix.
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if subject_begins_with is not None:
            pulumi.set(__self__, "subject_begins_with", subject_begins_with)
        if subject_ends_with is not None:
            pulumi.set(__self__, "subject_ends_with", subject_ends_with)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if `subject_begins_with` and `subject_ends_with` case sensitive. This value
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="subjectBeginsWith")
    def subject_begins_with(self) -> Optional[pulumi.Input[str]]:
        """
        A string to filter events for an event subscription based on a resource path prefix.
        """
        return pulumi.get(self, "subject_begins_with")

    @subject_begins_with.setter
    def subject_begins_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_begins_with", value)

    @property
    @pulumi.getter(name="subjectEndsWith")
    def subject_ends_with(self) -> Optional[pulumi.Input[str]]:
        """
        A string to filter events for an event subscription based on a resource path suffix.
        """
        return pulumi.get(self, "subject_ends_with")

    @subject_ends_with.setter
    def subject_ends_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_ends_with", value)


if not MYPY:
    class SystemTopicEventSubscriptionWebhookEndpointArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        Specifies the url of the webhook where the Event Subscription will receive events.
        """
        active_directory_app_id_or_uri: NotRequired[pulumi.Input[str]]
        """
        The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        """
        active_directory_tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        """
        base_url: NotRequired[pulumi.Input[str]]
        """
        The base url of the webhook where the Event Subscription will receive events.
        """
        max_events_per_batch: NotRequired[pulumi.Input[int]]
        """
        Maximum number of events per batch.
        """
        preferred_batch_size_in_kilobytes: NotRequired[pulumi.Input[int]]
        """
        Preferred batch size in Kilobytes.
        """
elif False:
    SystemTopicEventSubscriptionWebhookEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicEventSubscriptionWebhookEndpointArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 active_directory_app_id_or_uri: Optional[pulumi.Input[str]] = None,
                 active_directory_tenant_id: Optional[pulumi.Input[str]] = None,
                 base_url: Optional[pulumi.Input[str]] = None,
                 max_events_per_batch: Optional[pulumi.Input[int]] = None,
                 preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] url: Specifies the url of the webhook where the Event Subscription will receive events.
        :param pulumi.Input[str] active_directory_app_id_or_uri: The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        :param pulumi.Input[str] active_directory_tenant_id: The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        :param pulumi.Input[str] base_url: The base url of the webhook where the Event Subscription will receive events.
        :param pulumi.Input[int] max_events_per_batch: Maximum number of events per batch.
        :param pulumi.Input[int] preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        """
        pulumi.set(__self__, "url", url)
        if active_directory_app_id_or_uri is not None:
            pulumi.set(__self__, "active_directory_app_id_or_uri", active_directory_app_id_or_uri)
        if active_directory_tenant_id is not None:
            pulumi.set(__self__, "active_directory_tenant_id", active_directory_tenant_id)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if max_events_per_batch is not None:
            pulumi.set(__self__, "max_events_per_batch", max_events_per_batch)
        if preferred_batch_size_in_kilobytes is not None:
            pulumi.set(__self__, "preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the url of the webhook where the Event Subscription will receive events.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="activeDirectoryAppIdOrUri")
    def active_directory_app_id_or_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "active_directory_app_id_or_uri")

    @active_directory_app_id_or_uri.setter
    def active_directory_app_id_or_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_directory_app_id_or_uri", value)

    @property
    @pulumi.getter(name="activeDirectoryTenantId")
    def active_directory_tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "active_directory_tenant_id")

    @active_directory_tenant_id.setter
    def active_directory_tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_directory_tenant_id", value)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[str]]:
        """
        The base url of the webhook where the Event Subscription will receive events.
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @max_events_per_batch.setter
    def max_events_per_batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_events_per_batch", value)

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[pulumi.Input[int]]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")

    @preferred_batch_size_in_kilobytes.setter
    def preferred_batch_size_in_kilobytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preferred_batch_size_in_kilobytes", value)


if not MYPY:
    class SystemTopicIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Event Grid System Topic. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid System Topic.

        > **NOTE:** This is required when `type` is set to `UserAssigned`

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid System Topic has been created. More details are available below.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    SystemTopicIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemTopicIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Event Grid System Topic. Possible values are `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid System Topic.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid System Topic has been created. More details are available below.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Event Grid System Topic. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid System Topic.

        > **NOTE:** This is required when `type` is set to `UserAssigned`

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid System Topic has been created. More details are available below.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TopicIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Event Grid Topic. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Topic.

        > **NOTE:** This is required when `type` is set to `UserAssigned`

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Topic has been created. More details are available below.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    TopicIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Event Grid Topic. Possible values are `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Topic.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Topic has been created. More details are available below.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Event Grid Topic. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Topic.

        > **NOTE:** This is required when `type` is set to `UserAssigned`

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Event Grid Topic has been created. More details are available below.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TopicInboundIpRuleArgsDict(TypedDict):
        ip_mask: pulumi.Input[str]
        """
        The IP mask (CIDR) to match on.
        """
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
elif False:
    TopicInboundIpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicInboundIpRuleArgs:
    def __init__(__self__, *,
                 ip_mask: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_mask: The IP mask (CIDR) to match on.
        :param pulumi.Input[str] action: The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        pulumi.set(__self__, "ip_mask", ip_mask)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> pulumi.Input[str]:
        """
        The IP mask (CIDR) to match on.
        """
        return pulumi.get(self, "ip_mask")

    @ip_mask.setter
    def ip_mask(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_mask", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when the rule is matched. Possible values are `Allow`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class TopicInputMappingDefaultValuesArgsDict(TypedDict):
        data_version: NotRequired[pulumi.Input[str]]
        """
        Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        event_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
elif False:
    TopicInputMappingDefaultValuesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicInputMappingDefaultValuesArgs:
    def __init__(__self__, *,
                 data_version: Optional[pulumi.Input[str]] = None,
                 event_type: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_version: Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_type: Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subject: Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        if data_version is not None:
            pulumi.set(__self__, "data_version", data_version)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "data_version")

    @data_version.setter
    def data_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_version", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class TopicInputMappingFieldsArgsDict(TypedDict):
        data_version: NotRequired[pulumi.Input[str]]
        """
        Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        event_time: NotRequired[pulumi.Input[str]]
        """
        Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        event_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        topic: NotRequired[pulumi.Input[str]]
        """
        Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
elif False:
    TopicInputMappingFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicInputMappingFieldsArgs:
    def __init__(__self__, *,
                 data_version: Optional[pulumi.Input[str]] = None,
                 event_time: Optional[pulumi.Input[str]] = None,
                 event_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 topic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_version: Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_time: Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] event_type: Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] id: Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subject: Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] topic: Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        if data_version is not None:
            pulumi.set(__self__, "data_version", data_version)
        if event_time is not None:
            pulumi.set(__self__, "event_time", event_time)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "data_version")

    @data_version.setter
    def data_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_version", value)

    @property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_time")

    @event_time.setter
    def event_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_time", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic", value)


