# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'BudgetManagementGroupFilterArgs',
    'BudgetManagementGroupFilterDimensionArgs',
    'BudgetManagementGroupFilterNotArgs',
    'BudgetManagementGroupFilterNotDimensionArgs',
    'BudgetManagementGroupFilterNotTagArgs',
    'BudgetManagementGroupFilterTagArgs',
    'BudgetManagementGroupNotificationArgs',
    'BudgetManagementGroupTimePeriodArgs',
    'BudgetResourceGroupFilterArgs',
    'BudgetResourceGroupFilterDimensionArgs',
    'BudgetResourceGroupFilterNotArgs',
    'BudgetResourceGroupFilterNotDimensionArgs',
    'BudgetResourceGroupFilterNotTagArgs',
    'BudgetResourceGroupFilterTagArgs',
    'BudgetResourceGroupNotificationArgs',
    'BudgetResourceGroupTimePeriodArgs',
    'BudgetSubscriptionFilterArgs',
    'BudgetSubscriptionFilterDimensionArgs',
    'BudgetSubscriptionFilterNotArgs',
    'BudgetSubscriptionFilterNotDimensionArgs',
    'BudgetSubscriptionFilterNotTagArgs',
    'BudgetSubscriptionFilterTagArgs',
    'BudgetSubscriptionNotificationArgs',
    'BudgetSubscriptionTimePeriodArgs',
]

@pulumi.input_type
class BudgetManagementGroupFilterArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterDimensionArgs']]]] = None,
                 not_: Optional[pulumi.Input['BudgetManagementGroupFilterNotArgs']] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterTagArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterDimensionArgs']]] dimensions: One or more `dimension` blocks as defined below to filter the budget on.
        :param pulumi.Input['BudgetManagementGroupFilterNotArgs'] not_: A `not` block as defined below to filter the budget on. This is deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
        :param pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterTagArgs']]] tags: One or more `tag` blocks as defined below to filter the budget on.
        """
        BudgetManagementGroupFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimensions=dimensions,
            not_=not_,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterDimensionArgs']]]] = None,
             not_: Optional[pulumi.Input['BudgetManagementGroupFilterNotArgs']] = None,
             tags: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterTagArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if not_ is not None:
            warnings.warn("""This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""", DeprecationWarning)
            pulumi.log.warn("""not_ is deprecated: This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""")
        if not_ is not None:
            _setter("not_", not_)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterDimensionArgs']]]]:
        """
        One or more `dimension` blocks as defined below to filter the budget on.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['BudgetManagementGroupFilterNotArgs']]:
        """
        A `not` block as defined below to filter the budget on. This is deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
        """
        warnings.warn("""This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""", DeprecationWarning)
        pulumi.log.warn("""not_ is deprecated: This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""")

        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['BudgetManagementGroupFilterNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterTagArgs']]]]:
        """
        One or more `tag` blocks as defined below to filter the budget on.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetManagementGroupFilterTagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class BudgetManagementGroupFilterDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the column.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetManagementGroupFilterDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the column.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetManagementGroupFilterNotArgs:
    def __init__(__self__, *,
                 dimension: Optional[pulumi.Input['BudgetManagementGroupFilterNotDimensionArgs']] = None,
                 tag: Optional[pulumi.Input['BudgetManagementGroupFilterNotTagArgs']] = None):
        """
        :param pulumi.Input['BudgetManagementGroupFilterNotDimensionArgs'] dimension: One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
        :param pulumi.Input['BudgetManagementGroupFilterNotTagArgs'] tag: One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
        """
        BudgetManagementGroupFilterNotArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimension=dimension,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimension: Optional[pulumi.Input['BudgetManagementGroupFilterNotDimensionArgs']] = None,
             tag: Optional[pulumi.Input['BudgetManagementGroupFilterNotTagArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dimension is not None:
            _setter("dimension", dimension)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['BudgetManagementGroupFilterNotDimensionArgs']]:
        """
        One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['BudgetManagementGroupFilterNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['BudgetManagementGroupFilterNotTagArgs']]:
        """
        One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['BudgetManagementGroupFilterNotTagArgs']]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class BudgetManagementGroupFilterNotDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the column.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetManagementGroupFilterNotDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the column.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetManagementGroupFilterNotTagArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the tag to use for the filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the tag.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetManagementGroupFilterNotTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the tag to use for the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetManagementGroupFilterTagArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the tag to use for the filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the tag.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetManagementGroupFilterTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the tag to use for the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetManagementGroupNotificationArgs:
    def __init__(__self__, *,
                 contact_emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: pulumi.Input[str],
                 threshold: pulumi.Input[int],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] contact_emails: Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
        :param pulumi.Input[str] operator: The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
        :param pulumi.Input[int] threshold: Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
        :param pulumi.Input[bool] enabled: Should the notification be enabled? Defaults to `true`.
        :param pulumi.Input[str] threshold_type: The type of threshold for the notification. This determines whether the notification is triggered by forecasted costs or actual costs. The allowed values are `Actual` and `Forecasted`. Default is `Actual`. Changing this forces a new resource to be created.
        """
        BudgetManagementGroupNotificationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contact_emails=contact_emails,
            operator=operator,
            threshold=threshold,
            enabled=enabled,
            threshold_type=threshold_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contact_emails: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: pulumi.Input[str],
             threshold: pulumi.Input[int],
             enabled: Optional[pulumi.Input[bool]] = None,
             threshold_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("contact_emails", contact_emails)
        _setter("operator", operator)
        _setter("threshold", threshold)
        if enabled is not None:
            _setter("enabled", enabled)
        if threshold_type is not None:
            _setter("threshold_type", threshold_type)

    @property
    @pulumi.getter(name="contactEmails")
    def contact_emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
        """
        return pulumi.get(self, "contact_emails")

    @contact_emails.setter
    def contact_emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "contact_emails", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[int]:
        """
        Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the notification be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of threshold for the notification. This determines whether the notification is triggered by forecasted costs or actual costs. The allowed values are `Actual` and `Forecasted`. Default is `Actual`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


@pulumi.input_type
class BudgetManagementGroupTimePeriodArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] start_date: The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new resource to be created.
        :param pulumi.Input[str] end_date: The end date for the budget. If not set this will be 10 years after the start date.
        """
        BudgetManagementGroupTimePeriodArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            start_date=start_date,
            end_date=end_date,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             start_date: pulumi.Input[str],
             end_date: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("start_date", start_date)
        if end_date is not None:
            _setter("end_date", end_date)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The end date for the budget. If not set this will be 10 years after the start date.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)


@pulumi.input_type
class BudgetResourceGroupFilterArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterDimensionArgs']]]] = None,
                 not_: Optional[pulumi.Input['BudgetResourceGroupFilterNotArgs']] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterTagArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterDimensionArgs']]] dimensions: One or more `dimension` blocks as defined below to filter the budget on.
        :param pulumi.Input['BudgetResourceGroupFilterNotArgs'] not_: A `not` block as defined below to filter the budget on. This is deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
        :param pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterTagArgs']]] tags: One or more `tag` blocks as defined below to filter the budget on.
        """
        BudgetResourceGroupFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimensions=dimensions,
            not_=not_,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterDimensionArgs']]]] = None,
             not_: Optional[pulumi.Input['BudgetResourceGroupFilterNotArgs']] = None,
             tags: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterTagArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if not_ is not None:
            warnings.warn("""This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""", DeprecationWarning)
            pulumi.log.warn("""not_ is deprecated: This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""")
        if not_ is not None:
            _setter("not_", not_)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterDimensionArgs']]]]:
        """
        One or more `dimension` blocks as defined below to filter the budget on.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['BudgetResourceGroupFilterNotArgs']]:
        """
        A `not` block as defined below to filter the budget on. This is deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
        """
        warnings.warn("""This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""", DeprecationWarning)
        pulumi.log.warn("""not_ is deprecated: This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""")

        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['BudgetResourceGroupFilterNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterTagArgs']]]]:
        """
        One or more `tag` blocks as defined below to filter the budget on.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetResourceGroupFilterTagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class BudgetResourceGroupFilterDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the column.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetResourceGroupFilterDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the column.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetResourceGroupFilterNotArgs:
    def __init__(__self__, *,
                 dimension: Optional[pulumi.Input['BudgetResourceGroupFilterNotDimensionArgs']] = None,
                 tag: Optional[pulumi.Input['BudgetResourceGroupFilterNotTagArgs']] = None):
        """
        :param pulumi.Input['BudgetResourceGroupFilterNotDimensionArgs'] dimension: One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
        :param pulumi.Input['BudgetResourceGroupFilterNotTagArgs'] tag: One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
        """
        BudgetResourceGroupFilterNotArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimension=dimension,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimension: Optional[pulumi.Input['BudgetResourceGroupFilterNotDimensionArgs']] = None,
             tag: Optional[pulumi.Input['BudgetResourceGroupFilterNotTagArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dimension is not None:
            _setter("dimension", dimension)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['BudgetResourceGroupFilterNotDimensionArgs']]:
        """
        One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['BudgetResourceGroupFilterNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['BudgetResourceGroupFilterNotTagArgs']]:
        """
        One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['BudgetResourceGroupFilterNotTagArgs']]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class BudgetResourceGroupFilterNotDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the column.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetResourceGroupFilterNotDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the column.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetResourceGroupFilterNotTagArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the tag to use for the filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the tag.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetResourceGroupFilterNotTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the tag to use for the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetResourceGroupFilterTagArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the tag to use for the filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the tag.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetResourceGroupFilterTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the tag to use for the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetResourceGroupNotificationArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 threshold: pulumi.Input[int],
                 contact_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 contact_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 contact_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
        :param pulumi.Input[int] threshold: Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] contact_emails: Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] contact_groups: Specifies a list of Action Group IDs to send the budget notification to when the threshold is exceeded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] contact_roles: Specifies a list of contact roles to send the budget notification to when the threshold is exceeded.
        :param pulumi.Input[bool] enabled: Should the notification be enabled? Defaults to `true`.
               
               > **NOTE:** A `notification` block cannot have all of `contact_emails`, `contact_roles`, and `contact_groups` empty. This means that at least one of the three must be specified.
        :param pulumi.Input[str] threshold_type: The type of threshold for the notification. This determines whether the notification is triggered by forecasted costs or actual costs. The allowed values are `Actual` and `Forecasted`. Default is `Actual`. Changing this forces a new resource to be created.
        """
        BudgetResourceGroupNotificationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            threshold=threshold,
            contact_emails=contact_emails,
            contact_groups=contact_groups,
            contact_roles=contact_roles,
            enabled=enabled,
            threshold_type=threshold_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: pulumi.Input[str],
             threshold: pulumi.Input[int],
             contact_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             contact_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             contact_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             threshold_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operator", operator)
        _setter("threshold", threshold)
        if contact_emails is not None:
            _setter("contact_emails", contact_emails)
        if contact_groups is not None:
            _setter("contact_groups", contact_groups)
        if contact_roles is not None:
            _setter("contact_roles", contact_roles)
        if enabled is not None:
            _setter("enabled", enabled)
        if threshold_type is not None:
            _setter("threshold_type", threshold_type)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[int]:
        """
        Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="contactEmails")
    def contact_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
        """
        return pulumi.get(self, "contact_emails")

    @contact_emails.setter
    def contact_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "contact_emails", value)

    @property
    @pulumi.getter(name="contactGroups")
    def contact_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Action Group IDs to send the budget notification to when the threshold is exceeded.
        """
        return pulumi.get(self, "contact_groups")

    @contact_groups.setter
    def contact_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "contact_groups", value)

    @property
    @pulumi.getter(name="contactRoles")
    def contact_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of contact roles to send the budget notification to when the threshold is exceeded.
        """
        return pulumi.get(self, "contact_roles")

    @contact_roles.setter
    def contact_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "contact_roles", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the notification be enabled? Defaults to `true`.

        > **NOTE:** A `notification` block cannot have all of `contact_emails`, `contact_roles`, and `contact_groups` empty. This means that at least one of the three must be specified.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of threshold for the notification. This determines whether the notification is triggered by forecasted costs or actual costs. The allowed values are `Actual` and `Forecasted`. Default is `Actual`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


@pulumi.input_type
class BudgetResourceGroupTimePeriodArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] start_date: The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new Resource Group Consumption Budget to be created.
        :param pulumi.Input[str] end_date: The end date for the budget. If not set this will be 10 years after the start date.
        """
        BudgetResourceGroupTimePeriodArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            start_date=start_date,
            end_date=end_date,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             start_date: pulumi.Input[str],
             end_date: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("start_date", start_date)
        if end_date is not None:
            _setter("end_date", end_date)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new Resource Group Consumption Budget to be created.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The end date for the budget. If not set this will be 10 years after the start date.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)


@pulumi.input_type
class BudgetSubscriptionFilterArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterDimensionArgs']]]] = None,
                 not_: Optional[pulumi.Input['BudgetSubscriptionFilterNotArgs']] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterTagArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterDimensionArgs']]] dimensions: One or more `dimension` blocks as defined below to filter the budget on.
        :param pulumi.Input['BudgetSubscriptionFilterNotArgs'] not_: A `not` block as defined below to filter the budget on. This is deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
        :param pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterTagArgs']]] tags: One or more `tag` blocks as defined below to filter the budget on.
        """
        BudgetSubscriptionFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimensions=dimensions,
            not_=not_,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterDimensionArgs']]]] = None,
             not_: Optional[pulumi.Input['BudgetSubscriptionFilterNotArgs']] = None,
             tags: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterTagArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if not_ is not None:
            warnings.warn("""This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""", DeprecationWarning)
            pulumi.log.warn("""not_ is deprecated: This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""")
        if not_ is not None:
            _setter("not_", not_)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterDimensionArgs']]]]:
        """
        One or more `dimension` blocks as defined below to filter the budget on.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['BudgetSubscriptionFilterNotArgs']]:
        """
        A `not` block as defined below to filter the budget on. This is deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
        """
        warnings.warn("""This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""", DeprecationWarning)
        pulumi.log.warn("""not_ is deprecated: This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""")

        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['BudgetSubscriptionFilterNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterTagArgs']]]]:
        """
        One or more `tag` blocks as defined below to filter the budget on.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetSubscriptionFilterTagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class BudgetSubscriptionFilterDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the column.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetSubscriptionFilterDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the column.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetSubscriptionFilterNotArgs:
    def __init__(__self__, *,
                 dimension: Optional[pulumi.Input['BudgetSubscriptionFilterNotDimensionArgs']] = None,
                 tag: Optional[pulumi.Input['BudgetSubscriptionFilterNotTagArgs']] = None):
        """
        :param pulumi.Input['BudgetSubscriptionFilterNotDimensionArgs'] dimension: One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
        :param pulumi.Input['BudgetSubscriptionFilterNotTagArgs'] tag: One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
        """
        BudgetSubscriptionFilterNotArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimension=dimension,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimension: Optional[pulumi.Input['BudgetSubscriptionFilterNotDimensionArgs']] = None,
             tag: Optional[pulumi.Input['BudgetSubscriptionFilterNotTagArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dimension is not None:
            _setter("dimension", dimension)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['BudgetSubscriptionFilterNotDimensionArgs']]:
        """
        One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['BudgetSubscriptionFilterNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['BudgetSubscriptionFilterNotTagArgs']]:
        """
        One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['BudgetSubscriptionFilterNotTagArgs']]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class BudgetSubscriptionFilterNotDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the column.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetSubscriptionFilterNotDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the column.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetSubscriptionFilterNotTagArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the tag to use for the filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the tag.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetSubscriptionFilterNotTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the tag to use for the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetSubscriptionFilterTagArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the tag to use for the filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specifies a list of values for the tag.
        :param pulumi.Input[str] operator: The operator to use for comparison. The allowed values are `In`.
        """
        BudgetSubscriptionFilterTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             values: pulumi.Input[Sequence[pulumi.Input[str]]],
             operator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the tag to use for the filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of values for the tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for comparison. The allowed values are `In`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class BudgetSubscriptionNotificationArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 threshold: pulumi.Input[int],
                 contact_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 contact_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 contact_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
        :param pulumi.Input[int] threshold: Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] contact_emails: Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] contact_groups: Specifies a list of Action Group IDs to send the budget notification to when the threshold is exceeded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] contact_roles: Specifies a list of contact roles to send the budget notification to when the threshold is exceeded.
        :param pulumi.Input[bool] enabled: Should the notification be enabled? Defaults to `true`.
               
               > **NOTE:** A `notification` block cannot have all of `contact_emails`, `contact_roles`, and `contact_groups` empty. This means that at least one of the three must be specified.
        :param pulumi.Input[str] threshold_type: The type of threshold for the notification. This determines whether the notification is triggered by forecasted costs or actual costs. The allowed values are `Actual` and `Forecasted`. Default is `Actual`. Changing this forces a new resource to be created.
        """
        BudgetSubscriptionNotificationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            threshold=threshold,
            contact_emails=contact_emails,
            contact_groups=contact_groups,
            contact_roles=contact_roles,
            enabled=enabled,
            threshold_type=threshold_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: pulumi.Input[str],
             threshold: pulumi.Input[int],
             contact_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             contact_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             contact_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             threshold_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operator", operator)
        _setter("threshold", threshold)
        if contact_emails is not None:
            _setter("contact_emails", contact_emails)
        if contact_groups is not None:
            _setter("contact_groups", contact_groups)
        if contact_roles is not None:
            _setter("contact_roles", contact_roles)
        if enabled is not None:
            _setter("enabled", enabled)
        if threshold_type is not None:
            _setter("threshold_type", threshold_type)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[int]:
        """
        Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="contactEmails")
    def contact_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
        """
        return pulumi.get(self, "contact_emails")

    @contact_emails.setter
    def contact_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "contact_emails", value)

    @property
    @pulumi.getter(name="contactGroups")
    def contact_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Action Group IDs to send the budget notification to when the threshold is exceeded.
        """
        return pulumi.get(self, "contact_groups")

    @contact_groups.setter
    def contact_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "contact_groups", value)

    @property
    @pulumi.getter(name="contactRoles")
    def contact_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of contact roles to send the budget notification to when the threshold is exceeded.
        """
        return pulumi.get(self, "contact_roles")

    @contact_roles.setter
    def contact_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "contact_roles", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the notification be enabled? Defaults to `true`.

        > **NOTE:** A `notification` block cannot have all of `contact_emails`, `contact_roles`, and `contact_groups` empty. This means that at least one of the three must be specified.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of threshold for the notification. This determines whether the notification is triggered by forecasted costs or actual costs. The allowed values are `Actual` and `Forecasted`. Default is `Actual`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


@pulumi.input_type
class BudgetSubscriptionTimePeriodArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] start_date: The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new Subscription Consumption Budget to be created.
        :param pulumi.Input[str] end_date: The end date for the budget. If not set this will be 10 years after the start date.
        """
        BudgetSubscriptionTimePeriodArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            start_date=start_date,
            end_date=end_date,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             start_date: pulumi.Input[str],
             end_date: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("start_date", start_date)
        if end_date is not None:
            _setter("end_date", end_date)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new Subscription Consumption Budget to be created.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The end date for the budget. If not set this will be 10 years after the start date.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)


