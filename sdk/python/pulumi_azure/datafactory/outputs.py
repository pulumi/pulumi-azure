# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'DatasetAzureBlobSchemaColumn',
    'DatasetCosmosDBApiSchemaColumn',
    'DatasetDelimitedTextAzureBlobStorageLocation',
    'DatasetDelimitedTextHttpServerLocation',
    'DatasetDelimitedTextSchemaColumn',
    'DatasetHttpSchemaColumn',
    'DatasetJsonAzureBlobStorageLocation',
    'DatasetJsonHttpServerLocation',
    'DatasetJsonSchemaColumn',
    'DatasetMysqlSchemaColumn',
    'DatasetParquetAzureBlobStorageLocation',
    'DatasetParquetHttpServerLocation',
    'DatasetParquetSchemaColumn',
    'DatasetPostgresqlSchemaColumn',
    'DatasetSnowflakeSchemaColumn',
    'DatasetSqlServerTableSchemaColumn',
    'FactoryGithubConfiguration',
    'FactoryIdentity',
    'FactoryVstsConfiguration',
    'IntegrationRuntimeManagedCatalogInfo',
    'IntegrationRuntimeManagedCustomSetupScript',
    'IntegrationRuntimeManagedVnetIntegration',
    'IntegrationRuntimeSelfHostedRbacAuthorization',
    'IntegrationRuntimeSsisCatalogInfo',
    'IntegrationRuntimeSsisCustomSetupScript',
    'IntegrationRuntimeSsisVnetIntegration',
    'LinkedServiceAzureDatabricksInstancePool',
    'LinkedServiceAzureDatabricksKeyVaultPassword',
    'LinkedServiceAzureDatabricksNewClusterConfig',
    'LinkedServiceAzureFileStorageKeyVaultPassword',
    'LinkedServiceAzureSqlDatabaseKeyVaultPassword',
    'LinkedServiceSnowflakeKeyVaultPassword',
    'LinkedServiceSqlServerKeyVaultPassword',
    'LinkedServiceSynapseKeyVaultPassword',
    'GetFactoryGithubConfigurationResult',
    'GetFactoryIdentityResult',
    'GetFactoryVstsConfigurationResult',
]

@pulumi.output_type
class DatasetAzureBlobSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetCosmosDBApiSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetDelimitedTextAzureBlobStorageLocation(dict):
    def __init__(__self__, *,
                 container: str,
                 filename: str,
                 path: str):
        """
        :param str container: The container on the Azure Blob Storage Account hosting the file.
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetDelimitedTextHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDelimitedTextHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDelimitedTextHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDelimitedTextHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: str,
                 path: str,
                 relative_url: str):
        """
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        :param str relative_url: The base URL to the web server hosting the file.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")


@pulumi.output_type
class DatasetDelimitedTextSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetHttpSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetJsonAzureBlobStorageLocation(dict):
    def __init__(__self__, *,
                 container: str,
                 filename: str,
                 path: str):
        """
        :param str container: The container on the Azure Blob Storage Account hosting the file.
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetJsonHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetJsonHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetJsonHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetJsonHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: str,
                 path: str,
                 relative_url: str):
        """
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        :param str relative_url: The base URL to the web server hosting the file.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")


@pulumi.output_type
class DatasetJsonSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetMysqlSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetParquetAzureBlobStorageLocation(dict):
    def __init__(__self__, *,
                 container: str,
                 filename: str,
                 path: str):
        """
        :param str container: The container on the Azure Blob Storage Account hosting the file.
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetParquetHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetParquetHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetParquetHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetParquetHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: str,
                 path: str,
                 relative_url: str):
        """
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        :param str relative_url: The base URL to the web server hosting the file.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")


@pulumi.output_type
class DatasetParquetSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetPostgresqlSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetSnowflakeSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetSqlServerTableSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FactoryGithubConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "gitUrl":
            suggest = "git_url"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "rootFolder":
            suggest = "root_folder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FactoryGithubConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FactoryGithubConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FactoryGithubConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 branch_name: str,
                 git_url: str,
                 repository_name: str,
                 root_folder: str):
        """
        :param str account_name: Specifies the GitHub account name.
        :param str branch_name: Specifies the branch of the repository to get code from.
        :param str git_url: Specifies the GitHub Enterprise host name. For example: https://github.mydomain.com. Use https://github.com for open source repositories.
        :param str repository_name: Specifies the name of the git repository.
        :param str root_folder: Specifies the root folder within the repository. Set to `/` for the top level.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "git_url", git_url)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        Specifies the GitHub account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        Specifies the branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="gitUrl")
    def git_url(self) -> str:
        """
        Specifies the GitHub Enterprise host name. For example: https://github.mydomain.com. Use https://github.com for open source repositories.
        """
        return pulumi.get(self, "git_url")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        Specifies the name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        return pulumi.get(self, "root_folder")


@pulumi.output_type
class FactoryIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FactoryIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FactoryIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FactoryIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the Data Factory. Possible values are `SystemAssigned` and `UserAssigned`.
        :param Sequence[str] identity_ids: Specifies the IDs of user assigned identities. Requiered if `UserAssigned` type is used.
        :param str principal_id: The ID of the Principal (Client) in Azure Active Directory
        :param str tenant_id: Specifies the Tenant ID associated with the VSTS account.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the Data Factory. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies the IDs of user assigned identities. Requiered if `UserAssigned` type is used.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The ID of the Principal (Client) in Azure Active Directory
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Specifies the Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FactoryVstsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "projectName":
            suggest = "project_name"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "rootFolder":
            suggest = "root_folder"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FactoryVstsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FactoryVstsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FactoryVstsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 branch_name: str,
                 project_name: str,
                 repository_name: str,
                 root_folder: str,
                 tenant_id: str):
        """
        :param str account_name: Specifies the VSTS account name.
        :param str branch_name: Specifies the branch of the repository to get code from.
        :param str project_name: Specifies the name of the VSTS project.
        :param str repository_name: Specifies the name of the git repository.
        :param str root_folder: Specifies the root folder within the repository. Set to `/` for the top level.
        :param str tenant_id: Specifies the Tenant ID associated with the VSTS account.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        Specifies the VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        Specifies the branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        Specifies the name of the VSTS project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        Specifies the name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Specifies the Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class IntegrationRuntimeManagedCatalogInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverEndpoint":
            suggest = "server_endpoint"
        elif key == "administratorLogin":
            suggest = "administrator_login"
        elif key == "administratorPassword":
            suggest = "administrator_password"
        elif key == "pricingTier":
            suggest = "pricing_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeManagedCatalogInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeManagedCatalogInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeManagedCatalogInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_endpoint: str,
                 administrator_login: Optional[str] = None,
                 administrator_password: Optional[str] = None,
                 pricing_tier: Optional[str] = None):
        """
        :param str server_endpoint: The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        :param str administrator_login: Administrator login name for the SQL Server.
        :param str administrator_password: Administrator login password for the SQL Server.
        :param str pricing_tier: Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
        """
        pulumi.set(__self__, "server_endpoint", server_endpoint)
        if administrator_login is not None:
            pulumi.set(__self__, "administrator_login", administrator_login)
        if administrator_password is not None:
            pulumi.set(__self__, "administrator_password", administrator_password)
        if pricing_tier is not None:
            pulumi.set(__self__, "pricing_tier", pricing_tier)

    @property
    @pulumi.getter(name="serverEndpoint")
    def server_endpoint(self) -> str:
        """
        The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        """
        return pulumi.get(self, "server_endpoint")

    @property
    @pulumi.getter(name="administratorLogin")
    def administrator_login(self) -> Optional[str]:
        """
        Administrator login name for the SQL Server.
        """
        return pulumi.get(self, "administrator_login")

    @property
    @pulumi.getter(name="administratorPassword")
    def administrator_password(self) -> Optional[str]:
        """
        Administrator login password for the SQL Server.
        """
        return pulumi.get(self, "administrator_password")

    @property
    @pulumi.getter(name="pricingTier")
    def pricing_tier(self) -> Optional[str]:
        """
        Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
        """
        return pulumi.get(self, "pricing_tier")


@pulumi.output_type
class IntegrationRuntimeManagedCustomSetupScript(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobContainerUri":
            suggest = "blob_container_uri"
        elif key == "sasToken":
            suggest = "sas_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeManagedCustomSetupScript. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeManagedCustomSetupScript.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeManagedCustomSetupScript.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_container_uri: str,
                 sas_token: str):
        """
        :param str blob_container_uri: The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        :param str sas_token: A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        pulumi.set(__self__, "sas_token", sas_token)

    @property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> str:
        """
        The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "blob_container_uri")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> str:
        """
        A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "sas_token")


@pulumi.output_type
class IntegrationRuntimeManagedVnetIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetName":
            suggest = "subnet_name"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeManagedVnetIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeManagedVnetIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeManagedVnetIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_name: str,
                 vnet_id: str):
        """
        :param str subnet_name: Name of the subnet to which the nodes of the Managed Integration Runtime will be added.
        :param str vnet_id: ID of the virtual network to which the nodes of the Managed Integration Runtime will be added.
        """
        pulumi.set(__self__, "subnet_name", subnet_name)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> str:
        """
        Name of the subnet to which the nodes of the Managed Integration Runtime will be added.
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        ID of the virtual network to which the nodes of the Managed Integration Runtime will be added.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class IntegrationRuntimeSelfHostedRbacAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSelfHostedRbacAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSelfHostedRbacAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSelfHostedRbacAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: str):
        """
        :param str resource_id: The resource identifier of the integration runtime to be shared. Changing this forces a new Data Factory to be created.
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The resource identifier of the integration runtime to be shared. Changing this forces a new Data Factory to be created.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class IntegrationRuntimeSsisCatalogInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverEndpoint":
            suggest = "server_endpoint"
        elif key == "administratorLogin":
            suggest = "administrator_login"
        elif key == "administratorPassword":
            suggest = "administrator_password"
        elif key == "pricingTier":
            suggest = "pricing_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisCatalogInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisCatalogInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisCatalogInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_endpoint: str,
                 administrator_login: Optional[str] = None,
                 administrator_password: Optional[str] = None,
                 pricing_tier: Optional[str] = None):
        """
        :param str server_endpoint: The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        :param str administrator_login: Administrator login name for the SQL Server.
        :param str administrator_password: Administrator login password for the SQL Server.
        :param str pricing_tier: Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
        """
        pulumi.set(__self__, "server_endpoint", server_endpoint)
        if administrator_login is not None:
            pulumi.set(__self__, "administrator_login", administrator_login)
        if administrator_password is not None:
            pulumi.set(__self__, "administrator_password", administrator_password)
        if pricing_tier is not None:
            pulumi.set(__self__, "pricing_tier", pricing_tier)

    @property
    @pulumi.getter(name="serverEndpoint")
    def server_endpoint(self) -> str:
        """
        The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        """
        return pulumi.get(self, "server_endpoint")

    @property
    @pulumi.getter(name="administratorLogin")
    def administrator_login(self) -> Optional[str]:
        """
        Administrator login name for the SQL Server.
        """
        return pulumi.get(self, "administrator_login")

    @property
    @pulumi.getter(name="administratorPassword")
    def administrator_password(self) -> Optional[str]:
        """
        Administrator login password for the SQL Server.
        """
        return pulumi.get(self, "administrator_password")

    @property
    @pulumi.getter(name="pricingTier")
    def pricing_tier(self) -> Optional[str]:
        """
        Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
        """
        return pulumi.get(self, "pricing_tier")


@pulumi.output_type
class IntegrationRuntimeSsisCustomSetupScript(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobContainerUri":
            suggest = "blob_container_uri"
        elif key == "sasToken":
            suggest = "sas_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisCustomSetupScript. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisCustomSetupScript.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisCustomSetupScript.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_container_uri: str,
                 sas_token: str):
        """
        :param str blob_container_uri: The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        :param str sas_token: A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        pulumi.set(__self__, "sas_token", sas_token)

    @property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> str:
        """
        The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "blob_container_uri")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> str:
        """
        A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "sas_token")


@pulumi.output_type
class IntegrationRuntimeSsisVnetIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetName":
            suggest = "subnet_name"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisVnetIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisVnetIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisVnetIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_name: str,
                 vnet_id: str):
        """
        :param str subnet_name: Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        :param str vnet_id: ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        pulumi.set(__self__, "subnet_name", subnet_name)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> str:
        """
        Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class LinkedServiceAzureDatabricksInstancePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "maxNumberOfWorkers":
            suggest = "max_number_of_workers"
        elif key == "minNumberOfWorkers":
            suggest = "min_number_of_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureDatabricksInstancePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureDatabricksInstancePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureDatabricksInstancePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: str,
                 instance_pool_id: str,
                 max_number_of_workers: Optional[int] = None,
                 min_number_of_workers: Optional[int] = None):
        """
        :param str cluster_version: Spark version of a the cluster.
        :param str instance_pool_id: Identifier of the instance pool within the linked ADB instance.
        :param int max_number_of_workers: The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        :param int min_number_of_workers: The minimum number of worker nodes. Defaults to 1.
        """
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if max_number_of_workers is not None:
            pulumi.set(__self__, "max_number_of_workers", max_number_of_workers)
        if min_number_of_workers is not None:
            pulumi.set(__self__, "min_number_of_workers", min_number_of_workers)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> str:
        """
        Spark version of a the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        """
        Identifier of the instance pool within the linked ADB instance.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter(name="maxNumberOfWorkers")
    def max_number_of_workers(self) -> Optional[int]:
        """
        The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        """
        return pulumi.get(self, "max_number_of_workers")

    @property
    @pulumi.getter(name="minNumberOfWorkers")
    def min_number_of_workers(self) -> Optional[int]:
        """
        The minimum number of worker nodes. Defaults to 1.
        """
        return pulumi.get(self, "min_number_of_workers")


@pulumi.output_type
class LinkedServiceAzureDatabricksKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureDatabricksKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureDatabricksKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureDatabricksKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores ADB access token.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores ADB access token.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureDatabricksNewClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "driverNodeType":
            suggest = "driver_node_type"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "logDestination":
            suggest = "log_destination"
        elif key == "maxNumberOfWorkers":
            suggest = "max_number_of_workers"
        elif key == "minNumberOfWorkers":
            suggest = "min_number_of_workers"
        elif key == "sparkConfig":
            suggest = "spark_config"
        elif key == "sparkEnvironmentVariables":
            suggest = "spark_environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureDatabricksNewClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureDatabricksNewClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureDatabricksNewClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: str,
                 node_type: str,
                 custom_tags: Optional[Mapping[str, str]] = None,
                 driver_node_type: Optional[str] = None,
                 init_scripts: Optional[Sequence[str]] = None,
                 log_destination: Optional[str] = None,
                 max_number_of_workers: Optional[int] = None,
                 min_number_of_workers: Optional[int] = None,
                 spark_config: Optional[Mapping[str, str]] = None,
                 spark_environment_variables: Optional[Mapping[str, str]] = None):
        """
        :param str cluster_version: Spark version of a the cluster.
        :param str node_type: Node type for the new cluster.
        :param Mapping[str, str] custom_tags: Tags for the cluster resource.
        :param str driver_node_type: Driver node type for the cluster.
        :param Sequence[str] init_scripts: User defined initialization scripts for the cluster.
        :param str log_destination: Location to deliver Spark driver, worker, and event logs.
        :param int max_number_of_workers: The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        :param int min_number_of_workers: The minimum number of worker nodes. Defaults to 1.
        :param Mapping[str, str] spark_config: User-specified Spark configuration variables key-value pairs.
        :param Mapping[str, str] spark_environment_variables: User-specified Spark environment variables key-value pairs.
        """
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "node_type", node_type)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if driver_node_type is not None:
            pulumi.set(__self__, "driver_node_type", driver_node_type)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if log_destination is not None:
            pulumi.set(__self__, "log_destination", log_destination)
        if max_number_of_workers is not None:
            pulumi.set(__self__, "max_number_of_workers", max_number_of_workers)
        if min_number_of_workers is not None:
            pulumi.set(__self__, "min_number_of_workers", min_number_of_workers)
        if spark_config is not None:
            pulumi.set(__self__, "spark_config", spark_config)
        if spark_environment_variables is not None:
            pulumi.set(__self__, "spark_environment_variables", spark_environment_variables)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> str:
        """
        Spark version of a the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> str:
        """
        Node type for the new cluster.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags for the cluster resource.
        """
        return pulumi.get(self, "custom_tags")

    @property
    @pulumi.getter(name="driverNodeType")
    def driver_node_type(self) -> Optional[str]:
        """
        Driver node type for the cluster.
        """
        return pulumi.get(self, "driver_node_type")

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence[str]]:
        """
        User defined initialization scripts for the cluster.
        """
        return pulumi.get(self, "init_scripts")

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> Optional[str]:
        """
        Location to deliver Spark driver, worker, and event logs.
        """
        return pulumi.get(self, "log_destination")

    @property
    @pulumi.getter(name="maxNumberOfWorkers")
    def max_number_of_workers(self) -> Optional[int]:
        """
        The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        """
        return pulumi.get(self, "max_number_of_workers")

    @property
    @pulumi.getter(name="minNumberOfWorkers")
    def min_number_of_workers(self) -> Optional[int]:
        """
        The minimum number of worker nodes. Defaults to 1.
        """
        return pulumi.get(self, "min_number_of_workers")

    @property
    @pulumi.getter(name="sparkConfig")
    def spark_config(self) -> Optional[Mapping[str, str]]:
        """
        User-specified Spark configuration variables key-value pairs.
        """
        return pulumi.get(self, "spark_config")

    @property
    @pulumi.getter(name="sparkEnvironmentVariables")
    def spark_environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        User-specified Spark environment variables key-value pairs.
        """
        return pulumi.get(self, "spark_environment_variables")


@pulumi.output_type
class LinkedServiceAzureFileStorageKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureFileStorageKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureFileStorageKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureFileStorageKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureSqlDatabaseKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureSqlDatabaseKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceSnowflakeKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSnowflakeKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSnowflakeKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSnowflakeKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores Snowflake password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores Snowflake password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceSqlServerKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSqlServerKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSqlServerKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSqlServerKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceSynapseKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSynapseKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSynapseKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSynapseKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores Synapse password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores Synapse password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetFactoryGithubConfigurationResult(dict):
    def __init__(__self__, *,
                 account_name: str,
                 branch_name: str,
                 git_url: str,
                 repository_name: str,
                 root_folder: str):
        """
        :param str account_name: The VSTS account name.
        :param str branch_name: The branch of the repository to get code from.
        :param str git_url: The GitHub Enterprise host name.
        :param str repository_name: The name of the git repository.
        :param str root_folder: The root folder within the repository.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "git_url", git_url)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        The branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="gitUrl")
    def git_url(self) -> str:
        """
        The GitHub Enterprise host name.
        """
        return pulumi.get(self, "git_url")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        The name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        The root folder within the repository.
        """
        return pulumi.get(self, "root_folder")


@pulumi.output_type
class GetFactoryIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param str principal_id: The ID of the Principal (Client) in Azure Active Directory.
        :param str tenant_id: The Tenant ID associated with the VSTS account.
        :param str type: The identity type of the Data Factory.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The ID of the Principal (Client) in Azure Active Directory.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type of the Data Factory.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFactoryVstsConfigurationResult(dict):
    def __init__(__self__, *,
                 account_name: str,
                 branch_name: str,
                 project_name: str,
                 repository_name: str,
                 root_folder: str,
                 tenant_id: str):
        """
        :param str account_name: The VSTS account name.
        :param str branch_name: The branch of the repository to get code from.
        :param str project_name: The name of the VSTS project.
        :param str repository_name: The name of the git repository.
        :param str root_folder: The root folder within the repository.
        :param str tenant_id: The Tenant ID associated with the VSTS account.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        The branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        The name of the VSTS project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        The name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        The root folder within the repository.
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")


