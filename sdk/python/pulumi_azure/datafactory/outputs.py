# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CredentialServicePrincipalServicePrincipalKey',
    'CustomDatasetLinkedService',
    'DataFlowSink',
    'DataFlowSinkDataset',
    'DataFlowSinkFlowlet',
    'DataFlowSinkLinkedService',
    'DataFlowSinkRejectedLinkedService',
    'DataFlowSinkSchemaLinkedService',
    'DataFlowSource',
    'DataFlowSourceDataset',
    'DataFlowSourceFlowlet',
    'DataFlowSourceLinkedService',
    'DataFlowSourceRejectedLinkedService',
    'DataFlowSourceSchemaLinkedService',
    'DataFlowTransformation',
    'DataFlowTransformationDataset',
    'DataFlowTransformationFlowlet',
    'DataFlowTransformationLinkedService',
    'DatasetAzureBlobSchemaColumn',
    'DatasetAzureSqlTableSchemaColumn',
    'DatasetBinaryAzureBlobStorageLocation',
    'DatasetBinaryCompression',
    'DatasetBinaryHttpServerLocation',
    'DatasetBinarySftpServerLocation',
    'DatasetCosmosDBApiSchemaColumn',
    'DatasetDelimitedTextAzureBlobFsLocation',
    'DatasetDelimitedTextAzureBlobStorageLocation',
    'DatasetDelimitedTextHttpServerLocation',
    'DatasetDelimitedTextSchemaColumn',
    'DatasetHttpSchemaColumn',
    'DatasetJsonAzureBlobStorageLocation',
    'DatasetJsonHttpServerLocation',
    'DatasetJsonSchemaColumn',
    'DatasetMysqlSchemaColumn',
    'DatasetParquetAzureBlobFsLocation',
    'DatasetParquetAzureBlobStorageLocation',
    'DatasetParquetHttpServerLocation',
    'DatasetParquetSchemaColumn',
    'DatasetPostgresqlSchemaColumn',
    'DatasetSnowflakeSchemaColumn',
    'DatasetSqlServerTableSchemaColumn',
    'FactoryGithubConfiguration',
    'FactoryGlobalParameter',
    'FactoryIdentity',
    'FactoryVstsConfiguration',
    'FlowletDataFlowSink',
    'FlowletDataFlowSinkDataset',
    'FlowletDataFlowSinkFlowlet',
    'FlowletDataFlowSinkLinkedService',
    'FlowletDataFlowSinkRejectedLinkedService',
    'FlowletDataFlowSinkSchemaLinkedService',
    'FlowletDataFlowSource',
    'FlowletDataFlowSourceDataset',
    'FlowletDataFlowSourceFlowlet',
    'FlowletDataFlowSourceLinkedService',
    'FlowletDataFlowSourceRejectedLinkedService',
    'FlowletDataFlowSourceSchemaLinkedService',
    'FlowletDataFlowTransformation',
    'FlowletDataFlowTransformationDataset',
    'FlowletDataFlowTransformationFlowlet',
    'FlowletDataFlowTransformationLinkedService',
    'IntegrationRuntimeSelfHostedRbacAuthorization',
    'IntegrationRuntimeSsisCatalogInfo',
    'IntegrationRuntimeSsisCopyComputeScale',
    'IntegrationRuntimeSsisCustomSetupScript',
    'IntegrationRuntimeSsisExpressCustomSetup',
    'IntegrationRuntimeSsisExpressCustomSetupCommandKey',
    'IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword',
    'IntegrationRuntimeSsisExpressCustomSetupComponent',
    'IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense',
    'IntegrationRuntimeSsisExpressVnetIntegration',
    'IntegrationRuntimeSsisPackageStore',
    'IntegrationRuntimeSsisPipelineExternalComputeScale',
    'IntegrationRuntimeSsisProxy',
    'IntegrationRuntimeSsisVnetIntegration',
    'LinkedCustomServiceIntegrationRuntime',
    'LinkedServiceAzureBlobStorageKeyVaultSasToken',
    'LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKey',
    'LinkedServiceAzureDatabricksInstancePool',
    'LinkedServiceAzureDatabricksKeyVaultPassword',
    'LinkedServiceAzureDatabricksNewClusterConfig',
    'LinkedServiceAzureFileStorageKeyVaultPassword',
    'LinkedServiceAzureFunctionKeyVaultKey',
    'LinkedServiceAzureSqlDatabaseKeyVaultConnectionString',
    'LinkedServiceAzureSqlDatabaseKeyVaultPassword',
    'LinkedServiceOdataBasicAuthentication',
    'LinkedServiceOdbcBasicAuthentication',
    'LinkedServiceSnowflakeKeyVaultPassword',
    'LinkedServiceSqlServerKeyVaultConnectionString',
    'LinkedServiceSqlServerKeyVaultPassword',
    'LinkedServiceSynapseKeyVaultPassword',
    'TriggerBlobEventPipeline',
    'TriggerCustomEventPipeline',
    'TriggerSchedulePipeline',
    'TriggerScheduleSchedule',
    'TriggerScheduleScheduleMonthly',
    'TriggerTumblingWindowPipeline',
    'TriggerTumblingWindowRetry',
    'TriggerTumblingWindowTriggerDependency',
    'GetFactoryGithubConfigurationResult',
    'GetFactoryIdentityResult',
    'GetFactoryVstsConfigurationResult',
    'GetTriggerScheduleScheduleResult',
    'GetTriggerScheduleScheduleMonthlyResult',
]

@pulumi.output_type
class CredentialServicePrincipalServicePrincipalKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "secretVersion":
            suggest = "secret_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CredentialServicePrincipalServicePrincipalKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CredentialServicePrincipalServicePrincipalKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CredentialServicePrincipalServicePrincipalKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str,
                 secret_version: Optional[builtins.str] = None):
        """
        :param builtins.str linked_service_name: The name of the Linked Service to use for the Service Principal Key.
        :param builtins.str secret_name: The name of the Secret in the Key Vault.
        :param builtins.str secret_version: The version of the Secret in the Key Vault.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        The name of the Linked Service to use for the Service Principal Key.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        The name of the Secret in the Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[builtins.str]:
        """
        The version of the Secret in the Key Vault.
        """
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class CustomDatasetLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name of the Data Factory Linked Service.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedService":
            suggest = "linked_service"
        elif key == "rejectedLinkedService":
            suggest = "rejected_linked_service"
        elif key == "schemaLinkedService":
            suggest = "schema_linked_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFlowSink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFlowSink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFlowSink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset: Optional['outputs.DataFlowSinkDataset'] = None,
                 description: Optional[builtins.str] = None,
                 flowlet: Optional['outputs.DataFlowSinkFlowlet'] = None,
                 linked_service: Optional['outputs.DataFlowSinkLinkedService'] = None,
                 rejected_linked_service: Optional['outputs.DataFlowSinkRejectedLinkedService'] = None,
                 schema_linked_service: Optional['outputs.DataFlowSinkSchemaLinkedService'] = None):
        """
        :param builtins.str name: The name for the Data Flow Source.
        :param 'DataFlowSinkDatasetArgs' dataset: A `dataset` block as defined below.
        :param builtins.str description: The description for the Data Flow Source.
        :param 'DataFlowSinkFlowletArgs' flowlet: A `flowlet` block as defined below.
        :param 'DataFlowSinkLinkedServiceArgs' linked_service: A `linked_service` block as defined below.
        :param 'DataFlowSinkRejectedLinkedServiceArgs' rejected_linked_service: A `rejected_linked_service` block as defined below.
        :param 'DataFlowSinkSchemaLinkedServiceArgs' schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if rejected_linked_service is not None:
            pulumi.set(__self__, "rejected_linked_service", rejected_linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.DataFlowSinkDataset']:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def flowlet(self) -> Optional['outputs.DataFlowSinkFlowlet']:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.DataFlowSinkLinkedService']:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @property
    @pulumi.getter(name="rejectedLinkedService")
    def rejected_linked_service(self) -> Optional['outputs.DataFlowSinkRejectedLinkedService']:
        """
        A `rejected_linked_service` block as defined below.
        """
        return pulumi.get(self, "rejected_linked_service")

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional['outputs.DataFlowSinkSchemaLinkedService']:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")


@pulumi.output_type
class DataFlowSinkDataset(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSinkFlowlet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetParameters":
            suggest = "dataset_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFlowSinkFlowlet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFlowSinkFlowlet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFlowSinkFlowlet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset_parameters: Optional[builtins.str] = None,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Flowlet.
        :param builtins.str dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[builtins.str]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSinkLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSinkRejectedLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSinkSchemaLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedService":
            suggest = "linked_service"
        elif key == "rejectedLinkedService":
            suggest = "rejected_linked_service"
        elif key == "schemaLinkedService":
            suggest = "schema_linked_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFlowSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFlowSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFlowSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset: Optional['outputs.DataFlowSourceDataset'] = None,
                 description: Optional[builtins.str] = None,
                 flowlet: Optional['outputs.DataFlowSourceFlowlet'] = None,
                 linked_service: Optional['outputs.DataFlowSourceLinkedService'] = None,
                 rejected_linked_service: Optional['outputs.DataFlowSourceRejectedLinkedService'] = None,
                 schema_linked_service: Optional['outputs.DataFlowSourceSchemaLinkedService'] = None):
        """
        :param builtins.str name: The name for the Data Flow Source.
        :param 'DataFlowSourceDatasetArgs' dataset: A `dataset` block as defined below.
        :param builtins.str description: The description for the Data Flow Source.
        :param 'DataFlowSourceFlowletArgs' flowlet: A `flowlet` block as defined below.
        :param 'DataFlowSourceLinkedServiceArgs' linked_service: A `linked_service` block as defined below.
        :param 'DataFlowSourceRejectedLinkedServiceArgs' rejected_linked_service: A `rejected_linked_service` block as defined below.
        :param 'DataFlowSourceSchemaLinkedServiceArgs' schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if rejected_linked_service is not None:
            pulumi.set(__self__, "rejected_linked_service", rejected_linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.DataFlowSourceDataset']:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def flowlet(self) -> Optional['outputs.DataFlowSourceFlowlet']:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.DataFlowSourceLinkedService']:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @property
    @pulumi.getter(name="rejectedLinkedService")
    def rejected_linked_service(self) -> Optional['outputs.DataFlowSourceRejectedLinkedService']:
        """
        A `rejected_linked_service` block as defined below.
        """
        return pulumi.get(self, "rejected_linked_service")

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional['outputs.DataFlowSourceSchemaLinkedService']:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")


@pulumi.output_type
class DataFlowSourceDataset(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSourceFlowlet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetParameters":
            suggest = "dataset_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFlowSourceFlowlet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFlowSourceFlowlet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFlowSourceFlowlet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset_parameters: Optional[builtins.str] = None,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Flowlet.
        :param builtins.str dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[builtins.str]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSourceLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSourceRejectedLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSourceSchemaLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedService":
            suggest = "linked_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFlowTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFlowTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFlowTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset: Optional['outputs.DataFlowTransformationDataset'] = None,
                 description: Optional[builtins.str] = None,
                 flowlet: Optional['outputs.DataFlowTransformationFlowlet'] = None,
                 linked_service: Optional['outputs.DataFlowTransformationLinkedService'] = None):
        """
        :param builtins.str name: The name for the Data Flow transformation.
        :param 'DataFlowTransformationDatasetArgs' dataset: A `dataset` block as defined below.
        :param builtins.str description: The description for the Data Flow transformation.
        :param 'DataFlowTransformationFlowletArgs' flowlet: A `flowlet` block as defined below.
        :param 'DataFlowTransformationLinkedServiceArgs' linked_service: A `linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Flow transformation.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.DataFlowTransformationDataset']:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description for the Data Flow transformation.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def flowlet(self) -> Optional['outputs.DataFlowTransformationFlowlet']:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.DataFlowTransformationLinkedService']:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")


@pulumi.output_type
class DataFlowTransformationDataset(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowTransformationFlowlet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetParameters":
            suggest = "dataset_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFlowTransformationFlowlet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFlowTransformationFlowlet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFlowTransformationFlowlet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset_parameters: Optional[builtins.str] = None,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Flowlet.
        :param builtins.str dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[builtins.str]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowTransformationLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DatasetAzureBlobSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetAzureSqlTableSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetBinaryAzureBlobStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicContainerEnabled":
            suggest = "dynamic_container_enabled"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetBinaryAzureBlobStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetBinaryAzureBlobStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetBinaryAzureBlobStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: builtins.str,
                 dynamic_container_enabled: Optional[builtins.bool] = None,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None,
                 filename: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.str container: The container on the Azure Blob Storage Account hosting the file.
        :param builtins.bool dynamic_container_enabled: Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.str filename: The filename of the file in the blob container.
        :param builtins.str path: The folder path to the file in the blob container.
        """
        pulumi.set(__self__, "container", container)
        if dynamic_container_enabled is not None:
            pulumi.set(__self__, "dynamic_container_enabled", dynamic_container_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> builtins.str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="dynamicContainerEnabled")
    def dynamic_container_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_container_enabled")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @property
    @pulumi.getter
    def filename(self) -> Optional[builtins.str]:
        """
        The filename of the file in the blob container.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The folder path to the file in the blob container.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetBinaryCompression(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 level: Optional[builtins.str] = None):
        """
        :param builtins.str type: The type of compression used during transport. Possible values are `BZip2`, `Deflate`, `GZip`, `Tar`, `TarGZip` and `ZipDeflate`.
        :param builtins.str level: The level of compression. Possible values are `Fastest` and `Optimal`.
        """
        pulumi.set(__self__, "type", type)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of compression used during transport. Possible values are `BZip2`, `Deflate`, `GZip`, `Tar`, `TarGZip` and `ZipDeflate`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def level(self) -> Optional[builtins.str]:
        """
        The level of compression. Possible values are `Fastest` and `Optimal`.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class DatasetBinaryHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetBinaryHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetBinaryHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetBinaryHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: builtins.str,
                 path: builtins.str,
                 relative_url: builtins.str,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str filename: The filename of the file on the web server.
        :param builtins.str path: The folder path to the file on the web server.
        :param builtins.str relative_url: The base URL to the web server hosting the file.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> builtins.str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> builtins.str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetBinarySftpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetBinarySftpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetBinarySftpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetBinarySftpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: builtins.str,
                 path: builtins.str,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str filename: The filename of the file on the SFTP server.
        :param builtins.str path: The folder path to the file on the SFTP server.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> builtins.str:
        """
        The filename of the file on the SFTP server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The folder path to the file on the SFTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetCosmosDBApiSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetDelimitedTextAzureBlobFsLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicFileSystemEnabled":
            suggest = "dynamic_file_system_enabled"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDelimitedTextAzureBlobFsLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDelimitedTextAzureBlobFsLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDelimitedTextAzureBlobFsLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_file_system_enabled: Optional[builtins.bool] = None,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None,
                 file_system: Optional[builtins.str] = None,
                 filename: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.bool dynamic_file_system_enabled: Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.str file_system: The storage data lake gen2 file system on the Azure Blob Storage Account hosting the file.
        :param builtins.str filename: The filename of the file.
        :param builtins.str path: The folder path to the file.
        """
        if dynamic_file_system_enabled is not None:
            pulumi.set(__self__, "dynamic_file_system_enabled", dynamic_file_system_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="dynamicFileSystemEnabled")
    def dynamic_file_system_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_file_system_enabled")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[builtins.str]:
        """
        The storage data lake gen2 file system on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "file_system")

    @property
    @pulumi.getter
    def filename(self) -> Optional[builtins.str]:
        """
        The filename of the file.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The folder path to the file.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetDelimitedTextAzureBlobStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicContainerEnabled":
            suggest = "dynamic_container_enabled"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDelimitedTextAzureBlobStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDelimitedTextAzureBlobStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDelimitedTextAzureBlobStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: builtins.str,
                 dynamic_container_enabled: Optional[builtins.bool] = None,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None,
                 filename: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.str container: The container on the Azure Blob Storage Account hosting the file.
        :param builtins.bool dynamic_container_enabled: Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.str filename: The filename of the file.
        :param builtins.str path: The folder path to the file. This can be an empty string.
        """
        pulumi.set(__self__, "container", container)
        if dynamic_container_enabled is not None:
            pulumi.set(__self__, "dynamic_container_enabled", dynamic_container_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> builtins.str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="dynamicContainerEnabled")
    def dynamic_container_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_container_enabled")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @property
    @pulumi.getter
    def filename(self) -> Optional[builtins.str]:
        """
        The filename of the file.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The folder path to the file. This can be an empty string.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetDelimitedTextHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDelimitedTextHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDelimitedTextHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDelimitedTextHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: builtins.str,
                 path: builtins.str,
                 relative_url: builtins.str,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str filename: The filename of the file on the web server.
        :param builtins.str path: The folder path to the file on the web server.
        :param builtins.str relative_url: The base URL to the web server hosting the file.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> builtins.str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> builtins.str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetDelimitedTextSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetHttpSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetJsonAzureBlobStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicContainerEnabled":
            suggest = "dynamic_container_enabled"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetJsonAzureBlobStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetJsonAzureBlobStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetJsonAzureBlobStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: builtins.str,
                 filename: builtins.str,
                 path: builtins.str,
                 dynamic_container_enabled: Optional[builtins.bool] = None,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str container: The container on the Azure Blob Storage Account hosting the file.
        :param builtins.str filename: The filename of the file on the web server.
        :param builtins.str path: The folder path to the file on the web server.
        :param builtins.bool dynamic_container_enabled: Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        if dynamic_container_enabled is not None:
            pulumi.set(__self__, "dynamic_container_enabled", dynamic_container_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def container(self) -> builtins.str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter
    def filename(self) -> builtins.str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="dynamicContainerEnabled")
    def dynamic_container_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_container_enabled")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetJsonHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetJsonHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetJsonHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetJsonHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: builtins.str,
                 path: builtins.str,
                 relative_url: builtins.str,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str filename: The filename of the file on the web server.
        :param builtins.str path: The folder path to the file on the web server.
        :param builtins.str relative_url: The base URL to the web server hosting the file.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> builtins.str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> builtins.str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetJsonSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetMysqlSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetParquetAzureBlobFsLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicFileSystemEnabled":
            suggest = "dynamic_file_system_enabled"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetParquetAzureBlobFsLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetParquetAzureBlobFsLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetParquetAzureBlobFsLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_file_system_enabled: Optional[builtins.bool] = None,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None,
                 file_system: Optional[builtins.str] = None,
                 filename: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.bool dynamic_file_system_enabled: Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.str file_system: The container on the Azure Data Lake Storage Account hosting the file.
        :param builtins.str filename: The filename of the file on the Azure Data Lake Storage Account.
        :param builtins.str path: The folder path to the file on the Azure Data Lake Storage Account.
        """
        if dynamic_file_system_enabled is not None:
            pulumi.set(__self__, "dynamic_file_system_enabled", dynamic_file_system_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="dynamicFileSystemEnabled")
    def dynamic_file_system_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_file_system_enabled")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[builtins.str]:
        """
        The container on the Azure Data Lake Storage Account hosting the file.
        """
        return pulumi.get(self, "file_system")

    @property
    @pulumi.getter
    def filename(self) -> Optional[builtins.str]:
        """
        The filename of the file on the Azure Data Lake Storage Account.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The folder path to the file on the Azure Data Lake Storage Account.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetParquetAzureBlobStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicContainerEnabled":
            suggest = "dynamic_container_enabled"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetParquetAzureBlobStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetParquetAzureBlobStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetParquetAzureBlobStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: builtins.str,
                 dynamic_container_enabled: Optional[builtins.bool] = None,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None,
                 filename: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.str container: The container on the Azure Blob Storage Account hosting the file.
        :param builtins.bool dynamic_container_enabled: Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.str filename: The filename of the file on the Azure Blob Storage Account.
        :param builtins.str path: The folder path to the file on the Azure Blob Storage Account.
        """
        pulumi.set(__self__, "container", container)
        if dynamic_container_enabled is not None:
            pulumi.set(__self__, "dynamic_container_enabled", dynamic_container_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> builtins.str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="dynamicContainerEnabled")
    def dynamic_container_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_container_enabled")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @property
    @pulumi.getter
    def filename(self) -> Optional[builtins.str]:
        """
        The filename of the file on the Azure Blob Storage Account.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The folder path to the file on the Azure Blob Storage Account.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetParquetHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetParquetHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetParquetHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetParquetHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: builtins.str,
                 relative_url: builtins.str,
                 dynamic_filename_enabled: Optional[builtins.bool] = None,
                 dynamic_path_enabled: Optional[builtins.bool] = None,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.str filename: The filename of the file on the web server.
        :param builtins.str relative_url: The base URL to the web server hosting the file.
        :param builtins.bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param builtins.str path: The folder path to the file on the web server.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def filename(self) -> builtins.str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> builtins.str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[builtins.bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetParquetSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetPostgresqlSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetSnowflakeSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 precision: Optional[builtins.int] = None,
                 scale: Optional[builtins.int] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.int precision: The total number of digits allowed.
        :param builtins.int scale: The number of digits allowed to the right of the decimal point.
        :param builtins.str type: Type of the column. Valid values are `NUMBER`, `DECIMAL`, `NUMERIC`, `INT`, `INTEGER`, `BIGINT`, `SMALLINT`, `FLOAT``FLOAT4`, `FLOAT8`, `DOUBLE`, `DOUBLE PRECISION`, `REAL`, `VARCHAR`, `CHAR`, `CHARACTER`, `STRING`, `TEXT`, `BINARY`, `VARBINARY`, `BOOLEAN`, `DATE`, `DATETIME`, `TIME`, `TIMESTAMP`, `TIMESTAMP_LTZ`, `TIMESTAMP_NTZ`, `TIMESTAMP_TZ`, `VARIANT`, `OBJECT`, `ARRAY`, `GEOGRAPHY`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def precision(self) -> Optional[builtins.int]:
        """
        The total number of digits allowed.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def scale(self) -> Optional[builtins.int]:
        """
        The number of digits allowed to the right of the decimal point.
        """
        return pulumi.get(self, "scale")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `NUMBER`, `DECIMAL`, `NUMERIC`, `INT`, `INTEGER`, `BIGINT`, `SMALLINT`, `FLOAT``FLOAT4`, `FLOAT8`, `DOUBLE`, `DOUBLE PRECISION`, `REAL`, `VARCHAR`, `CHAR`, `CHARACTER`, `STRING`, `TEXT`, `BINARY`, `VARBINARY`, `BOOLEAN`, `DATE`, `DATETIME`, `TIME`, `TIMESTAMP`, `TIMESTAMP_LTZ`, `TIMESTAMP_NTZ`, `TIMESTAMP_TZ`, `VARIANT`, `OBJECT`, `ARRAY`, `GEOGRAPHY`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetSqlServerTableSchemaColumn(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the column.
        :param builtins.str description: The description of the column.
        :param builtins.str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FactoryGithubConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "rootFolder":
            suggest = "root_folder"
        elif key == "gitUrl":
            suggest = "git_url"
        elif key == "publishingEnabled":
            suggest = "publishing_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FactoryGithubConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FactoryGithubConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FactoryGithubConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: builtins.str,
                 branch_name: builtins.str,
                 repository_name: builtins.str,
                 root_folder: builtins.str,
                 git_url: Optional[builtins.str] = None,
                 publishing_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str account_name: Specifies the GitHub account name.
        :param builtins.str branch_name: Specifies the branch of the repository to get code from.
        :param builtins.str repository_name: Specifies the name of the git repository.
        :param builtins.str root_folder: Specifies the root folder within the repository. Set to `/` for the top level.
        :param builtins.str git_url: Specifies the GitHub Enterprise host name. For example: <https://github.mydomain.com>. Use <https://github.com> for open source repositories.
        :param builtins.bool publishing_enabled: Is automated publishing enabled? Defaults to `true`.
               
               > **Note:** You must log in to the Data Factory management UI to complete the authentication to the GitHub repository.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        if git_url is not None:
            pulumi.set(__self__, "git_url", git_url)
        if publishing_enabled is not None:
            pulumi.set(__self__, "publishing_enabled", publishing_enabled)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> builtins.str:
        """
        Specifies the GitHub account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> builtins.str:
        """
        Specifies the branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> builtins.str:
        """
        Specifies the name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> builtins.str:
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter(name="gitUrl")
    def git_url(self) -> Optional[builtins.str]:
        """
        Specifies the GitHub Enterprise host name. For example: <https://github.mydomain.com>. Use <https://github.com> for open source repositories.
        """
        return pulumi.get(self, "git_url")

    @property
    @pulumi.getter(name="publishingEnabled")
    def publishing_enabled(self) -> Optional[builtins.bool]:
        """
        Is automated publishing enabled? Defaults to `true`.

        > **Note:** You must log in to the Data Factory management UI to complete the authentication to the GitHub repository.
        """
        return pulumi.get(self, "publishing_enabled")


@pulumi.output_type
class FactoryGlobalParameter(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str name: Specifies the global parameter name.
        :param builtins.str type: Specifies the global parameter type. Possible Values are `Array`, `Bool`, `Float`, `Int`, `Object` or `String`.
        :param builtins.str value: Specifies the global parameter value.
               
               > **Note:** For type `Array` and `Object` it is recommended to use `jsonencode()` for the value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Specifies the global parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Specifies the global parameter type. Possible Values are `Array`, `Bool`, `Float`, `Int`, `Object` or `String`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Specifies the global parameter value.

        > **Note:** For type `Array` and `Object` it is recommended to use `jsonencode()` for the value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FactoryIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FactoryIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FactoryIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FactoryIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 identity_ids: Optional[Sequence[builtins.str]] = None,
                 principal_id: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None):
        """
        :param builtins.str type: Specifies the type of Managed Service Identity that should be configured on this Data Factory. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[builtins.str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Data Factory.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param builtins.str principal_id: The Principal ID associated with this Managed Service Identity.
        :param builtins.str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Data Factory. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Data Factory.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[builtins.str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FactoryVstsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "projectName":
            suggest = "project_name"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "rootFolder":
            suggest = "root_folder"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "publishingEnabled":
            suggest = "publishing_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FactoryVstsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FactoryVstsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FactoryVstsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: builtins.str,
                 branch_name: builtins.str,
                 project_name: builtins.str,
                 repository_name: builtins.str,
                 root_folder: builtins.str,
                 tenant_id: builtins.str,
                 publishing_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.str account_name: Specifies the VSTS account name.
        :param builtins.str branch_name: Specifies the branch of the repository to get code from.
        :param builtins.str project_name: Specifies the name of the VSTS project.
        :param builtins.str repository_name: Specifies the name of the git repository.
        :param builtins.str root_folder: Specifies the root folder within the repository. Set to `/` for the top level.
        :param builtins.str tenant_id: Specifies the Tenant ID associated with the VSTS account.
        :param builtins.bool publishing_enabled: Is automated publishing enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if publishing_enabled is not None:
            pulumi.set(__self__, "publishing_enabled", publishing_enabled)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> builtins.str:
        """
        Specifies the VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> builtins.str:
        """
        Specifies the branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> builtins.str:
        """
        Specifies the name of the VSTS project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> builtins.str:
        """
        Specifies the name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> builtins.str:
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        Specifies the Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="publishingEnabled")
    def publishing_enabled(self) -> Optional[builtins.bool]:
        """
        Is automated publishing enabled? Defaults to `true`.
        """
        return pulumi.get(self, "publishing_enabled")


@pulumi.output_type
class FlowletDataFlowSink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedService":
            suggest = "linked_service"
        elif key == "rejectedLinkedService":
            suggest = "rejected_linked_service"
        elif key == "schemaLinkedService":
            suggest = "schema_linked_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowletDataFlowSink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowletDataFlowSink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowletDataFlowSink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset: Optional['outputs.FlowletDataFlowSinkDataset'] = None,
                 description: Optional[builtins.str] = None,
                 flowlet: Optional['outputs.FlowletDataFlowSinkFlowlet'] = None,
                 linked_service: Optional['outputs.FlowletDataFlowSinkLinkedService'] = None,
                 rejected_linked_service: Optional['outputs.FlowletDataFlowSinkRejectedLinkedService'] = None,
                 schema_linked_service: Optional['outputs.FlowletDataFlowSinkSchemaLinkedService'] = None):
        """
        :param builtins.str name: The name for the Data Flow Source.
        :param 'FlowletDataFlowSinkDatasetArgs' dataset: A `dataset` block as defined below.
        :param builtins.str description: The description for the Data Flow Source.
        :param 'FlowletDataFlowSinkFlowletArgs' flowlet: A `flowlet` block as defined below.
        :param 'FlowletDataFlowSinkLinkedServiceArgs' linked_service: A `linked_service` block as defined below.
        :param 'FlowletDataFlowSinkRejectedLinkedServiceArgs' rejected_linked_service: A `rejected_linked_service` block as defined below.
        :param 'FlowletDataFlowSinkSchemaLinkedServiceArgs' schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if rejected_linked_service is not None:
            pulumi.set(__self__, "rejected_linked_service", rejected_linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.FlowletDataFlowSinkDataset']:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def flowlet(self) -> Optional['outputs.FlowletDataFlowSinkFlowlet']:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.FlowletDataFlowSinkLinkedService']:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @property
    @pulumi.getter(name="rejectedLinkedService")
    def rejected_linked_service(self) -> Optional['outputs.FlowletDataFlowSinkRejectedLinkedService']:
        """
        A `rejected_linked_service` block as defined below.
        """
        return pulumi.get(self, "rejected_linked_service")

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional['outputs.FlowletDataFlowSinkSchemaLinkedService']:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")


@pulumi.output_type
class FlowletDataFlowSinkDataset(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowSinkFlowlet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetParameters":
            suggest = "dataset_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowletDataFlowSinkFlowlet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowletDataFlowSinkFlowlet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowletDataFlowSinkFlowlet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset_parameters: Optional[builtins.str] = None,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Flowlet.
        :param builtins.str dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[builtins.str]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowSinkLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowSinkRejectedLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowSinkSchemaLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedService":
            suggest = "linked_service"
        elif key == "rejectedLinkedService":
            suggest = "rejected_linked_service"
        elif key == "schemaLinkedService":
            suggest = "schema_linked_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowletDataFlowSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowletDataFlowSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowletDataFlowSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset: Optional['outputs.FlowletDataFlowSourceDataset'] = None,
                 description: Optional[builtins.str] = None,
                 flowlet: Optional['outputs.FlowletDataFlowSourceFlowlet'] = None,
                 linked_service: Optional['outputs.FlowletDataFlowSourceLinkedService'] = None,
                 rejected_linked_service: Optional['outputs.FlowletDataFlowSourceRejectedLinkedService'] = None,
                 schema_linked_service: Optional['outputs.FlowletDataFlowSourceSchemaLinkedService'] = None):
        """
        :param builtins.str name: The name for the Data Flow Source.
        :param 'FlowletDataFlowSourceDatasetArgs' dataset: A `dataset` block as defined below.
        :param builtins.str description: The description for the Data Flow Source.
        :param 'FlowletDataFlowSourceFlowletArgs' flowlet: A `flowlet` block as defined below.
        :param 'FlowletDataFlowSourceLinkedServiceArgs' linked_service: A `linked_service` block as defined below.
        :param 'FlowletDataFlowSourceRejectedLinkedServiceArgs' rejected_linked_service: A `rejected_linked_service` block as defined below.
        :param 'FlowletDataFlowSourceSchemaLinkedServiceArgs' schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if rejected_linked_service is not None:
            pulumi.set(__self__, "rejected_linked_service", rejected_linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.FlowletDataFlowSourceDataset']:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def flowlet(self) -> Optional['outputs.FlowletDataFlowSourceFlowlet']:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.FlowletDataFlowSourceLinkedService']:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @property
    @pulumi.getter(name="rejectedLinkedService")
    def rejected_linked_service(self) -> Optional['outputs.FlowletDataFlowSourceRejectedLinkedService']:
        """
        A `rejected_linked_service` block as defined below.
        """
        return pulumi.get(self, "rejected_linked_service")

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional['outputs.FlowletDataFlowSourceSchemaLinkedService']:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")


@pulumi.output_type
class FlowletDataFlowSourceDataset(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowSourceFlowlet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetParameters":
            suggest = "dataset_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowletDataFlowSourceFlowlet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowletDataFlowSourceFlowlet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowletDataFlowSourceFlowlet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset_parameters: Optional[builtins.str] = None,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Flowlet.
        :param builtins.str dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[builtins.str]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowSourceLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowSourceRejectedLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowSourceSchemaLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedService":
            suggest = "linked_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowletDataFlowTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowletDataFlowTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowletDataFlowTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset: Optional['outputs.FlowletDataFlowTransformationDataset'] = None,
                 description: Optional[builtins.str] = None,
                 flowlet: Optional['outputs.FlowletDataFlowTransformationFlowlet'] = None,
                 linked_service: Optional['outputs.FlowletDataFlowTransformationLinkedService'] = None):
        """
        :param builtins.str name: The name for the Data Flow transformation.
        :param 'FlowletDataFlowTransformationDatasetArgs' dataset: A `dataset` block as defined below.
        :param builtins.str description: The description for the Data Flow transformation.
        :param 'FlowletDataFlowTransformationFlowletArgs' flowlet: A `flowlet` block as defined below.
        :param 'FlowletDataFlowTransformationLinkedServiceArgs' linked_service: A `linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Flow transformation.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.FlowletDataFlowTransformationDataset']:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description for the Data Flow transformation.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def flowlet(self) -> Optional['outputs.FlowletDataFlowTransformationFlowlet']:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.FlowletDataFlowTransformationLinkedService']:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")


@pulumi.output_type
class FlowletDataFlowTransformationDataset(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowTransformationFlowlet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetParameters":
            suggest = "dataset_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowletDataFlowTransformationFlowlet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowletDataFlowTransformationFlowlet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowletDataFlowTransformationFlowlet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 dataset_parameters: Optional[builtins.str] = None,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Flowlet.
        :param builtins.str dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[builtins.str]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class FlowletDataFlowTransformationLinkedService(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The name for the Data Factory Linked Service.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class IntegrationRuntimeSelfHostedRbacAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSelfHostedRbacAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSelfHostedRbacAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSelfHostedRbacAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: builtins.str):
        """
        :param builtins.str resource_id: The resource identifier of the integration runtime to be shared.
               
               > **Please Note**: RBAC Authorization creates a [linked Self-hosted Integration Runtime targeting the Shared Self-hosted Integration Runtime in resource_id](https://docs.microsoft.com/azure/data-factory/create-shared-self-hosted-integration-runtime-powershell#share-the-self-hosted-integration-runtime-with-another-data-factory). The linked Self-hosted Integration Runtime needs Contributor access granted to the Shared Self-hosted Data Factory.
               
               For more information on the configuration, please check out the [Azure documentation](https://docs.microsoft.com/rest/api/datafactory/integrationruntimes/createorupdate#linkedintegrationruntimerbacauthorization)
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> builtins.str:
        """
        The resource identifier of the integration runtime to be shared.

        > **Please Note**: RBAC Authorization creates a [linked Self-hosted Integration Runtime targeting the Shared Self-hosted Integration Runtime in resource_id](https://docs.microsoft.com/azure/data-factory/create-shared-self-hosted-integration-runtime-powershell#share-the-self-hosted-integration-runtime-with-another-data-factory). The linked Self-hosted Integration Runtime needs Contributor access granted to the Shared Self-hosted Data Factory.

        For more information on the configuration, please check out the [Azure documentation](https://docs.microsoft.com/rest/api/datafactory/integrationruntimes/createorupdate#linkedintegrationruntimerbacauthorization)
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class IntegrationRuntimeSsisCatalogInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverEndpoint":
            suggest = "server_endpoint"
        elif key == "administratorLogin":
            suggest = "administrator_login"
        elif key == "administratorPassword":
            suggest = "administrator_password"
        elif key == "dualStandbyPairName":
            suggest = "dual_standby_pair_name"
        elif key == "elasticPoolName":
            suggest = "elastic_pool_name"
        elif key == "pricingTier":
            suggest = "pricing_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisCatalogInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisCatalogInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisCatalogInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_endpoint: builtins.str,
                 administrator_login: Optional[builtins.str] = None,
                 administrator_password: Optional[builtins.str] = None,
                 dual_standby_pair_name: Optional[builtins.str] = None,
                 elastic_pool_name: Optional[builtins.str] = None,
                 pricing_tier: Optional[builtins.str] = None):
        """
        :param builtins.str server_endpoint: The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        :param builtins.str administrator_login: Administrator login name for the SQL Server.
        :param builtins.str administrator_password: Administrator login password for the SQL Server.
        :param builtins.str dual_standby_pair_name: The dual standby Azure-SSIS Integration Runtime pair with SSISDB failover.
        :param builtins.str elastic_pool_name: The name of SQL elastic pool where the database will be created for the SSIS catalog. Mutually exclusive with `pricing_tier`.
        :param builtins.str pricing_tier: Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `S0`, `S1`, `S2`, `S3`, `S4`, `S6`, `S7`, `S9`, `S12`, `P1`, `P2`, `P4`, `P6`, `P11`, `P15`, `GP_S_Gen5_1`, `GP_S_Gen5_2`, `GP_S_Gen5_4`, `GP_S_Gen5_6`, `GP_S_Gen5_8`, `GP_S_Gen5_10`, `GP_S_Gen5_12`, `GP_S_Gen5_14`, `GP_S_Gen5_16`, `GP_S_Gen5_18`, `GP_S_Gen5_20`, `GP_S_Gen5_24`, `GP_S_Gen5_32`, `GP_S_Gen5_40`, `GP_Gen5_2`, `GP_Gen5_4`, `GP_Gen5_6`, `GP_Gen5_8`, `GP_Gen5_10`, `GP_Gen5_12`, `GP_Gen5_14`, `GP_Gen5_16`, `GP_Gen5_18`, `GP_Gen5_20`, `GP_Gen5_24`, `GP_Gen5_32`, `GP_Gen5_40`, `GP_Gen5_80`, `BC_Gen5_2`, `BC_Gen5_4`, `BC_Gen5_6`, `BC_Gen5_8`, `BC_Gen5_10`, `BC_Gen5_12`, `BC_Gen5_14`, `BC_Gen5_16`, `BC_Gen5_18`, `BC_Gen5_20`, `BC_Gen5_24`, `BC_Gen5_32`, `BC_Gen5_40`, `BC_Gen5_80`, `HS_Gen5_2`, `HS_Gen5_4`, `HS_Gen5_6`, `HS_Gen5_8`, `HS_Gen5_10`, `HS_Gen5_12`, `HS_Gen5_14`, `HS_Gen5_16`, `HS_Gen5_18`, `HS_Gen5_20`, `HS_Gen5_24`, `HS_Gen5_32`, `HS_Gen5_40` and `HS_Gen5_80`. Mutually exclusive with `elastic_pool_name`.
        """
        pulumi.set(__self__, "server_endpoint", server_endpoint)
        if administrator_login is not None:
            pulumi.set(__self__, "administrator_login", administrator_login)
        if administrator_password is not None:
            pulumi.set(__self__, "administrator_password", administrator_password)
        if dual_standby_pair_name is not None:
            pulumi.set(__self__, "dual_standby_pair_name", dual_standby_pair_name)
        if elastic_pool_name is not None:
            pulumi.set(__self__, "elastic_pool_name", elastic_pool_name)
        if pricing_tier is not None:
            pulumi.set(__self__, "pricing_tier", pricing_tier)

    @property
    @pulumi.getter(name="serverEndpoint")
    def server_endpoint(self) -> builtins.str:
        """
        The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        """
        return pulumi.get(self, "server_endpoint")

    @property
    @pulumi.getter(name="administratorLogin")
    def administrator_login(self) -> Optional[builtins.str]:
        """
        Administrator login name for the SQL Server.
        """
        return pulumi.get(self, "administrator_login")

    @property
    @pulumi.getter(name="administratorPassword")
    def administrator_password(self) -> Optional[builtins.str]:
        """
        Administrator login password for the SQL Server.
        """
        return pulumi.get(self, "administrator_password")

    @property
    @pulumi.getter(name="dualStandbyPairName")
    def dual_standby_pair_name(self) -> Optional[builtins.str]:
        """
        The dual standby Azure-SSIS Integration Runtime pair with SSISDB failover.
        """
        return pulumi.get(self, "dual_standby_pair_name")

    @property
    @pulumi.getter(name="elasticPoolName")
    def elastic_pool_name(self) -> Optional[builtins.str]:
        """
        The name of SQL elastic pool where the database will be created for the SSIS catalog. Mutually exclusive with `pricing_tier`.
        """
        return pulumi.get(self, "elastic_pool_name")

    @property
    @pulumi.getter(name="pricingTier")
    def pricing_tier(self) -> Optional[builtins.str]:
        """
        Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `S0`, `S1`, `S2`, `S3`, `S4`, `S6`, `S7`, `S9`, `S12`, `P1`, `P2`, `P4`, `P6`, `P11`, `P15`, `GP_S_Gen5_1`, `GP_S_Gen5_2`, `GP_S_Gen5_4`, `GP_S_Gen5_6`, `GP_S_Gen5_8`, `GP_S_Gen5_10`, `GP_S_Gen5_12`, `GP_S_Gen5_14`, `GP_S_Gen5_16`, `GP_S_Gen5_18`, `GP_S_Gen5_20`, `GP_S_Gen5_24`, `GP_S_Gen5_32`, `GP_S_Gen5_40`, `GP_Gen5_2`, `GP_Gen5_4`, `GP_Gen5_6`, `GP_Gen5_8`, `GP_Gen5_10`, `GP_Gen5_12`, `GP_Gen5_14`, `GP_Gen5_16`, `GP_Gen5_18`, `GP_Gen5_20`, `GP_Gen5_24`, `GP_Gen5_32`, `GP_Gen5_40`, `GP_Gen5_80`, `BC_Gen5_2`, `BC_Gen5_4`, `BC_Gen5_6`, `BC_Gen5_8`, `BC_Gen5_10`, `BC_Gen5_12`, `BC_Gen5_14`, `BC_Gen5_16`, `BC_Gen5_18`, `BC_Gen5_20`, `BC_Gen5_24`, `BC_Gen5_32`, `BC_Gen5_40`, `BC_Gen5_80`, `HS_Gen5_2`, `HS_Gen5_4`, `HS_Gen5_6`, `HS_Gen5_8`, `HS_Gen5_10`, `HS_Gen5_12`, `HS_Gen5_14`, `HS_Gen5_16`, `HS_Gen5_18`, `HS_Gen5_20`, `HS_Gen5_24`, `HS_Gen5_32`, `HS_Gen5_40` and `HS_Gen5_80`. Mutually exclusive with `elastic_pool_name`.
        """
        return pulumi.get(self, "pricing_tier")


@pulumi.output_type
class IntegrationRuntimeSsisCopyComputeScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataIntegrationUnit":
            suggest = "data_integration_unit"
        elif key == "timeToLive":
            suggest = "time_to_live"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisCopyComputeScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisCopyComputeScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisCopyComputeScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_integration_unit: Optional[builtins.int] = None,
                 time_to_live: Optional[builtins.int] = None):
        """
        :param builtins.int data_integration_unit: Specifies the data integration unit number setting reserved for copy activity execution. Supported values are multiples of `4` in range 4-256.
        :param builtins.int time_to_live: Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
        if data_integration_unit is not None:
            pulumi.set(__self__, "data_integration_unit", data_integration_unit)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @property
    @pulumi.getter(name="dataIntegrationUnit")
    def data_integration_unit(self) -> Optional[builtins.int]:
        """
        Specifies the data integration unit number setting reserved for copy activity execution. Supported values are multiples of `4` in range 4-256.
        """
        return pulumi.get(self, "data_integration_unit")

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[builtins.int]:
        """
        Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
        return pulumi.get(self, "time_to_live")


@pulumi.output_type
class IntegrationRuntimeSsisCustomSetupScript(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobContainerUri":
            suggest = "blob_container_uri"
        elif key == "sasToken":
            suggest = "sas_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisCustomSetupScript. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisCustomSetupScript.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisCustomSetupScript.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_container_uri: builtins.str,
                 sas_token: builtins.str):
        """
        :param builtins.str blob_container_uri: The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        :param builtins.str sas_token: A container SAS token that gives access to the files. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        pulumi.set(__self__, "sas_token", sas_token)

    @property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> builtins.str:
        """
        The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "blob_container_uri")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> builtins.str:
        """
        A container SAS token that gives access to the files. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "sas_token")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandKeys":
            suggest = "command_keys"
        elif key == "powershellVersion":
            suggest = "powershell_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_keys: Optional[Sequence['outputs.IntegrationRuntimeSsisExpressCustomSetupCommandKey']] = None,
                 components: Optional[Sequence['outputs.IntegrationRuntimeSsisExpressCustomSetupComponent']] = None,
                 environment: Optional[Mapping[str, builtins.str]] = None,
                 powershell_version: Optional[builtins.str] = None):
        """
        :param Sequence['IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgs'] command_keys: One or more `command_key` blocks as defined below.
        :param Sequence['IntegrationRuntimeSsisExpressCustomSetupComponentArgs'] components: One or more `component` blocks as defined below.
        :param Mapping[str, builtins.str] environment: The Environment Variables for the Azure-SSIS Integration Runtime.
        :param builtins.str powershell_version: The version of Azure Powershell installed for the Azure-SSIS Integration Runtime.
               
               > **NOTE** At least one of `env`, `powershell_version`, `component` and `command_key` should be specified.
        """
        if command_keys is not None:
            pulumi.set(__self__, "command_keys", command_keys)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if powershell_version is not None:
            pulumi.set(__self__, "powershell_version", powershell_version)

    @property
    @pulumi.getter(name="commandKeys")
    def command_keys(self) -> Optional[Sequence['outputs.IntegrationRuntimeSsisExpressCustomSetupCommandKey']]:
        """
        One or more `command_key` blocks as defined below.
        """
        return pulumi.get(self, "command_keys")

    @property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.IntegrationRuntimeSsisExpressCustomSetupComponent']]:
        """
        One or more `component` blocks as defined below.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter
    def environment(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The Environment Variables for the Azure-SSIS Integration Runtime.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="powershellVersion")
    def powershell_version(self) -> Optional[builtins.str]:
        """
        The version of Azure Powershell installed for the Azure-SSIS Integration Runtime.

        > **NOTE** At least one of `env`, `powershell_version`, `component` and `command_key` should be specified.
        """
        return pulumi.get(self, "powershell_version")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetupCommandKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetName":
            suggest = "target_name"
        elif key == "userName":
            suggest = "user_name"
        elif key == "keyVaultPassword":
            suggest = "key_vault_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetupCommandKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupCommandKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupCommandKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_name: builtins.str,
                 user_name: builtins.str,
                 key_vault_password: Optional['outputs.IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword'] = None,
                 password: Optional[builtins.str] = None):
        """
        :param builtins.str target_name: The target computer or domain name.
        :param builtins.str user_name: The username for the target device.
        :param 'IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgs' key_vault_password: A `key_vault_secret_reference` block as defined below.
        :param builtins.str password: The password for the target device.
        """
        pulumi.set(__self__, "target_name", target_name)
        pulumi.set(__self__, "user_name", user_name)
        if key_vault_password is not None:
            pulumi.set(__self__, "key_vault_password", key_vault_password)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> builtins.str:
        """
        The target computer or domain name.
        """
        return pulumi.get(self, "target_name")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> builtins.str:
        """
        The username for the target device.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="keyVaultPassword")
    def key_vault_password(self) -> Optional['outputs.IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword']:
        """
        A `key_vault_secret_reference` block as defined below.
        """
        return pulumi.get(self, "key_vault_password")

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        The password for the target device.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "secretVersion":
            suggest = "secret_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None,
                 secret_version: Optional[builtins.str] = None):
        """
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Key Vault Data Factory Linked Service.
        :param builtins.str secret_version: Specifies the secret version in Azure Key Vault.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[builtins.str]:
        """
        Specifies the secret version in Azure Key Vault.
        """
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetupComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultLicense":
            suggest = "key_vault_license"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetupComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 key_vault_license: Optional['outputs.IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense'] = None,
                 license: Optional[builtins.str] = None):
        """
        :param builtins.str name: The Component Name installed for the Azure-SSIS Integration Runtime.
        :param 'IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgs' key_vault_license: A `key_vault_secret_reference` block as defined below.
        :param builtins.str license: The license used for the Component.
        """
        pulumi.set(__self__, "name", name)
        if key_vault_license is not None:
            pulumi.set(__self__, "key_vault_license", key_vault_license)
        if license is not None:
            pulumi.set(__self__, "license", license)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The Component Name installed for the Azure-SSIS Integration Runtime.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="keyVaultLicense")
    def key_vault_license(self) -> Optional['outputs.IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense']:
        """
        A `key_vault_secret_reference` block as defined below.
        """
        return pulumi.get(self, "key_vault_license")

    @property
    @pulumi.getter
    def license(self) -> Optional[builtins.str]:
        """
        The license used for the Component.
        """
        return pulumi.get(self, "license")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "secretVersion":
            suggest = "secret_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None,
                 secret_version: Optional[builtins.str] = None):
        """
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the Key Vault Data Factory Linked Service.
        :param builtins.str secret_version: Specifies the secret version in Azure Key Vault.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[builtins.str]:
        """
        Specifies the secret version in Azure Key Vault.
        """
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class IntegrationRuntimeSsisExpressVnetIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressVnetIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressVnetIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressVnetIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: builtins.str):
        """
        :param builtins.str subnet_id: id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class IntegrationRuntimeSsisPackageStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisPackageStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisPackageStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisPackageStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str linked_service_name: Name of the Linked Service to associate with the packages.
        :param builtins.str name: Name of the package store.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Name of the Linked Service to associate with the packages.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the package store.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class IntegrationRuntimeSsisPipelineExternalComputeScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfExternalNodes":
            suggest = "number_of_external_nodes"
        elif key == "numberOfPipelineNodes":
            suggest = "number_of_pipeline_nodes"
        elif key == "timeToLive":
            suggest = "time_to_live"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisPipelineExternalComputeScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisPipelineExternalComputeScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisPipelineExternalComputeScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_external_nodes: Optional[builtins.int] = None,
                 number_of_pipeline_nodes: Optional[builtins.int] = None,
                 time_to_live: Optional[builtins.int] = None):
        """
        :param builtins.int number_of_external_nodes: Specifies the number of the external nodes, which should be greater than `0` and less than `11`.
        :param builtins.int number_of_pipeline_nodes: Specifies the number of the pipeline nodes, which should be greater than `0` and less than `11`.
        :param builtins.int time_to_live: Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
        if number_of_external_nodes is not None:
            pulumi.set(__self__, "number_of_external_nodes", number_of_external_nodes)
        if number_of_pipeline_nodes is not None:
            pulumi.set(__self__, "number_of_pipeline_nodes", number_of_pipeline_nodes)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @property
    @pulumi.getter(name="numberOfExternalNodes")
    def number_of_external_nodes(self) -> Optional[builtins.int]:
        """
        Specifies the number of the external nodes, which should be greater than `0` and less than `11`.
        """
        return pulumi.get(self, "number_of_external_nodes")

    @property
    @pulumi.getter(name="numberOfPipelineNodes")
    def number_of_pipeline_nodes(self) -> Optional[builtins.int]:
        """
        Specifies the number of the pipeline nodes, which should be greater than `0` and less than `11`.
        """
        return pulumi.get(self, "number_of_pipeline_nodes")

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[builtins.int]:
        """
        Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
        return pulumi.get(self, "time_to_live")


@pulumi.output_type
class IntegrationRuntimeSsisProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selfHostedIntegrationRuntimeName":
            suggest = "self_hosted_integration_runtime_name"
        elif key == "stagingStorageLinkedServiceName":
            suggest = "staging_storage_linked_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 self_hosted_integration_runtime_name: builtins.str,
                 staging_storage_linked_service_name: builtins.str,
                 path: Optional[builtins.str] = None):
        """
        :param builtins.str self_hosted_integration_runtime_name: Name of Self Hosted Integration Runtime as a proxy.
        :param builtins.str staging_storage_linked_service_name: Name of Azure Blob Storage linked service to reference the staging data store to be used when moving data between self-hosted and Azure-SSIS integration runtimes.
        :param builtins.str path: The path in the data store to be used when moving data between Self-Hosted and Azure-SSIS Integration Runtimes.
        """
        pulumi.set(__self__, "self_hosted_integration_runtime_name", self_hosted_integration_runtime_name)
        pulumi.set(__self__, "staging_storage_linked_service_name", staging_storage_linked_service_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="selfHostedIntegrationRuntimeName")
    def self_hosted_integration_runtime_name(self) -> builtins.str:
        """
        Name of Self Hosted Integration Runtime as a proxy.
        """
        return pulumi.get(self, "self_hosted_integration_runtime_name")

    @property
    @pulumi.getter(name="stagingStorageLinkedServiceName")
    def staging_storage_linked_service_name(self) -> builtins.str:
        """
        Name of Azure Blob Storage linked service to reference the staging data store to be used when moving data between self-hosted and Azure-SSIS integration runtimes.
        """
        return pulumi.get(self, "staging_storage_linked_service_name")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The path in the data store to be used when moving data between Self-Hosted and Azure-SSIS Integration Runtimes.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class IntegrationRuntimeSsisVnetIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIps":
            suggest = "public_ips"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisVnetIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisVnetIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisVnetIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ips: Optional[Sequence[builtins.str]] = None,
                 subnet_id: Optional[builtins.str] = None,
                 subnet_name: Optional[builtins.str] = None,
                 vnet_id: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] public_ips: Static public IP addresses for the Azure-SSIS Integration Runtime. The size must be 2.
        :param builtins.str subnet_id: id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
               
               > **NOTE** Only one of `subnet_id` and `subnet_name` can be specified. If `subnet_name` is specified, `vnet_id` must be provided.
        :param builtins.str subnet_name: Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        :param builtins.str vnet_id: ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Optional[Sequence[builtins.str]]:
        """
        Static public IP addresses for the Azure-SSIS Integration Runtime. The size must be 2.
        """
        return pulumi.get(self, "public_ips")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[builtins.str]:
        """
        id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.

        > **NOTE** Only one of `subnet_id` and `subnet_name` can be specified. If `subnet_name` is specified, `vnet_id` must be provided.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[builtins.str]:
        """
        Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[builtins.str]:
        """
        ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class LinkedCustomServiceIntegrationRuntime(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The integration runtime reference to associate with the Data Factory Linked Service.
        :param Mapping[str, builtins.str] parameters: A map of parameters to associate with the integration runtime.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The integration runtime reference to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of parameters to associate with the integration runtime.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class LinkedServiceAzureBlobStorageKeyVaultSasToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureBlobStorageKeyVaultSasToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureBlobStorageKeyVaultSasToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureBlobStorageKeyVaultSasToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores the SAS token.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores the SAS token.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores the Service Principal key.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores the Service Principal key.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureDatabricksInstancePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "maxNumberOfWorkers":
            suggest = "max_number_of_workers"
        elif key == "minNumberOfWorkers":
            suggest = "min_number_of_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureDatabricksInstancePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureDatabricksInstancePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureDatabricksInstancePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: builtins.str,
                 instance_pool_id: builtins.str,
                 max_number_of_workers: Optional[builtins.int] = None,
                 min_number_of_workers: Optional[builtins.int] = None):
        """
        :param builtins.str cluster_version: Spark version of a the cluster.
        :param builtins.str instance_pool_id: Identifier of the instance pool within the linked ADB instance.
        :param builtins.int max_number_of_workers: The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        :param builtins.int min_number_of_workers: The minimum number of worker nodes. Defaults to `1`.
        """
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if max_number_of_workers is not None:
            pulumi.set(__self__, "max_number_of_workers", max_number_of_workers)
        if min_number_of_workers is not None:
            pulumi.set(__self__, "min_number_of_workers", min_number_of_workers)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> builtins.str:
        """
        Spark version of a the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> builtins.str:
        """
        Identifier of the instance pool within the linked ADB instance.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter(name="maxNumberOfWorkers")
    def max_number_of_workers(self) -> Optional[builtins.int]:
        """
        The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        """
        return pulumi.get(self, "max_number_of_workers")

    @property
    @pulumi.getter(name="minNumberOfWorkers")
    def min_number_of_workers(self) -> Optional[builtins.int]:
        """
        The minimum number of worker nodes. Defaults to `1`.
        """
        return pulumi.get(self, "min_number_of_workers")


@pulumi.output_type
class LinkedServiceAzureDatabricksKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureDatabricksKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureDatabricksKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureDatabricksKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores ADB access token.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores ADB access token.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureDatabricksNewClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "driverNodeType":
            suggest = "driver_node_type"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "logDestination":
            suggest = "log_destination"
        elif key == "maxNumberOfWorkers":
            suggest = "max_number_of_workers"
        elif key == "minNumberOfWorkers":
            suggest = "min_number_of_workers"
        elif key == "sparkConfig":
            suggest = "spark_config"
        elif key == "sparkEnvironmentVariables":
            suggest = "spark_environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureDatabricksNewClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureDatabricksNewClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureDatabricksNewClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: builtins.str,
                 node_type: builtins.str,
                 custom_tags: Optional[Mapping[str, builtins.str]] = None,
                 driver_node_type: Optional[builtins.str] = None,
                 init_scripts: Optional[Sequence[builtins.str]] = None,
                 log_destination: Optional[builtins.str] = None,
                 max_number_of_workers: Optional[builtins.int] = None,
                 min_number_of_workers: Optional[builtins.int] = None,
                 spark_config: Optional[Mapping[str, builtins.str]] = None,
                 spark_environment_variables: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str cluster_version: Spark version of a the cluster.
        :param builtins.str node_type: Node type for the new cluster.
        :param Mapping[str, builtins.str] custom_tags: Tags for the cluster resource.
        :param builtins.str driver_node_type: Driver node type for the cluster.
        :param Sequence[builtins.str] init_scripts: User defined initialization scripts for the cluster.
        :param builtins.str log_destination: Location to deliver Spark driver, worker, and event logs.
        :param builtins.int max_number_of_workers: Specifies the maximum number of worker nodes. It should be between 1 and 25000.
        :param builtins.int min_number_of_workers: Specifies the minimum number of worker nodes. It should be between 1 and 25000. It defaults to `1`.
        :param Mapping[str, builtins.str] spark_config: User-specified Spark configuration variables key-value pairs.
        :param Mapping[str, builtins.str] spark_environment_variables: User-specified Spark environment variables key-value pairs.
        """
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "node_type", node_type)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if driver_node_type is not None:
            pulumi.set(__self__, "driver_node_type", driver_node_type)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if log_destination is not None:
            pulumi.set(__self__, "log_destination", log_destination)
        if max_number_of_workers is not None:
            pulumi.set(__self__, "max_number_of_workers", max_number_of_workers)
        if min_number_of_workers is not None:
            pulumi.set(__self__, "min_number_of_workers", min_number_of_workers)
        if spark_config is not None:
            pulumi.set(__self__, "spark_config", spark_config)
        if spark_environment_variables is not None:
            pulumi.set(__self__, "spark_environment_variables", spark_environment_variables)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> builtins.str:
        """
        Spark version of a the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> builtins.str:
        """
        Node type for the new cluster.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tags for the cluster resource.
        """
        return pulumi.get(self, "custom_tags")

    @property
    @pulumi.getter(name="driverNodeType")
    def driver_node_type(self) -> Optional[builtins.str]:
        """
        Driver node type for the cluster.
        """
        return pulumi.get(self, "driver_node_type")

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence[builtins.str]]:
        """
        User defined initialization scripts for the cluster.
        """
        return pulumi.get(self, "init_scripts")

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> Optional[builtins.str]:
        """
        Location to deliver Spark driver, worker, and event logs.
        """
        return pulumi.get(self, "log_destination")

    @property
    @pulumi.getter(name="maxNumberOfWorkers")
    def max_number_of_workers(self) -> Optional[builtins.int]:
        """
        Specifies the maximum number of worker nodes. It should be between 1 and 25000.
        """
        return pulumi.get(self, "max_number_of_workers")

    @property
    @pulumi.getter(name="minNumberOfWorkers")
    def min_number_of_workers(self) -> Optional[builtins.int]:
        """
        Specifies the minimum number of worker nodes. It should be between 1 and 25000. It defaults to `1`.
        """
        return pulumi.get(self, "min_number_of_workers")

    @property
    @pulumi.getter(name="sparkConfig")
    def spark_config(self) -> Optional[Mapping[str, builtins.str]]:
        """
        User-specified Spark configuration variables key-value pairs.
        """
        return pulumi.get(self, "spark_config")

    @property
    @pulumi.getter(name="sparkEnvironmentVariables")
    def spark_environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        User-specified Spark environment variables key-value pairs.
        """
        return pulumi.get(self, "spark_environment_variables")


@pulumi.output_type
class LinkedServiceAzureFileStorageKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureFileStorageKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureFileStorageKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureFileStorageKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureFunctionKeyVaultKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureFunctionKeyVaultKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureFunctionKeyVaultKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureFunctionKeyVaultKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores the system key of the Azure Function.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores the system key of the Azure Function.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureSqlDatabaseKeyVaultConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureSqlDatabaseKeyVaultConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureSqlDatabaseKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureSqlDatabaseKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceOdataBasicAuthentication(dict):
    def __init__(__self__, *,
                 password: builtins.str,
                 username: builtins.str):
        """
        :param builtins.str password: The password associated with the username, which can be used to authenticate to the OData endpoint.
        :param builtins.str username: The username which can be used to authenticate to the OData endpoint.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        """
        The password associated with the username, which can be used to authenticate to the OData endpoint.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        The username which can be used to authenticate to the OData endpoint.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class LinkedServiceOdbcBasicAuthentication(dict):
    def __init__(__self__, *,
                 password: builtins.str,
                 username: builtins.str):
        """
        :param builtins.str password: The password associated with the username, which can be used to authenticate to the ODBC endpoint.
        :param builtins.str username: The username which can be used to authenticate to the ODBC endpoint.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        """
        The password associated with the username, which can be used to authenticate to the ODBC endpoint.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        The username which can be used to authenticate to the ODBC endpoint.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class LinkedServiceSnowflakeKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSnowflakeKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSnowflakeKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSnowflakeKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores Snowflake password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores Snowflake password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceSqlServerKeyVaultConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSqlServerKeyVaultConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSqlServerKeyVaultConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSqlServerKeyVaultConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceSqlServerKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSqlServerKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSqlServerKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSqlServerKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceSynapseKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSynapseKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSynapseKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSynapseKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: builtins.str,
                 secret_name: builtins.str):
        """
        :param builtins.str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param builtins.str secret_name: Specifies the secret name in Azure Key Vault that stores Synapse password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> builtins.str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> builtins.str:
        """
        Specifies the secret name in Azure Key Vault that stores Synapse password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class TriggerBlobEventPipeline(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The Data Factory Pipeline name that the trigger will act on.
        :param Mapping[str, builtins.str] parameters: The Data Factory Pipeline parameters that the trigger will act on.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class TriggerCustomEventPipeline(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The Data Factory Pipeline name that the trigger will act on.
        :param Mapping[str, builtins.str] parameters: The Data Factory Pipeline parameters that the trigger will act on.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class TriggerSchedulePipeline(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: Reference pipeline name.
        :param Mapping[str, builtins.str] parameters: The pipeline parameters that the trigger will act upon.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Reference pipeline name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The pipeline parameters that the trigger will act upon.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class TriggerScheduleSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonths":
            suggest = "days_of_months"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerScheduleSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerScheduleSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerScheduleSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_months: Optional[Sequence[builtins.int]] = None,
                 days_of_weeks: Optional[Sequence[builtins.str]] = None,
                 hours: Optional[Sequence[builtins.int]] = None,
                 minutes: Optional[Sequence[builtins.int]] = None,
                 monthlies: Optional[Sequence['outputs.TriggerScheduleScheduleMonthly']] = None):
        """
        :param Sequence[builtins.int] days_of_months: Day(s) of the month on which the trigger is scheduled. This value can be specified with a monthly frequency only.
        :param Sequence[builtins.str] days_of_weeks: Days of the week on which the trigger is scheduled. This value can be specified only with a weekly frequency.
        :param Sequence[builtins.int] hours: Hours of the day on which the trigger is scheduled.
        :param Sequence[builtins.int] minutes: Minutes of the hour on which the trigger is scheduled.
        :param Sequence['TriggerScheduleScheduleMonthlyArgs'] monthlies: A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled. The value can be specified only with a monthly frequency.
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if monthlies is not None:
            pulumi.set(__self__, "monthlies", monthlies)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[Sequence[builtins.int]]:
        """
        Day(s) of the month on which the trigger is scheduled. This value can be specified with a monthly frequency only.
        """
        return pulumi.get(self, "days_of_months")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[builtins.str]]:
        """
        Days of the week on which the trigger is scheduled. This value can be specified only with a weekly frequency.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter
    def hours(self) -> Optional[Sequence[builtins.int]]:
        """
        Hours of the day on which the trigger is scheduled.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[Sequence[builtins.int]]:
        """
        Minutes of the hour on which the trigger is scheduled.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def monthlies(self) -> Optional[Sequence['outputs.TriggerScheduleScheduleMonthly']]:
        """
        A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled. The value can be specified only with a monthly frequency.
        """
        return pulumi.get(self, "monthlies")


@pulumi.output_type
class TriggerScheduleScheduleMonthly(dict):
    def __init__(__self__, *,
                 weekday: builtins.str,
                 week: Optional[builtins.int] = None):
        """
        :param builtins.str weekday: The day of the week on which the trigger runs. For example, a `monthly` property with a `weekday` value of `Sunday` means every Sunday of the month.
        :param builtins.int week: The occurrence of the specified day during the month. For example, a `monthly` property with `weekday` and `week` values of `Sunday, -1` means the last Sunday of the month.
        """
        pulumi.set(__self__, "weekday", weekday)
        if week is not None:
            pulumi.set(__self__, "week", week)

    @property
    @pulumi.getter
    def weekday(self) -> builtins.str:
        """
        The day of the week on which the trigger runs. For example, a `monthly` property with a `weekday` value of `Sunday` means every Sunday of the month.
        """
        return pulumi.get(self, "weekday")

    @property
    @pulumi.getter
    def week(self) -> Optional[builtins.int]:
        """
        The occurrence of the specified day during the month. For example, a `monthly` property with `weekday` and `week` values of `Sunday, -1` means the last Sunday of the month.
        """
        return pulumi.get(self, "week")


@pulumi.output_type
class TriggerTumblingWindowPipeline(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 parameters: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str name: The Data Factory Pipeline name that the trigger will act on.
        :param Mapping[str, builtins.str] parameters: The Data Factory Pipeline parameters that the trigger will act on.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class TriggerTumblingWindowRetry(dict):
    def __init__(__self__, *,
                 count: builtins.int,
                 interval: Optional[builtins.int] = None):
        """
        :param builtins.int count: The maximum retry attempts if the pipeline run failed.
        :param builtins.int interval: The Interval in seconds between each retry if the pipeline run failed. Defaults to `30`.
        """
        pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> builtins.int:
        """
        The maximum retry attempts if the pipeline run failed.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[builtins.int]:
        """
        The Interval in seconds between each retry if the pipeline run failed. Defaults to `30`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class TriggerTumblingWindowTriggerDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerName":
            suggest = "trigger_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerTumblingWindowTriggerDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerTumblingWindowTriggerDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerTumblingWindowTriggerDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 offset: Optional[builtins.str] = None,
                 size: Optional[builtins.str] = None,
                 trigger_name: Optional[builtins.str] = None):
        """
        :param builtins.str offset: The offset of the dependency trigger. Must be in Timespan format (±hh:mm:ss) and must be a negative offset for a self dependency.
        :param builtins.str size: The size of the dependency tumbling window. Must be in Timespan format (hh:mm:ss).
        :param builtins.str trigger_name: The dependency trigger name. If not specified, it will use self dependency.
        """
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if trigger_name is not None:
            pulumi.set(__self__, "trigger_name", trigger_name)

    @property
    @pulumi.getter
    def offset(self) -> Optional[builtins.str]:
        """
        The offset of the dependency trigger. Must be in Timespan format (±hh:mm:ss) and must be a negative offset for a self dependency.
        """
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter
    def size(self) -> Optional[builtins.str]:
        """
        The size of the dependency tumbling window. Must be in Timespan format (hh:mm:ss).
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="triggerName")
    def trigger_name(self) -> Optional[builtins.str]:
        """
        The dependency trigger name. If not specified, it will use self dependency.
        """
        return pulumi.get(self, "trigger_name")


@pulumi.output_type
class GetFactoryGithubConfigurationResult(dict):
    def __init__(__self__, *,
                 account_name: builtins.str,
                 branch_name: builtins.str,
                 git_url: builtins.str,
                 repository_name: builtins.str,
                 root_folder: builtins.str):
        """
        :param builtins.str account_name: The VSTS account name.
        :param builtins.str branch_name: The branch of the repository to get code from.
        :param builtins.str git_url: The GitHub repository url.
        :param builtins.str repository_name: The name of the git repository.
        :param builtins.str root_folder: The root folder within the repository.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "git_url", git_url)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> builtins.str:
        """
        The VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> builtins.str:
        """
        The branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="gitUrl")
    def git_url(self) -> builtins.str:
        """
        The GitHub repository url.
        """
        return pulumi.get(self, "git_url")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> builtins.str:
        """
        The name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> builtins.str:
        """
        The root folder within the repository.
        """
        return pulumi.get(self, "root_folder")


@pulumi.output_type
class GetFactoryIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[builtins.str],
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: builtins.str):
        """
        :param Sequence[builtins.str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Data Factory.
        :param builtins.str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Data Factory.
        :param builtins.str tenant_id: The Tenant ID associated with the VSTS account.
        :param builtins.str type: The type of Managed Service Identity that is configured on this Data Factory.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[builtins.str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Data Factory.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Data Factory.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of Managed Service Identity that is configured on this Data Factory.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFactoryVstsConfigurationResult(dict):
    def __init__(__self__, *,
                 account_name: builtins.str,
                 branch_name: builtins.str,
                 project_name: builtins.str,
                 repository_name: builtins.str,
                 root_folder: builtins.str,
                 tenant_id: builtins.str):
        """
        :param builtins.str account_name: The VSTS account name.
        :param builtins.str branch_name: The branch of the repository to get code from.
        :param builtins.str project_name: The name of the VSTS project.
        :param builtins.str repository_name: The name of the git repository.
        :param builtins.str root_folder: The root folder within the repository.
        :param builtins.str tenant_id: The Tenant ID associated with the VSTS account.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> builtins.str:
        """
        The VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> builtins.str:
        """
        The branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> builtins.str:
        """
        The name of the VSTS project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> builtins.str:
        """
        The name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> builtins.str:
        """
        The root folder within the repository.
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetTriggerScheduleScheduleResult(dict):
    def __init__(__self__, *,
                 days_of_months: Sequence[builtins.int],
                 days_of_weeks: Sequence[builtins.str],
                 hours: Sequence[builtins.int],
                 minutes: Sequence[builtins.int],
                 monthlies: Sequence['outputs.GetTriggerScheduleScheduleMonthlyResult']):
        """
        :param Sequence[builtins.int] days_of_months: Day(s) of the month on which the trigger is scheduled.
        :param Sequence[builtins.str] days_of_weeks: Day(s) of the week on which the trigger is scheduled.
        :param Sequence[builtins.int] hours: Hours of the day on which the trigger is scheduled.
        :param Sequence[builtins.int] minutes: Minutes of the hour on which the trigger is scheduled.
        :param Sequence['GetTriggerScheduleScheduleMonthlyArgs'] monthlies: A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled.
        """
        pulumi.set(__self__, "days_of_months", days_of_months)
        pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "monthlies", monthlies)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Sequence[builtins.int]:
        """
        Day(s) of the month on which the trigger is scheduled.
        """
        return pulumi.get(self, "days_of_months")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence[builtins.str]:
        """
        Day(s) of the week on which the trigger is scheduled.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter
    def hours(self) -> Sequence[builtins.int]:
        """
        Hours of the day on which the trigger is scheduled.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Sequence[builtins.int]:
        """
        Minutes of the hour on which the trigger is scheduled.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def monthlies(self) -> Sequence['outputs.GetTriggerScheduleScheduleMonthlyResult']:
        """
        A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled.
        """
        return pulumi.get(self, "monthlies")


@pulumi.output_type
class GetTriggerScheduleScheduleMonthlyResult(dict):
    def __init__(__self__, *,
                 week: builtins.int,
                 weekday: builtins.str):
        """
        :param builtins.int week: The occurrence of the specified day during the month.
        :param builtins.str weekday: The day of the week on which the trigger runs.
        """
        pulumi.set(__self__, "week", week)
        pulumi.set(__self__, "weekday", weekday)

    @property
    @pulumi.getter
    def week(self) -> builtins.int:
        """
        The occurrence of the specified day during the month.
        """
        return pulumi.get(self, "week")

    @property
    @pulumi.getter
    def weekday(self) -> builtins.str:
        """
        The day of the week on which the trigger runs.
        """
        return pulumi.get(self, "weekday")


