# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'CustomDatasetLinkedService',
    'DataFlowSink',
    'DataFlowSinkDataset',
    'DataFlowSinkLinkedService',
    'DataFlowSinkSchemaLinkedService',
    'DataFlowSource',
    'DataFlowSourceDataset',
    'DataFlowSourceLinkedService',
    'DataFlowSourceSchemaLinkedService',
    'DataFlowTransformation',
    'DatasetAzureBlobSchemaColumn',
    'DatasetBinaryAzureBlobStorageLocation',
    'DatasetBinaryCompression',
    'DatasetBinaryHttpServerLocation',
    'DatasetBinarySftpServerLocation',
    'DatasetCosmosDBApiSchemaColumn',
    'DatasetDelimitedTextAzureBlobFsLocation',
    'DatasetDelimitedTextAzureBlobStorageLocation',
    'DatasetDelimitedTextHttpServerLocation',
    'DatasetDelimitedTextSchemaColumn',
    'DatasetHttpSchemaColumn',
    'DatasetJsonAzureBlobStorageLocation',
    'DatasetJsonHttpServerLocation',
    'DatasetJsonSchemaColumn',
    'DatasetMysqlSchemaColumn',
    'DatasetParquetAzureBlobStorageLocation',
    'DatasetParquetHttpServerLocation',
    'DatasetParquetSchemaColumn',
    'DatasetPostgresqlSchemaColumn',
    'DatasetSnowflakeSchemaColumn',
    'DatasetSnowflakeStructureColumn',
    'DatasetSqlServerTableSchemaColumn',
    'FactoryGithubConfiguration',
    'FactoryGlobalParameter',
    'FactoryIdentity',
    'FactoryVstsConfiguration',
    'IntegrationRuntimeManagedCatalogInfo',
    'IntegrationRuntimeManagedCustomSetupScript',
    'IntegrationRuntimeManagedVnetIntegration',
    'IntegrationRuntimeSelfHostedRbacAuthorization',
    'IntegrationRuntimeSsisCatalogInfo',
    'IntegrationRuntimeSsisCustomSetupScript',
    'IntegrationRuntimeSsisExpressCustomSetup',
    'IntegrationRuntimeSsisExpressCustomSetupCommandKey',
    'IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword',
    'IntegrationRuntimeSsisExpressCustomSetupComponent',
    'IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense',
    'IntegrationRuntimeSsisPackageStore',
    'IntegrationRuntimeSsisProxy',
    'IntegrationRuntimeSsisVnetIntegration',
    'LinkedCustomServiceIntegrationRuntime',
    'LinkedServiceAzureBlobStorageKeyVaultSasToken',
    'LinkedServiceAzureDatabricksInstancePool',
    'LinkedServiceAzureDatabricksKeyVaultPassword',
    'LinkedServiceAzureDatabricksNewClusterConfig',
    'LinkedServiceAzureFileStorageKeyVaultPassword',
    'LinkedServiceAzureFunctionKeyVaultKey',
    'LinkedServiceAzureSqlDatabaseKeyVaultConnectionString',
    'LinkedServiceAzureSqlDatabaseKeyVaultPassword',
    'LinkedServiceOdataBasicAuthentication',
    'LinkedServiceSnowflakeKeyVaultPassword',
    'LinkedServiceSqlServerKeyVaultConnectionString',
    'LinkedServiceSqlServerKeyVaultPassword',
    'LinkedServiceSynapseKeyVaultPassword',
    'TriggerBlobEventPipeline',
    'TriggerCustomEventPipeline',
    'TriggerScheduleSchedule',
    'TriggerScheduleScheduleMonthly',
    'TriggerTumblingWindowPipeline',
    'TriggerTumblingWindowRetry',
    'TriggerTumblingWindowTriggerDependency',
    'GetFactoryGithubConfigurationResult',
    'GetFactoryIdentityResult',
    'GetFactoryVstsConfigurationResult',
]

@pulumi.output_type
class CustomDatasetLinkedService(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The name of the Data Factory Linked Service.
        :param Mapping[str, str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedService":
            suggest = "linked_service"
        elif key == "schemaLinkedService":
            suggest = "schema_linked_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFlowSink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFlowSink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFlowSink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 dataset: Optional['outputs.DataFlowSinkDataset'] = None,
                 description: Optional[str] = None,
                 linked_service: Optional['outputs.DataFlowSinkLinkedService'] = None,
                 schema_linked_service: Optional['outputs.DataFlowSinkSchemaLinkedService'] = None):
        """
        :param str name: The name for the Data Flow Source.
        :param 'DataFlowSinkDatasetArgs' dataset: A `dataset` block as defined below.
        :param str description: The description for the Data Flow Source.
        :param 'DataFlowSinkLinkedServiceArgs' linked_service: A `linked_service` block as defined below.
        :param 'DataFlowSinkSchemaLinkedServiceArgs' schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.DataFlowSinkDataset']:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.DataFlowSinkLinkedService']:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional['outputs.DataFlowSinkSchemaLinkedService']:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")


@pulumi.output_type
class DataFlowSinkDataset(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The name for the Data Factory Dataset.
        :param Mapping[str, str] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSinkLinkedService(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The name for the Data Factory Linked Service.
        :param Mapping[str, str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSinkSchemaLinkedService(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedService":
            suggest = "linked_service"
        elif key == "schemaLinkedService":
            suggest = "schema_linked_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFlowSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFlowSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFlowSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 dataset: Optional['outputs.DataFlowSourceDataset'] = None,
                 description: Optional[str] = None,
                 linked_service: Optional['outputs.DataFlowSourceLinkedService'] = None,
                 schema_linked_service: Optional['outputs.DataFlowSourceSchemaLinkedService'] = None):
        """
        :param str name: The name for the Data Flow Source.
        :param 'DataFlowSourceDatasetArgs' dataset: A `dataset` block as defined below.
        :param str description: The description for the Data Flow Source.
        :param 'DataFlowSourceLinkedServiceArgs' linked_service: A `linked_service` block as defined below.
        :param 'DataFlowSourceSchemaLinkedServiceArgs' schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.DataFlowSourceDataset']:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.DataFlowSourceLinkedService']:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional['outputs.DataFlowSourceSchemaLinkedService']:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")


@pulumi.output_type
class DataFlowSourceDataset(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The name for the Data Factory Dataset.
        :param Mapping[str, str] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSourceLinkedService(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The name for the Data Factory Linked Service.
        :param Mapping[str, str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowSourceSchemaLinkedService(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The name for the Data Factory Linked Service with schema.
        :param Mapping[str, str] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DataFlowTransformation(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None):
        """
        :param str name: The name for the Data Flow transformation.
        :param str description: The description for the Data Flow transformation.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Data Flow transformation.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description for the Data Flow transformation.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class DatasetAzureBlobSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetBinaryAzureBlobStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetBinaryAzureBlobStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetBinaryAzureBlobStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetBinaryAzureBlobStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: str,
                 dynamic_filename_enabled: Optional[bool] = None,
                 dynamic_path_enabled: Optional[bool] = None,
                 filename: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str container: The container on the Azure Blob Storage Account hosting the file.
        :param bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param str filename: The filename of the file in the blob container.
        :param str path: The folder path to the file in the blob container.
        """
        pulumi.set(__self__, "container", container)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        The filename of the file in the blob container.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The folder path to the file in the blob container.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetBinaryCompression(dict):
    def __init__(__self__, *,
                 type: str,
                 level: Optional[str] = None):
        """
        :param str type: The type of compression used during transport.
        :param str level: The level of compression. Possible values are `Fastest` and `Optimal`.
        """
        pulumi.set(__self__, "type", type)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of compression used during transport.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The level of compression. Possible values are `Fastest` and `Optimal`.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class DatasetBinaryHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetBinaryHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetBinaryHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetBinaryHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: str,
                 path: str,
                 relative_url: str,
                 dynamic_filename_enabled: Optional[bool] = None,
                 dynamic_path_enabled: Optional[bool] = None):
        """
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        :param str relative_url: The base URL to the web server hosting the file.
        :param bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetBinarySftpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetBinarySftpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetBinarySftpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetBinarySftpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: str,
                 path: str,
                 dynamic_filename_enabled: Optional[bool] = None,
                 dynamic_path_enabled: Optional[bool] = None):
        """
        :param str filename: The filename of the file on the SFTP server.
        :param str path: The folder path to the file on the SFTP server.
        :param bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the SFTP server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the SFTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetCosmosDBApiSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetDelimitedTextAzureBlobFsLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDelimitedTextAzureBlobFsLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDelimitedTextAzureBlobFsLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDelimitedTextAzureBlobFsLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system: str,
                 filename: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str file_system: The storage data lake gen2 file system on the Azure Blob Storage Account hosting the file.
        :param str filename: The filename of the file.
        :param str path: The folder path to the file.
        """
        pulumi.set(__self__, "file_system", file_system)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> str:
        """
        The storage data lake gen2 file system on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "file_system")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        The filename of the file.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The folder path to the file.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetDelimitedTextAzureBlobStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDelimitedTextAzureBlobStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDelimitedTextAzureBlobStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDelimitedTextAzureBlobStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: str,
                 dynamic_filename_enabled: Optional[bool] = None,
                 dynamic_path_enabled: Optional[bool] = None,
                 filename: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str container: The container on the Azure Blob Storage Account hosting the file.
        :param bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param str filename: The filename of the file.
        :param str path: The folder path to the file.
        """
        pulumi.set(__self__, "container", container)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        The filename of the file.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The folder path to the file.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DatasetDelimitedTextHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDelimitedTextHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDelimitedTextHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDelimitedTextHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: str,
                 path: str,
                 relative_url: str,
                 dynamic_filename_enabled: Optional[bool] = None,
                 dynamic_path_enabled: Optional[bool] = None):
        """
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        :param str relative_url: The base URL to the web server hosting the file.
        :param bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetDelimitedTextSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetHttpSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetJsonAzureBlobStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetJsonAzureBlobStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetJsonAzureBlobStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetJsonAzureBlobStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: str,
                 filename: str,
                 path: str,
                 dynamic_filename_enabled: Optional[bool] = None,
                 dynamic_path_enabled: Optional[bool] = None):
        """
        :param str container: The container on the Azure Blob Storage Account hosting the file.
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        :param bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetJsonHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetJsonHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetJsonHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetJsonHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: str,
                 path: str,
                 relative_url: str,
                 dynamic_filename_enabled: Optional[bool] = None,
                 dynamic_path_enabled: Optional[bool] = None):
        """
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        :param str relative_url: The base URL to the web server hosting the file.
        :param bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetJsonSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetMysqlSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetParquetAzureBlobStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetParquetAzureBlobStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetParquetAzureBlobStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetParquetAzureBlobStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: str,
                 path: str,
                 dynamic_filename_enabled: Optional[bool] = None,
                 dynamic_path_enabled: Optional[bool] = None,
                 filename: Optional[str] = None):
        """
        :param str container: The container on the Azure Blob Storage Account hosting the file.
        :param str path: The folder path to the file on the web server.
        :param bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param str filename: The filename of the file on the web server.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "path", path)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class DatasetParquetHttpServerLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUrl":
            suggest = "relative_url"
        elif key == "dynamicFilenameEnabled":
            suggest = "dynamic_filename_enabled"
        elif key == "dynamicPathEnabled":
            suggest = "dynamic_path_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetParquetHttpServerLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetParquetHttpServerLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetParquetHttpServerLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filename: str,
                 path: str,
                 relative_url: str,
                 dynamic_filename_enabled: Optional[bool] = None,
                 dynamic_path_enabled: Optional[bool] = None):
        """
        :param str filename: The filename of the file on the web server.
        :param str path: The folder path to the file on the web server.
        :param str relative_url: The base URL to the web server hosting the file.
        :param bool dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param bool dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> str:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> str:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[bool]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[bool]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")


@pulumi.output_type
class DatasetParquetSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetPostgresqlSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetSnowflakeSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 precision: Optional[int] = None,
                 scale: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param int precision: The total number of digits allowed.
        :param int scale: The number of digits allowed to the right of the decimal point.
        :param str type: Type of the column. Valid values are `NUMBER`, `DECIMAL`, `NUMERIC`, `INT`, `INTEGER`, `BIGINT`, `SMALLINT`, `FLOAT``FLOAT4`, `FLOAT8`, `DOUBLE`, `DOUBLE PRECISION`, `REAL`, `VARCHAR`, `CHAR`, `CHARACTER`, `STRING`, `TEXT`, `BINARY`, `VARBINARY`, `BOOLEAN`, `DATE`, `DATETIME`, `TIME`, `TIMESTAMP`, `TIMESTAMP_LTZ`, `TIMESTAMP_NTZ`, `TIMESTAMP_TZ`, `VARIANT`, `OBJECT`, `ARRAY`, `GEOGRAPHY`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        The total number of digits allowed.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def scale(self) -> Optional[int]:
        """
        The number of digits allowed to the right of the decimal point.
        """
        return pulumi.get(self, "scale")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `NUMBER`, `DECIMAL`, `NUMERIC`, `INT`, `INTEGER`, `BIGINT`, `SMALLINT`, `FLOAT``FLOAT4`, `FLOAT8`, `DOUBLE`, `DOUBLE PRECISION`, `REAL`, `VARCHAR`, `CHAR`, `CHARACTER`, `STRING`, `TEXT`, `BINARY`, `VARBINARY`, `BOOLEAN`, `DATE`, `DATETIME`, `TIME`, `TIMESTAMP`, `TIMESTAMP_LTZ`, `TIMESTAMP_NTZ`, `TIMESTAMP_TZ`, `VARIANT`, `OBJECT`, `ARRAY`, `GEOGRAPHY`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetSnowflakeStructureColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetSqlServerTableSchemaColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the column.
        :param str description: The description of the column.
        :param str type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FactoryGithubConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "gitUrl":
            suggest = "git_url"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "rootFolder":
            suggest = "root_folder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FactoryGithubConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FactoryGithubConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FactoryGithubConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 branch_name: str,
                 git_url: str,
                 repository_name: str,
                 root_folder: str):
        """
        :param str account_name: Specifies the GitHub account name.
        :param str branch_name: Specifies the branch of the repository to get code from.
        :param str git_url: Specifies the GitHub Enterprise host name. For example: https://github.mydomain.com. Use https://github.com for open source repositories.
        :param str repository_name: Specifies the name of the git repository.
        :param str root_folder: Specifies the root folder within the repository. Set to `/` for the top level.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "git_url", git_url)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        Specifies the GitHub account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        Specifies the branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="gitUrl")
    def git_url(self) -> str:
        """
        Specifies the GitHub Enterprise host name. For example: https://github.mydomain.com. Use https://github.com for open source repositories.
        """
        return pulumi.get(self, "git_url")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        Specifies the name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        return pulumi.get(self, "root_folder")


@pulumi.output_type
class FactoryGlobalParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Specifies the global parameter name.
        :param str type: Specifies the global parameter type. Possible Values are `Array`, `Bool`, `Float`, `Int`, `Object` or `String`.
        :param str value: Specifies the global parameter value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the global parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the global parameter type. Possible Values are `Array`, `Bool`, `Float`, `Int`, `Object` or `String`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Specifies the global parameter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FactoryIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FactoryIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FactoryIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FactoryIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type of the Data Factory. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned,UserAssigned`.
        :param Sequence[str] identity_ids: Specifies the IDs of user assigned identities. Required if `UserAssigned` or `SystemAssigned,UserAssigned` type is used.
        :param str principal_id: The ID of the Principal (Client) in Azure Active Directory
        :param str tenant_id: Specifies the Tenant ID associated with the VSTS account.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type of the Data Factory. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned,UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies the IDs of user assigned identities. Required if `UserAssigned` or `SystemAssigned,UserAssigned` type is used.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The ID of the Principal (Client) in Azure Active Directory
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Specifies the Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FactoryVstsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "projectName":
            suggest = "project_name"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "rootFolder":
            suggest = "root_folder"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FactoryVstsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FactoryVstsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FactoryVstsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 branch_name: str,
                 project_name: str,
                 repository_name: str,
                 root_folder: str,
                 tenant_id: str):
        """
        :param str account_name: Specifies the VSTS account name.
        :param str branch_name: Specifies the branch of the repository to get code from.
        :param str project_name: Specifies the name of the VSTS project.
        :param str repository_name: Specifies the name of the git repository.
        :param str root_folder: Specifies the root folder within the repository. Set to `/` for the top level.
        :param str tenant_id: Specifies the Tenant ID associated with the VSTS account.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        Specifies the VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        Specifies the branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        Specifies the name of the VSTS project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        Specifies the name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Specifies the Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class IntegrationRuntimeManagedCatalogInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverEndpoint":
            suggest = "server_endpoint"
        elif key == "administratorLogin":
            suggest = "administrator_login"
        elif key == "administratorPassword":
            suggest = "administrator_password"
        elif key == "pricingTier":
            suggest = "pricing_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeManagedCatalogInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeManagedCatalogInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeManagedCatalogInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_endpoint: str,
                 administrator_login: Optional[str] = None,
                 administrator_password: Optional[str] = None,
                 pricing_tier: Optional[str] = None):
        """
        :param str server_endpoint: The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        :param str administrator_login: Administrator login name for the SQL Server.
        :param str administrator_password: Administrator login password for the SQL Server.
        :param str pricing_tier: Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
        """
        pulumi.set(__self__, "server_endpoint", server_endpoint)
        if administrator_login is not None:
            pulumi.set(__self__, "administrator_login", administrator_login)
        if administrator_password is not None:
            pulumi.set(__self__, "administrator_password", administrator_password)
        if pricing_tier is not None:
            pulumi.set(__self__, "pricing_tier", pricing_tier)

    @property
    @pulumi.getter(name="serverEndpoint")
    def server_endpoint(self) -> str:
        """
        The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        """
        return pulumi.get(self, "server_endpoint")

    @property
    @pulumi.getter(name="administratorLogin")
    def administrator_login(self) -> Optional[str]:
        """
        Administrator login name for the SQL Server.
        """
        return pulumi.get(self, "administrator_login")

    @property
    @pulumi.getter(name="administratorPassword")
    def administrator_password(self) -> Optional[str]:
        """
        Administrator login password for the SQL Server.
        """
        return pulumi.get(self, "administrator_password")

    @property
    @pulumi.getter(name="pricingTier")
    def pricing_tier(self) -> Optional[str]:
        """
        Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
        """
        return pulumi.get(self, "pricing_tier")


@pulumi.output_type
class IntegrationRuntimeManagedCustomSetupScript(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobContainerUri":
            suggest = "blob_container_uri"
        elif key == "sasToken":
            suggest = "sas_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeManagedCustomSetupScript. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeManagedCustomSetupScript.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeManagedCustomSetupScript.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_container_uri: str,
                 sas_token: str):
        """
        :param str blob_container_uri: The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        :param str sas_token: A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        pulumi.set(__self__, "sas_token", sas_token)

    @property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> str:
        """
        The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "blob_container_uri")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> str:
        """
        A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "sas_token")


@pulumi.output_type
class IntegrationRuntimeManagedVnetIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetName":
            suggest = "subnet_name"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeManagedVnetIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeManagedVnetIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeManagedVnetIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_name: str,
                 vnet_id: str):
        """
        :param str subnet_name: Name of the subnet to which the nodes of the Managed Integration Runtime will be added.
        :param str vnet_id: ID of the virtual network to which the nodes of the Managed Integration Runtime will be added.
        """
        pulumi.set(__self__, "subnet_name", subnet_name)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> str:
        """
        Name of the subnet to which the nodes of the Managed Integration Runtime will be added.
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> str:
        """
        ID of the virtual network to which the nodes of the Managed Integration Runtime will be added.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class IntegrationRuntimeSelfHostedRbacAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSelfHostedRbacAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSelfHostedRbacAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSelfHostedRbacAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: str):
        """
        :param str resource_id: The resource identifier of the integration runtime to be shared. Changing this forces a new Data Factory to be created.
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The resource identifier of the integration runtime to be shared. Changing this forces a new Data Factory to be created.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class IntegrationRuntimeSsisCatalogInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverEndpoint":
            suggest = "server_endpoint"
        elif key == "administratorLogin":
            suggest = "administrator_login"
        elif key == "administratorPassword":
            suggest = "administrator_password"
        elif key == "dualStandbyPairName":
            suggest = "dual_standby_pair_name"
        elif key == "pricingTier":
            suggest = "pricing_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisCatalogInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisCatalogInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisCatalogInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_endpoint: str,
                 administrator_login: Optional[str] = None,
                 administrator_password: Optional[str] = None,
                 dual_standby_pair_name: Optional[str] = None,
                 pricing_tier: Optional[str] = None):
        """
        :param str server_endpoint: The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        :param str administrator_login: Administrator login name for the SQL Server.
        :param str administrator_password: Administrator login password for the SQL Server.
        :param str dual_standby_pair_name: The dual standby Azure-SSIS Integration Runtime pair with SSISDB failover.
        :param str pricing_tier: Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
        """
        pulumi.set(__self__, "server_endpoint", server_endpoint)
        if administrator_login is not None:
            pulumi.set(__self__, "administrator_login", administrator_login)
        if administrator_password is not None:
            pulumi.set(__self__, "administrator_password", administrator_password)
        if dual_standby_pair_name is not None:
            pulumi.set(__self__, "dual_standby_pair_name", dual_standby_pair_name)
        if pricing_tier is not None:
            pulumi.set(__self__, "pricing_tier", pricing_tier)

    @property
    @pulumi.getter(name="serverEndpoint")
    def server_endpoint(self) -> str:
        """
        The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        """
        return pulumi.get(self, "server_endpoint")

    @property
    @pulumi.getter(name="administratorLogin")
    def administrator_login(self) -> Optional[str]:
        """
        Administrator login name for the SQL Server.
        """
        return pulumi.get(self, "administrator_login")

    @property
    @pulumi.getter(name="administratorPassword")
    def administrator_password(self) -> Optional[str]:
        """
        Administrator login password for the SQL Server.
        """
        return pulumi.get(self, "administrator_password")

    @property
    @pulumi.getter(name="dualStandbyPairName")
    def dual_standby_pair_name(self) -> Optional[str]:
        """
        The dual standby Azure-SSIS Integration Runtime pair with SSISDB failover.
        """
        return pulumi.get(self, "dual_standby_pair_name")

    @property
    @pulumi.getter(name="pricingTier")
    def pricing_tier(self) -> Optional[str]:
        """
        Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
        """
        return pulumi.get(self, "pricing_tier")


@pulumi.output_type
class IntegrationRuntimeSsisCustomSetupScript(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobContainerUri":
            suggest = "blob_container_uri"
        elif key == "sasToken":
            suggest = "sas_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisCustomSetupScript. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisCustomSetupScript.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisCustomSetupScript.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_container_uri: str,
                 sas_token: str):
        """
        :param str blob_container_uri: The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        :param str sas_token: A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        pulumi.set(__self__, "sas_token", sas_token)

    @property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> str:
        """
        The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "blob_container_uri")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> str:
        """
        A container SAS token that gives access to the files. See [https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/en-us/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "sas_token")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandKeys":
            suggest = "command_keys"
        elif key == "powershellVersion":
            suggest = "powershell_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_keys: Optional[Sequence['outputs.IntegrationRuntimeSsisExpressCustomSetupCommandKey']] = None,
                 components: Optional[Sequence['outputs.IntegrationRuntimeSsisExpressCustomSetupComponent']] = None,
                 environment: Optional[Mapping[str, str]] = None,
                 powershell_version: Optional[str] = None):
        """
        :param Sequence['IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgs'] command_keys: One or more `command_key` blocks as defined below.
        :param Sequence['IntegrationRuntimeSsisExpressCustomSetupComponentArgs'] components: One or more `component` blocks as defined below.
        :param Mapping[str, str] environment: The Environment Variables for the Azure-SSIS Integration Runtime.
        :param str powershell_version: The version of Azure Powershell installed for the Azure-SSIS Integration Runtime.
        """
        if command_keys is not None:
            pulumi.set(__self__, "command_keys", command_keys)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if powershell_version is not None:
            pulumi.set(__self__, "powershell_version", powershell_version)

    @property
    @pulumi.getter(name="commandKeys")
    def command_keys(self) -> Optional[Sequence['outputs.IntegrationRuntimeSsisExpressCustomSetupCommandKey']]:
        """
        One or more `command_key` blocks as defined below.
        """
        return pulumi.get(self, "command_keys")

    @property
    @pulumi.getter
    def components(self) -> Optional[Sequence['outputs.IntegrationRuntimeSsisExpressCustomSetupComponent']]:
        """
        One or more `component` blocks as defined below.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter
    def environment(self) -> Optional[Mapping[str, str]]:
        """
        The Environment Variables for the Azure-SSIS Integration Runtime.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="powershellVersion")
    def powershell_version(self) -> Optional[str]:
        """
        The version of Azure Powershell installed for the Azure-SSIS Integration Runtime.
        """
        return pulumi.get(self, "powershell_version")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetupCommandKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetName":
            suggest = "target_name"
        elif key == "userName":
            suggest = "user_name"
        elif key == "keyVaultPassword":
            suggest = "key_vault_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetupCommandKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupCommandKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupCommandKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_name: str,
                 user_name: str,
                 key_vault_password: Optional['outputs.IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword'] = None,
                 password: Optional[str] = None):
        """
        :param str target_name: The target computer or domain name.
        :param str user_name: The username for the target device.
        :param 'IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgs' key_vault_password: A `key_vault_secret_reference` block as defined below.
        :param str password: The password for the target device.
        """
        pulumi.set(__self__, "target_name", target_name)
        pulumi.set(__self__, "user_name", user_name)
        if key_vault_password is not None:
            pulumi.set(__self__, "key_vault_password", key_vault_password)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> str:
        """
        The target computer or domain name.
        """
        return pulumi.get(self, "target_name")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        The username for the target device.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="keyVaultPassword")
    def key_vault_password(self) -> Optional['outputs.IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword']:
        """
        A `key_vault_secret_reference` block as defined below.
        """
        return pulumi.get(self, "key_vault_password")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for the target device.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "secretVersion":
            suggest = "secret_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str,
                 parameters: Optional[Mapping[str, str]] = None,
                 secret_version: Optional[str] = None):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault.
        :param Mapping[str, str] parameters: A map of parameters to associate with the Key Vault Data Factory Linked Service.
        :param str secret_version: Specifies the secret version in Azure Key Vault.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[str]:
        """
        Specifies the secret version in Azure Key Vault.
        """
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetupComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultLicense":
            suggest = "key_vault_license"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetupComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 key_vault_license: Optional['outputs.IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense'] = None,
                 license: Optional[str] = None):
        """
        :param str name: The Component Name installed for the Azure-SSIS Integration Runtime.
        :param 'IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgs' key_vault_license: A `key_vault_secret_reference` block as defined below.
        :param str license: The license used for the Component.
        """
        pulumi.set(__self__, "name", name)
        if key_vault_license is not None:
            pulumi.set(__self__, "key_vault_license", key_vault_license)
        if license is not None:
            pulumi.set(__self__, "license", license)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Component Name installed for the Azure-SSIS Integration Runtime.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="keyVaultLicense")
    def key_vault_license(self) -> Optional['outputs.IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense']:
        """
        A `key_vault_secret_reference` block as defined below.
        """
        return pulumi.get(self, "key_vault_license")

    @property
    @pulumi.getter
    def license(self) -> Optional[str]:
        """
        The license used for the Component.
        """
        return pulumi.get(self, "license")


@pulumi.output_type
class IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "secretVersion":
            suggest = "secret_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str,
                 parameters: Optional[Mapping[str, str]] = None,
                 secret_version: Optional[str] = None):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault.
        :param Mapping[str, str] parameters: A map of parameters to associate with the Key Vault Data Factory Linked Service.
        :param str secret_version: Specifies the secret version in Azure Key Vault.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[str]:
        """
        Specifies the secret version in Azure Key Vault.
        """
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class IntegrationRuntimeSsisPackageStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisPackageStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisPackageStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisPackageStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 name: str):
        """
        :param str linked_service_name: Name of the Linked Service to associate with the packages.
        :param str name: Name of the package store.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Name of the Linked Service to associate with the packages.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the package store.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class IntegrationRuntimeSsisProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selfHostedIntegrationRuntimeName":
            suggest = "self_hosted_integration_runtime_name"
        elif key == "stagingStorageLinkedServiceName":
            suggest = "staging_storage_linked_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 self_hosted_integration_runtime_name: str,
                 staging_storage_linked_service_name: str,
                 path: Optional[str] = None):
        """
        :param str self_hosted_integration_runtime_name: Name of Self Hosted Integration Runtime as a proxy.
        :param str staging_storage_linked_service_name: Name of Azure Blob Storage linked service to reference the staging data store to be used when moving data between self-hosted and Azure-SSIS integration runtimes.
        :param str path: The path in the data store to be used when moving data between Self-Hosted and Azure-SSIS Integration Runtimes.
        """
        pulumi.set(__self__, "self_hosted_integration_runtime_name", self_hosted_integration_runtime_name)
        pulumi.set(__self__, "staging_storage_linked_service_name", staging_storage_linked_service_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="selfHostedIntegrationRuntimeName")
    def self_hosted_integration_runtime_name(self) -> str:
        """
        Name of Self Hosted Integration Runtime as a proxy.
        """
        return pulumi.get(self, "self_hosted_integration_runtime_name")

    @property
    @pulumi.getter(name="stagingStorageLinkedServiceName")
    def staging_storage_linked_service_name(self) -> str:
        """
        Name of Azure Blob Storage linked service to reference the staging data store to be used when moving data between self-hosted and Azure-SSIS integration runtimes.
        """
        return pulumi.get(self, "staging_storage_linked_service_name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path in the data store to be used when moving data between Self-Hosted and Azure-SSIS Integration Runtimes.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class IntegrationRuntimeSsisVnetIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIps":
            suggest = "public_ips"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "vnetId":
            suggest = "vnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisVnetIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisVnetIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisVnetIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ips: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None,
                 subnet_name: Optional[str] = None,
                 vnet_id: Optional[str] = None):
        """
        :param Sequence[str] public_ips: Static public IP addresses for the Azure-SSIS Integration Runtime. The size must be 2.
        :param str subnet_id: id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        :param str subnet_name: Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        :param str vnet_id: ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Optional[Sequence[str]]:
        """
        Static public IP addresses for the Azure-SSIS Integration Runtime. The size must be 2.
        """
        return pulumi.get(self, "public_ips")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[str]:
        """
        Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[str]:
        """
        ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "vnet_id")


@pulumi.output_type
class LinkedCustomServiceIntegrationRuntime(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The integration runtime reference to associate with the Data Factory Linked Service.
        :param Mapping[str, str] parameters: A map of parameters to associate with the integration runtime.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The integration runtime reference to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        A map of parameters to associate with the integration runtime.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class LinkedServiceAzureBlobStorageKeyVaultSasToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureBlobStorageKeyVaultSasToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureBlobStorageKeyVaultSasToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureBlobStorageKeyVaultSasToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores the sas token.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores the sas token.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureDatabricksInstancePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "maxNumberOfWorkers":
            suggest = "max_number_of_workers"
        elif key == "minNumberOfWorkers":
            suggest = "min_number_of_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureDatabricksInstancePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureDatabricksInstancePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureDatabricksInstancePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: str,
                 instance_pool_id: str,
                 max_number_of_workers: Optional[int] = None,
                 min_number_of_workers: Optional[int] = None):
        """
        :param str cluster_version: Spark version of a the cluster.
        :param str instance_pool_id: Identifier of the instance pool within the linked ADB instance.
        :param int max_number_of_workers: The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        :param int min_number_of_workers: The minimum number of worker nodes. Defaults to 1.
        """
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if max_number_of_workers is not None:
            pulumi.set(__self__, "max_number_of_workers", max_number_of_workers)
        if min_number_of_workers is not None:
            pulumi.set(__self__, "min_number_of_workers", min_number_of_workers)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> str:
        """
        Spark version of a the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        """
        Identifier of the instance pool within the linked ADB instance.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter(name="maxNumberOfWorkers")
    def max_number_of_workers(self) -> Optional[int]:
        """
        The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        """
        return pulumi.get(self, "max_number_of_workers")

    @property
    @pulumi.getter(name="minNumberOfWorkers")
    def min_number_of_workers(self) -> Optional[int]:
        """
        The minimum number of worker nodes. Defaults to 1.
        """
        return pulumi.get(self, "min_number_of_workers")


@pulumi.output_type
class LinkedServiceAzureDatabricksKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureDatabricksKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureDatabricksKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureDatabricksKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores ADB access token.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores ADB access token.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureDatabricksNewClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "driverNodeType":
            suggest = "driver_node_type"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "logDestination":
            suggest = "log_destination"
        elif key == "maxNumberOfWorkers":
            suggest = "max_number_of_workers"
        elif key == "minNumberOfWorkers":
            suggest = "min_number_of_workers"
        elif key == "sparkConfig":
            suggest = "spark_config"
        elif key == "sparkEnvironmentVariables":
            suggest = "spark_environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureDatabricksNewClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureDatabricksNewClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureDatabricksNewClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: str,
                 node_type: str,
                 custom_tags: Optional[Mapping[str, str]] = None,
                 driver_node_type: Optional[str] = None,
                 init_scripts: Optional[Sequence[str]] = None,
                 log_destination: Optional[str] = None,
                 max_number_of_workers: Optional[int] = None,
                 min_number_of_workers: Optional[int] = None,
                 spark_config: Optional[Mapping[str, str]] = None,
                 spark_environment_variables: Optional[Mapping[str, str]] = None):
        """
        :param str cluster_version: Spark version of a the cluster.
        :param str node_type: Node type for the new cluster.
        :param Mapping[str, str] custom_tags: Tags for the cluster resource.
        :param str driver_node_type: Driver node type for the cluster.
        :param Sequence[str] init_scripts: User defined initialization scripts for the cluster.
        :param str log_destination: Location to deliver Spark driver, worker, and event logs.
        :param int max_number_of_workers: The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        :param int min_number_of_workers: The minimum number of worker nodes. Defaults to 1.
        :param Mapping[str, str] spark_config: User-specified Spark configuration variables key-value pairs.
        :param Mapping[str, str] spark_environment_variables: User-specified Spark environment variables key-value pairs.
        """
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "node_type", node_type)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if driver_node_type is not None:
            pulumi.set(__self__, "driver_node_type", driver_node_type)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if log_destination is not None:
            pulumi.set(__self__, "log_destination", log_destination)
        if max_number_of_workers is not None:
            pulumi.set(__self__, "max_number_of_workers", max_number_of_workers)
        if min_number_of_workers is not None:
            pulumi.set(__self__, "min_number_of_workers", min_number_of_workers)
        if spark_config is not None:
            pulumi.set(__self__, "spark_config", spark_config)
        if spark_environment_variables is not None:
            pulumi.set(__self__, "spark_environment_variables", spark_environment_variables)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> str:
        """
        Spark version of a the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> str:
        """
        Node type for the new cluster.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags for the cluster resource.
        """
        return pulumi.get(self, "custom_tags")

    @property
    @pulumi.getter(name="driverNodeType")
    def driver_node_type(self) -> Optional[str]:
        """
        Driver node type for the cluster.
        """
        return pulumi.get(self, "driver_node_type")

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence[str]]:
        """
        User defined initialization scripts for the cluster.
        """
        return pulumi.get(self, "init_scripts")

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> Optional[str]:
        """
        Location to deliver Spark driver, worker, and event logs.
        """
        return pulumi.get(self, "log_destination")

    @property
    @pulumi.getter(name="maxNumberOfWorkers")
    def max_number_of_workers(self) -> Optional[int]:
        """
        The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        """
        return pulumi.get(self, "max_number_of_workers")

    @property
    @pulumi.getter(name="minNumberOfWorkers")
    def min_number_of_workers(self) -> Optional[int]:
        """
        The minimum number of worker nodes. Defaults to 1.
        """
        return pulumi.get(self, "min_number_of_workers")

    @property
    @pulumi.getter(name="sparkConfig")
    def spark_config(self) -> Optional[Mapping[str, str]]:
        """
        User-specified Spark configuration variables key-value pairs.
        """
        return pulumi.get(self, "spark_config")

    @property
    @pulumi.getter(name="sparkEnvironmentVariables")
    def spark_environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        User-specified Spark environment variables key-value pairs.
        """
        return pulumi.get(self, "spark_environment_variables")


@pulumi.output_type
class LinkedServiceAzureFileStorageKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureFileStorageKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureFileStorageKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureFileStorageKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureFunctionKeyVaultKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureFunctionKeyVaultKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureFunctionKeyVaultKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureFunctionKeyVaultKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores the system key of the Azure Function.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores the system key of the Azure Function.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureSqlDatabaseKeyVaultConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureSqlDatabaseKeyVaultConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceAzureSqlDatabaseKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceAzureSqlDatabaseKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceAzureSqlDatabaseKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceOdataBasicAuthentication(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password associated with the username, which can be used to authenticate to the OData endpoint.
        :param str username: The username which can be used to authenticate to the OData endpoint.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password associated with the username, which can be used to authenticate to the OData endpoint.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username which can be used to authenticate to the OData endpoint.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class LinkedServiceSnowflakeKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSnowflakeKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSnowflakeKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSnowflakeKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores Snowflake password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores Snowflake password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceSqlServerKeyVaultConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSqlServerKeyVaultConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSqlServerKeyVaultConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSqlServerKeyVaultConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceSqlServerKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSqlServerKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSqlServerKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSqlServerKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class LinkedServiceSynapseKeyVaultPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceName":
            suggest = "linked_service_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServiceSynapseKeyVaultPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServiceSynapseKeyVaultPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServiceSynapseKeyVaultPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_name: str,
                 secret_name: str):
        """
        :param str linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param str secret_name: Specifies the secret name in Azure Key Vault that stores Synapse password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> str:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        Specifies the secret name in Azure Key Vault that stores Synapse password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class TriggerBlobEventPipeline(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The Data Factory Pipeline name that the trigger will act on.
        :param Mapping[str, str] parameters: The Data Factory Pipeline parameters that the trigger will act on.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class TriggerCustomEventPipeline(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        """
        :param str name: The Data Factory Pipeline name that the trigger will act on.
        :param Mapping[str, str] parameters: The Data Factory Pipeline parameters that the trigger will act on.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class TriggerScheduleSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonths":
            suggest = "days_of_months"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerScheduleSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerScheduleSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerScheduleSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_months: Optional[Sequence[int]] = None,
                 days_of_weeks: Optional[Sequence[str]] = None,
                 hours: Optional[Sequence[int]] = None,
                 minutes: Optional[Sequence[int]] = None,
                 monthlies: Optional[Sequence['outputs.TriggerScheduleScheduleMonthly']] = None):
        """
        :param Sequence[int] days_of_months: Day(s) of the month on which the trigger is scheduled. This value can be specified with a monthly frequency only.
        :param Sequence[str] days_of_weeks: Days of the week on which the trigger is scheduled. This value can be specified only with a weekly frequency.
        :param Sequence[int] hours: Hours of the day on which the trigger is scheduled.
        :param Sequence[int] minutes: Minutes of the hour on which the trigger is scheduled.
        :param Sequence['TriggerScheduleScheduleMonthlyArgs'] monthlies: A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled. The value can be specified only with a monthly frequency.
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if monthlies is not None:
            pulumi.set(__self__, "monthlies", monthlies)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[Sequence[int]]:
        """
        Day(s) of the month on which the trigger is scheduled. This value can be specified with a monthly frequency only.
        """
        return pulumi.get(self, "days_of_months")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[str]]:
        """
        Days of the week on which the trigger is scheduled. This value can be specified only with a weekly frequency.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter
    def hours(self) -> Optional[Sequence[int]]:
        """
        Hours of the day on which the trigger is scheduled.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[Sequence[int]]:
        """
        Minutes of the hour on which the trigger is scheduled.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def monthlies(self) -> Optional[Sequence['outputs.TriggerScheduleScheduleMonthly']]:
        """
        A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled. The value can be specified only with a monthly frequency.
        """
        return pulumi.get(self, "monthlies")


@pulumi.output_type
class TriggerScheduleScheduleMonthly(dict):
    def __init__(__self__, *,
                 weekday: str,
                 week: Optional[int] = None):
        """
        :param str weekday: The day of the week on which the trigger runs. For example, a `monthly` property with a `weekday` value of `Sunday` means every Sunday of the month.
        :param int week: The occurrence of the specified day during the month. For example, a `monthly` property with `weekday` and `week` values of `Sunday, -1` means the last Sunday of the month.
        """
        pulumi.set(__self__, "weekday", weekday)
        if week is not None:
            pulumi.set(__self__, "week", week)

    @property
    @pulumi.getter
    def weekday(self) -> str:
        """
        The day of the week on which the trigger runs. For example, a `monthly` property with a `weekday` value of `Sunday` means every Sunday of the month.
        """
        return pulumi.get(self, "weekday")

    @property
    @pulumi.getter
    def week(self) -> Optional[int]:
        """
        The occurrence of the specified day during the month. For example, a `monthly` property with `weekday` and `week` values of `Sunday, -1` means the last Sunday of the month.
        """
        return pulumi.get(self, "week")


@pulumi.output_type
class TriggerTumblingWindowPipeline(dict):
    def __init__(__self__, *,
                 name: str,
                 parameters: Optional[Mapping[str, str]] = None):
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class TriggerTumblingWindowRetry(dict):
    def __init__(__self__, *,
                 count: int,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class TriggerTumblingWindowTriggerDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerName":
            suggest = "trigger_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerTumblingWindowTriggerDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerTumblingWindowTriggerDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerTumblingWindowTriggerDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 offset: Optional[str] = None,
                 size: Optional[str] = None,
                 trigger_name: Optional[str] = None):
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if trigger_name is not None:
            pulumi.set(__self__, "trigger_name", trigger_name)

    @property
    @pulumi.getter
    def offset(self) -> Optional[str]:
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="triggerName")
    def trigger_name(self) -> Optional[str]:
        return pulumi.get(self, "trigger_name")


@pulumi.output_type
class GetFactoryGithubConfigurationResult(dict):
    def __init__(__self__, *,
                 account_name: str,
                 branch_name: str,
                 git_url: str,
                 repository_name: str,
                 root_folder: str):
        """
        :param str account_name: The VSTS account name.
        :param str branch_name: The branch of the repository to get code from.
        :param str git_url: The GitHub Enterprise host name.
        :param str repository_name: The name of the git repository.
        :param str root_folder: The root folder within the repository.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "git_url", git_url)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        The branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="gitUrl")
    def git_url(self) -> str:
        """
        The GitHub Enterprise host name.
        """
        return pulumi.get(self, "git_url")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        The name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        The root folder within the repository.
        """
        return pulumi.get(self, "root_folder")


@pulumi.output_type
class GetFactoryIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param str principal_id: The ID of the Principal (Client) in Azure Active Directory.
        :param str tenant_id: The Tenant ID associated with the VSTS account.
        :param str type: The identity type of the Data Factory.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The ID of the Principal (Client) in Azure Active Directory.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type of the Data Factory.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFactoryVstsConfigurationResult(dict):
    def __init__(__self__, *,
                 account_name: str,
                 branch_name: str,
                 project_name: str,
                 repository_name: str,
                 root_folder: str,
                 tenant_id: str):
        """
        :param str account_name: The VSTS account name.
        :param str branch_name: The branch of the repository to get code from.
        :param str project_name: The name of the VSTS project.
        :param str repository_name: The name of the git repository.
        :param str root_folder: The root folder within the repository.
        :param str tenant_id: The Tenant ID associated with the VSTS account.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        The VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        The branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        The name of the VSTS project.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        The name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        The root folder within the repository.
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")


