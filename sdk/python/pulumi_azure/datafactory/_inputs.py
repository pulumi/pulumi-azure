# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CredentialServicePrincipalServicePrincipalKeyArgs',
    'CredentialServicePrincipalServicePrincipalKeyArgsDict',
    'CustomDatasetLinkedServiceArgs',
    'CustomDatasetLinkedServiceArgsDict',
    'DataFlowSinkArgs',
    'DataFlowSinkArgsDict',
    'DataFlowSinkDatasetArgs',
    'DataFlowSinkDatasetArgsDict',
    'DataFlowSinkFlowletArgs',
    'DataFlowSinkFlowletArgsDict',
    'DataFlowSinkLinkedServiceArgs',
    'DataFlowSinkLinkedServiceArgsDict',
    'DataFlowSinkRejectedLinkedServiceArgs',
    'DataFlowSinkRejectedLinkedServiceArgsDict',
    'DataFlowSinkSchemaLinkedServiceArgs',
    'DataFlowSinkSchemaLinkedServiceArgsDict',
    'DataFlowSourceArgs',
    'DataFlowSourceArgsDict',
    'DataFlowSourceDatasetArgs',
    'DataFlowSourceDatasetArgsDict',
    'DataFlowSourceFlowletArgs',
    'DataFlowSourceFlowletArgsDict',
    'DataFlowSourceLinkedServiceArgs',
    'DataFlowSourceLinkedServiceArgsDict',
    'DataFlowSourceRejectedLinkedServiceArgs',
    'DataFlowSourceRejectedLinkedServiceArgsDict',
    'DataFlowSourceSchemaLinkedServiceArgs',
    'DataFlowSourceSchemaLinkedServiceArgsDict',
    'DataFlowTransformationArgs',
    'DataFlowTransformationArgsDict',
    'DataFlowTransformationDatasetArgs',
    'DataFlowTransformationDatasetArgsDict',
    'DataFlowTransformationFlowletArgs',
    'DataFlowTransformationFlowletArgsDict',
    'DataFlowTransformationLinkedServiceArgs',
    'DataFlowTransformationLinkedServiceArgsDict',
    'DatasetAzureBlobSchemaColumnArgs',
    'DatasetAzureBlobSchemaColumnArgsDict',
    'DatasetAzureSqlTableSchemaColumnArgs',
    'DatasetAzureSqlTableSchemaColumnArgsDict',
    'DatasetBinaryAzureBlobStorageLocationArgs',
    'DatasetBinaryAzureBlobStorageLocationArgsDict',
    'DatasetBinaryCompressionArgs',
    'DatasetBinaryCompressionArgsDict',
    'DatasetBinaryHttpServerLocationArgs',
    'DatasetBinaryHttpServerLocationArgsDict',
    'DatasetBinarySftpServerLocationArgs',
    'DatasetBinarySftpServerLocationArgsDict',
    'DatasetCosmosDBApiSchemaColumnArgs',
    'DatasetCosmosDBApiSchemaColumnArgsDict',
    'DatasetDelimitedTextAzureBlobFsLocationArgs',
    'DatasetDelimitedTextAzureBlobFsLocationArgsDict',
    'DatasetDelimitedTextAzureBlobStorageLocationArgs',
    'DatasetDelimitedTextAzureBlobStorageLocationArgsDict',
    'DatasetDelimitedTextHttpServerLocationArgs',
    'DatasetDelimitedTextHttpServerLocationArgsDict',
    'DatasetDelimitedTextSchemaColumnArgs',
    'DatasetDelimitedTextSchemaColumnArgsDict',
    'DatasetHttpSchemaColumnArgs',
    'DatasetHttpSchemaColumnArgsDict',
    'DatasetJsonAzureBlobStorageLocationArgs',
    'DatasetJsonAzureBlobStorageLocationArgsDict',
    'DatasetJsonHttpServerLocationArgs',
    'DatasetJsonHttpServerLocationArgsDict',
    'DatasetJsonSchemaColumnArgs',
    'DatasetJsonSchemaColumnArgsDict',
    'DatasetMysqlSchemaColumnArgs',
    'DatasetMysqlSchemaColumnArgsDict',
    'DatasetParquetAzureBlobFsLocationArgs',
    'DatasetParquetAzureBlobFsLocationArgsDict',
    'DatasetParquetAzureBlobStorageLocationArgs',
    'DatasetParquetAzureBlobStorageLocationArgsDict',
    'DatasetParquetHttpServerLocationArgs',
    'DatasetParquetHttpServerLocationArgsDict',
    'DatasetParquetSchemaColumnArgs',
    'DatasetParquetSchemaColumnArgsDict',
    'DatasetPostgresqlSchemaColumnArgs',
    'DatasetPostgresqlSchemaColumnArgsDict',
    'DatasetSnowflakeSchemaColumnArgs',
    'DatasetSnowflakeSchemaColumnArgsDict',
    'DatasetSqlServerTableSchemaColumnArgs',
    'DatasetSqlServerTableSchemaColumnArgsDict',
    'FactoryGithubConfigurationArgs',
    'FactoryGithubConfigurationArgsDict',
    'FactoryGlobalParameterArgs',
    'FactoryGlobalParameterArgsDict',
    'FactoryIdentityArgs',
    'FactoryIdentityArgsDict',
    'FactoryVstsConfigurationArgs',
    'FactoryVstsConfigurationArgsDict',
    'FlowletDataFlowSinkArgs',
    'FlowletDataFlowSinkArgsDict',
    'FlowletDataFlowSinkDatasetArgs',
    'FlowletDataFlowSinkDatasetArgsDict',
    'FlowletDataFlowSinkFlowletArgs',
    'FlowletDataFlowSinkFlowletArgsDict',
    'FlowletDataFlowSinkLinkedServiceArgs',
    'FlowletDataFlowSinkLinkedServiceArgsDict',
    'FlowletDataFlowSinkRejectedLinkedServiceArgs',
    'FlowletDataFlowSinkRejectedLinkedServiceArgsDict',
    'FlowletDataFlowSinkSchemaLinkedServiceArgs',
    'FlowletDataFlowSinkSchemaLinkedServiceArgsDict',
    'FlowletDataFlowSourceArgs',
    'FlowletDataFlowSourceArgsDict',
    'FlowletDataFlowSourceDatasetArgs',
    'FlowletDataFlowSourceDatasetArgsDict',
    'FlowletDataFlowSourceFlowletArgs',
    'FlowletDataFlowSourceFlowletArgsDict',
    'FlowletDataFlowSourceLinkedServiceArgs',
    'FlowletDataFlowSourceLinkedServiceArgsDict',
    'FlowletDataFlowSourceRejectedLinkedServiceArgs',
    'FlowletDataFlowSourceRejectedLinkedServiceArgsDict',
    'FlowletDataFlowSourceSchemaLinkedServiceArgs',
    'FlowletDataFlowSourceSchemaLinkedServiceArgsDict',
    'FlowletDataFlowTransformationArgs',
    'FlowletDataFlowTransformationArgsDict',
    'FlowletDataFlowTransformationDatasetArgs',
    'FlowletDataFlowTransformationDatasetArgsDict',
    'FlowletDataFlowTransformationFlowletArgs',
    'FlowletDataFlowTransformationFlowletArgsDict',
    'FlowletDataFlowTransformationLinkedServiceArgs',
    'FlowletDataFlowTransformationLinkedServiceArgsDict',
    'IntegrationRuntimeSelfHostedRbacAuthorizationArgs',
    'IntegrationRuntimeSelfHostedRbacAuthorizationArgsDict',
    'IntegrationRuntimeSsisCatalogInfoArgs',
    'IntegrationRuntimeSsisCatalogInfoArgsDict',
    'IntegrationRuntimeSsisCopyComputeScaleArgs',
    'IntegrationRuntimeSsisCopyComputeScaleArgsDict',
    'IntegrationRuntimeSsisCustomSetupScriptArgs',
    'IntegrationRuntimeSsisCustomSetupScriptArgsDict',
    'IntegrationRuntimeSsisExpressCustomSetupArgs',
    'IntegrationRuntimeSsisExpressCustomSetupArgsDict',
    'IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgs',
    'IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgsDict',
    'IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgs',
    'IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgsDict',
    'IntegrationRuntimeSsisExpressCustomSetupComponentArgs',
    'IntegrationRuntimeSsisExpressCustomSetupComponentArgsDict',
    'IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgs',
    'IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgsDict',
    'IntegrationRuntimeSsisExpressVnetIntegrationArgs',
    'IntegrationRuntimeSsisExpressVnetIntegrationArgsDict',
    'IntegrationRuntimeSsisPackageStoreArgs',
    'IntegrationRuntimeSsisPackageStoreArgsDict',
    'IntegrationRuntimeSsisPipelineExternalComputeScaleArgs',
    'IntegrationRuntimeSsisPipelineExternalComputeScaleArgsDict',
    'IntegrationRuntimeSsisProxyArgs',
    'IntegrationRuntimeSsisProxyArgsDict',
    'IntegrationRuntimeSsisVnetIntegrationArgs',
    'IntegrationRuntimeSsisVnetIntegrationArgsDict',
    'LinkedCustomServiceIntegrationRuntimeArgs',
    'LinkedCustomServiceIntegrationRuntimeArgsDict',
    'LinkedServiceAzureBlobStorageKeyVaultSasTokenArgs',
    'LinkedServiceAzureBlobStorageKeyVaultSasTokenArgsDict',
    'LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKeyArgs',
    'LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKeyArgsDict',
    'LinkedServiceAzureDatabricksInstancePoolArgs',
    'LinkedServiceAzureDatabricksInstancePoolArgsDict',
    'LinkedServiceAzureDatabricksKeyVaultPasswordArgs',
    'LinkedServiceAzureDatabricksKeyVaultPasswordArgsDict',
    'LinkedServiceAzureDatabricksNewClusterConfigArgs',
    'LinkedServiceAzureDatabricksNewClusterConfigArgsDict',
    'LinkedServiceAzureFileStorageKeyVaultPasswordArgs',
    'LinkedServiceAzureFileStorageKeyVaultPasswordArgsDict',
    'LinkedServiceAzureFunctionKeyVaultKeyArgs',
    'LinkedServiceAzureFunctionKeyVaultKeyArgsDict',
    'LinkedServiceAzureSqlDatabaseKeyVaultConnectionStringArgs',
    'LinkedServiceAzureSqlDatabaseKeyVaultConnectionStringArgsDict',
    'LinkedServiceAzureSqlDatabaseKeyVaultPasswordArgs',
    'LinkedServiceAzureSqlDatabaseKeyVaultPasswordArgsDict',
    'LinkedServiceOdataBasicAuthenticationArgs',
    'LinkedServiceOdataBasicAuthenticationArgsDict',
    'LinkedServiceOdbcBasicAuthenticationArgs',
    'LinkedServiceOdbcBasicAuthenticationArgsDict',
    'LinkedServiceSnowflakeKeyVaultPasswordArgs',
    'LinkedServiceSnowflakeKeyVaultPasswordArgsDict',
    'LinkedServiceSqlServerKeyVaultConnectionStringArgs',
    'LinkedServiceSqlServerKeyVaultConnectionStringArgsDict',
    'LinkedServiceSqlServerKeyVaultPasswordArgs',
    'LinkedServiceSqlServerKeyVaultPasswordArgsDict',
    'LinkedServiceSynapseKeyVaultPasswordArgs',
    'LinkedServiceSynapseKeyVaultPasswordArgsDict',
    'TriggerBlobEventPipelineArgs',
    'TriggerBlobEventPipelineArgsDict',
    'TriggerCustomEventPipelineArgs',
    'TriggerCustomEventPipelineArgsDict',
    'TriggerSchedulePipelineArgs',
    'TriggerSchedulePipelineArgsDict',
    'TriggerScheduleScheduleArgs',
    'TriggerScheduleScheduleArgsDict',
    'TriggerScheduleScheduleMonthlyArgs',
    'TriggerScheduleScheduleMonthlyArgsDict',
    'TriggerTumblingWindowPipelineArgs',
    'TriggerTumblingWindowPipelineArgsDict',
    'TriggerTumblingWindowRetryArgs',
    'TriggerTumblingWindowRetryArgsDict',
    'TriggerTumblingWindowTriggerDependencyArgs',
    'TriggerTumblingWindowTriggerDependencyArgsDict',
]

MYPY = False

if not MYPY:
    class CredentialServicePrincipalServicePrincipalKeyArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        The name of the Linked Service to use for the Service Principal Key.
        """
        secret_name: pulumi.Input[str]
        """
        The name of the Secret in the Key Vault.
        """
        secret_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Secret in the Key Vault.
        """
elif False:
    CredentialServicePrincipalServicePrincipalKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CredentialServicePrincipalServicePrincipalKeyArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str],
                 secret_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] linked_service_name: The name of the Linked Service to use for the Service Principal Key.
        :param pulumi.Input[str] secret_name: The name of the Secret in the Key Vault.
        :param pulumi.Input[str] secret_version: The version of the Secret in the Key Vault.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        The name of the Linked Service to use for the Service Principal Key.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret in the Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Secret in the Key Vault.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_version", value)


if not MYPY:
    class CustomDatasetLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Data Factory Linked Service.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    CustomDatasetLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDatasetLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the Data Factory Linked Service.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSinkArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Flow Source.
        """
        dataset: NotRequired[pulumi.Input['DataFlowSinkDatasetArgsDict']]
        """
        A `dataset` block as defined below.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description for the Data Flow Source.
        """
        flowlet: NotRequired[pulumi.Input['DataFlowSinkFlowletArgsDict']]
        """
        A `flowlet` block as defined below.
        """
        linked_service: NotRequired[pulumi.Input['DataFlowSinkLinkedServiceArgsDict']]
        """
        A `linked_service` block as defined below.
        """
        rejected_linked_service: NotRequired[pulumi.Input['DataFlowSinkRejectedLinkedServiceArgsDict']]
        """
        A `rejected_linked_service` block as defined below.
        """
        schema_linked_service: NotRequired[pulumi.Input['DataFlowSinkSchemaLinkedServiceArgsDict']]
        """
        A `schema_linked_service` block as defined below.
        """
elif False:
    DataFlowSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['DataFlowSinkDatasetArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['DataFlowSinkFlowletArgs']] = None,
                 linked_service: Optional[pulumi.Input['DataFlowSinkLinkedServiceArgs']] = None,
                 rejected_linked_service: Optional[pulumi.Input['DataFlowSinkRejectedLinkedServiceArgs']] = None,
                 schema_linked_service: Optional[pulumi.Input['DataFlowSinkSchemaLinkedServiceArgs']] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Flow Source.
        :param pulumi.Input['DataFlowSinkDatasetArgs'] dataset: A `dataset` block as defined below.
        :param pulumi.Input[str] description: The description for the Data Flow Source.
        :param pulumi.Input['DataFlowSinkFlowletArgs'] flowlet: A `flowlet` block as defined below.
        :param pulumi.Input['DataFlowSinkLinkedServiceArgs'] linked_service: A `linked_service` block as defined below.
        :param pulumi.Input['DataFlowSinkRejectedLinkedServiceArgs'] rejected_linked_service: A `rejected_linked_service` block as defined below.
        :param pulumi.Input['DataFlowSinkSchemaLinkedServiceArgs'] schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if rejected_linked_service is not None:
            pulumi.set(__self__, "rejected_linked_service", rejected_linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['DataFlowSinkDatasetArgs']]:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['DataFlowSinkDatasetArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['DataFlowSinkFlowletArgs']]:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['DataFlowSinkFlowletArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['DataFlowSinkLinkedServiceArgs']]:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['DataFlowSinkLinkedServiceArgs']]):
        pulumi.set(self, "linked_service", value)

    @property
    @pulumi.getter(name="rejectedLinkedService")
    def rejected_linked_service(self) -> Optional[pulumi.Input['DataFlowSinkRejectedLinkedServiceArgs']]:
        """
        A `rejected_linked_service` block as defined below.
        """
        return pulumi.get(self, "rejected_linked_service")

    @rejected_linked_service.setter
    def rejected_linked_service(self, value: Optional[pulumi.Input['DataFlowSinkRejectedLinkedServiceArgs']]):
        pulumi.set(self, "rejected_linked_service", value)

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional[pulumi.Input['DataFlowSinkSchemaLinkedServiceArgs']]:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")

    @schema_linked_service.setter
    def schema_linked_service(self, value: Optional[pulumi.Input['DataFlowSinkSchemaLinkedServiceArgs']]):
        pulumi.set(self, "schema_linked_service", value)


if not MYPY:
    class DataFlowSinkDatasetArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory dataset.
        """
elif False:
    DataFlowSinkDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSinkDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSinkFlowletArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Flowlet.
        """
        dataset_parameters: NotRequired[pulumi.Input[str]]
        """
        Specifies the reference data flow parameters from dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
elif False:
    DataFlowSinkFlowletArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSinkFlowletArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset_parameters: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Flowlet.
        :param pulumi.Input[str] dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @dataset_parameters.setter
    def dataset_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_parameters", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSinkLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    DataFlowSinkLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSinkLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSinkRejectedLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service with schema.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    DataFlowSinkRejectedLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSinkRejectedLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service with schema.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSinkSchemaLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service with schema.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    DataFlowSinkSchemaLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSinkSchemaLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service with schema.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSourceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Flow Source.
        """
        dataset: NotRequired[pulumi.Input['DataFlowSourceDatasetArgsDict']]
        """
        A `dataset` block as defined below.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description for the Data Flow Source.
        """
        flowlet: NotRequired[pulumi.Input['DataFlowSourceFlowletArgsDict']]
        """
        A `flowlet` block as defined below.
        """
        linked_service: NotRequired[pulumi.Input['DataFlowSourceLinkedServiceArgsDict']]
        """
        A `linked_service` block as defined below.
        """
        rejected_linked_service: NotRequired[pulumi.Input['DataFlowSourceRejectedLinkedServiceArgsDict']]
        """
        A `rejected_linked_service` block as defined below.
        """
        schema_linked_service: NotRequired[pulumi.Input['DataFlowSourceSchemaLinkedServiceArgsDict']]
        """
        A `schema_linked_service` block as defined below.
        """
elif False:
    DataFlowSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['DataFlowSourceDatasetArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['DataFlowSourceFlowletArgs']] = None,
                 linked_service: Optional[pulumi.Input['DataFlowSourceLinkedServiceArgs']] = None,
                 rejected_linked_service: Optional[pulumi.Input['DataFlowSourceRejectedLinkedServiceArgs']] = None,
                 schema_linked_service: Optional[pulumi.Input['DataFlowSourceSchemaLinkedServiceArgs']] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Flow Source.
        :param pulumi.Input['DataFlowSourceDatasetArgs'] dataset: A `dataset` block as defined below.
        :param pulumi.Input[str] description: The description for the Data Flow Source.
        :param pulumi.Input['DataFlowSourceFlowletArgs'] flowlet: A `flowlet` block as defined below.
        :param pulumi.Input['DataFlowSourceLinkedServiceArgs'] linked_service: A `linked_service` block as defined below.
        :param pulumi.Input['DataFlowSourceRejectedLinkedServiceArgs'] rejected_linked_service: A `rejected_linked_service` block as defined below.
        :param pulumi.Input['DataFlowSourceSchemaLinkedServiceArgs'] schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if rejected_linked_service is not None:
            pulumi.set(__self__, "rejected_linked_service", rejected_linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['DataFlowSourceDatasetArgs']]:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['DataFlowSourceDatasetArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['DataFlowSourceFlowletArgs']]:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['DataFlowSourceFlowletArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['DataFlowSourceLinkedServiceArgs']]:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['DataFlowSourceLinkedServiceArgs']]):
        pulumi.set(self, "linked_service", value)

    @property
    @pulumi.getter(name="rejectedLinkedService")
    def rejected_linked_service(self) -> Optional[pulumi.Input['DataFlowSourceRejectedLinkedServiceArgs']]:
        """
        A `rejected_linked_service` block as defined below.
        """
        return pulumi.get(self, "rejected_linked_service")

    @rejected_linked_service.setter
    def rejected_linked_service(self, value: Optional[pulumi.Input['DataFlowSourceRejectedLinkedServiceArgs']]):
        pulumi.set(self, "rejected_linked_service", value)

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional[pulumi.Input['DataFlowSourceSchemaLinkedServiceArgs']]:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")

    @schema_linked_service.setter
    def schema_linked_service(self, value: Optional[pulumi.Input['DataFlowSourceSchemaLinkedServiceArgs']]):
        pulumi.set(self, "schema_linked_service", value)


if not MYPY:
    class DataFlowSourceDatasetArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory dataset.
        """
elif False:
    DataFlowSourceDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSourceDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSourceFlowletArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Flowlet.
        """
        dataset_parameters: NotRequired[pulumi.Input[str]]
        """
        Specifies the reference data flow parameters from dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
elif False:
    DataFlowSourceFlowletArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSourceFlowletArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset_parameters: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Flowlet.
        :param pulumi.Input[str] dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @dataset_parameters.setter
    def dataset_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_parameters", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSourceLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    DataFlowSourceLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSourceLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSourceRejectedLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service with schema.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    DataFlowSourceRejectedLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSourceRejectedLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service with schema.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowSourceSchemaLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service with schema.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    DataFlowSourceSchemaLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSourceSchemaLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service with schema.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowTransformationArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Flow transformation.
        """
        dataset: NotRequired[pulumi.Input['DataFlowTransformationDatasetArgsDict']]
        """
        A `dataset` block as defined below.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description for the Data Flow transformation.
        """
        flowlet: NotRequired[pulumi.Input['DataFlowTransformationFlowletArgsDict']]
        """
        A `flowlet` block as defined below.
        """
        linked_service: NotRequired[pulumi.Input['DataFlowTransformationLinkedServiceArgsDict']]
        """
        A `linked_service` block as defined below.
        """
elif False:
    DataFlowTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowTransformationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['DataFlowTransformationDatasetArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['DataFlowTransformationFlowletArgs']] = None,
                 linked_service: Optional[pulumi.Input['DataFlowTransformationLinkedServiceArgs']] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Flow transformation.
        :param pulumi.Input['DataFlowTransformationDatasetArgs'] dataset: A `dataset` block as defined below.
        :param pulumi.Input[str] description: The description for the Data Flow transformation.
        :param pulumi.Input['DataFlowTransformationFlowletArgs'] flowlet: A `flowlet` block as defined below.
        :param pulumi.Input['DataFlowTransformationLinkedServiceArgs'] linked_service: A `linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Flow transformation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['DataFlowTransformationDatasetArgs']]:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['DataFlowTransformationDatasetArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for the Data Flow transformation.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['DataFlowTransformationFlowletArgs']]:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['DataFlowTransformationFlowletArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['DataFlowTransformationLinkedServiceArgs']]:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['DataFlowTransformationLinkedServiceArgs']]):
        pulumi.set(self, "linked_service", value)


if not MYPY:
    class DataFlowTransformationDatasetArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory dataset.
        """
elif False:
    DataFlowTransformationDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowTransformationDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowTransformationFlowletArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Flowlet.
        """
        dataset_parameters: NotRequired[pulumi.Input[str]]
        """
        Specifies the reference data flow parameters from dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
elif False:
    DataFlowTransformationFlowletArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowTransformationFlowletArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset_parameters: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Flowlet.
        :param pulumi.Input[str] dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @dataset_parameters.setter
    def dataset_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_parameters", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DataFlowTransformationLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    DataFlowTransformationLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowTransformationLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DatasetAzureBlobSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetAzureBlobSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAzureBlobSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetAzureSqlTableSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetAzureSqlTableSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAzureSqlTableSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetBinaryAzureBlobStorageLocationArgsDict(TypedDict):
        container: pulumi.Input[str]
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        dynamic_container_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        filename: NotRequired[pulumi.Input[str]]
        """
        The filename of the file in the blob container.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The folder path to the file in the blob container.
        """
elif False:
    DatasetBinaryAzureBlobStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetBinaryAzureBlobStorageLocationArgs:
    def __init__(__self__, *,
                 container: pulumi.Input[str],
                 dynamic_container_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None,
                 filename: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] container: The container on the Azure Blob Storage Account hosting the file.
        :param pulumi.Input[bool] dynamic_container_enabled: Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[str] filename: The filename of the file in the blob container.
        :param pulumi.Input[str] path: The folder path to the file in the blob container.
        """
        pulumi.set(__self__, "container", container)
        if dynamic_container_enabled is not None:
            pulumi.set(__self__, "dynamic_container_enabled", dynamic_container_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input[str]:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[str]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="dynamicContainerEnabled")
    def dynamic_container_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_container_enabled")

    @dynamic_container_enabled.setter
    def dynamic_container_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_container_enabled", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)

    @property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[str]]:
        """
        The filename of the file in the blob container.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The folder path to the file in the blob container.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class DatasetBinaryCompressionArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of compression used during transport. Possible values are `BZip2`, `Deflate`, `GZip`, `Tar`, `TarGZip` and `ZipDeflate`.
        """
        level: NotRequired[pulumi.Input[str]]
        """
        The level of compression. Possible values are `Fastest` and `Optimal`.
        """
elif False:
    DatasetBinaryCompressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetBinaryCompressionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of compression used during transport. Possible values are `BZip2`, `Deflate`, `GZip`, `Tar`, `TarGZip` and `ZipDeflate`.
        :param pulumi.Input[str] level: The level of compression. Possible values are `Fastest` and `Optimal`.
        """
        pulumi.set(__self__, "type", type)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of compression used during transport. Possible values are `BZip2`, `Deflate`, `GZip`, `Tar`, `TarGZip` and `ZipDeflate`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        The level of compression. Possible values are `Fastest` and `Optimal`.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class DatasetBinaryHttpServerLocationArgsDict(TypedDict):
        filename: pulumi.Input[str]
        """
        The filename of the file on the web server.
        """
        path: pulumi.Input[str]
        """
        The folder path to the file on the web server.
        """
        relative_url: pulumi.Input[str]
        """
        The base URL to the web server hosting the file.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
elif False:
    DatasetBinaryHttpServerLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetBinaryHttpServerLocationArgs:
    def __init__(__self__, *,
                 filename: pulumi.Input[str],
                 path: pulumi.Input[str],
                 relative_url: pulumi.Input[str],
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] filename: The filename of the file on the web server.
        :param pulumi.Input[str] path: The folder path to the file on the web server.
        :param pulumi.Input[str] relative_url: The base URL to the web server hosting the file.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> pulumi.Input[str]:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @relative_url.setter
    def relative_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_url", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)


if not MYPY:
    class DatasetBinarySftpServerLocationArgsDict(TypedDict):
        filename: pulumi.Input[str]
        """
        The filename of the file on the SFTP server.
        """
        path: pulumi.Input[str]
        """
        The folder path to the file on the SFTP server.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
elif False:
    DatasetBinarySftpServerLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetBinarySftpServerLocationArgs:
    def __init__(__self__, *,
                 filename: pulumi.Input[str],
                 path: pulumi.Input[str],
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] filename: The filename of the file on the SFTP server.
        :param pulumi.Input[str] path: The folder path to the file on the SFTP server.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        The filename of the file on the SFTP server.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The folder path to the file on the SFTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)


if not MYPY:
    class DatasetCosmosDBApiSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetCosmosDBApiSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetCosmosDBApiSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetDelimitedTextAzureBlobFsLocationArgsDict(TypedDict):
        dynamic_file_system_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        file_system: NotRequired[pulumi.Input[str]]
        """
        The storage data lake gen2 file system on the Azure Blob Storage Account hosting the file.
        """
        filename: NotRequired[pulumi.Input[str]]
        """
        The filename of the file.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The folder path to the file.
        """
elif False:
    DatasetDelimitedTextAzureBlobFsLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetDelimitedTextAzureBlobFsLocationArgs:
    def __init__(__self__, *,
                 dynamic_file_system_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None,
                 file_system: Optional[pulumi.Input[str]] = None,
                 filename: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] dynamic_file_system_enabled: Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[str] file_system: The storage data lake gen2 file system on the Azure Blob Storage Account hosting the file.
        :param pulumi.Input[str] filename: The filename of the file.
        :param pulumi.Input[str] path: The folder path to the file.
        """
        if dynamic_file_system_enabled is not None:
            pulumi.set(__self__, "dynamic_file_system_enabled", dynamic_file_system_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="dynamicFileSystemEnabled")
    def dynamic_file_system_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_file_system_enabled")

    @dynamic_file_system_enabled.setter
    def dynamic_file_system_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_file_system_enabled", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input[str]]:
        """
        The storage data lake gen2 file system on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_system", value)

    @property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[str]]:
        """
        The filename of the file.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The folder path to the file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class DatasetDelimitedTextAzureBlobStorageLocationArgsDict(TypedDict):
        container: pulumi.Input[str]
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        dynamic_container_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        filename: NotRequired[pulumi.Input[str]]
        """
        The filename of the file.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The folder path to the file. This can be an empty string.
        """
elif False:
    DatasetDelimitedTextAzureBlobStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetDelimitedTextAzureBlobStorageLocationArgs:
    def __init__(__self__, *,
                 container: pulumi.Input[str],
                 dynamic_container_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None,
                 filename: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] container: The container on the Azure Blob Storage Account hosting the file.
        :param pulumi.Input[bool] dynamic_container_enabled: Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[str] filename: The filename of the file.
        :param pulumi.Input[str] path: The folder path to the file. This can be an empty string.
        """
        pulumi.set(__self__, "container", container)
        if dynamic_container_enabled is not None:
            pulumi.set(__self__, "dynamic_container_enabled", dynamic_container_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input[str]:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[str]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="dynamicContainerEnabled")
    def dynamic_container_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_container_enabled")

    @dynamic_container_enabled.setter
    def dynamic_container_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_container_enabled", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)

    @property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[str]]:
        """
        The filename of the file.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The folder path to the file. This can be an empty string.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class DatasetDelimitedTextHttpServerLocationArgsDict(TypedDict):
        filename: pulumi.Input[str]
        """
        The filename of the file on the web server.
        """
        path: pulumi.Input[str]
        """
        The folder path to the file on the web server.
        """
        relative_url: pulumi.Input[str]
        """
        The base URL to the web server hosting the file.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
elif False:
    DatasetDelimitedTextHttpServerLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetDelimitedTextHttpServerLocationArgs:
    def __init__(__self__, *,
                 filename: pulumi.Input[str],
                 path: pulumi.Input[str],
                 relative_url: pulumi.Input[str],
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] filename: The filename of the file on the web server.
        :param pulumi.Input[str] path: The folder path to the file on the web server.
        :param pulumi.Input[str] relative_url: The base URL to the web server hosting the file.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> pulumi.Input[str]:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @relative_url.setter
    def relative_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_url", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)


if not MYPY:
    class DatasetDelimitedTextSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetDelimitedTextSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetDelimitedTextSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetHttpSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetHttpSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetHttpSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetJsonAzureBlobStorageLocationArgsDict(TypedDict):
        container: pulumi.Input[str]
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        filename: pulumi.Input[str]
        """
        The filename of the file on the web server.
        """
        path: pulumi.Input[str]
        """
        The folder path to the file on the web server.
        """
        dynamic_container_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
elif False:
    DatasetJsonAzureBlobStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetJsonAzureBlobStorageLocationArgs:
    def __init__(__self__, *,
                 container: pulumi.Input[str],
                 filename: pulumi.Input[str],
                 path: pulumi.Input[str],
                 dynamic_container_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] container: The container on the Azure Blob Storage Account hosting the file.
        :param pulumi.Input[str] filename: The filename of the file on the web server.
        :param pulumi.Input[str] path: The folder path to the file on the web server.
        :param pulumi.Input[bool] dynamic_container_enabled: Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        if dynamic_container_enabled is not None:
            pulumi.set(__self__, "dynamic_container_enabled", dynamic_container_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input[str]:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[str]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="dynamicContainerEnabled")
    def dynamic_container_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_container_enabled")

    @dynamic_container_enabled.setter
    def dynamic_container_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_container_enabled", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)


if not MYPY:
    class DatasetJsonHttpServerLocationArgsDict(TypedDict):
        filename: pulumi.Input[str]
        """
        The filename of the file on the web server.
        """
        path: pulumi.Input[str]
        """
        The folder path to the file on the web server.
        """
        relative_url: pulumi.Input[str]
        """
        The base URL to the web server hosting the file.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
elif False:
    DatasetJsonHttpServerLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetJsonHttpServerLocationArgs:
    def __init__(__self__, *,
                 filename: pulumi.Input[str],
                 path: pulumi.Input[str],
                 relative_url: pulumi.Input[str],
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] filename: The filename of the file on the web server.
        :param pulumi.Input[str] path: The folder path to the file on the web server.
        :param pulumi.Input[str] relative_url: The base URL to the web server hosting the file.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> pulumi.Input[str]:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @relative_url.setter
    def relative_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_url", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)


if not MYPY:
    class DatasetJsonSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetJsonSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetJsonSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetMysqlSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetMysqlSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetMysqlSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetParquetAzureBlobFsLocationArgsDict(TypedDict):
        dynamic_file_system_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        file_system: NotRequired[pulumi.Input[str]]
        """
        The container on the Azure Data Lake Storage Account hosting the file.
        """
        filename: NotRequired[pulumi.Input[str]]
        """
        The filename of the file on the Azure Data Lake Storage Account.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The folder path to the file on the Azure Data Lake Storage Account.
        """
elif False:
    DatasetParquetAzureBlobFsLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetParquetAzureBlobFsLocationArgs:
    def __init__(__self__, *,
                 dynamic_file_system_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None,
                 file_system: Optional[pulumi.Input[str]] = None,
                 filename: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] dynamic_file_system_enabled: Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[str] file_system: The container on the Azure Data Lake Storage Account hosting the file.
        :param pulumi.Input[str] filename: The filename of the file on the Azure Data Lake Storage Account.
        :param pulumi.Input[str] path: The folder path to the file on the Azure Data Lake Storage Account.
        """
        if dynamic_file_system_enabled is not None:
            pulumi.set(__self__, "dynamic_file_system_enabled", dynamic_file_system_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="dynamicFileSystemEnabled")
    def dynamic_file_system_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `file_system` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_file_system_enabled")

    @dynamic_file_system_enabled.setter
    def dynamic_file_system_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_file_system_enabled", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input[str]]:
        """
        The container on the Azure Data Lake Storage Account hosting the file.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_system", value)

    @property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[str]]:
        """
        The filename of the file on the Azure Data Lake Storage Account.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The folder path to the file on the Azure Data Lake Storage Account.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class DatasetParquetAzureBlobStorageLocationArgsDict(TypedDict):
        container: pulumi.Input[str]
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        dynamic_container_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        filename: NotRequired[pulumi.Input[str]]
        """
        The filename of the file on the Azure Blob Storage Account.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The folder path to the file on the Azure Blob Storage Account.
        """
elif False:
    DatasetParquetAzureBlobStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetParquetAzureBlobStorageLocationArgs:
    def __init__(__self__, *,
                 container: pulumi.Input[str],
                 dynamic_container_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None,
                 filename: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] container: The container on the Azure Blob Storage Account hosting the file.
        :param pulumi.Input[bool] dynamic_container_enabled: Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[str] filename: The filename of the file on the Azure Blob Storage Account.
        :param pulumi.Input[str] path: The folder path to the file on the Azure Blob Storage Account.
        """
        pulumi.set(__self__, "container", container)
        if dynamic_container_enabled is not None:
            pulumi.set(__self__, "dynamic_container_enabled", dynamic_container_enabled)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input[str]:
        """
        The container on the Azure Blob Storage Account hosting the file.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[str]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="dynamicContainerEnabled")
    def dynamic_container_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_container_enabled")

    @dynamic_container_enabled.setter
    def dynamic_container_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_container_enabled", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)

    @property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[str]]:
        """
        The filename of the file on the Azure Blob Storage Account.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The folder path to the file on the Azure Blob Storage Account.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class DatasetParquetHttpServerLocationArgsDict(TypedDict):
        filename: pulumi.Input[str]
        """
        The filename of the file on the web server.
        """
        relative_url: pulumi.Input[str]
        """
        The base URL to the web server hosting the file.
        """
        dynamic_filename_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        dynamic_path_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The folder path to the file on the web server.
        """
elif False:
    DatasetParquetHttpServerLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetParquetHttpServerLocationArgs:
    def __init__(__self__, *,
                 filename: pulumi.Input[str],
                 relative_url: pulumi.Input[str],
                 dynamic_filename_enabled: Optional[pulumi.Input[bool]] = None,
                 dynamic_path_enabled: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] filename: The filename of the file on the web server.
        :param pulumi.Input[str] relative_url: The base URL to the web server hosting the file.
        :param pulumi.Input[bool] dynamic_filename_enabled: Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[bool] dynamic_path_enabled: Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        :param pulumi.Input[str] path: The folder path to the file on the web server.
        """
        pulumi.set(__self__, "filename", filename)
        pulumi.set(__self__, "relative_url", relative_url)
        if dynamic_filename_enabled is not None:
            pulumi.set(__self__, "dynamic_filename_enabled", dynamic_filename_enabled)
        if dynamic_path_enabled is not None:
            pulumi.set(__self__, "dynamic_path_enabled", dynamic_path_enabled)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        The filename of the file on the web server.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> pulumi.Input[str]:
        """
        The base URL to the web server hosting the file.
        """
        return pulumi.get(self, "relative_url")

    @relative_url.setter
    def relative_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_url", value)

    @property
    @pulumi.getter(name="dynamicFilenameEnabled")
    def dynamic_filename_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_filename_enabled")

    @dynamic_filename_enabled.setter
    def dynamic_filename_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_filename_enabled", value)

    @property
    @pulumi.getter(name="dynamicPathEnabled")
    def dynamic_path_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
        """
        return pulumi.get(self, "dynamic_path_enabled")

    @dynamic_path_enabled.setter
    def dynamic_path_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic_path_enabled", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The folder path to the file on the web server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class DatasetParquetSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetParquetSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetParquetSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetPostgresqlSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetPostgresqlSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetPostgresqlSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetSnowflakeSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        The total number of digits allowed.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        The number of digits allowed to the right of the decimal point.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `NUMBER`, `DECIMAL`, `NUMERIC`, `INT`, `INTEGER`, `BIGINT`, `SMALLINT`, `FLOAT``FLOAT4`, `FLOAT8`, `DOUBLE`, `DOUBLE PRECISION`, `REAL`, `VARCHAR`, `CHAR`, `CHARACTER`, `STRING`, `TEXT`, `BINARY`, `VARBINARY`, `BOOLEAN`, `DATE`, `DATETIME`, `TIME`, `TIMESTAMP`, `TIMESTAMP_LTZ`, `TIMESTAMP_NTZ`, `TIMESTAMP_TZ`, `VARIANT`, `OBJECT`, `ARRAY`, `GEOGRAPHY`. Please note these values are case sensitive.
        """
elif False:
    DatasetSnowflakeSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetSnowflakeSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 precision: Optional[pulumi.Input[int]] = None,
                 scale: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[int] precision: The total number of digits allowed.
        :param pulumi.Input[int] scale: The number of digits allowed to the right of the decimal point.
        :param pulumi.Input[str] type: Type of the column. Valid values are `NUMBER`, `DECIMAL`, `NUMERIC`, `INT`, `INTEGER`, `BIGINT`, `SMALLINT`, `FLOAT``FLOAT4`, `FLOAT8`, `DOUBLE`, `DOUBLE PRECISION`, `REAL`, `VARCHAR`, `CHAR`, `CHARACTER`, `STRING`, `TEXT`, `BINARY`, `VARBINARY`, `BOOLEAN`, `DATE`, `DATETIME`, `TIME`, `TIMESTAMP`, `TIMESTAMP_LTZ`, `TIMESTAMP_NTZ`, `TIMESTAMP_TZ`, `VARIANT`, `OBJECT`, `ARRAY`, `GEOGRAPHY`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of digits allowed.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        The number of digits allowed to the right of the decimal point.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `NUMBER`, `DECIMAL`, `NUMERIC`, `INT`, `INTEGER`, `BIGINT`, `SMALLINT`, `FLOAT``FLOAT4`, `FLOAT8`, `DOUBLE`, `DOUBLE PRECISION`, `REAL`, `VARCHAR`, `CHAR`, `CHARACTER`, `STRING`, `TEXT`, `BINARY`, `VARBINARY`, `BOOLEAN`, `DATE`, `DATETIME`, `TIME`, `TIMESTAMP`, `TIMESTAMP_LTZ`, `TIMESTAMP_NTZ`, `TIMESTAMP_TZ`, `VARIANT`, `OBJECT`, `ARRAY`, `GEOGRAPHY`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetSqlServerTableSchemaColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
elif False:
    DatasetSqlServerTableSchemaColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetSqlServerTableSchemaColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the column.
        :param pulumi.Input[str] description: The description of the column.
        :param pulumi.Input[str] type: Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FactoryGithubConfigurationArgsDict(TypedDict):
        account_name: pulumi.Input[str]
        """
        Specifies the GitHub account name.
        """
        branch_name: pulumi.Input[str]
        """
        Specifies the branch of the repository to get code from.
        """
        repository_name: pulumi.Input[str]
        """
        Specifies the name of the git repository.
        """
        root_folder: pulumi.Input[str]
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        git_url: NotRequired[pulumi.Input[str]]
        """
        Specifies the GitHub Enterprise host name. For example: <https://github.mydomain.com>. Use <https://github.com> for open source repositories.
        """
        publishing_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is automated publishing enabled? Defaults to `true`.

        > **Note:** You must log in to the Data Factory management UI to complete the authentication to the GitHub repository.
        """
elif False:
    FactoryGithubConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FactoryGithubConfigurationArgs:
    def __init__(__self__, *,
                 account_name: pulumi.Input[str],
                 branch_name: pulumi.Input[str],
                 repository_name: pulumi.Input[str],
                 root_folder: pulumi.Input[str],
                 git_url: Optional[pulumi.Input[str]] = None,
                 publishing_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] account_name: Specifies the GitHub account name.
        :param pulumi.Input[str] branch_name: Specifies the branch of the repository to get code from.
        :param pulumi.Input[str] repository_name: Specifies the name of the git repository.
        :param pulumi.Input[str] root_folder: Specifies the root folder within the repository. Set to `/` for the top level.
        :param pulumi.Input[str] git_url: Specifies the GitHub Enterprise host name. For example: <https://github.mydomain.com>. Use <https://github.com> for open source repositories.
        :param pulumi.Input[bool] publishing_enabled: Is automated publishing enabled? Defaults to `true`.
               
               > **Note:** You must log in to the Data Factory management UI to complete the authentication to the GitHub repository.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        if git_url is not None:
            pulumi.set(__self__, "git_url", git_url)
        if publishing_enabled is not None:
            pulumi.set(__self__, "publishing_enabled", publishing_enabled)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        Specifies the GitHub account name.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> pulumi.Input[str]:
        """
        Specifies the branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_name", value)

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> pulumi.Input[str]:
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        return pulumi.get(self, "root_folder")

    @root_folder.setter
    def root_folder(self, value: pulumi.Input[str]):
        pulumi.set(self, "root_folder", value)

    @property
    @pulumi.getter(name="gitUrl")
    def git_url(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the GitHub Enterprise host name. For example: <https://github.mydomain.com>. Use <https://github.com> for open source repositories.
        """
        return pulumi.get(self, "git_url")

    @git_url.setter
    def git_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "git_url", value)

    @property
    @pulumi.getter(name="publishingEnabled")
    def publishing_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is automated publishing enabled? Defaults to `true`.

        > **Note:** You must log in to the Data Factory management UI to complete the authentication to the GitHub repository.
        """
        return pulumi.get(self, "publishing_enabled")

    @publishing_enabled.setter
    def publishing_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "publishing_enabled", value)


if not MYPY:
    class FactoryGlobalParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Specifies the global parameter name.
        """
        type: pulumi.Input[str]
        """
        Specifies the global parameter type. Possible Values are `Array`, `Bool`, `Float`, `Int`, `Object` or `String`.
        """
        value: pulumi.Input[str]
        """
        Specifies the global parameter value.

        > **Note:** For type `Array` and `Object` it is recommended to use `jsonencode()` for the value
        """
elif False:
    FactoryGlobalParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FactoryGlobalParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Specifies the global parameter name.
        :param pulumi.Input[str] type: Specifies the global parameter type. Possible Values are `Array`, `Bool`, `Float`, `Int`, `Object` or `String`.
        :param pulumi.Input[str] value: Specifies the global parameter value.
               
               > **Note:** For type `Array` and `Object` it is recommended to use `jsonencode()` for the value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the global parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the global parameter type. Possible Values are `Array`, `Bool`, `Float`, `Int`, `Object` or `String`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Specifies the global parameter value.

        > **Note:** For type `Array` and `Object` it is recommended to use `jsonencode()` for the value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FactoryIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Data Factory. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Data Factory.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    FactoryIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FactoryIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Data Factory. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Data Factory.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Data Factory. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Data Factory.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class FactoryVstsConfigurationArgsDict(TypedDict):
        account_name: pulumi.Input[str]
        """
        Specifies the VSTS account name.
        """
        branch_name: pulumi.Input[str]
        """
        Specifies the branch of the repository to get code from.
        """
        project_name: pulumi.Input[str]
        """
        Specifies the name of the VSTS project.
        """
        repository_name: pulumi.Input[str]
        """
        Specifies the name of the git repository.
        """
        root_folder: pulumi.Input[str]
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        tenant_id: pulumi.Input[str]
        """
        Specifies the Tenant ID associated with the VSTS account.
        """
        publishing_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is automated publishing enabled? Defaults to `true`.
        """
elif False:
    FactoryVstsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FactoryVstsConfigurationArgs:
    def __init__(__self__, *,
                 account_name: pulumi.Input[str],
                 branch_name: pulumi.Input[str],
                 project_name: pulumi.Input[str],
                 repository_name: pulumi.Input[str],
                 root_folder: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 publishing_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] account_name: Specifies the VSTS account name.
        :param pulumi.Input[str] branch_name: Specifies the branch of the repository to get code from.
        :param pulumi.Input[str] project_name: Specifies the name of the VSTS project.
        :param pulumi.Input[str] repository_name: Specifies the name of the git repository.
        :param pulumi.Input[str] root_folder: Specifies the root folder within the repository. Set to `/` for the top level.
        :param pulumi.Input[str] tenant_id: Specifies the Tenant ID associated with the VSTS account.
        :param pulumi.Input[bool] publishing_enabled: Is automated publishing enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if publishing_enabled is not None:
            pulumi.set(__self__, "publishing_enabled", publishing_enabled)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        Specifies the VSTS account name.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> pulumi.Input[str]:
        """
        Specifies the branch of the repository to get code from.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the VSTS project.
        """
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the git repository.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_name", value)

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> pulumi.Input[str]:
        """
        Specifies the root folder within the repository. Set to `/` for the top level.
        """
        return pulumi.get(self, "root_folder")

    @root_folder.setter
    def root_folder(self, value: pulumi.Input[str]):
        pulumi.set(self, "root_folder", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Specifies the Tenant ID associated with the VSTS account.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="publishingEnabled")
    def publishing_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is automated publishing enabled? Defaults to `true`.
        """
        return pulumi.get(self, "publishing_enabled")

    @publishing_enabled.setter
    def publishing_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "publishing_enabled", value)


if not MYPY:
    class FlowletDataFlowSinkArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Flow Source.
        """
        dataset: NotRequired[pulumi.Input['FlowletDataFlowSinkDatasetArgsDict']]
        """
        A `dataset` block as defined below.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description for the Data Flow Source.
        """
        flowlet: NotRequired[pulumi.Input['FlowletDataFlowSinkFlowletArgsDict']]
        """
        A `flowlet` block as defined below.
        """
        linked_service: NotRequired[pulumi.Input['FlowletDataFlowSinkLinkedServiceArgsDict']]
        """
        A `linked_service` block as defined below.
        """
        rejected_linked_service: NotRequired[pulumi.Input['FlowletDataFlowSinkRejectedLinkedServiceArgsDict']]
        """
        A `rejected_linked_service` block as defined below.
        """
        schema_linked_service: NotRequired[pulumi.Input['FlowletDataFlowSinkSchemaLinkedServiceArgsDict']]
        """
        A `schema_linked_service` block as defined below.
        """
elif False:
    FlowletDataFlowSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['FlowletDataFlowSinkDatasetArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['FlowletDataFlowSinkFlowletArgs']] = None,
                 linked_service: Optional[pulumi.Input['FlowletDataFlowSinkLinkedServiceArgs']] = None,
                 rejected_linked_service: Optional[pulumi.Input['FlowletDataFlowSinkRejectedLinkedServiceArgs']] = None,
                 schema_linked_service: Optional[pulumi.Input['FlowletDataFlowSinkSchemaLinkedServiceArgs']] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Flow Source.
        :param pulumi.Input['FlowletDataFlowSinkDatasetArgs'] dataset: A `dataset` block as defined below.
        :param pulumi.Input[str] description: The description for the Data Flow Source.
        :param pulumi.Input['FlowletDataFlowSinkFlowletArgs'] flowlet: A `flowlet` block as defined below.
        :param pulumi.Input['FlowletDataFlowSinkLinkedServiceArgs'] linked_service: A `linked_service` block as defined below.
        :param pulumi.Input['FlowletDataFlowSinkRejectedLinkedServiceArgs'] rejected_linked_service: A `rejected_linked_service` block as defined below.
        :param pulumi.Input['FlowletDataFlowSinkSchemaLinkedServiceArgs'] schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if rejected_linked_service is not None:
            pulumi.set(__self__, "rejected_linked_service", rejected_linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['FlowletDataFlowSinkDatasetArgs']]:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['FlowletDataFlowSinkDatasetArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['FlowletDataFlowSinkFlowletArgs']]:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['FlowletDataFlowSinkFlowletArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['FlowletDataFlowSinkLinkedServiceArgs']]:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['FlowletDataFlowSinkLinkedServiceArgs']]):
        pulumi.set(self, "linked_service", value)

    @property
    @pulumi.getter(name="rejectedLinkedService")
    def rejected_linked_service(self) -> Optional[pulumi.Input['FlowletDataFlowSinkRejectedLinkedServiceArgs']]:
        """
        A `rejected_linked_service` block as defined below.
        """
        return pulumi.get(self, "rejected_linked_service")

    @rejected_linked_service.setter
    def rejected_linked_service(self, value: Optional[pulumi.Input['FlowletDataFlowSinkRejectedLinkedServiceArgs']]):
        pulumi.set(self, "rejected_linked_service", value)

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional[pulumi.Input['FlowletDataFlowSinkSchemaLinkedServiceArgs']]:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")

    @schema_linked_service.setter
    def schema_linked_service(self, value: Optional[pulumi.Input['FlowletDataFlowSinkSchemaLinkedServiceArgs']]):
        pulumi.set(self, "schema_linked_service", value)


if not MYPY:
    class FlowletDataFlowSinkDatasetArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory dataset.
        """
elif False:
    FlowletDataFlowSinkDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSinkDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowSinkFlowletArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Flowlet.
        """
        dataset_parameters: NotRequired[pulumi.Input[str]]
        """
        Specifies the reference data flow parameters from dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
elif False:
    FlowletDataFlowSinkFlowletArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSinkFlowletArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset_parameters: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Flowlet.
        :param pulumi.Input[str] dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @dataset_parameters.setter
    def dataset_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_parameters", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowSinkLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    FlowletDataFlowSinkLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSinkLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowSinkRejectedLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service with schema.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    FlowletDataFlowSinkRejectedLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSinkRejectedLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service with schema.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowSinkSchemaLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service with schema.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    FlowletDataFlowSinkSchemaLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSinkSchemaLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service with schema.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowSourceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Flow Source.
        """
        dataset: NotRequired[pulumi.Input['FlowletDataFlowSourceDatasetArgsDict']]
        """
        A `dataset` block as defined below.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description for the Data Flow Source.
        """
        flowlet: NotRequired[pulumi.Input['FlowletDataFlowSourceFlowletArgsDict']]
        """
        A `flowlet` block as defined below.
        """
        linked_service: NotRequired[pulumi.Input['FlowletDataFlowSourceLinkedServiceArgsDict']]
        """
        A `linked_service` block as defined below.
        """
        rejected_linked_service: NotRequired[pulumi.Input['FlowletDataFlowSourceRejectedLinkedServiceArgsDict']]
        """
        A `rejected_linked_service` block as defined below.
        """
        schema_linked_service: NotRequired[pulumi.Input['FlowletDataFlowSourceSchemaLinkedServiceArgsDict']]
        """
        A `schema_linked_service` block as defined below.
        """
elif False:
    FlowletDataFlowSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['FlowletDataFlowSourceDatasetArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['FlowletDataFlowSourceFlowletArgs']] = None,
                 linked_service: Optional[pulumi.Input['FlowletDataFlowSourceLinkedServiceArgs']] = None,
                 rejected_linked_service: Optional[pulumi.Input['FlowletDataFlowSourceRejectedLinkedServiceArgs']] = None,
                 schema_linked_service: Optional[pulumi.Input['FlowletDataFlowSourceSchemaLinkedServiceArgs']] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Flow Source.
        :param pulumi.Input['FlowletDataFlowSourceDatasetArgs'] dataset: A `dataset` block as defined below.
        :param pulumi.Input[str] description: The description for the Data Flow Source.
        :param pulumi.Input['FlowletDataFlowSourceFlowletArgs'] flowlet: A `flowlet` block as defined below.
        :param pulumi.Input['FlowletDataFlowSourceLinkedServiceArgs'] linked_service: A `linked_service` block as defined below.
        :param pulumi.Input['FlowletDataFlowSourceRejectedLinkedServiceArgs'] rejected_linked_service: A `rejected_linked_service` block as defined below.
        :param pulumi.Input['FlowletDataFlowSourceSchemaLinkedServiceArgs'] schema_linked_service: A `schema_linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if rejected_linked_service is not None:
            pulumi.set(__self__, "rejected_linked_service", rejected_linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Flow Source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['FlowletDataFlowSourceDatasetArgs']]:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['FlowletDataFlowSourceDatasetArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for the Data Flow Source.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['FlowletDataFlowSourceFlowletArgs']]:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['FlowletDataFlowSourceFlowletArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['FlowletDataFlowSourceLinkedServiceArgs']]:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['FlowletDataFlowSourceLinkedServiceArgs']]):
        pulumi.set(self, "linked_service", value)

    @property
    @pulumi.getter(name="rejectedLinkedService")
    def rejected_linked_service(self) -> Optional[pulumi.Input['FlowletDataFlowSourceRejectedLinkedServiceArgs']]:
        """
        A `rejected_linked_service` block as defined below.
        """
        return pulumi.get(self, "rejected_linked_service")

    @rejected_linked_service.setter
    def rejected_linked_service(self, value: Optional[pulumi.Input['FlowletDataFlowSourceRejectedLinkedServiceArgs']]):
        pulumi.set(self, "rejected_linked_service", value)

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional[pulumi.Input['FlowletDataFlowSourceSchemaLinkedServiceArgs']]:
        """
        A `schema_linked_service` block as defined below.
        """
        return pulumi.get(self, "schema_linked_service")

    @schema_linked_service.setter
    def schema_linked_service(self, value: Optional[pulumi.Input['FlowletDataFlowSourceSchemaLinkedServiceArgs']]):
        pulumi.set(self, "schema_linked_service", value)


if not MYPY:
    class FlowletDataFlowSourceDatasetArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory dataset.
        """
elif False:
    FlowletDataFlowSourceDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSourceDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowSourceFlowletArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Flowlet.
        """
        dataset_parameters: NotRequired[pulumi.Input[str]]
        """
        Specifies the reference data flow parameters from dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
elif False:
    FlowletDataFlowSourceFlowletArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSourceFlowletArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset_parameters: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Flowlet.
        :param pulumi.Input[str] dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @dataset_parameters.setter
    def dataset_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_parameters", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowSourceLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    FlowletDataFlowSourceLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSourceLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowSourceRejectedLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service with schema.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    FlowletDataFlowSourceRejectedLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSourceRejectedLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service with schema.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowSourceSchemaLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service with schema.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    FlowletDataFlowSourceSchemaLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowSourceSchemaLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service with schema.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service with schema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowTransformationArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Flow transformation.
        """
        dataset: NotRequired[pulumi.Input['FlowletDataFlowTransformationDatasetArgsDict']]
        """
        A `dataset` block as defined below.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description for the Data Flow transformation.
        """
        flowlet: NotRequired[pulumi.Input['FlowletDataFlowTransformationFlowletArgsDict']]
        """
        A `flowlet` block as defined below.
        """
        linked_service: NotRequired[pulumi.Input['FlowletDataFlowTransformationLinkedServiceArgsDict']]
        """
        A `linked_service` block as defined below.
        """
elif False:
    FlowletDataFlowTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowTransformationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset: Optional[pulumi.Input['FlowletDataFlowTransformationDatasetArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 flowlet: Optional[pulumi.Input['FlowletDataFlowTransformationFlowletArgs']] = None,
                 linked_service: Optional[pulumi.Input['FlowletDataFlowTransformationLinkedServiceArgs']] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Flow transformation.
        :param pulumi.Input['FlowletDataFlowTransformationDatasetArgs'] dataset: A `dataset` block as defined below.
        :param pulumi.Input[str] description: The description for the Data Flow transformation.
        :param pulumi.Input['FlowletDataFlowTransformationFlowletArgs'] flowlet: A `flowlet` block as defined below.
        :param pulumi.Input['FlowletDataFlowTransformationLinkedServiceArgs'] linked_service: A `linked_service` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flowlet is not None:
            pulumi.set(__self__, "flowlet", flowlet)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Flow transformation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['FlowletDataFlowTransformationDatasetArgs']]:
        """
        A `dataset` block as defined below.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['FlowletDataFlowTransformationDatasetArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for the Data Flow transformation.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def flowlet(self) -> Optional[pulumi.Input['FlowletDataFlowTransformationFlowletArgs']]:
        """
        A `flowlet` block as defined below.
        """
        return pulumi.get(self, "flowlet")

    @flowlet.setter
    def flowlet(self, value: Optional[pulumi.Input['FlowletDataFlowTransformationFlowletArgs']]):
        pulumi.set(self, "flowlet", value)

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional[pulumi.Input['FlowletDataFlowTransformationLinkedServiceArgs']]:
        """
        A `linked_service` block as defined below.
        """
        return pulumi.get(self, "linked_service")

    @linked_service.setter
    def linked_service(self, value: Optional[pulumi.Input['FlowletDataFlowTransformationLinkedServiceArgs']]):
        pulumi.set(self, "linked_service", value)


if not MYPY:
    class FlowletDataFlowTransformationDatasetArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory dataset.
        """
elif False:
    FlowletDataFlowTransformationDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowTransformationDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory dataset.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory dataset.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowTransformationFlowletArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Flowlet.
        """
        dataset_parameters: NotRequired[pulumi.Input[str]]
        """
        Specifies the reference data flow parameters from dataset.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
elif False:
    FlowletDataFlowTransformationFlowletArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowTransformationFlowletArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 dataset_parameters: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Flowlet.
        :param pulumi.Input[str] dataset_parameters: Specifies the reference data flow parameters from dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Flowlet.
        """
        pulumi.set(__self__, "name", name)
        if dataset_parameters is not None:
            pulumi.set(__self__, "dataset_parameters", dataset_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Flowlet.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="datasetParameters")
    def dataset_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the reference data flow parameters from dataset.
        """
        return pulumi.get(self, "dataset_parameters")

    @dataset_parameters.setter
    def dataset_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_parameters", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Flowlet.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class FlowletDataFlowTransformationLinkedServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the Data Factory Linked Service.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
elif False:
    FlowletDataFlowTransformationLinkedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowletDataFlowTransformationLinkedServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the Data Factory Linked Service.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Data Factory Linked Service.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class IntegrationRuntimeSelfHostedRbacAuthorizationArgsDict(TypedDict):
        resource_id: pulumi.Input[str]
        """
        The resource identifier of the integration runtime to be shared.

        > **Please Note**: RBAC Authorization creates a [linked Self-hosted Integration Runtime targeting the Shared Self-hosted Integration Runtime in resource_id](https://docs.microsoft.com/azure/data-factory/create-shared-self-hosted-integration-runtime-powershell#share-the-self-hosted-integration-runtime-with-another-data-factory). The linked Self-hosted Integration Runtime needs Contributor access granted to the Shared Self-hosted Data Factory.

        For more information on the configuration, please check out the [Azure documentation](https://docs.microsoft.com/rest/api/datafactory/integrationruntimes/createorupdate#linkedintegrationruntimerbacauthorization)
        """
elif False:
    IntegrationRuntimeSelfHostedRbacAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSelfHostedRbacAuthorizationArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] resource_id: The resource identifier of the integration runtime to be shared.
               
               > **Please Note**: RBAC Authorization creates a [linked Self-hosted Integration Runtime targeting the Shared Self-hosted Integration Runtime in resource_id](https://docs.microsoft.com/azure/data-factory/create-shared-self-hosted-integration-runtime-powershell#share-the-self-hosted-integration-runtime-with-another-data-factory). The linked Self-hosted Integration Runtime needs Contributor access granted to the Shared Self-hosted Data Factory.
               
               For more information on the configuration, please check out the [Azure documentation](https://docs.microsoft.com/rest/api/datafactory/integrationruntimes/createorupdate#linkedintegrationruntimerbacauthorization)
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        The resource identifier of the integration runtime to be shared.

        > **Please Note**: RBAC Authorization creates a [linked Self-hosted Integration Runtime targeting the Shared Self-hosted Integration Runtime in resource_id](https://docs.microsoft.com/azure/data-factory/create-shared-self-hosted-integration-runtime-powershell#share-the-self-hosted-integration-runtime-with-another-data-factory). The linked Self-hosted Integration Runtime needs Contributor access granted to the Shared Self-hosted Data Factory.

        For more information on the configuration, please check out the [Azure documentation](https://docs.microsoft.com/rest/api/datafactory/integrationruntimes/createorupdate#linkedintegrationruntimerbacauthorization)
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class IntegrationRuntimeSsisCatalogInfoArgsDict(TypedDict):
        server_endpoint: pulumi.Input[str]
        """
        The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        """
        administrator_login: NotRequired[pulumi.Input[str]]
        """
        Administrator login name for the SQL Server.
        """
        administrator_password: NotRequired[pulumi.Input[str]]
        """
        Administrator login password for the SQL Server.
        """
        dual_standby_pair_name: NotRequired[pulumi.Input[str]]
        """
        The dual standby Azure-SSIS Integration Runtime pair with SSISDB failover.
        """
        elastic_pool_name: NotRequired[pulumi.Input[str]]
        """
        The name of SQL elastic pool where the database will be created for the SSIS catalog. Mutually exclusive with `pricing_tier`.
        """
        pricing_tier: NotRequired[pulumi.Input[str]]
        """
        Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `S0`, `S1`, `S2`, `S3`, `S4`, `S6`, `S7`, `S9`, `S12`, `P1`, `P2`, `P4`, `P6`, `P11`, `P15`, `GP_S_Gen5_1`, `GP_S_Gen5_2`, `GP_S_Gen5_4`, `GP_S_Gen5_6`, `GP_S_Gen5_8`, `GP_S_Gen5_10`, `GP_S_Gen5_12`, `GP_S_Gen5_14`, `GP_S_Gen5_16`, `GP_S_Gen5_18`, `GP_S_Gen5_20`, `GP_S_Gen5_24`, `GP_S_Gen5_32`, `GP_S_Gen5_40`, `GP_Gen5_2`, `GP_Gen5_4`, `GP_Gen5_6`, `GP_Gen5_8`, `GP_Gen5_10`, `GP_Gen5_12`, `GP_Gen5_14`, `GP_Gen5_16`, `GP_Gen5_18`, `GP_Gen5_20`, `GP_Gen5_24`, `GP_Gen5_32`, `GP_Gen5_40`, `GP_Gen5_80`, `BC_Gen5_2`, `BC_Gen5_4`, `BC_Gen5_6`, `BC_Gen5_8`, `BC_Gen5_10`, `BC_Gen5_12`, `BC_Gen5_14`, `BC_Gen5_16`, `BC_Gen5_18`, `BC_Gen5_20`, `BC_Gen5_24`, `BC_Gen5_32`, `BC_Gen5_40`, `BC_Gen5_80`, `HS_Gen5_2`, `HS_Gen5_4`, `HS_Gen5_6`, `HS_Gen5_8`, `HS_Gen5_10`, `HS_Gen5_12`, `HS_Gen5_14`, `HS_Gen5_16`, `HS_Gen5_18`, `HS_Gen5_20`, `HS_Gen5_24`, `HS_Gen5_32`, `HS_Gen5_40` and `HS_Gen5_80`. Mutually exclusive with `elastic_pool_name`.
        """
elif False:
    IntegrationRuntimeSsisCatalogInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisCatalogInfoArgs:
    def __init__(__self__, *,
                 server_endpoint: pulumi.Input[str],
                 administrator_login: Optional[pulumi.Input[str]] = None,
                 administrator_password: Optional[pulumi.Input[str]] = None,
                 dual_standby_pair_name: Optional[pulumi.Input[str]] = None,
                 elastic_pool_name: Optional[pulumi.Input[str]] = None,
                 pricing_tier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] server_endpoint: The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        :param pulumi.Input[str] administrator_login: Administrator login name for the SQL Server.
        :param pulumi.Input[str] administrator_password: Administrator login password for the SQL Server.
        :param pulumi.Input[str] dual_standby_pair_name: The dual standby Azure-SSIS Integration Runtime pair with SSISDB failover.
        :param pulumi.Input[str] elastic_pool_name: The name of SQL elastic pool where the database will be created for the SSIS catalog. Mutually exclusive with `pricing_tier`.
        :param pulumi.Input[str] pricing_tier: Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `S0`, `S1`, `S2`, `S3`, `S4`, `S6`, `S7`, `S9`, `S12`, `P1`, `P2`, `P4`, `P6`, `P11`, `P15`, `GP_S_Gen5_1`, `GP_S_Gen5_2`, `GP_S_Gen5_4`, `GP_S_Gen5_6`, `GP_S_Gen5_8`, `GP_S_Gen5_10`, `GP_S_Gen5_12`, `GP_S_Gen5_14`, `GP_S_Gen5_16`, `GP_S_Gen5_18`, `GP_S_Gen5_20`, `GP_S_Gen5_24`, `GP_S_Gen5_32`, `GP_S_Gen5_40`, `GP_Gen5_2`, `GP_Gen5_4`, `GP_Gen5_6`, `GP_Gen5_8`, `GP_Gen5_10`, `GP_Gen5_12`, `GP_Gen5_14`, `GP_Gen5_16`, `GP_Gen5_18`, `GP_Gen5_20`, `GP_Gen5_24`, `GP_Gen5_32`, `GP_Gen5_40`, `GP_Gen5_80`, `BC_Gen5_2`, `BC_Gen5_4`, `BC_Gen5_6`, `BC_Gen5_8`, `BC_Gen5_10`, `BC_Gen5_12`, `BC_Gen5_14`, `BC_Gen5_16`, `BC_Gen5_18`, `BC_Gen5_20`, `BC_Gen5_24`, `BC_Gen5_32`, `BC_Gen5_40`, `BC_Gen5_80`, `HS_Gen5_2`, `HS_Gen5_4`, `HS_Gen5_6`, `HS_Gen5_8`, `HS_Gen5_10`, `HS_Gen5_12`, `HS_Gen5_14`, `HS_Gen5_16`, `HS_Gen5_18`, `HS_Gen5_20`, `HS_Gen5_24`, `HS_Gen5_32`, `HS_Gen5_40` and `HS_Gen5_80`. Mutually exclusive with `elastic_pool_name`.
        """
        pulumi.set(__self__, "server_endpoint", server_endpoint)
        if administrator_login is not None:
            pulumi.set(__self__, "administrator_login", administrator_login)
        if administrator_password is not None:
            pulumi.set(__self__, "administrator_password", administrator_password)
        if dual_standby_pair_name is not None:
            pulumi.set(__self__, "dual_standby_pair_name", dual_standby_pair_name)
        if elastic_pool_name is not None:
            pulumi.set(__self__, "elastic_pool_name", elastic_pool_name)
        if pricing_tier is not None:
            pulumi.set(__self__, "pricing_tier", pricing_tier)

    @property
    @pulumi.getter(name="serverEndpoint")
    def server_endpoint(self) -> pulumi.Input[str]:
        """
        The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
        """
        return pulumi.get(self, "server_endpoint")

    @server_endpoint.setter
    def server_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_endpoint", value)

    @property
    @pulumi.getter(name="administratorLogin")
    def administrator_login(self) -> Optional[pulumi.Input[str]]:
        """
        Administrator login name for the SQL Server.
        """
        return pulumi.get(self, "administrator_login")

    @administrator_login.setter
    def administrator_login(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "administrator_login", value)

    @property
    @pulumi.getter(name="administratorPassword")
    def administrator_password(self) -> Optional[pulumi.Input[str]]:
        """
        Administrator login password for the SQL Server.
        """
        return pulumi.get(self, "administrator_password")

    @administrator_password.setter
    def administrator_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "administrator_password", value)

    @property
    @pulumi.getter(name="dualStandbyPairName")
    def dual_standby_pair_name(self) -> Optional[pulumi.Input[str]]:
        """
        The dual standby Azure-SSIS Integration Runtime pair with SSISDB failover.
        """
        return pulumi.get(self, "dual_standby_pair_name")

    @dual_standby_pair_name.setter
    def dual_standby_pair_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dual_standby_pair_name", value)

    @property
    @pulumi.getter(name="elasticPoolName")
    def elastic_pool_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of SQL elastic pool where the database will be created for the SSIS catalog. Mutually exclusive with `pricing_tier`.
        """
        return pulumi.get(self, "elastic_pool_name")

    @elastic_pool_name.setter
    def elastic_pool_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "elastic_pool_name", value)

    @property
    @pulumi.getter(name="pricingTier")
    def pricing_tier(self) -> Optional[pulumi.Input[str]]:
        """
        Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `S0`, `S1`, `S2`, `S3`, `S4`, `S6`, `S7`, `S9`, `S12`, `P1`, `P2`, `P4`, `P6`, `P11`, `P15`, `GP_S_Gen5_1`, `GP_S_Gen5_2`, `GP_S_Gen5_4`, `GP_S_Gen5_6`, `GP_S_Gen5_8`, `GP_S_Gen5_10`, `GP_S_Gen5_12`, `GP_S_Gen5_14`, `GP_S_Gen5_16`, `GP_S_Gen5_18`, `GP_S_Gen5_20`, `GP_S_Gen5_24`, `GP_S_Gen5_32`, `GP_S_Gen5_40`, `GP_Gen5_2`, `GP_Gen5_4`, `GP_Gen5_6`, `GP_Gen5_8`, `GP_Gen5_10`, `GP_Gen5_12`, `GP_Gen5_14`, `GP_Gen5_16`, `GP_Gen5_18`, `GP_Gen5_20`, `GP_Gen5_24`, `GP_Gen5_32`, `GP_Gen5_40`, `GP_Gen5_80`, `BC_Gen5_2`, `BC_Gen5_4`, `BC_Gen5_6`, `BC_Gen5_8`, `BC_Gen5_10`, `BC_Gen5_12`, `BC_Gen5_14`, `BC_Gen5_16`, `BC_Gen5_18`, `BC_Gen5_20`, `BC_Gen5_24`, `BC_Gen5_32`, `BC_Gen5_40`, `BC_Gen5_80`, `HS_Gen5_2`, `HS_Gen5_4`, `HS_Gen5_6`, `HS_Gen5_8`, `HS_Gen5_10`, `HS_Gen5_12`, `HS_Gen5_14`, `HS_Gen5_16`, `HS_Gen5_18`, `HS_Gen5_20`, `HS_Gen5_24`, `HS_Gen5_32`, `HS_Gen5_40` and `HS_Gen5_80`. Mutually exclusive with `elastic_pool_name`.
        """
        return pulumi.get(self, "pricing_tier")

    @pricing_tier.setter
    def pricing_tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pricing_tier", value)


if not MYPY:
    class IntegrationRuntimeSsisCopyComputeScaleArgsDict(TypedDict):
        data_integration_unit: NotRequired[pulumi.Input[int]]
        """
        Specifies the data integration unit number setting reserved for copy activity execution. Supported values are multiples of `4` in range 4-256.
        """
        time_to_live: NotRequired[pulumi.Input[int]]
        """
        Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
elif False:
    IntegrationRuntimeSsisCopyComputeScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisCopyComputeScaleArgs:
    def __init__(__self__, *,
                 data_integration_unit: Optional[pulumi.Input[int]] = None,
                 time_to_live: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] data_integration_unit: Specifies the data integration unit number setting reserved for copy activity execution. Supported values are multiples of `4` in range 4-256.
        :param pulumi.Input[int] time_to_live: Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
        if data_integration_unit is not None:
            pulumi.set(__self__, "data_integration_unit", data_integration_unit)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @property
    @pulumi.getter(name="dataIntegrationUnit")
    def data_integration_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the data integration unit number setting reserved for copy activity execution. Supported values are multiples of `4` in range 4-256.
        """
        return pulumi.get(self, "data_integration_unit")

    @data_integration_unit.setter
    def data_integration_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_integration_unit", value)

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
        return pulumi.get(self, "time_to_live")

    @time_to_live.setter
    def time_to_live(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_to_live", value)


if not MYPY:
    class IntegrationRuntimeSsisCustomSetupScriptArgsDict(TypedDict):
        blob_container_uri: pulumi.Input[str]
        """
        The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        sas_token: pulumi.Input[str]
        """
        A container SAS token that gives access to the files. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
elif False:
    IntegrationRuntimeSsisCustomSetupScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisCustomSetupScriptArgs:
    def __init__(__self__, *,
                 blob_container_uri: pulumi.Input[str],
                 sas_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] blob_container_uri: The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        :param pulumi.Input[str] sas_token: A container SAS token that gives access to the files. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        pulumi.set(__self__, "sas_token", sas_token)

    @property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> pulumi.Input[str]:
        """
        The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "blob_container_uri")

    @blob_container_uri.setter
    def blob_container_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "blob_container_uri", value)

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> pulumi.Input[str]:
        """
        A container SAS token that gives access to the files. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_token", value)


if not MYPY:
    class IntegrationRuntimeSsisExpressCustomSetupArgsDict(TypedDict):
        command_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgsDict']]]]
        """
        One or more `command_key` blocks as defined below.
        """
        components: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentArgsDict']]]]
        """
        One or more `component` blocks as defined below.
        """
        environment: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The Environment Variables for the Azure-SSIS Integration Runtime.
        """
        powershell_version: NotRequired[pulumi.Input[str]]
        """
        The version of Azure Powershell installed for the Azure-SSIS Integration Runtime.

        > **NOTE** At least one of `env`, `powershell_version`, `component` and `command_key` should be specified.
        """
elif False:
    IntegrationRuntimeSsisExpressCustomSetupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisExpressCustomSetupArgs:
    def __init__(__self__, *,
                 command_keys: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgs']]]] = None,
                 components: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentArgs']]]] = None,
                 environment: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 powershell_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgs']]] command_keys: One or more `command_key` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentArgs']]] components: One or more `component` blocks as defined below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment: The Environment Variables for the Azure-SSIS Integration Runtime.
        :param pulumi.Input[str] powershell_version: The version of Azure Powershell installed for the Azure-SSIS Integration Runtime.
               
               > **NOTE** At least one of `env`, `powershell_version`, `component` and `command_key` should be specified.
        """
        if command_keys is not None:
            pulumi.set(__self__, "command_keys", command_keys)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if powershell_version is not None:
            pulumi.set(__self__, "powershell_version", powershell_version)

    @property
    @pulumi.getter(name="commandKeys")
    def command_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgs']]]]:
        """
        One or more `command_key` blocks as defined below.
        """
        return pulumi.get(self, "command_keys")

    @command_keys.setter
    def command_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgs']]]]):
        pulumi.set(self, "command_keys", value)

    @property
    @pulumi.getter
    def components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentArgs']]]]:
        """
        One or more `component` blocks as defined below.
        """
        return pulumi.get(self, "components")

    @components.setter
    def components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentArgs']]]]):
        pulumi.set(self, "components", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The Environment Variables for the Azure-SSIS Integration Runtime.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="powershellVersion")
    def powershell_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Azure Powershell installed for the Azure-SSIS Integration Runtime.

        > **NOTE** At least one of `env`, `powershell_version`, `component` and `command_key` should be specified.
        """
        return pulumi.get(self, "powershell_version")

    @powershell_version.setter
    def powershell_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "powershell_version", value)


if not MYPY:
    class IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgsDict(TypedDict):
        target_name: pulumi.Input[str]
        """
        The target computer or domain name.
        """
        user_name: pulumi.Input[str]
        """
        The username for the target device.
        """
        key_vault_password: NotRequired[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgsDict']]
        """
        A `key_vault_secret_reference` block as defined below.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password for the target device.
        """
elif False:
    IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisExpressCustomSetupCommandKeyArgs:
    def __init__(__self__, *,
                 target_name: pulumi.Input[str],
                 user_name: pulumi.Input[str],
                 key_vault_password: Optional[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgs']] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target_name: The target computer or domain name.
        :param pulumi.Input[str] user_name: The username for the target device.
        :param pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgs'] key_vault_password: A `key_vault_secret_reference` block as defined below.
        :param pulumi.Input[str] password: The password for the target device.
        """
        pulumi.set(__self__, "target_name", target_name)
        pulumi.set(__self__, "user_name", user_name)
        if key_vault_password is not None:
            pulumi.set(__self__, "key_vault_password", key_vault_password)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> pulumi.Input[str]:
        """
        The target computer or domain name.
        """
        return pulumi.get(self, "target_name")

    @target_name.setter
    def target_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_name", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        The username for the target device.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter(name="keyVaultPassword")
    def key_vault_password(self) -> Optional[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgs']]:
        """
        A `key_vault_secret_reference` block as defined below.
        """
        return pulumi.get(self, "key_vault_password")

    @key_vault_password.setter
    def key_vault_password(self, value: Optional[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgs']]):
        pulumi.set(self, "key_vault_password", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password for the target device.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Key Vault Data Factory Linked Service.
        """
        secret_version: NotRequired[pulumi.Input[str]]
        """
        Specifies the secret version in Azure Key Vault.
        """
elif False:
    IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPasswordArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secret_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_version: Specifies the secret version in Azure Key Vault.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the secret version in Azure Key Vault.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_version", value)


if not MYPY:
    class IntegrationRuntimeSsisExpressCustomSetupComponentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The Component Name installed for the Azure-SSIS Integration Runtime.
        """
        key_vault_license: NotRequired[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgsDict']]
        """
        A `key_vault_secret_reference` block as defined below.
        """
        license: NotRequired[pulumi.Input[str]]
        """
        The license used for the Component.
        """
elif False:
    IntegrationRuntimeSsisExpressCustomSetupComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisExpressCustomSetupComponentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 key_vault_license: Optional[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgs']] = None,
                 license: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Component Name installed for the Azure-SSIS Integration Runtime.
        :param pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgs'] key_vault_license: A `key_vault_secret_reference` block as defined below.
        :param pulumi.Input[str] license: The license used for the Component.
        """
        pulumi.set(__self__, "name", name)
        if key_vault_license is not None:
            pulumi.set(__self__, "key_vault_license", key_vault_license)
        if license is not None:
            pulumi.set(__self__, "license", license)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Component Name installed for the Azure-SSIS Integration Runtime.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="keyVaultLicense")
    def key_vault_license(self) -> Optional[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgs']]:
        """
        A `key_vault_secret_reference` block as defined below.
        """
        return pulumi.get(self, "key_vault_license")

    @key_vault_license.setter
    def key_vault_license(self, value: Optional[pulumi.Input['IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgs']]):
        pulumi.set(self, "key_vault_license", value)

    @property
    @pulumi.getter
    def license(self) -> Optional[pulumi.Input[str]]:
        """
        The license used for the Component.
        """
        return pulumi.get(self, "license")

    @license.setter
    def license(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license", value)


if not MYPY:
    class IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the Key Vault Data Factory Linked Service.
        """
        secret_version: NotRequired[pulumi.Input[str]]
        """
        Specifies the secret version in Azure Key Vault.
        """
elif False:
    IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicenseArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secret_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_version: Specifies the secret version in Azure Key Vault.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the secret version in Azure Key Vault.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_version", value)


if not MYPY:
    class IntegrationRuntimeSsisExpressVnetIntegrationArgsDict(TypedDict):
        subnet_id: pulumi.Input[str]
        """
        id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
elif False:
    IntegrationRuntimeSsisExpressVnetIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisExpressVnetIntegrationArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] subnet_id: id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class IntegrationRuntimeSsisPackageStoreArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Name of the Linked Service to associate with the packages.
        """
        name: pulumi.Input[str]
        """
        Name of the package store.
        """
elif False:
    IntegrationRuntimeSsisPackageStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisPackageStoreArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Name of the Linked Service to associate with the packages.
        :param pulumi.Input[str] name: Name of the package store.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Name of the Linked Service to associate with the packages.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the package store.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class IntegrationRuntimeSsisPipelineExternalComputeScaleArgsDict(TypedDict):
        number_of_external_nodes: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of the external nodes, which should be greater than `0` and less than `11`.
        """
        number_of_pipeline_nodes: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of the pipeline nodes, which should be greater than `0` and less than `11`.
        """
        time_to_live: NotRequired[pulumi.Input[int]]
        """
        Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
elif False:
    IntegrationRuntimeSsisPipelineExternalComputeScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisPipelineExternalComputeScaleArgs:
    def __init__(__self__, *,
                 number_of_external_nodes: Optional[pulumi.Input[int]] = None,
                 number_of_pipeline_nodes: Optional[pulumi.Input[int]] = None,
                 time_to_live: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] number_of_external_nodes: Specifies the number of the external nodes, which should be greater than `0` and less than `11`.
        :param pulumi.Input[int] number_of_pipeline_nodes: Specifies the number of the pipeline nodes, which should be greater than `0` and less than `11`.
        :param pulumi.Input[int] time_to_live: Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
        if number_of_external_nodes is not None:
            pulumi.set(__self__, "number_of_external_nodes", number_of_external_nodes)
        if number_of_pipeline_nodes is not None:
            pulumi.set(__self__, "number_of_pipeline_nodes", number_of_pipeline_nodes)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @property
    @pulumi.getter(name="numberOfExternalNodes")
    def number_of_external_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of the external nodes, which should be greater than `0` and less than `11`.
        """
        return pulumi.get(self, "number_of_external_nodes")

    @number_of_external_nodes.setter
    def number_of_external_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_external_nodes", value)

    @property
    @pulumi.getter(name="numberOfPipelineNodes")
    def number_of_pipeline_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of the pipeline nodes, which should be greater than `0` and less than `11`.
        """
        return pulumi.get(self, "number_of_pipeline_nodes")

    @number_of_pipeline_nodes.setter
    def number_of_pipeline_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_pipeline_nodes", value)

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the time to live (in minutes) setting of integration runtime which will execute copy activity. Possible values are at least `5`.
        """
        return pulumi.get(self, "time_to_live")

    @time_to_live.setter
    def time_to_live(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_to_live", value)


if not MYPY:
    class IntegrationRuntimeSsisProxyArgsDict(TypedDict):
        self_hosted_integration_runtime_name: pulumi.Input[str]
        """
        Name of Self Hosted Integration Runtime as a proxy.
        """
        staging_storage_linked_service_name: pulumi.Input[str]
        """
        Name of Azure Blob Storage linked service to reference the staging data store to be used when moving data between self-hosted and Azure-SSIS integration runtimes.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path in the data store to be used when moving data between Self-Hosted and Azure-SSIS Integration Runtimes.
        """
elif False:
    IntegrationRuntimeSsisProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisProxyArgs:
    def __init__(__self__, *,
                 self_hosted_integration_runtime_name: pulumi.Input[str],
                 staging_storage_linked_service_name: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] self_hosted_integration_runtime_name: Name of Self Hosted Integration Runtime as a proxy.
        :param pulumi.Input[str] staging_storage_linked_service_name: Name of Azure Blob Storage linked service to reference the staging data store to be used when moving data between self-hosted and Azure-SSIS integration runtimes.
        :param pulumi.Input[str] path: The path in the data store to be used when moving data between Self-Hosted and Azure-SSIS Integration Runtimes.
        """
        pulumi.set(__self__, "self_hosted_integration_runtime_name", self_hosted_integration_runtime_name)
        pulumi.set(__self__, "staging_storage_linked_service_name", staging_storage_linked_service_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="selfHostedIntegrationRuntimeName")
    def self_hosted_integration_runtime_name(self) -> pulumi.Input[str]:
        """
        Name of Self Hosted Integration Runtime as a proxy.
        """
        return pulumi.get(self, "self_hosted_integration_runtime_name")

    @self_hosted_integration_runtime_name.setter
    def self_hosted_integration_runtime_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "self_hosted_integration_runtime_name", value)

    @property
    @pulumi.getter(name="stagingStorageLinkedServiceName")
    def staging_storage_linked_service_name(self) -> pulumi.Input[str]:
        """
        Name of Azure Blob Storage linked service to reference the staging data store to be used when moving data between self-hosted and Azure-SSIS integration runtimes.
        """
        return pulumi.get(self, "staging_storage_linked_service_name")

    @staging_storage_linked_service_name.setter
    def staging_storage_linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "staging_storage_linked_service_name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path in the data store to be used when moving data between Self-Hosted and Azure-SSIS Integration Runtimes.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class IntegrationRuntimeSsisVnetIntegrationArgsDict(TypedDict):
        public_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Static public IP addresses for the Azure-SSIS Integration Runtime. The size must be 2.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.

        > **NOTE** Only one of `subnet_id` and `subnet_name` can be specified. If `subnet_name` is specified, `vnet_id` must be provided.
        """
        subnet_name: NotRequired[pulumi.Input[str]]
        """
        Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        vnet_id: NotRequired[pulumi.Input[str]]
        """
        ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
elif False:
    IntegrationRuntimeSsisVnetIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationRuntimeSsisVnetIntegrationArgs:
    def __init__(__self__, *,
                 public_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 subnet_name: Optional[pulumi.Input[str]] = None,
                 vnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] public_ips: Static public IP addresses for the Azure-SSIS Integration Runtime. The size must be 2.
        :param pulumi.Input[str] subnet_id: id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
               
               > **NOTE** Only one of `subnet_id` and `subnet_name` can be specified. If `subnet_name` is specified, `vnet_id` must be provided.
        :param pulumi.Input[str] subnet_name: Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        :param pulumi.Input[str] vnet_id: ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Static public IP addresses for the Azure-SSIS Integration Runtime. The size must be 2.
        """
        return pulumi.get(self, "public_ips")

    @public_ips.setter
    def public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "public_ips", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.

        > **NOTE** Only one of `subnet_id` and `subnet_name` can be specified. If `subnet_name` is specified, `vnet_id` must be provided.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_name", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class LinkedCustomServiceIntegrationRuntimeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The integration runtime reference to associate with the Data Factory Linked Service.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of parameters to associate with the integration runtime.
        """
elif False:
    LinkedCustomServiceIntegrationRuntimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedCustomServiceIntegrationRuntimeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The integration runtime reference to associate with the Data Factory Linked Service.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of parameters to associate with the integration runtime.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The integration runtime reference to associate with the Data Factory Linked Service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of parameters to associate with the integration runtime.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class LinkedServiceAzureBlobStorageKeyVaultSasTokenArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores the SAS token.
        """
elif False:
    LinkedServiceAzureBlobStorageKeyVaultSasTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceAzureBlobStorageKeyVaultSasTokenArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores the SAS token.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores the SAS token.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKeyArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores the Service Principal key.
        """
elif False:
    LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKeyArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores the Service Principal key.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores the Service Principal key.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceAzureDatabricksInstancePoolArgsDict(TypedDict):
        cluster_version: pulumi.Input[str]
        """
        Spark version of a the cluster.
        """
        instance_pool_id: pulumi.Input[str]
        """
        Identifier of the instance pool within the linked ADB instance.
        """
        max_number_of_workers: NotRequired[pulumi.Input[int]]
        """
        The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        """
        min_number_of_workers: NotRequired[pulumi.Input[int]]
        """
        The minimum number of worker nodes. Defaults to `1`.
        """
elif False:
    LinkedServiceAzureDatabricksInstancePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceAzureDatabricksInstancePoolArgs:
    def __init__(__self__, *,
                 cluster_version: pulumi.Input[str],
                 instance_pool_id: pulumi.Input[str],
                 max_number_of_workers: Optional[pulumi.Input[int]] = None,
                 min_number_of_workers: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cluster_version: Spark version of a the cluster.
        :param pulumi.Input[str] instance_pool_id: Identifier of the instance pool within the linked ADB instance.
        :param pulumi.Input[int] max_number_of_workers: The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        :param pulumi.Input[int] min_number_of_workers: The minimum number of worker nodes. Defaults to `1`.
        """
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if max_number_of_workers is not None:
            pulumi.set(__self__, "max_number_of_workers", max_number_of_workers)
        if min_number_of_workers is not None:
            pulumi.set(__self__, "min_number_of_workers", min_number_of_workers)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> pulumi.Input[str]:
        """
        Spark version of a the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @cluster_version.setter
    def cluster_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_version", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> pulumi.Input[str]:
        """
        Identifier of the instance pool within the linked ADB instance.
        """
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="maxNumberOfWorkers")
    def max_number_of_workers(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of worker nodes. Set this value if you want to enable autoscaling between the `min_number_of_workers` and this value. Omit this value to use a fixed number of workers defined in the `min_number_of_workers` property.
        """
        return pulumi.get(self, "max_number_of_workers")

    @max_number_of_workers.setter
    def max_number_of_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_number_of_workers", value)

    @property
    @pulumi.getter(name="minNumberOfWorkers")
    def min_number_of_workers(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of worker nodes. Defaults to `1`.
        """
        return pulumi.get(self, "min_number_of_workers")

    @min_number_of_workers.setter
    def min_number_of_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_number_of_workers", value)


if not MYPY:
    class LinkedServiceAzureDatabricksKeyVaultPasswordArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores ADB access token.
        """
elif False:
    LinkedServiceAzureDatabricksKeyVaultPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceAzureDatabricksKeyVaultPasswordArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores ADB access token.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores ADB access token.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceAzureDatabricksNewClusterConfigArgsDict(TypedDict):
        cluster_version: pulumi.Input[str]
        """
        Spark version of a the cluster.
        """
        node_type: pulumi.Input[str]
        """
        Node type for the new cluster.
        """
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Tags for the cluster resource.
        """
        driver_node_type: NotRequired[pulumi.Input[str]]
        """
        Driver node type for the cluster.
        """
        init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        User defined initialization scripts for the cluster.
        """
        log_destination: NotRequired[pulumi.Input[str]]
        """
        Location to deliver Spark driver, worker, and event logs.
        """
        max_number_of_workers: NotRequired[pulumi.Input[int]]
        """
        Specifies the maximum number of worker nodes. It should be between 1 and 25000.
        """
        min_number_of_workers: NotRequired[pulumi.Input[int]]
        """
        Specifies the minimum number of worker nodes. It should be between 1 and 25000. It defaults to `1`.
        """
        spark_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        User-specified Spark configuration variables key-value pairs.
        """
        spark_environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        User-specified Spark environment variables key-value pairs.
        """
elif False:
    LinkedServiceAzureDatabricksNewClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceAzureDatabricksNewClusterConfigArgs:
    def __init__(__self__, *,
                 cluster_version: pulumi.Input[str],
                 node_type: pulumi.Input[str],
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 driver_node_type: Optional[pulumi.Input[str]] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 log_destination: Optional[pulumi.Input[str]] = None,
                 max_number_of_workers: Optional[pulumi.Input[int]] = None,
                 min_number_of_workers: Optional[pulumi.Input[int]] = None,
                 spark_config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 spark_environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] cluster_version: Spark version of a the cluster.
        :param pulumi.Input[str] node_type: Node type for the new cluster.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_tags: Tags for the cluster resource.
        :param pulumi.Input[str] driver_node_type: Driver node type for the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] init_scripts: User defined initialization scripts for the cluster.
        :param pulumi.Input[str] log_destination: Location to deliver Spark driver, worker, and event logs.
        :param pulumi.Input[int] max_number_of_workers: Specifies the maximum number of worker nodes. It should be between 1 and 25000.
        :param pulumi.Input[int] min_number_of_workers: Specifies the minimum number of worker nodes. It should be between 1 and 25000. It defaults to `1`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] spark_config: User-specified Spark configuration variables key-value pairs.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] spark_environment_variables: User-specified Spark environment variables key-value pairs.
        """
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "node_type", node_type)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if driver_node_type is not None:
            pulumi.set(__self__, "driver_node_type", driver_node_type)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if log_destination is not None:
            pulumi.set(__self__, "log_destination", log_destination)
        if max_number_of_workers is not None:
            pulumi.set(__self__, "max_number_of_workers", max_number_of_workers)
        if min_number_of_workers is not None:
            pulumi.set(__self__, "min_number_of_workers", min_number_of_workers)
        if spark_config is not None:
            pulumi.set(__self__, "spark_config", spark_config)
        if spark_environment_variables is not None:
            pulumi.set(__self__, "spark_environment_variables", spark_environment_variables)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> pulumi.Input[str]:
        """
        Spark version of a the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @cluster_version.setter
    def cluster_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_version", value)

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> pulumi.Input[str]:
        """
        Node type for the new cluster.
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_type", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tags for the cluster resource.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="driverNodeType")
    def driver_node_type(self) -> Optional[pulumi.Input[str]]:
        """
        Driver node type for the cluster.
        """
        return pulumi.get(self, "driver_node_type")

    @driver_node_type.setter
    def driver_node_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        User defined initialization scripts for the cluster.
        """
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> Optional[pulumi.Input[str]]:
        """
        Location to deliver Spark driver, worker, and event logs.
        """
        return pulumi.get(self, "log_destination")

    @log_destination.setter
    def log_destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_destination", value)

    @property
    @pulumi.getter(name="maxNumberOfWorkers")
    def max_number_of_workers(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum number of worker nodes. It should be between 1 and 25000.
        """
        return pulumi.get(self, "max_number_of_workers")

    @max_number_of_workers.setter
    def max_number_of_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_number_of_workers", value)

    @property
    @pulumi.getter(name="minNumberOfWorkers")
    def min_number_of_workers(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the minimum number of worker nodes. It should be between 1 and 25000. It defaults to `1`.
        """
        return pulumi.get(self, "min_number_of_workers")

    @min_number_of_workers.setter
    def min_number_of_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_number_of_workers", value)

    @property
    @pulumi.getter(name="sparkConfig")
    def spark_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        User-specified Spark configuration variables key-value pairs.
        """
        return pulumi.get(self, "spark_config")

    @spark_config.setter
    def spark_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_config", value)

    @property
    @pulumi.getter(name="sparkEnvironmentVariables")
    def spark_environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        User-specified Spark environment variables key-value pairs.
        """
        return pulumi.get(self, "spark_environment_variables")

    @spark_environment_variables.setter
    def spark_environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_environment_variables", value)


if not MYPY:
    class LinkedServiceAzureFileStorageKeyVaultPasswordArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
        """
elif False:
    LinkedServiceAzureFileStorageKeyVaultPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceAzureFileStorageKeyVaultPasswordArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceAzureFunctionKeyVaultKeyArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores the system key of the Azure Function.
        """
elif False:
    LinkedServiceAzureFunctionKeyVaultKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceAzureFunctionKeyVaultKeyArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores the system key of the Azure Function.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores the system key of the Azure Function.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceAzureSqlDatabaseKeyVaultConnectionStringArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
elif False:
    LinkedServiceAzureSqlDatabaseKeyVaultConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceAzureSqlDatabaseKeyVaultConnectionStringArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceAzureSqlDatabaseKeyVaultPasswordArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
elif False:
    LinkedServiceAzureSqlDatabaseKeyVaultPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceAzureSqlDatabaseKeyVaultPasswordArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceOdataBasicAuthenticationArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The password associated with the username, which can be used to authenticate to the OData endpoint.
        """
        username: pulumi.Input[str]
        """
        The username which can be used to authenticate to the OData endpoint.
        """
elif False:
    LinkedServiceOdataBasicAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceOdataBasicAuthenticationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The password associated with the username, which can be used to authenticate to the OData endpoint.
        :param pulumi.Input[str] username: The username which can be used to authenticate to the OData endpoint.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password associated with the username, which can be used to authenticate to the OData endpoint.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username which can be used to authenticate to the OData endpoint.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class LinkedServiceOdbcBasicAuthenticationArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        The password associated with the username, which can be used to authenticate to the ODBC endpoint.
        """
        username: pulumi.Input[str]
        """
        The username which can be used to authenticate to the ODBC endpoint.
        """
elif False:
    LinkedServiceOdbcBasicAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceOdbcBasicAuthenticationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The password associated with the username, which can be used to authenticate to the ODBC endpoint.
        :param pulumi.Input[str] username: The username which can be used to authenticate to the ODBC endpoint.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password associated with the username, which can be used to authenticate to the ODBC endpoint.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username which can be used to authenticate to the ODBC endpoint.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class LinkedServiceSnowflakeKeyVaultPasswordArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores Snowflake password.
        """
elif False:
    LinkedServiceSnowflakeKeyVaultPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceSnowflakeKeyVaultPasswordArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores Snowflake password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores Snowflake password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceSqlServerKeyVaultConnectionStringArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
elif False:
    LinkedServiceSqlServerKeyVaultConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceSqlServerKeyVaultConnectionStringArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceSqlServerKeyVaultPasswordArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
elif False:
    LinkedServiceSqlServerKeyVaultPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceSqlServerKeyVaultPasswordArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores SQL Server password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class LinkedServiceSynapseKeyVaultPasswordArgsDict(TypedDict):
        linked_service_name: pulumi.Input[str]
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        secret_name: pulumi.Input[str]
        """
        Specifies the secret name in Azure Key Vault that stores Synapse password.
        """
elif False:
    LinkedServiceSynapseKeyVaultPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedServiceSynapseKeyVaultPasswordArgs:
    def __init__(__self__, *,
                 linked_service_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] linked_service_name: Specifies the name of an existing Key Vault Data Factory Linked Service.
        :param pulumi.Input[str] secret_name: Specifies the secret name in Azure Key Vault that stores Synapse password.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of an existing Key Vault Data Factory Linked Service.
        """
        return pulumi.get(self, "linked_service_name")

    @linked_service_name.setter
    def linked_service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "linked_service_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Specifies the secret name in Azure Key Vault that stores Synapse password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class TriggerBlobEventPipelineArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
elif False:
    TriggerBlobEventPipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerBlobEventPipelineArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The Data Factory Pipeline name that the trigger will act on.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: The Data Factory Pipeline parameters that the trigger will act on.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class TriggerCustomEventPipelineArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
elif False:
    TriggerCustomEventPipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerCustomEventPipelineArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The Data Factory Pipeline name that the trigger will act on.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: The Data Factory Pipeline parameters that the trigger will act on.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class TriggerSchedulePipelineArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Reference pipeline name.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The pipeline parameters that the trigger will act upon.
        """
elif False:
    TriggerSchedulePipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerSchedulePipelineArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: Reference pipeline name.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: The pipeline parameters that the trigger will act upon.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Reference pipeline name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The pipeline parameters that the trigger will act upon.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class TriggerScheduleScheduleArgsDict(TypedDict):
        days_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Day(s) of the month on which the trigger is scheduled. This value can be specified with a monthly frequency only.
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Days of the week on which the trigger is scheduled. This value can be specified only with a weekly frequency.
        """
        hours: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Hours of the day on which the trigger is scheduled.
        """
        minutes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Minutes of the hour on which the trigger is scheduled.
        """
        monthlies: NotRequired[pulumi.Input[Sequence[pulumi.Input['TriggerScheduleScheduleMonthlyArgsDict']]]]
        """
        A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled. The value can be specified only with a monthly frequency.
        """
elif False:
    TriggerScheduleScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerScheduleScheduleArgs:
    def __init__(__self__, *,
                 days_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hours: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 minutes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 monthlies: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerScheduleScheduleMonthlyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] days_of_months: Day(s) of the month on which the trigger is scheduled. This value can be specified with a monthly frequency only.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_of_weeks: Days of the week on which the trigger is scheduled. This value can be specified only with a weekly frequency.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours: Hours of the day on which the trigger is scheduled.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] minutes: Minutes of the hour on which the trigger is scheduled.
        :param pulumi.Input[Sequence[pulumi.Input['TriggerScheduleScheduleMonthlyArgs']]] monthlies: A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled. The value can be specified only with a monthly frequency.
        """
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if monthlies is not None:
            pulumi.set(__self__, "monthlies", monthlies)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Day(s) of the month on which the trigger is scheduled. This value can be specified with a monthly frequency only.
        """
        return pulumi.get(self, "days_of_months")

    @days_of_months.setter
    def days_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "days_of_months", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Days of the week on which the trigger is scheduled. This value can be specified only with a weekly frequency.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Hours of the day on which the trigger is scheduled.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Minutes of the hour on which the trigger is scheduled.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def monthlies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TriggerScheduleScheduleMonthlyArgs']]]]:
        """
        A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled. The value can be specified only with a monthly frequency.
        """
        return pulumi.get(self, "monthlies")

    @monthlies.setter
    def monthlies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TriggerScheduleScheduleMonthlyArgs']]]]):
        pulumi.set(self, "monthlies", value)


if not MYPY:
    class TriggerScheduleScheduleMonthlyArgsDict(TypedDict):
        weekday: pulumi.Input[str]
        """
        The day of the week on which the trigger runs. For example, a `monthly` property with a `weekday` value of `Sunday` means every Sunday of the month.
        """
        week: NotRequired[pulumi.Input[int]]
        """
        The occurrence of the specified day during the month. For example, a `monthly` property with `weekday` and `week` values of `Sunday, -1` means the last Sunday of the month.
        """
elif False:
    TriggerScheduleScheduleMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerScheduleScheduleMonthlyArgs:
    def __init__(__self__, *,
                 weekday: pulumi.Input[str],
                 week: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] weekday: The day of the week on which the trigger runs. For example, a `monthly` property with a `weekday` value of `Sunday` means every Sunday of the month.
        :param pulumi.Input[int] week: The occurrence of the specified day during the month. For example, a `monthly` property with `weekday` and `week` values of `Sunday, -1` means the last Sunday of the month.
        """
        pulumi.set(__self__, "weekday", weekday)
        if week is not None:
            pulumi.set(__self__, "week", week)

    @property
    @pulumi.getter
    def weekday(self) -> pulumi.Input[str]:
        """
        The day of the week on which the trigger runs. For example, a `monthly` property with a `weekday` value of `Sunday` means every Sunday of the month.
        """
        return pulumi.get(self, "weekday")

    @weekday.setter
    def weekday(self, value: pulumi.Input[str]):
        pulumi.set(self, "weekday", value)

    @property
    @pulumi.getter
    def week(self) -> Optional[pulumi.Input[int]]:
        """
        The occurrence of the specified day during the month. For example, a `monthly` property with `weekday` and `week` values of `Sunday, -1` means the last Sunday of the month.
        """
        return pulumi.get(self, "week")

    @week.setter
    def week(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "week", value)


if not MYPY:
    class TriggerTumblingWindowPipelineArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
elif False:
    TriggerTumblingWindowPipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerTumblingWindowPipelineArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The Data Factory Pipeline name that the trigger will act on.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: The Data Factory Pipeline parameters that the trigger will act on.
        """
        pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Data Factory Pipeline name that the trigger will act on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The Data Factory Pipeline parameters that the trigger will act on.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class TriggerTumblingWindowRetryArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The maximum retry attempts if the pipeline run failed.
        """
        interval: NotRequired[pulumi.Input[int]]
        """
        The Interval in seconds between each retry if the pipeline run failed. Defaults to `30`.
        """
elif False:
    TriggerTumblingWindowRetryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerTumblingWindowRetryArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] count: The maximum retry attempts if the pipeline run failed.
        :param pulumi.Input[int] interval: The Interval in seconds between each retry if the pipeline run failed. Defaults to `30`.
        """
        pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The maximum retry attempts if the pipeline run failed.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The Interval in seconds between each retry if the pipeline run failed. Defaults to `30`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class TriggerTumblingWindowTriggerDependencyArgsDict(TypedDict):
        offset: NotRequired[pulumi.Input[str]]
        """
        The offset of the dependency trigger. Must be in Timespan format (hh:mm:ss) and must be a negative offset for a self dependency.
        """
        size: NotRequired[pulumi.Input[str]]
        """
        The size of the dependency tumbling window. Must be in Timespan format (hh:mm:ss).
        """
        trigger_name: NotRequired[pulumi.Input[str]]
        """
        The dependency trigger name. If not specified, it will use self dependency.
        """
elif False:
    TriggerTumblingWindowTriggerDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerTumblingWindowTriggerDependencyArgs:
    def __init__(__self__, *,
                 offset: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 trigger_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] offset: The offset of the dependency trigger. Must be in Timespan format (hh:mm:ss) and must be a negative offset for a self dependency.
        :param pulumi.Input[str] size: The size of the dependency tumbling window. Must be in Timespan format (hh:mm:ss).
        :param pulumi.Input[str] trigger_name: The dependency trigger name. If not specified, it will use self dependency.
        """
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if trigger_name is not None:
            pulumi.set(__self__, "trigger_name", trigger_name)

    @property
    @pulumi.getter
    def offset(self) -> Optional[pulumi.Input[str]]:
        """
        The offset of the dependency trigger. Must be in Timespan format (hh:mm:ss) and must be a negative offset for a self dependency.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the dependency tumbling window. Must be in Timespan format (hh:mm:ss).
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="triggerName")
    def trigger_name(self) -> Optional[pulumi.Input[str]]:
        """
        The dependency trigger name. If not specified, it will use self dependency.
        """
        return pulumi.get(self, "trigger_name")

    @trigger_name.setter
    def trigger_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_name", value)


