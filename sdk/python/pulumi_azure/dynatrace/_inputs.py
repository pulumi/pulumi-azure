# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'MonitorEnvironmentPropertyArgs',
    'MonitorEnvironmentPropertyArgsDict',
    'MonitorEnvironmentPropertyEnvironmentInfoArgs',
    'MonitorEnvironmentPropertyEnvironmentInfoArgsDict',
    'MonitorIdentityArgs',
    'MonitorIdentityArgsDict',
    'MonitorPlanArgs',
    'MonitorPlanArgsDict',
    'MonitorUserArgs',
    'MonitorUserArgsDict',
    'TagRulesLogRuleArgs',
    'TagRulesLogRuleArgsDict',
    'TagRulesLogRuleFilteringTagArgs',
    'TagRulesLogRuleFilteringTagArgsDict',
    'TagRulesMetricRuleArgs',
    'TagRulesMetricRuleArgsDict',
    'TagRulesMetricRuleFilteringTagArgs',
    'TagRulesMetricRuleFilteringTagArgsDict',
]

MYPY = False

if not MYPY:
    class MonitorEnvironmentPropertyArgsDict(TypedDict):
        environment_infos: pulumi.Input[Sequence[pulumi.Input['MonitorEnvironmentPropertyEnvironmentInfoArgsDict']]]
        """
        Information about the Dynatrace environment. An `environment_info` block as defined below.
        """
elif False:
    MonitorEnvironmentPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorEnvironmentPropertyArgs:
    def __init__(__self__, *,
                 environment_infos: pulumi.Input[Sequence[pulumi.Input['MonitorEnvironmentPropertyEnvironmentInfoArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitorEnvironmentPropertyEnvironmentInfoArgs']]] environment_infos: Information about the Dynatrace environment. An `environment_info` block as defined below.
        """
        pulumi.set(__self__, "environment_infos", environment_infos)

    @_builtins.property
    @pulumi.getter(name="environmentInfos")
    def environment_infos(self) -> pulumi.Input[Sequence[pulumi.Input['MonitorEnvironmentPropertyEnvironmentInfoArgs']]]:
        """
        Information about the Dynatrace environment. An `environment_info` block as defined below.
        """
        return pulumi.get(self, "environment_infos")

    @environment_infos.setter
    def environment_infos(self, value: pulumi.Input[Sequence[pulumi.Input['MonitorEnvironmentPropertyEnvironmentInfoArgs']]]):
        pulumi.set(self, "environment_infos", value)


if not MYPY:
    class MonitorEnvironmentPropertyEnvironmentInfoArgsDict(TypedDict):
        environment_id: pulumi.Input[_builtins.str]
        """
        The ID of the Dynatrace environment to be created.
        """
elif False:
    MonitorEnvironmentPropertyEnvironmentInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorEnvironmentPropertyEnvironmentInfoArgs:
    def __init__(__self__, *,
                 environment_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] environment_id: The ID of the Dynatrace environment to be created.
        """
        pulumi.set(__self__, "environment_id", environment_id)

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Dynatrace environment to be created.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "environment_id", value)


if not MYPY:
    class MonitorIdentityArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of identity used for the resource. Only possible value is `SystemAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[_builtins.str]]
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MonitorIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 principal_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of identity used for the resource. Only possible value is `SystemAssigned`.
        """
        pulumi.set(__self__, "type", type)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of identity used for the resource. Only possible value is `SystemAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "principal_id", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class MonitorPlanArgsDict(TypedDict):
        plan: pulumi.Input[_builtins.str]
        """
        Plan id as published by Dynatrace.
        """
        billing_cycle: NotRequired[pulumi.Input[_builtins.str]]
        """
        Different billing cycles. Possible values are `MONTHLY` and `WEEKLY`.
        """
        effective_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Date when plan was applied.
        """
        usage_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Different usage type. Possible values are `PAYG` and `COMMITTED`.
        """
elif False:
    MonitorPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorPlanArgs:
    def __init__(__self__, *,
                 plan: pulumi.Input[_builtins.str],
                 billing_cycle: Optional[pulumi.Input[_builtins.str]] = None,
                 effective_date: Optional[pulumi.Input[_builtins.str]] = None,
                 usage_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] plan: Plan id as published by Dynatrace.
        :param pulumi.Input[_builtins.str] billing_cycle: Different billing cycles. Possible values are `MONTHLY` and `WEEKLY`.
        :param pulumi.Input[_builtins.str] effective_date: Date when plan was applied.
        :param pulumi.Input[_builtins.str] usage_type: Different usage type. Possible values are `PAYG` and `COMMITTED`.
        """
        pulumi.set(__self__, "plan", plan)
        if billing_cycle is not None:
            pulumi.set(__self__, "billing_cycle", billing_cycle)
        if effective_date is not None:
            pulumi.set(__self__, "effective_date", effective_date)
        if usage_type is not None:
            pulumi.set(__self__, "usage_type", usage_type)

    @_builtins.property
    @pulumi.getter
    def plan(self) -> pulumi.Input[_builtins.str]:
        """
        Plan id as published by Dynatrace.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plan", value)

    @_builtins.property
    @pulumi.getter(name="billingCycle")
    def billing_cycle(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Different billing cycles. Possible values are `MONTHLY` and `WEEKLY`.
        """
        return pulumi.get(self, "billing_cycle")

    @billing_cycle.setter
    def billing_cycle(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "billing_cycle", value)

    @_builtins.property
    @pulumi.getter(name="effectiveDate")
    def effective_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date when plan was applied.
        """
        return pulumi.get(self, "effective_date")

    @effective_date.setter
    def effective_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective_date", value)

    @_builtins.property
    @pulumi.getter(name="usageType")
    def usage_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Different usage type. Possible values are `PAYG` and `COMMITTED`.
        """
        return pulumi.get(self, "usage_type")

    @usage_type.setter
    def usage_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "usage_type", value)


if not MYPY:
    class MonitorUserArgsDict(TypedDict):
        country: pulumi.Input[_builtins.str]
        """
        Country of the user.
        """
        email: pulumi.Input[_builtins.str]
        """
        Email of the user used by Dynatrace for contacting them if needed.
        """
        first_name: pulumi.Input[_builtins.str]
        """
        First name of the user.
        """
        last_name: pulumi.Input[_builtins.str]
        """
        Last name of the user.
        """
        phone_number: pulumi.Input[_builtins.str]
        """
        phone number of the user by Dynatrace for contacting them if needed.
        """
elif False:
    MonitorUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorUserArgs:
    def __init__(__self__, *,
                 country: pulumi.Input[_builtins.str],
                 email: pulumi.Input[_builtins.str],
                 first_name: pulumi.Input[_builtins.str],
                 last_name: pulumi.Input[_builtins.str],
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country: Country of the user.
        :param pulumi.Input[_builtins.str] email: Email of the user used by Dynatrace for contacting them if needed.
        :param pulumi.Input[_builtins.str] first_name: First name of the user.
        :param pulumi.Input[_builtins.str] last_name: Last name of the user.
        :param pulumi.Input[_builtins.str] phone_number: phone number of the user by Dynatrace for contacting them if needed.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter
    def country(self) -> pulumi.Input[_builtins.str]:
        """
        Country of the user.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        Email of the user used by Dynatrace for contacting them if needed.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> pulumi.Input[_builtins.str]:
        """
        First name of the user.
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> pulumi.Input[_builtins.str]:
        """
        Last name of the user.
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        phone number of the user by Dynatrace for contacting them if needed.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class TagRulesLogRuleArgsDict(TypedDict):
        filtering_tags: pulumi.Input[Sequence[pulumi.Input['TagRulesLogRuleFilteringTagArgsDict']]]
        """
        Filtering tag for the log rule. A `filtering_tag` block as defined below.
        """
        send_activity_logs_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Send Activity logs. The default value is `false`.
        """
        send_azure_active_directory_logs_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Send Azure Active Directory logs. The default value is `false`.
        """
        send_subscription_logs_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Send Subscription logs. The default value is `false`.
        """
elif False:
    TagRulesLogRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagRulesLogRuleArgs:
    def __init__(__self__, *,
                 filtering_tags: pulumi.Input[Sequence[pulumi.Input['TagRulesLogRuleFilteringTagArgs']]],
                 send_activity_logs_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_azure_active_directory_logs_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_subscription_logs_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TagRulesLogRuleFilteringTagArgs']]] filtering_tags: Filtering tag for the log rule. A `filtering_tag` block as defined below.
        :param pulumi.Input[_builtins.bool] send_activity_logs_enabled: Send Activity logs. The default value is `false`.
        :param pulumi.Input[_builtins.bool] send_azure_active_directory_logs_enabled: Send Azure Active Directory logs. The default value is `false`.
        :param pulumi.Input[_builtins.bool] send_subscription_logs_enabled: Send Subscription logs. The default value is `false`.
        """
        pulumi.set(__self__, "filtering_tags", filtering_tags)
        if send_activity_logs_enabled is not None:
            pulumi.set(__self__, "send_activity_logs_enabled", send_activity_logs_enabled)
        if send_azure_active_directory_logs_enabled is not None:
            pulumi.set(__self__, "send_azure_active_directory_logs_enabled", send_azure_active_directory_logs_enabled)
        if send_subscription_logs_enabled is not None:
            pulumi.set(__self__, "send_subscription_logs_enabled", send_subscription_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="filteringTags")
    def filtering_tags(self) -> pulumi.Input[Sequence[pulumi.Input['TagRulesLogRuleFilteringTagArgs']]]:
        """
        Filtering tag for the log rule. A `filtering_tag` block as defined below.
        """
        return pulumi.get(self, "filtering_tags")

    @filtering_tags.setter
    def filtering_tags(self, value: pulumi.Input[Sequence[pulumi.Input['TagRulesLogRuleFilteringTagArgs']]]):
        pulumi.set(self, "filtering_tags", value)

    @_builtins.property
    @pulumi.getter(name="sendActivityLogsEnabled")
    def send_activity_logs_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Send Activity logs. The default value is `false`.
        """
        return pulumi.get(self, "send_activity_logs_enabled")

    @send_activity_logs_enabled.setter
    def send_activity_logs_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_activity_logs_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sendAzureActiveDirectoryLogsEnabled")
    def send_azure_active_directory_logs_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Send Azure Active Directory logs. The default value is `false`.
        """
        return pulumi.get(self, "send_azure_active_directory_logs_enabled")

    @send_azure_active_directory_logs_enabled.setter
    def send_azure_active_directory_logs_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_azure_active_directory_logs_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sendSubscriptionLogsEnabled")
    def send_subscription_logs_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Send Subscription logs. The default value is `false`.
        """
        return pulumi.get(self, "send_subscription_logs_enabled")

    @send_subscription_logs_enabled.setter
    def send_subscription_logs_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_subscription_logs_enabled", value)


if not MYPY:
    class TagRulesLogRuleFilteringTagArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action of the filtering tag. Possible values are `Include` and `Exclude`.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the filtering tag.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the filtering tag.
        """
elif False:
    TagRulesLogRuleFilteringTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagRulesLogRuleFilteringTagArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] action: Action of the filtering tag. Possible values are `Include` and `Exclude`.
        :param pulumi.Input[_builtins.str] name: Name of the filtering tag.
        :param pulumi.Input[_builtins.str] value: Value of the filtering tag.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action of the filtering tag. Possible values are `Include` and `Exclude`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the filtering tag.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the filtering tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TagRulesMetricRuleArgsDict(TypedDict):
        filtering_tags: pulumi.Input[Sequence[pulumi.Input['TagRulesMetricRuleFilteringTagArgsDict']]]
        """
        Filtering tag for the metric rule. A `filtering_tag` block as defined below.
        """
        sending_metrics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If sending metrics is enabled. The default value is `false`.
        """
elif False:
    TagRulesMetricRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagRulesMetricRuleArgs:
    def __init__(__self__, *,
                 filtering_tags: pulumi.Input[Sequence[pulumi.Input['TagRulesMetricRuleFilteringTagArgs']]],
                 sending_metrics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TagRulesMetricRuleFilteringTagArgs']]] filtering_tags: Filtering tag for the metric rule. A `filtering_tag` block as defined below.
        :param pulumi.Input[_builtins.bool] sending_metrics_enabled: If sending metrics is enabled. The default value is `false`.
        """
        pulumi.set(__self__, "filtering_tags", filtering_tags)
        if sending_metrics_enabled is not None:
            pulumi.set(__self__, "sending_metrics_enabled", sending_metrics_enabled)

    @_builtins.property
    @pulumi.getter(name="filteringTags")
    def filtering_tags(self) -> pulumi.Input[Sequence[pulumi.Input['TagRulesMetricRuleFilteringTagArgs']]]:
        """
        Filtering tag for the metric rule. A `filtering_tag` block as defined below.
        """
        return pulumi.get(self, "filtering_tags")

    @filtering_tags.setter
    def filtering_tags(self, value: pulumi.Input[Sequence[pulumi.Input['TagRulesMetricRuleFilteringTagArgs']]]):
        pulumi.set(self, "filtering_tags", value)

    @_builtins.property
    @pulumi.getter(name="sendingMetricsEnabled")
    def sending_metrics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If sending metrics is enabled. The default value is `false`.
        """
        return pulumi.get(self, "sending_metrics_enabled")

    @sending_metrics_enabled.setter
    def sending_metrics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sending_metrics_enabled", value)


if not MYPY:
    class TagRulesMetricRuleFilteringTagArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action of the filtering tag. Possible values are `Include` and `Exclude`.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the filtering tag.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the filtering tag.
        """
elif False:
    TagRulesMetricRuleFilteringTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagRulesMetricRuleFilteringTagArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] action: Action of the filtering tag. Possible values are `Include` and `Exclude`.
        :param pulumi.Input[_builtins.str] name: Name of the filtering tag.
        :param pulumi.Input[_builtins.str] value: Value of the filtering tag.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action of the filtering tag. Possible values are `Include` and `Exclude`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the filtering tag.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the filtering tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


