# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ServiceInitialReplicaSetArgs',
    'ServiceNotificationsArgs',
    'ServiceSecureLdapArgs',
    'ServiceSecurityArgs',
]

@pulumi.input_type
class ServiceInitialReplicaSetArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 domain_controller_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 external_access_ip_address: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 service_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: The ID of the subnet in which to place the initial replica set.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domain_controller_ip_addresses: A list of subnet IP addresses for the domain controllers in the initial replica set, typically two.
        :param pulumi.Input[str] external_access_ip_address: The publicly routable IP address for the domain controllers in the initial replica set.
        :param pulumi.Input[str] id: The ID of the Domain Service.
        :param pulumi.Input[str] location: The Azure location where the Domain Service exists. Changing this forces a new resource to be created.
        :param pulumi.Input[str] service_status: The current service status for the initial replica set.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if domain_controller_ip_addresses is not None:
            pulumi.set(__self__, "domain_controller_ip_addresses", domain_controller_ip_addresses)
        if external_access_ip_address is not None:
            pulumi.set(__self__, "external_access_ip_address", external_access_ip_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if service_status is not None:
            pulumi.set(__self__, "service_status", service_status)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The ID of the subnet in which to place the initial replica set.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="domainControllerIpAddresses")
    def domain_controller_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of subnet IP addresses for the domain controllers in the initial replica set, typically two.
        """
        return pulumi.get(self, "domain_controller_ip_addresses")

    @domain_controller_ip_addresses.setter
    def domain_controller_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domain_controller_ip_addresses", value)

    @property
    @pulumi.getter(name="externalAccessIpAddress")
    def external_access_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The publicly routable IP address for the domain controllers in the initial replica set.
        """
        return pulumi.get(self, "external_access_ip_address")

    @external_access_ip_address.setter
    def external_access_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_access_ip_address", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Domain Service.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure location where the Domain Service exists. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="serviceStatus")
    def service_status(self) -> Optional[pulumi.Input[str]]:
        """
        The current service status for the initial replica set.
        """
        return pulumi.get(self, "service_status")

    @service_status.setter
    def service_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_status", value)


@pulumi.input_type
class ServiceNotificationsArgs:
    def __init__(__self__, *,
                 additional_recipients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 notify_dc_admins: Optional[pulumi.Input[bool]] = None,
                 notify_global_admins: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_recipients: A list of additional email addresses to notify when there are alerts in the managed domain.
        :param pulumi.Input[bool] notify_dc_admins: Whether to notify members of the _AAD DC Administrators_ group when there are alerts in the managed domain.
        :param pulumi.Input[bool] notify_global_admins: Whether to notify all Global Administrators when there are alerts in the managed domain.
        """
        if additional_recipients is not None:
            pulumi.set(__self__, "additional_recipients", additional_recipients)
        if notify_dc_admins is not None:
            pulumi.set(__self__, "notify_dc_admins", notify_dc_admins)
        if notify_global_admins is not None:
            pulumi.set(__self__, "notify_global_admins", notify_global_admins)

    @property
    @pulumi.getter(name="additionalRecipients")
    def additional_recipients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of additional email addresses to notify when there are alerts in the managed domain.
        """
        return pulumi.get(self, "additional_recipients")

    @additional_recipients.setter
    def additional_recipients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_recipients", value)

    @property
    @pulumi.getter(name="notifyDcAdmins")
    def notify_dc_admins(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to notify members of the _AAD DC Administrators_ group when there are alerts in the managed domain.
        """
        return pulumi.get(self, "notify_dc_admins")

    @notify_dc_admins.setter
    def notify_dc_admins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notify_dc_admins", value)

    @property
    @pulumi.getter(name="notifyGlobalAdmins")
    def notify_global_admins(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to notify all Global Administrators when there are alerts in the managed domain.
        """
        return pulumi.get(self, "notify_global_admins")

    @notify_global_admins.setter
    def notify_global_admins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notify_global_admins", value)


@pulumi.input_type
class ServiceSecureLdapArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 pfx_certificate: pulumi.Input[str],
                 pfx_certificate_password: pulumi.Input[str],
                 certificate_expiry: Optional[pulumi.Input[str]] = None,
                 certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 external_access_enabled: Optional[pulumi.Input[bool]] = None,
                 public_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to enable secure LDAP for the managed domain. Defaults to `false`.
        :param pulumi.Input[str] pfx_certificate: The certificate/private key to use for LDAPS, as a base64-encoded TripleDES-SHA1 encrypted PKCS#12 bundle (PFX file).
        :param pulumi.Input[str] pfx_certificate_password: The password to use for decrypting the PKCS#12 bundle (PFX file).
        :param pulumi.Input[bool] external_access_enabled: Whether to enable external access to LDAPS over the Internet. Defaults to `false`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "pfx_certificate", pfx_certificate)
        pulumi.set(__self__, "pfx_certificate_password", pfx_certificate_password)
        if certificate_expiry is not None:
            pulumi.set(__self__, "certificate_expiry", certificate_expiry)
        if certificate_thumbprint is not None:
            pulumi.set(__self__, "certificate_thumbprint", certificate_thumbprint)
        if external_access_enabled is not None:
            pulumi.set(__self__, "external_access_enabled", external_access_enabled)
        if public_certificate is not None:
            pulumi.set(__self__, "public_certificate", public_certificate)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether to enable secure LDAP for the managed domain. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="pfxCertificate")
    def pfx_certificate(self) -> pulumi.Input[str]:
        """
        The certificate/private key to use for LDAPS, as a base64-encoded TripleDES-SHA1 encrypted PKCS#12 bundle (PFX file).
        """
        return pulumi.get(self, "pfx_certificate")

    @pfx_certificate.setter
    def pfx_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "pfx_certificate", value)

    @property
    @pulumi.getter(name="pfxCertificatePassword")
    def pfx_certificate_password(self) -> pulumi.Input[str]:
        """
        The password to use for decrypting the PKCS#12 bundle (PFX file).
        """
        return pulumi.get(self, "pfx_certificate_password")

    @pfx_certificate_password.setter
    def pfx_certificate_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "pfx_certificate_password", value)

    @property
    @pulumi.getter(name="certificateExpiry")
    def certificate_expiry(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate_expiry")

    @certificate_expiry.setter
    def certificate_expiry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_expiry", value)

    @property
    @pulumi.getter(name="certificateThumbprint")
    def certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate_thumbprint")

    @certificate_thumbprint.setter
    def certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_thumbprint", value)

    @property
    @pulumi.getter(name="externalAccessEnabled")
    def external_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable external access to LDAPS over the Internet. Defaults to `false`.
        """
        return pulumi.get(self, "external_access_enabled")

    @external_access_enabled.setter
    def external_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "external_access_enabled", value)

    @property
    @pulumi.getter(name="publicCertificate")
    def public_certificate(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "public_certificate")

    @public_certificate.setter
    def public_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_certificate", value)


@pulumi.input_type
class ServiceSecurityArgs:
    def __init__(__self__, *,
                 ntlm_v1_enabled: Optional[pulumi.Input[bool]] = None,
                 sync_kerberos_passwords: Optional[pulumi.Input[bool]] = None,
                 sync_ntlm_passwords: Optional[pulumi.Input[bool]] = None,
                 sync_on_prem_passwords: Optional[pulumi.Input[bool]] = None,
                 tls_v1_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] ntlm_v1_enabled: Whether to enable legacy NTLM v1 support. Defaults to `false`.
        :param pulumi.Input[bool] sync_kerberos_passwords: Whether to synchronize Kerberos password hashes to the managed domain. Defaults to `false`.
        :param pulumi.Input[bool] sync_ntlm_passwords: Whether to synchronize NTLM password hashes to the managed domain. Defaults to `false`.
        :param pulumi.Input[bool] sync_on_prem_passwords: Whether to synchronize on-premises password hashes to the managed domain. Defaults to `false`.
        :param pulumi.Input[bool] tls_v1_enabled: Whether to enable legacy TLS v1 support. Defaults to `false`.
        """
        if ntlm_v1_enabled is not None:
            pulumi.set(__self__, "ntlm_v1_enabled", ntlm_v1_enabled)
        if sync_kerberos_passwords is not None:
            pulumi.set(__self__, "sync_kerberos_passwords", sync_kerberos_passwords)
        if sync_ntlm_passwords is not None:
            pulumi.set(__self__, "sync_ntlm_passwords", sync_ntlm_passwords)
        if sync_on_prem_passwords is not None:
            pulumi.set(__self__, "sync_on_prem_passwords", sync_on_prem_passwords)
        if tls_v1_enabled is not None:
            pulumi.set(__self__, "tls_v1_enabled", tls_v1_enabled)

    @property
    @pulumi.getter(name="ntlmV1Enabled")
    def ntlm_v1_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable legacy NTLM v1 support. Defaults to `false`.
        """
        return pulumi.get(self, "ntlm_v1_enabled")

    @ntlm_v1_enabled.setter
    def ntlm_v1_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ntlm_v1_enabled", value)

    @property
    @pulumi.getter(name="syncKerberosPasswords")
    def sync_kerberos_passwords(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to synchronize Kerberos password hashes to the managed domain. Defaults to `false`.
        """
        return pulumi.get(self, "sync_kerberos_passwords")

    @sync_kerberos_passwords.setter
    def sync_kerberos_passwords(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_kerberos_passwords", value)

    @property
    @pulumi.getter(name="syncNtlmPasswords")
    def sync_ntlm_passwords(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to synchronize NTLM password hashes to the managed domain. Defaults to `false`.
        """
        return pulumi.get(self, "sync_ntlm_passwords")

    @sync_ntlm_passwords.setter
    def sync_ntlm_passwords(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_ntlm_passwords", value)

    @property
    @pulumi.getter(name="syncOnPremPasswords")
    def sync_on_prem_passwords(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to synchronize on-premises password hashes to the managed domain. Defaults to `false`.
        """
        return pulumi.get(self, "sync_on_prem_passwords")

    @sync_on_prem_passwords.setter
    def sync_on_prem_passwords(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_on_prem_passwords", value)

    @property
    @pulumi.getter(name="tlsV1Enabled")
    def tls_v1_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable legacy TLS v1 support. Defaults to `false`.
        """
        return pulumi.get(self, "tls_v1_enabled")

    @tls_v1_enabled.setter
    def tls_v1_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_v1_enabled", value)


