# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'FlexibleServerCustomerManagedKey',
    'FlexibleServerHighAvailability',
    'FlexibleServerIdentity',
    'FlexibleServerMaintenanceWindow',
    'FlexibleServerStorage',
    'ServerIdentity',
    'ServerThreatDetectionPolicy',
    'GetFlexibleServerHighAvailabilityResult',
    'GetFlexibleServerMaintenanceWindowResult',
    'GetFlexibleServerStorageResult',
    'GetServerIdentityResult',
    'GetServerThreatDetectionPolicyResult',
]

@pulumi.output_type
class FlexibleServerCustomerManagedKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoBackupKeyVaultKeyId":
            suggest = "geo_backup_key_vault_key_id"
        elif key == "geoBackupUserAssignedIdentityId":
            suggest = "geo_backup_user_assigned_identity_id"
        elif key == "keyVaultKeyId":
            suggest = "key_vault_key_id"
        elif key == "primaryUserAssignedIdentityId":
            suggest = "primary_user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlexibleServerCustomerManagedKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlexibleServerCustomerManagedKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlexibleServerCustomerManagedKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_backup_key_vault_key_id: Optional[str] = None,
                 geo_backup_user_assigned_identity_id: Optional[str] = None,
                 key_vault_key_id: Optional[str] = None,
                 primary_user_assigned_identity_id: Optional[str] = None):
        """
        :param str geo_backup_key_vault_key_id: The ID of the geo backup Key Vault Key. It can't cross region and need Customer Managed Key in same region as geo backup.
        :param str geo_backup_user_assigned_identity_id: The geo backup user managed identity id for a Customer Managed Key. Should be added with `identity_ids`. It can't cross region and need identity in same region as geo backup.
               
               > **NOTE:** `primary_user_assigned_identity_id` or `geo_backup_user_assigned_identity_id` is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param str key_vault_key_id: The ID of the Key Vault Key.
        :param str primary_user_assigned_identity_id: Specifies the primary user managed identity id for a Customer Managed Key. Should be added with `identity_ids`.
        """
        FlexibleServerCustomerManagedKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geo_backup_key_vault_key_id=geo_backup_key_vault_key_id,
            geo_backup_user_assigned_identity_id=geo_backup_user_assigned_identity_id,
            key_vault_key_id=key_vault_key_id,
            primary_user_assigned_identity_id=primary_user_assigned_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geo_backup_key_vault_key_id: Optional[str] = None,
             geo_backup_user_assigned_identity_id: Optional[str] = None,
             key_vault_key_id: Optional[str] = None,
             primary_user_assigned_identity_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if geo_backup_key_vault_key_id is not None:
            _setter("geo_backup_key_vault_key_id", geo_backup_key_vault_key_id)
        if geo_backup_user_assigned_identity_id is not None:
            _setter("geo_backup_user_assigned_identity_id", geo_backup_user_assigned_identity_id)
        if key_vault_key_id is not None:
            _setter("key_vault_key_id", key_vault_key_id)
        if primary_user_assigned_identity_id is not None:
            _setter("primary_user_assigned_identity_id", primary_user_assigned_identity_id)

    @property
    @pulumi.getter(name="geoBackupKeyVaultKeyId")
    def geo_backup_key_vault_key_id(self) -> Optional[str]:
        """
        The ID of the geo backup Key Vault Key. It can't cross region and need Customer Managed Key in same region as geo backup.
        """
        return pulumi.get(self, "geo_backup_key_vault_key_id")

    @property
    @pulumi.getter(name="geoBackupUserAssignedIdentityId")
    def geo_backup_user_assigned_identity_id(self) -> Optional[str]:
        """
        The geo backup user managed identity id for a Customer Managed Key. Should be added with `identity_ids`. It can't cross region and need identity in same region as geo backup.

        > **NOTE:** `primary_user_assigned_identity_id` or `geo_backup_user_assigned_identity_id` is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "geo_backup_user_assigned_identity_id")

    @property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> Optional[str]:
        """
        The ID of the Key Vault Key.
        """
        return pulumi.get(self, "key_vault_key_id")

    @property
    @pulumi.getter(name="primaryUserAssignedIdentityId")
    def primary_user_assigned_identity_id(self) -> Optional[str]:
        """
        Specifies the primary user managed identity id for a Customer Managed Key. Should be added with `identity_ids`.
        """
        return pulumi.get(self, "primary_user_assigned_identity_id")


@pulumi.output_type
class FlexibleServerHighAvailability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "standbyAvailabilityZone":
            suggest = "standby_availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlexibleServerHighAvailability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlexibleServerHighAvailability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlexibleServerHighAvailability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: str,
                 standby_availability_zone: Optional[str] = None):
        """
        :param str mode: The high availability mode for the MySQL Flexible Server. Possibles values are `SameZone` and `ZoneRedundant`.
               
               > **NOTE:** `storage.0.auto_grow_enabled` must be enabled when `high_availability` is enabled. To change the `high_availability` for a MySQL Flexible Server created with `high_availability` disabled during creation, the resource has to be recreated.
        """
        FlexibleServerHighAvailability._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            standby_availability_zone=standby_availability_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: str,
             standby_availability_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mode", mode)
        if standby_availability_zone is not None:
            _setter("standby_availability_zone", standby_availability_zone)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The high availability mode for the MySQL Flexible Server. Possibles values are `SameZone` and `ZoneRedundant`.

        > **NOTE:** `storage.0.auto_grow_enabled` must be enabled when `high_availability` is enabled. To change the `high_availability` for a MySQL Flexible Server created with `high_availability` disabled during creation, the resource has to be recreated.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="standbyAvailabilityZone")
    def standby_availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "standby_availability_zone")


@pulumi.output_type
class FlexibleServerIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlexibleServerIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlexibleServerIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlexibleServerIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 type: str):
        """
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this MySQL Flexible Server.
        :param str type: Specifies the type of Managed Service Identity that should be configured on this MySQL Flexible Server. The only possible value is `UserAssigned`.
        """
        FlexibleServerIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_ids=identity_ids,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_ids: Sequence[str],
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("identity_ids", identity_ids)
        _setter("type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this MySQL Flexible Server.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this MySQL Flexible Server. The only possible value is `UserAssigned`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FlexibleServerMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMinute":
            suggest = "start_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlexibleServerMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlexibleServerMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlexibleServerMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional[int] = None,
                 start_hour: Optional[int] = None,
                 start_minute: Optional[int] = None):
        """
        :param int day_of_week: The day of week for maintenance window. Defaults to `0`.
        :param int start_hour: The start hour for maintenance window. Defaults to `0`.
        :param int start_minute: The start minute for maintenance window. Defaults to `0`.
        """
        FlexibleServerMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_week=day_of_week,
            start_hour=start_hour,
            start_minute=start_minute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_week: Optional[int] = None,
             start_hour: Optional[int] = None,
             start_minute: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if day_of_week is not None:
            _setter("day_of_week", day_of_week)
        if start_hour is not None:
            _setter("start_hour", start_hour)
        if start_minute is not None:
            _setter("start_minute", start_minute)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[int]:
        """
        The day of week for maintenance window. Defaults to `0`.
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[int]:
        """
        The start hour for maintenance window. Defaults to `0`.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[int]:
        """
        The start minute for maintenance window. Defaults to `0`.
        """
        return pulumi.get(self, "start_minute")


@pulumi.output_type
class FlexibleServerStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoGrowEnabled":
            suggest = "auto_grow_enabled"
        elif key == "ioScalingEnabled":
            suggest = "io_scaling_enabled"
        elif key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlexibleServerStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlexibleServerStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlexibleServerStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_grow_enabled: Optional[bool] = None,
                 io_scaling_enabled: Optional[bool] = None,
                 iops: Optional[int] = None,
                 size_gb: Optional[int] = None):
        """
        :param bool auto_grow_enabled: Should Storage Auto Grow be enabled? Defaults to `true`.
        :param bool io_scaling_enabled: Should IOPS be scaled automatically? If `true`, `iops` can not be set. Defaults to `false`.
        :param int iops: The storage IOPS for the MySQL Flexible Server. Possible values are between `360` and `20000`.
        :param int size_gb: The max storage allowed for the MySQL Flexible Server. Possible values are between `20` and `16384`.
        """
        FlexibleServerStorage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_grow_enabled=auto_grow_enabled,
            io_scaling_enabled=io_scaling_enabled,
            iops=iops,
            size_gb=size_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_grow_enabled: Optional[bool] = None,
             io_scaling_enabled: Optional[bool] = None,
             iops: Optional[int] = None,
             size_gb: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_grow_enabled is not None:
            _setter("auto_grow_enabled", auto_grow_enabled)
        if io_scaling_enabled is not None:
            _setter("io_scaling_enabled", io_scaling_enabled)
        if iops is not None:
            _setter("iops", iops)
        if size_gb is not None:
            _setter("size_gb", size_gb)

    @property
    @pulumi.getter(name="autoGrowEnabled")
    def auto_grow_enabled(self) -> Optional[bool]:
        """
        Should Storage Auto Grow be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "auto_grow_enabled")

    @property
    @pulumi.getter(name="ioScalingEnabled")
    def io_scaling_enabled(self) -> Optional[bool]:
        """
        Should IOPS be scaled automatically? If `true`, `iops` can not be set. Defaults to `false`.
        """
        return pulumi.get(self, "io_scaling_enabled")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The storage IOPS for the MySQL Flexible Server. Possible values are between `360` and `20000`.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[int]:
        """
        The max storage allowed for the MySQL Flexible Server. Possible values are between `20` and `16384`.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class ServerIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this MySQL Server. The only possible value is `SystemAssigned`.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        ServerIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            principal_id=principal_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if principal_id is not None:
            _setter("principal_id", principal_id)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this MySQL Server. The only possible value is `SystemAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ServerThreatDetectionPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disabledAlerts":
            suggest = "disabled_alerts"
        elif key == "emailAccountAdmins":
            suggest = "email_account_admins"
        elif key == "emailAddresses":
            suggest = "email_addresses"
        elif key == "retentionDays":
            suggest = "retention_days"
        elif key == "storageAccountAccessKey":
            suggest = "storage_account_access_key"
        elif key == "storageEndpoint":
            suggest = "storage_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerThreatDetectionPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerThreatDetectionPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerThreatDetectionPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled_alerts: Optional[Sequence[str]] = None,
                 email_account_admins: Optional[bool] = None,
                 email_addresses: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None,
                 retention_days: Optional[int] = None,
                 storage_account_access_key: Optional[str] = None,
                 storage_endpoint: Optional[str] = None):
        """
        :param Sequence[str] disabled_alerts: Specifies a list of alerts which should be disabled. Possible values are `Sql_Injection`, `Sql_Injection_Vulnerability`, `Access_Anomaly`, `Data_Exfiltration` and `Unsafe_Action`.
        :param bool email_account_admins: Should the account administrators be emailed when this alert is triggered?
        :param Sequence[str] email_addresses: A list of email addresses which alerts should be sent to.
        :param bool enabled: Is the policy enabled?
        :param int retention_days: Specifies the number of days to keep in the Threat Detection audit logs.
        :param str storage_account_access_key: Specifies the identifier key of the Threat Detection audit storage account.
        :param str storage_endpoint: Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs.
        """
        ServerThreatDetectionPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disabled_alerts=disabled_alerts,
            email_account_admins=email_account_admins,
            email_addresses=email_addresses,
            enabled=enabled,
            retention_days=retention_days,
            storage_account_access_key=storage_account_access_key,
            storage_endpoint=storage_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disabled_alerts: Optional[Sequence[str]] = None,
             email_account_admins: Optional[bool] = None,
             email_addresses: Optional[Sequence[str]] = None,
             enabled: Optional[bool] = None,
             retention_days: Optional[int] = None,
             storage_account_access_key: Optional[str] = None,
             storage_endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if disabled_alerts is not None:
            _setter("disabled_alerts", disabled_alerts)
        if email_account_admins is not None:
            _setter("email_account_admins", email_account_admins)
        if email_addresses is not None:
            _setter("email_addresses", email_addresses)
        if enabled is not None:
            _setter("enabled", enabled)
        if retention_days is not None:
            _setter("retention_days", retention_days)
        if storage_account_access_key is not None:
            _setter("storage_account_access_key", storage_account_access_key)
        if storage_endpoint is not None:
            _setter("storage_endpoint", storage_endpoint)

    @property
    @pulumi.getter(name="disabledAlerts")
    def disabled_alerts(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of alerts which should be disabled. Possible values are `Sql_Injection`, `Sql_Injection_Vulnerability`, `Access_Anomaly`, `Data_Exfiltration` and `Unsafe_Action`.
        """
        return pulumi.get(self, "disabled_alerts")

    @property
    @pulumi.getter(name="emailAccountAdmins")
    def email_account_admins(self) -> Optional[bool]:
        """
        Should the account administrators be emailed when this alert is triggered?
        """
        return pulumi.get(self, "email_account_admins")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[str]]:
        """
        A list of email addresses which alerts should be sent to.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Is the policy enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[int]:
        """
        Specifies the number of days to keep in the Threat Detection audit logs.
        """
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter(name="storageAccountAccessKey")
    def storage_account_access_key(self) -> Optional[str]:
        """
        Specifies the identifier key of the Threat Detection audit storage account.
        """
        return pulumi.get(self, "storage_account_access_key")

    @property
    @pulumi.getter(name="storageEndpoint")
    def storage_endpoint(self) -> Optional[str]:
        """
        Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs.
        """
        return pulumi.get(self, "storage_endpoint")


@pulumi.output_type
class GetFlexibleServerHighAvailabilityResult(dict):
    def __init__(__self__, *,
                 mode: str,
                 standby_availability_zone: str):
        """
        :param str mode: The high availability mode of the MySQL Flexible Server.
        :param str standby_availability_zone: The availability zone of the standby Flexible Server.
        """
        GetFlexibleServerHighAvailabilityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            standby_availability_zone=standby_availability_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: str,
             standby_availability_zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mode", mode)
        _setter("standby_availability_zone", standby_availability_zone)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The high availability mode of the MySQL Flexible Server.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="standbyAvailabilityZone")
    def standby_availability_zone(self) -> str:
        """
        The availability zone of the standby Flexible Server.
        """
        return pulumi.get(self, "standby_availability_zone")


@pulumi.output_type
class GetFlexibleServerMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day_of_week: int,
                 start_hour: int,
                 start_minute: int):
        """
        :param int day_of_week: The day of week of the maintenance window.
        :param int start_hour: The start hour of the maintenance window.
        :param int start_minute: The start minute of the maintenance window.
        """
        GetFlexibleServerMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_week=day_of_week,
            start_hour=start_hour,
            start_minute=start_minute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_week: int,
             start_hour: int,
             start_minute: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("day_of_week", day_of_week)
        _setter("start_hour", start_hour)
        _setter("start_minute", start_minute)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> int:
        """
        The day of week of the maintenance window.
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        The start hour of the maintenance window.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> int:
        """
        The start minute of the maintenance window.
        """
        return pulumi.get(self, "start_minute")


@pulumi.output_type
class GetFlexibleServerStorageResult(dict):
    def __init__(__self__, *,
                 auto_grow_enabled: bool,
                 io_scaling_enabled: bool,
                 iops: int,
                 size_gb: int):
        """
        :param bool auto_grow_enabled: Is Storage Auto Grow enabled?
        :param bool io_scaling_enabled: Should IOPS be scaled automatically?
        :param int iops: The storage IOPS of the MySQL Flexible Server.
        :param int size_gb: The max storage allowed for the MySQL Flexible Server.
        """
        GetFlexibleServerStorageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_grow_enabled=auto_grow_enabled,
            io_scaling_enabled=io_scaling_enabled,
            iops=iops,
            size_gb=size_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_grow_enabled: bool,
             io_scaling_enabled: bool,
             iops: int,
             size_gb: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("auto_grow_enabled", auto_grow_enabled)
        _setter("io_scaling_enabled", io_scaling_enabled)
        _setter("iops", iops)
        _setter("size_gb", size_gb)

    @property
    @pulumi.getter(name="autoGrowEnabled")
    def auto_grow_enabled(self) -> bool:
        """
        Is Storage Auto Grow enabled?
        """
        return pulumi.get(self, "auto_grow_enabled")

    @property
    @pulumi.getter(name="ioScalingEnabled")
    def io_scaling_enabled(self) -> bool:
        """
        Should IOPS be scaled automatically?
        """
        return pulumi.get(self, "io_scaling_enabled")

    @property
    @pulumi.getter
    def iops(self) -> int:
        """
        The storage IOPS of the MySQL Flexible Server.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        The max storage allowed for the MySQL Flexible Server.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class GetServerIdentityResult(dict):
    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        :param str type: The identity type of this Managed Service Identity.
        """
        GetServerIdentityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: str,
             tenant_id: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        _setter("type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type of this Managed Service Identity.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetServerThreatDetectionPolicyResult(dict):
    def __init__(__self__, *,
                 disabled_alerts: Sequence[str],
                 email_account_admins: bool,
                 email_addresses: Sequence[str],
                 enabled: bool,
                 retention_days: int,
                 storage_account_access_key: str,
                 storage_endpoint: str):
        """
        :param Sequence[str] disabled_alerts: Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
        :param bool email_account_admins: Should the account administrators be emailed when this alert is triggered?
        :param Sequence[str] email_addresses: A list of email addresses which alerts should be sent to.
        :param bool enabled: Is the policy enabled?
        :param int retention_days: Specifies the number of days to keep in the Threat Detection audit logs.
        :param str storage_account_access_key: Specifies the identifier key of the Threat Detection audit storage account.
        :param str storage_endpoint: Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs.
        """
        GetServerThreatDetectionPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disabled_alerts=disabled_alerts,
            email_account_admins=email_account_admins,
            email_addresses=email_addresses,
            enabled=enabled,
            retention_days=retention_days,
            storage_account_access_key=storage_account_access_key,
            storage_endpoint=storage_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disabled_alerts: Sequence[str],
             email_account_admins: bool,
             email_addresses: Sequence[str],
             enabled: bool,
             retention_days: int,
             storage_account_access_key: str,
             storage_endpoint: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("disabled_alerts", disabled_alerts)
        _setter("email_account_admins", email_account_admins)
        _setter("email_addresses", email_addresses)
        _setter("enabled", enabled)
        _setter("retention_days", retention_days)
        _setter("storage_account_access_key", storage_account_access_key)
        _setter("storage_endpoint", storage_endpoint)

    @property
    @pulumi.getter(name="disabledAlerts")
    def disabled_alerts(self) -> Sequence[str]:
        """
        Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
        """
        return pulumi.get(self, "disabled_alerts")

    @property
    @pulumi.getter(name="emailAccountAdmins")
    def email_account_admins(self) -> bool:
        """
        Should the account administrators be emailed when this alert is triggered?
        """
        return pulumi.get(self, "email_account_admins")

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Sequence[str]:
        """
        A list of email addresses which alerts should be sent to.
        """
        return pulumi.get(self, "email_addresses")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the policy enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> int:
        """
        Specifies the number of days to keep in the Threat Detection audit logs.
        """
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter(name="storageAccountAccessKey")
    def storage_account_access_key(self) -> str:
        """
        Specifies the identifier key of the Threat Detection audit storage account.
        """
        return pulumi.get(self, "storage_account_access_key")

    @property
    @pulumi.getter(name="storageEndpoint")
    def storage_endpoint(self) -> str:
        """
        Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs.
        """
        return pulumi.get(self, "storage_endpoint")


