# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'BastionHostIpConfiguration',
    'CapacityReservationSku',
    'DiskEncryptionSetIdentity',
    'ExtensionProtectedSettingsFromKeyVault',
    'GalleryApplicationVersionManageAction',
    'GalleryApplicationVersionSource',
    'GalleryApplicationVersionTargetRegion',
    'ImageDataDisk',
    'ImageOsDisk',
    'LinuxVirtualMachineAdditionalCapabilities',
    'LinuxVirtualMachineAdminSshKey',
    'LinuxVirtualMachineBootDiagnostics',
    'LinuxVirtualMachineGalleryApplication',
    'LinuxVirtualMachineIdentity',
    'LinuxVirtualMachineOsDisk',
    'LinuxVirtualMachineOsDiskDiffDiskSettings',
    'LinuxVirtualMachinePlan',
    'LinuxVirtualMachineScaleSetAdditionalCapabilities',
    'LinuxVirtualMachineScaleSetAdminSshKey',
    'LinuxVirtualMachineScaleSetAutomaticInstanceRepair',
    'LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicy',
    'LinuxVirtualMachineScaleSetBootDiagnostics',
    'LinuxVirtualMachineScaleSetDataDisk',
    'LinuxVirtualMachineScaleSetExtension',
    'LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault',
    'LinuxVirtualMachineScaleSetGalleryApplication',
    'LinuxVirtualMachineScaleSetIdentity',
    'LinuxVirtualMachineScaleSetNetworkInterface',
    'LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration',
    'LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress',
    'LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag',
    'LinuxVirtualMachineScaleSetOsDisk',
    'LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings',
    'LinuxVirtualMachineScaleSetPlan',
    'LinuxVirtualMachineScaleSetRollingUpgradePolicy',
    'LinuxVirtualMachineScaleSetScaleIn',
    'LinuxVirtualMachineScaleSetSecret',
    'LinuxVirtualMachineScaleSetSecretCertificate',
    'LinuxVirtualMachineScaleSetSourceImageReference',
    'LinuxVirtualMachineScaleSetSpotRestore',
    'LinuxVirtualMachineScaleSetTerminateNotification',
    'LinuxVirtualMachineScaleSetTerminationNotification',
    'LinuxVirtualMachineSecret',
    'LinuxVirtualMachineSecretCertificate',
    'LinuxVirtualMachineSourceImageReference',
    'LinuxVirtualMachineTerminationNotification',
    'ManagedDiskEncryptionSettings',
    'ManagedDiskEncryptionSettingsDiskEncryptionKey',
    'ManagedDiskEncryptionSettingsKeyEncryptionKey',
    'OrchestratedVirtualMachineScaleSetAdditionalCapabilities',
    'OrchestratedVirtualMachineScaleSetAutomaticInstanceRepair',
    'OrchestratedVirtualMachineScaleSetBootDiagnostics',
    'OrchestratedVirtualMachineScaleSetDataDisk',
    'OrchestratedVirtualMachineScaleSetExtension',
    'OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault',
    'OrchestratedVirtualMachineScaleSetIdentity',
    'OrchestratedVirtualMachineScaleSetNetworkInterface',
    'OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration',
    'OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress',
    'OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag',
    'OrchestratedVirtualMachineScaleSetOsDisk',
    'OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettings',
    'OrchestratedVirtualMachineScaleSetOsProfile',
    'OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration',
    'OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey',
    'OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret',
    'OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificate',
    'OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration',
    'OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret',
    'OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificate',
    'OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener',
    'OrchestratedVirtualMachineScaleSetPlan',
    'OrchestratedVirtualMachineScaleSetSourceImageReference',
    'OrchestratedVirtualMachineScaleSetTerminationNotification',
    'ScaleSetBootDiagnostics',
    'ScaleSetExtension',
    'ScaleSetIdentity',
    'ScaleSetNetworkProfile',
    'ScaleSetNetworkProfileDnsSettings',
    'ScaleSetNetworkProfileIpConfiguration',
    'ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration',
    'ScaleSetOsProfile',
    'ScaleSetOsProfileLinuxConfig',
    'ScaleSetOsProfileLinuxConfigSshKey',
    'ScaleSetOsProfileSecret',
    'ScaleSetOsProfileSecretVaultCertificate',
    'ScaleSetOsProfileWindowsConfig',
    'ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig',
    'ScaleSetOsProfileWindowsConfigWinrm',
    'ScaleSetPlan',
    'ScaleSetRollingUpgradePolicy',
    'ScaleSetSku',
    'ScaleSetStorageProfileDataDisk',
    'ScaleSetStorageProfileImageReference',
    'ScaleSetStorageProfileOsDisk',
    'SharedImageIdentifier',
    'SharedImagePurchasePlan',
    'SharedImageVersionTargetRegion',
    'SnapshotEncryptionSettings',
    'SnapshotEncryptionSettingsDiskEncryptionKey',
    'SnapshotEncryptionSettingsKeyEncryptionKey',
    'VirtualMachineAdditionalCapabilities',
    'VirtualMachineBootDiagnostics',
    'VirtualMachineIdentity',
    'VirtualMachineOsProfile',
    'VirtualMachineOsProfileLinuxConfig',
    'VirtualMachineOsProfileLinuxConfigSshKey',
    'VirtualMachineOsProfileSecret',
    'VirtualMachineOsProfileSecretVaultCertificate',
    'VirtualMachineOsProfileWindowsConfig',
    'VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig',
    'VirtualMachineOsProfileWindowsConfigWinrm',
    'VirtualMachinePlan',
    'VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault',
    'VirtualMachineStorageDataDisk',
    'VirtualMachineStorageImageReference',
    'VirtualMachineStorageOsDisk',
    'WindowsVirtualMachineAdditionalCapabilities',
    'WindowsVirtualMachineAdditionalUnattendContent',
    'WindowsVirtualMachineBootDiagnostics',
    'WindowsVirtualMachineGalleryApplication',
    'WindowsVirtualMachineIdentity',
    'WindowsVirtualMachineOsDisk',
    'WindowsVirtualMachineOsDiskDiffDiskSettings',
    'WindowsVirtualMachinePlan',
    'WindowsVirtualMachineScaleSetAdditionalCapabilities',
    'WindowsVirtualMachineScaleSetAdditionalUnattendContent',
    'WindowsVirtualMachineScaleSetAutomaticInstanceRepair',
    'WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicy',
    'WindowsVirtualMachineScaleSetBootDiagnostics',
    'WindowsVirtualMachineScaleSetDataDisk',
    'WindowsVirtualMachineScaleSetExtension',
    'WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault',
    'WindowsVirtualMachineScaleSetGalleryApplication',
    'WindowsVirtualMachineScaleSetIdentity',
    'WindowsVirtualMachineScaleSetNetworkInterface',
    'WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration',
    'WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress',
    'WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag',
    'WindowsVirtualMachineScaleSetOsDisk',
    'WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings',
    'WindowsVirtualMachineScaleSetPlan',
    'WindowsVirtualMachineScaleSetRollingUpgradePolicy',
    'WindowsVirtualMachineScaleSetScaleIn',
    'WindowsVirtualMachineScaleSetSecret',
    'WindowsVirtualMachineScaleSetSecretCertificate',
    'WindowsVirtualMachineScaleSetSourceImageReference',
    'WindowsVirtualMachineScaleSetSpotRestore',
    'WindowsVirtualMachineScaleSetTerminateNotification',
    'WindowsVirtualMachineScaleSetTerminationNotification',
    'WindowsVirtualMachineScaleSetWinrmListener',
    'WindowsVirtualMachineSecret',
    'WindowsVirtualMachineSecretCertificate',
    'WindowsVirtualMachineSourceImageReference',
    'WindowsVirtualMachineTerminationNotification',
    'WindowsVirtualMachineWinrmListener',
    'GetConfidentialLedgerAzureadBasedServicePrincipalResult',
    'GetConfidentialLedgerCertificateBasedSecurityPrincipalResult',
    'GetImageDataDiskResult',
    'GetImageOsDiskResult',
    'GetImagesImageResult',
    'GetImagesImageDataDiskResult',
    'GetImagesImageOsDiskResult',
    'GetManagedDiskEncryptionSettingResult',
    'GetManagedDiskEncryptionSettingDiskEncryptionKeyResult',
    'GetManagedDiskEncryptionSettingKeyEncryptionKeyResult',
    'GetSharedImageIdentifierResult',
    'GetSharedImageVersionTargetRegionResult',
    'GetSharedImageVersionsImageResult',
    'GetSharedImageVersionsImageTargetRegionResult',
    'GetSnapshotEncryptionSettingResult',
    'GetSnapshotEncryptionSettingDiskEncryptionKeyResult',
    'GetSnapshotEncryptionSettingKeyEncryptionKeyResult',
    'GetVirtualMachineIdentityResult',
    'GetVirtualMachineScaleSetIdentityResult',
    'GetVirtualMachineScaleSetInstanceResult',
    'GetVirtualMachineScaleSetNetworkInterfaceResult',
    'GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationResult',
    'GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressResult',
    'GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagResult',
]

@pulumi.output_type
class BastionHostIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BastionHostIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BastionHostIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BastionHostIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 public_ip_address_id: str,
                 subnet_id: str):
        """
        :param str name: The name of the IP configuration. Changing this forces a new resource to be created.
        :param str public_ip_address_id: Reference to a Public IP Address to associate with this Bastion Host. Changing this forces a new resource to be created.
        :param str subnet_id: Reference to a subnet in which this Bastion Host has been created. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the IP configuration. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> str:
        """
        Reference to a Public IP Address to associate with this Bastion Host. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Reference to a subnet in which this Bastion Host has been created. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class CapacityReservationSku(dict):
    def __init__(__self__, *,
                 capacity: int,
                 name: str):
        """
        :param int capacity: Specifies the number of instances to be reserved. It must be a positive `integer` and not exceed the quota in the subscription.
        :param str name: Name of the sku, such as `Standard_F2`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Specifies the number of instances to be reserved. It must be a positive `integer` and not exceed the quota in the subscription.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the sku, such as `Standard_F2`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DiskEncryptionSetIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEncryptionSetIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEncryptionSetIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEncryptionSetIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: The type of Managed Service Identity that is configured on this Disk Encryption Set.  Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Disk Encryption Set.
        :param str principal_id: The (Client) ID of the Service Principal.
        :param str tenant_id: The ID of the Tenant the Service Principal is assigned in.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Managed Service Identity that is configured on this Disk Encryption Set.  Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Disk Encryption Set.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The (Client) ID of the Service Principal.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the Tenant the Service Principal is assigned in.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ExtensionProtectedSettingsFromKeyVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretUrl":
            suggest = "secret_url"
        elif key == "sourceVaultId":
            suggest = "source_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExtensionProtectedSettingsFromKeyVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_url: str,
                 source_vault_id: str):
        """
        :param str secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param str source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> str:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class GalleryApplicationVersionManageAction(dict):
    def __init__(__self__, *,
                 install: str,
                 remove: str,
                 update: Optional[str] = None):
        """
        :param str install: The command to install the Gallery Application. Changing this forces a new resource to be created.
        :param str remove: The command to remove the Gallery Application. Changing this forces a new resource to be created.
        :param str update: The command to update the Gallery Application. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "install", install)
        pulumi.set(__self__, "remove", remove)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def install(self) -> str:
        """
        The command to install the Gallery Application. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "install")

    @property
    @pulumi.getter
    def remove(self) -> str:
        """
        The command to remove the Gallery Application. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        The command to update the Gallery Application. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GalleryApplicationVersionSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaLink":
            suggest = "media_link"
        elif key == "defaultConfigurationLink":
            suggest = "default_configuration_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GalleryApplicationVersionSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GalleryApplicationVersionSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GalleryApplicationVersionSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 media_link: str,
                 default_configuration_link: Optional[str] = None):
        """
        :param str media_link: The Storage Blob URI of the source application package. Changing this forces a new resource to be created.
        :param str default_configuration_link: The Storage Blob URI of the default configuration. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "media_link", media_link)
        if default_configuration_link is not None:
            pulumi.set(__self__, "default_configuration_link", default_configuration_link)

    @property
    @pulumi.getter(name="mediaLink")
    def media_link(self) -> str:
        """
        The Storage Blob URI of the source application package. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "media_link")

    @property
    @pulumi.getter(name="defaultConfigurationLink")
    def default_configuration_link(self) -> Optional[str]:
        """
        The Storage Blob URI of the default configuration. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "default_configuration_link")


@pulumi.output_type
class GalleryApplicationVersionTargetRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionalReplicaCount":
            suggest = "regional_replica_count"
        elif key == "storageAccountType":
            suggest = "storage_account_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GalleryApplicationVersionTargetRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GalleryApplicationVersionTargetRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GalleryApplicationVersionTargetRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 regional_replica_count: int,
                 storage_account_type: Optional[str] = None):
        """
        :param str name: The Azure Region in which the Gallery Application Version exists.
        :param int regional_replica_count: The number of replicas of the Gallery Application Version to be created per region. Possible values are between `1` and `10`.
        :param str storage_account_type: The storage account type for the Gallery Application Version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regional_replica_count", regional_replica_count)
        if storage_account_type is not None:
            pulumi.set(__self__, "storage_account_type", storage_account_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Azure Region in which the Gallery Application Version exists.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="regionalReplicaCount")
    def regional_replica_count(self) -> int:
        """
        The number of replicas of the Gallery Application Version to be created per region. Possible values are between `1` and `10`.
        """
        return pulumi.get(self, "regional_replica_count")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> Optional[str]:
        """
        The storage account type for the Gallery Application Version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`.
        """
        return pulumi.get(self, "storage_account_type")


@pulumi.output_type
class ImageDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobUri":
            suggest = "blob_uri"
        elif key == "managedDiskId":
            suggest = "managed_disk_id"
        elif key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_uri: Optional[str] = None,
                 caching: Optional[str] = None,
                 lun: Optional[int] = None,
                 managed_disk_id: Optional[str] = None,
                 size_gb: Optional[int] = None):
        """
        :param str blob_uri: Specifies the URI in Azure storage of the blob that you want to use to create the image.
        :param str caching: Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
        :param int lun: Specifies the logical unit number of the data disk.
        :param str managed_disk_id: Specifies the ID of the managed disk resource that you want to use to create the image.
        :param int size_gb: Specifies the size of the image to be created. The target size can't be smaller than the source size.
        """
        if blob_uri is not None:
            pulumi.set(__self__, "blob_uri", blob_uri)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if lun is not None:
            pulumi.set(__self__, "lun", lun)
        if managed_disk_id is not None:
            pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blobUri")
    def blob_uri(self) -> Optional[str]:
        """
        Specifies the URI in Azure storage of the blob that you want to use to create the image.
        """
        return pulumi.get(self, "blob_uri")

    @property
    @pulumi.getter
    def caching(self) -> Optional[str]:
        """
        Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter
    def lun(self) -> Optional[int]:
        """
        Specifies the logical unit number of the data disk.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> Optional[str]:
        """
        Specifies the ID of the managed disk resource that you want to use to create the image.
        """
        return pulumi.get(self, "managed_disk_id")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[int]:
        """
        Specifies the size of the image to be created. The target size can't be smaller than the source size.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class ImageOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobUri":
            suggest = "blob_uri"
        elif key == "managedDiskId":
            suggest = "managed_disk_id"
        elif key == "osState":
            suggest = "os_state"
        elif key == "osType":
            suggest = "os_type"
        elif key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_uri: Optional[str] = None,
                 caching: Optional[str] = None,
                 managed_disk_id: Optional[str] = None,
                 os_state: Optional[str] = None,
                 os_type: Optional[str] = None,
                 size_gb: Optional[int] = None):
        """
        :param str blob_uri: Specifies the URI in Azure storage of the blob that you want to use to create the image.
        :param str caching: Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
        :param str managed_disk_id: Specifies the ID of the managed disk resource that you want to use to create the image.
        :param str os_state: Specifies the state of the operating system contained in the blob. Currently, the only value is Generalized.
        :param str os_type: Specifies the type of operating system contained in the virtual machine image. Possible values are: Windows or Linux.
        :param int size_gb: Specifies the size of the image to be created. The target size can't be smaller than the source size.
        """
        if blob_uri is not None:
            pulumi.set(__self__, "blob_uri", blob_uri)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if managed_disk_id is not None:
            pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        if os_state is not None:
            pulumi.set(__self__, "os_state", os_state)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blobUri")
    def blob_uri(self) -> Optional[str]:
        """
        Specifies the URI in Azure storage of the blob that you want to use to create the image.
        """
        return pulumi.get(self, "blob_uri")

    @property
    @pulumi.getter
    def caching(self) -> Optional[str]:
        """
        Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> Optional[str]:
        """
        Specifies the ID of the managed disk resource that you want to use to create the image.
        """
        return pulumi.get(self, "managed_disk_id")

    @property
    @pulumi.getter(name="osState")
    def os_state(self) -> Optional[str]:
        """
        Specifies the state of the operating system contained in the blob. Currently, the only value is Generalized.
        """
        return pulumi.get(self, "os_state")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[str]:
        """
        Specifies the type of operating system contained in the virtual machine image. Possible values are: Windows or Linux.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[int]:
        """
        Specifies the size of the image to be created. The target size can't be smaller than the source size.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class LinuxVirtualMachineAdditionalCapabilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ultraSsdEnabled":
            suggest = "ultra_ssd_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineAdditionalCapabilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineAdditionalCapabilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineAdditionalCapabilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[bool] = None):
        """
        :param bool ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[bool]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
        """
        return pulumi.get(self, "ultra_ssd_enabled")


@pulumi.output_type
class LinuxVirtualMachineAdminSshKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineAdminSshKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineAdminSshKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineAdminSshKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: str,
                 username: str):
        """
        :param str public_key: The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format. Changing this forces a new resource to be created.
        :param str username: The Username for which this Public SSH Key should be configured. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username for which this Public SSH Key should be configured. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class LinuxVirtualMachineBootDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUri":
            suggest = "storage_account_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineBootDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineBootDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineBootDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_account_uri: Optional[str] = None):
        """
        :param str storage_account_uri: The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
        """
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[str]:
        """
        The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
        """
        return pulumi.get(self, "storage_account_uri")


@pulumi.output_type
class LinuxVirtualMachineGalleryApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "versionId":
            suggest = "version_id"
        elif key == "configurationBlobUri":
            suggest = "configuration_blob_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineGalleryApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineGalleryApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineGalleryApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version_id: str,
                 configuration_blob_uri: Optional[str] = None,
                 order: Optional[int] = None,
                 tag: Optional[str] = None):
        """
        :param str version_id: Specifies the Gallery Application Version resource ID.
        :param str configuration_blob_uri: Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
        :param int order: Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
        :param str tag: Specifies a passthrough value for more generic context. This field can be any valid `string` value.
        """
        pulumi.set(__self__, "version_id", version_id)
        if configuration_blob_uri is not None:
            pulumi.set(__self__, "configuration_blob_uri", configuration_blob_uri)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> str:
        """
        Specifies the Gallery Application Version resource ID.
        """
        return pulumi.get(self, "version_id")

    @property
    @pulumi.getter(name="configurationBlobUri")
    def configuration_blob_uri(self) -> Optional[str]:
        """
        Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
        """
        return pulumi.get(self, "configuration_blob_uri")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Specifies a passthrough value for more generic context. This field can be any valid `string` value.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class LinuxVirtualMachineIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxVirtualMachineOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountType":
            suggest = "storage_account_type"
        elif key == "diffDiskSettings":
            suggest = "diff_disk_settings"
        elif key == "diskEncryptionSetId":
            suggest = "disk_encryption_set_id"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "secureVmDiskEncryptionSetId":
            suggest = "secure_vm_disk_encryption_set_id"
        elif key == "securityEncryptionType":
            suggest = "security_encryption_type"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: str,
                 storage_account_type: str,
                 diff_disk_settings: Optional['outputs.LinuxVirtualMachineOsDiskDiffDiskSettings'] = None,
                 disk_encryption_set_id: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 name: Optional[str] = None,
                 secure_vm_disk_encryption_set_id: Optional[str] = None,
                 security_encryption_type: Optional[str] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        """
        :param str caching: The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param str storage_account_type: The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        :param 'LinuxVirtualMachineOsDiskDiffDiskSettingsArgs' diff_disk_settings: A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        :param str disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`.
        :param int disk_size_gb: The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
        :param str name: The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
        :param str secure_vm_disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
        :param str security_encryption_type: Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
        :param bool write_accelerator_enabled: Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure_vm_disk_encryption_set_id is not None:
            pulumi.set(__self__, "secure_vm_disk_encryption_set_id", secure_vm_disk_encryption_set_id)
        if security_encryption_type is not None:
            pulumi.set(__self__, "security_encryption_type", security_encryption_type)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        """
        The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional['outputs.LinuxVirtualMachineOsDiskDiffDiskSettings']:
        """
        A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "diff_disk_settings")

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        """
        The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secureVmDiskEncryptionSetId")
    def secure_vm_disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secure_vm_disk_encryption_set_id")

    @property
    @pulumi.getter(name="securityEncryptionType")
    def security_encryption_type(self) -> Optional[str]:
        """
        Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "security_encryption_type")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        """
        Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class LinuxVirtualMachineOsDiskDiffDiskSettings(dict):
    def __init__(__self__, *,
                 option: str,
                 placement: Optional[str] = None):
        """
        :param str option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param str placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> str:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @property
    @pulumi.getter
    def placement(self) -> Optional[str]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")


@pulumi.output_type
class LinuxVirtualMachinePlan(dict):
    def __init__(__self__, *,
                 name: str,
                 product: str,
                 publisher: str):
        """
        :param str name: Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param str product: Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param str publisher: Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class LinuxVirtualMachineScaleSetAdditionalCapabilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ultraSsdEnabled":
            suggest = "ultra_ssd_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetAdditionalCapabilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetAdditionalCapabilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetAdditionalCapabilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[bool] = None):
        """
        :param bool ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[bool]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ultra_ssd_enabled")


@pulumi.output_type
class LinuxVirtualMachineScaleSetAdminSshKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetAdminSshKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetAdminSshKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetAdminSshKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: str,
                 username: str):
        """
        :param str public_key: The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format.
        :param str username: The Username for which this Public SSH Key should be configured.
        """
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username for which this Public SSH Key should be configured.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class LinuxVirtualMachineScaleSetAutomaticInstanceRepair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetAutomaticInstanceRepair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetAutomaticInstanceRepair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetAutomaticInstanceRepair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 grace_period: Optional[str] = None):
        """
        :param bool enabled: Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
        :param str grace_period: Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[str]:
        """
        Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableAutomaticRollback":
            suggest = "disable_automatic_rollback"
        elif key == "enableAutomaticOsUpgrade":
            suggest = "enable_automatic_os_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_automatic_rollback: bool,
                 enable_automatic_os_upgrade: bool):
        """
        :param bool disable_automatic_rollback: Should automatic rollbacks be disabled?
        :param bool enable_automatic_os_upgrade: Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
        """
        pulumi.set(__self__, "disable_automatic_rollback", disable_automatic_rollback)
        pulumi.set(__self__, "enable_automatic_os_upgrade", enable_automatic_os_upgrade)

    @property
    @pulumi.getter(name="disableAutomaticRollback")
    def disable_automatic_rollback(self) -> bool:
        """
        Should automatic rollbacks be disabled?
        """
        return pulumi.get(self, "disable_automatic_rollback")

    @property
    @pulumi.getter(name="enableAutomaticOsUpgrade")
    def enable_automatic_os_upgrade(self) -> bool:
        """
        Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
        """
        return pulumi.get(self, "enable_automatic_os_upgrade")


@pulumi.output_type
class LinuxVirtualMachineScaleSetBootDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUri":
            suggest = "storage_account_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetBootDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetBootDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetBootDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_account_uri: Optional[str] = None):
        """
        :param str storage_account_uri: The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
        """
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[str]:
        """
        The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
        """
        return pulumi.get(self, "storage_account_uri")


@pulumi.output_type
class LinuxVirtualMachineScaleSetDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "storageAccountType":
            suggest = "storage_account_type"
        elif key == "createOption":
            suggest = "create_option"
        elif key == "diskEncryptionSetId":
            suggest = "disk_encryption_set_id"
        elif key == "ultraSsdDiskIopsReadWrite":
            suggest = "ultra_ssd_disk_iops_read_write"
        elif key == "ultraSsdDiskMbpsReadWrite":
            suggest = "ultra_ssd_disk_mbps_read_write"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: str,
                 disk_size_gb: int,
                 lun: int,
                 storage_account_type: str,
                 create_option: Optional[str] = None,
                 disk_encryption_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 ultra_ssd_disk_iops_read_write: Optional[int] = None,
                 ultra_ssd_disk_mbps_read_write: Optional[int] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        """
        :param str caching: The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param int disk_size_gb: The size of the Data Disk which should be created.
        :param int lun: The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        :param str storage_account_type: The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
        :param str create_option: The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
        :param str disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.
        :param str name: The name of the Data Disk.
        :param bool write_accelerator_enabled: Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if create_option is not None:
            pulumi.set(__self__, "create_option", create_option)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ultra_ssd_disk_iops_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_iops_read_write", ultra_ssd_disk_iops_read_write)
        if ultra_ssd_disk_mbps_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_mbps_read_write", ultra_ssd_disk_mbps_read_write)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> int:
        """
        The size of the Data Disk which should be created.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        """
        The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
        """
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> Optional[str]:
        """
        The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
        """
        return pulumi.get(self, "create_option")

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Data Disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ultraSsdDiskIopsReadWrite")
    def ultra_ssd_disk_iops_read_write(self) -> Optional[int]:
        return pulumi.get(self, "ultra_ssd_disk_iops_read_write")

    @property
    @pulumi.getter(name="ultraSsdDiskMbpsReadWrite")
    def ultra_ssd_disk_mbps_read_write(self) -> Optional[int]:
        return pulumi.get(self, "ultra_ssd_disk_mbps_read_write")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        """
        Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class LinuxVirtualMachineScaleSetExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeHandlerVersion":
            suggest = "type_handler_version"
        elif key == "autoUpgradeMinorVersion":
            suggest = "auto_upgrade_minor_version"
        elif key == "automaticUpgradeEnabled":
            suggest = "automatic_upgrade_enabled"
        elif key == "forceUpdateTag":
            suggest = "force_update_tag"
        elif key == "protectedSettings":
            suggest = "protected_settings"
        elif key == "protectedSettingsFromKeyVault":
            suggest = "protected_settings_from_key_vault"
        elif key == "provisionAfterExtensions":
            suggest = "provision_after_extensions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 publisher: str,
                 type: str,
                 type_handler_version: str,
                 auto_upgrade_minor_version: Optional[bool] = None,
                 automatic_upgrade_enabled: Optional[bool] = None,
                 force_update_tag: Optional[str] = None,
                 protected_settings: Optional[str] = None,
                 protected_settings_from_key_vault: Optional['outputs.LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault'] = None,
                 provision_after_extensions: Optional[Sequence[str]] = None,
                 settings: Optional[str] = None):
        """
        :param str name: The name for the Virtual Machine Scale Set Extension.
        :param str publisher: Specifies the Publisher of the Extension.
        :param str type: Specifies the Type of the Extension.
        :param str type_handler_version: Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        :param bool auto_upgrade_minor_version: Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        :param bool automatic_upgrade_enabled: Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension? Defaults to `false`.
        :param str force_update_tag: A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        :param str protected_settings: A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
        :param Sequence[str] provision_after_extensions: An ordered list of Extension names which this should be provisioned after.
        :param str settings: A JSON String which specifies Settings for the Extension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version", auto_upgrade_minor_version)
        if automatic_upgrade_enabled is not None:
            pulumi.set(__self__, "automatic_upgrade_enabled", automatic_upgrade_enabled)
        if force_update_tag is not None:
            pulumi.set(__self__, "force_update_tag", force_update_tag)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if protected_settings_from_key_vault is not None:
            pulumi.set(__self__, "protected_settings_from_key_vault", protected_settings_from_key_vault)
        if provision_after_extensions is not None:
            pulumi.set(__self__, "provision_after_extensions", provision_after_extensions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Virtual Machine Scale Set Extension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the Publisher of the Extension.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the Type of the Extension.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> str:
        """
        Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        """
        return pulumi.get(self, "type_handler_version")

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[bool]:
        """
        Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @property
    @pulumi.getter(name="automaticUpgradeEnabled")
    def automatic_upgrade_enabled(self) -> Optional[bool]:
        """
        Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension? Defaults to `false`.
        """
        return pulumi.get(self, "automatic_upgrade_enabled")

    @property
    @pulumi.getter(name="forceUpdateTag")
    def force_update_tag(self) -> Optional[str]:
        """
        A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        """
        return pulumi.get(self, "force_update_tag")

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[str]:
        """
        A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
        """
        return pulumi.get(self, "protected_settings")

    @property
    @pulumi.getter(name="protectedSettingsFromKeyVault")
    def protected_settings_from_key_vault(self) -> Optional['outputs.LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault']:
        return pulumi.get(self, "protected_settings_from_key_vault")

    @property
    @pulumi.getter(name="provisionAfterExtensions")
    def provision_after_extensions(self) -> Optional[Sequence[str]]:
        """
        An ordered list of Extension names which this should be provisioned after.
        """
        return pulumi.get(self, "provision_after_extensions")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        """
        A JSON String which specifies Settings for the Extension.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretUrl":
            suggest = "secret_url"
        elif key == "sourceVaultId":
            suggest = "source_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_url: str,
                 source_vault_id: str):
        """
        :param str secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param str source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> str:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class LinuxVirtualMachineScaleSetGalleryApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packageReferenceId":
            suggest = "package_reference_id"
        elif key == "configurationReferenceBlobUri":
            suggest = "configuration_reference_blob_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetGalleryApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetGalleryApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetGalleryApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 package_reference_id: str,
                 configuration_reference_blob_uri: Optional[str] = None,
                 order: Optional[int] = None,
                 tag: Optional[str] = None):
        """
        :param int order: Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
        :param str tag: Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "package_reference_id", package_reference_id)
        if configuration_reference_blob_uri is not None:
            pulumi.set(__self__, "configuration_reference_blob_uri", configuration_reference_blob_uri)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="packageReferenceId")
    def package_reference_id(self) -> str:
        return pulumi.get(self, "package_reference_id")

    @property
    @pulumi.getter(name="configurationReferenceBlobUri")
    def configuration_reference_blob_uri(self) -> Optional[str]:
        return pulumi.get(self, "configuration_reference_blob_uri")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class LinuxVirtualMachineScaleSetIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine Scale Set.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine Scale Set.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LinuxVirtualMachineScaleSetNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipConfigurations":
            suggest = "ip_configurations"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "enableAcceleratedNetworking":
            suggest = "enable_accelerated_networking"
        elif key == "enableIpForwarding":
            suggest = "enable_ip_forwarding"
        elif key == "networkSecurityGroupId":
            suggest = "network_security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_configurations: Sequence['outputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration'],
                 name: str,
                 dns_servers: Optional[Sequence[str]] = None,
                 enable_accelerated_networking: Optional[bool] = None,
                 enable_ip_forwarding: Optional[bool] = None,
                 network_security_group_id: Optional[str] = None,
                 primary: Optional[bool] = None):
        """
        :param Sequence['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs'] ip_configurations: One or more `ip_configuration` blocks as defined above.
        :param str name: The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        :param Sequence[str] dns_servers: A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        :param bool enable_accelerated_networking: Does this Network Interface support Accelerated Networking? Defaults to `false`.
        :param bool enable_ip_forwarding: Does this Network Interface support IP Forwarding? Defaults to `false`.
        :param str network_security_group_id: The ID of a Network Security Group which should be assigned to this Network Interface.
        :param bool primary: Is this the Primary IP Configuration?
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if enable_accelerated_networking is not None:
            pulumi.set(__self__, "enable_accelerated_networking", enable_accelerated_networking)
        if enable_ip_forwarding is not None:
            pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration']:
        """
        One or more `ip_configuration` blocks as defined above.
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="enableAcceleratedNetworking")
    def enable_accelerated_networking(self) -> Optional[bool]:
        """
        Does this Network Interface support Accelerated Networking? Defaults to `false`.
        """
        return pulumi.get(self, "enable_accelerated_networking")

    @property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[bool]:
        """
        Does this Network Interface support IP Forwarding? Defaults to `false`.
        """
        return pulumi.get(self, "enable_ip_forwarding")

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[str]:
        """
        The ID of a Network Security Group which should be assigned to this Network Interface.
        """
        return pulumi.get(self, "network_security_group_id")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Is this the Primary IP Configuration?
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationGatewayBackendAddressPoolIds":
            suggest = "application_gateway_backend_address_pool_ids"
        elif key == "applicationSecurityGroupIds":
            suggest = "application_security_group_ids"
        elif key == "loadBalancerBackendAddressPoolIds":
            suggest = "load_balancer_backend_address_pool_ids"
        elif key == "loadBalancerInboundNatRulesIds":
            suggest = "load_balancer_inbound_nat_rules_ids"
        elif key == "publicIpAddresses":
            suggest = "public_ip_addresses"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 application_gateway_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 application_security_group_ids: Optional[Sequence[str]] = None,
                 load_balancer_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 load_balancer_inbound_nat_rules_ids: Optional[Sequence[str]] = None,
                 primary: Optional[bool] = None,
                 public_ip_addresses: Optional[Sequence['outputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress']] = None,
                 subnet_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: The Name which should be used for this IP Configuration.
        :param Sequence[str] application_gateway_backend_address_pool_ids: A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
        :param Sequence[str] application_security_group_ids: A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
        :param Sequence[str] load_balancer_backend_address_pool_ids: A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
        :param Sequence[str] load_balancer_inbound_nat_rules_ids: A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
        :param bool primary: Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
        :param Sequence['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs'] public_ip_addresses: A `public_ip_address` block as defined below.
        :param str subnet_id: The ID of the Subnet which this IP Configuration should be connected to.
        :param str version: The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        pulumi.set(__self__, "name", name)
        if application_gateway_backend_address_pool_ids is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if load_balancer_backend_address_pool_ids is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        if load_balancer_inbound_nat_rules_ids is not None:
            pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if public_ip_addresses is not None:
            pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name which should be used for this IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_security_group_ids")

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Optional[Sequence[str]]:
        """
        A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Optional[Sequence['outputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress']]:
        """
        A `public_ip_address` block as defined below.
        """
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet which this IP Configuration should be connected to.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNameLabel":
            suggest = "domain_name_label"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "ipTags":
            suggest = "ip_tags"
        elif key == "publicIpPrefixId":
            suggest = "public_ip_prefix_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 domain_name_label: Optional[str] = None,
                 idle_timeout_in_minutes: Optional[int] = None,
                 ip_tags: Optional[Sequence['outputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag']] = None,
                 public_ip_prefix_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: The Name of the Public IP Address Configuration.
        :param str domain_name_label: The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
        :param int idle_timeout_in_minutes: The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        :param Sequence['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs'] ip_tags: One or more `ip_tag` blocks as defined above.
        :param str public_ip_prefix_id: The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
        :param str version: The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        pulumi.set(__self__, "name", name)
        if domain_name_label is not None:
            pulumi.set(__self__, "domain_name_label", domain_name_label)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if public_ip_prefix_id is not None:
            pulumi.set(__self__, "public_ip_prefix_id", public_ip_prefix_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Public IP Address Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> Optional[str]:
        """
        The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
        """
        return pulumi.get(self, "domain_name_label")

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[int]:
        """
        The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[Sequence['outputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag']]:
        """
        One or more `ip_tag` blocks as defined above.
        """
        return pulumi.get(self, "ip_tags")

    @property
    @pulumi.getter(name="publicIpPrefixId")
    def public_ip_prefix_id(self) -> Optional[str]:
        """
        The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "public_ip_prefix_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag(dict):
    def __init__(__self__, *,
                 tag: str,
                 type: str):
        """
        :param str tag: The IP Tag associated with the Public IP, such as `SQL` or `Storage`.
        :param str type: The Type of IP Tag, such as `FirstPartyUsage`.
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        The IP Tag associated with the Public IP, such as `SQL` or `Storage`.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Type of IP Tag, such as `FirstPartyUsage`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LinuxVirtualMachineScaleSetOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountType":
            suggest = "storage_account_type"
        elif key == "diffDiskSettings":
            suggest = "diff_disk_settings"
        elif key == "diskEncryptionSetId":
            suggest = "disk_encryption_set_id"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "secureVmDiskEncryptionSetId":
            suggest = "secure_vm_disk_encryption_set_id"
        elif key == "securityEncryptionType":
            suggest = "security_encryption_type"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: str,
                 storage_account_type: str,
                 diff_disk_settings: Optional['outputs.LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings'] = None,
                 disk_encryption_set_id: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 secure_vm_disk_encryption_set_id: Optional[str] = None,
                 security_encryption_type: Optional[str] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        """
        :param str caching: The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param str storage_account_type: The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        :param 'LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs' diff_disk_settings: A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        :param str disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`. Changing this forces a new resource to be created.
        :param int disk_size_gb: The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
        :param str secure_vm_disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
        :param str security_encryption_type: Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
        :param bool write_accelerator_enabled: Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if secure_vm_disk_encryption_set_id is not None:
            pulumi.set(__self__, "secure_vm_disk_encryption_set_id", secure_vm_disk_encryption_set_id)
        if security_encryption_type is not None:
            pulumi.set(__self__, "security_encryption_type", security_encryption_type)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        """
        The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional['outputs.LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings']:
        """
        A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "diff_disk_settings")

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        """
        The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="secureVmDiskEncryptionSetId")
    def secure_vm_disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secure_vm_disk_encryption_set_id")

    @property
    @pulumi.getter(name="securityEncryptionType")
    def security_encryption_type(self) -> Optional[str]:
        """
        Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "security_encryption_type")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        """
        Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings(dict):
    def __init__(__self__, *,
                 option: str,
                 placement: Optional[str] = None):
        """
        :param str option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param str placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> str:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @property
    @pulumi.getter
    def placement(self) -> Optional[str]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")


@pulumi.output_type
class LinuxVirtualMachineScaleSetPlan(dict):
    def __init__(__self__, *,
                 name: str,
                 product: str,
                 publisher: str):
        """
        :param str name: Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        :param str product: Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        :param str publisher: Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class LinuxVirtualMachineScaleSetRollingUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBatchInstancePercent":
            suggest = "max_batch_instance_percent"
        elif key == "maxUnhealthyInstancePercent":
            suggest = "max_unhealthy_instance_percent"
        elif key == "maxUnhealthyUpgradedInstancePercent":
            suggest = "max_unhealthy_upgraded_instance_percent"
        elif key == "pauseTimeBetweenBatches":
            suggest = "pause_time_between_batches"
        elif key == "crossZoneUpgradesEnabled":
            suggest = "cross_zone_upgrades_enabled"
        elif key == "prioritizeUnhealthyInstancesEnabled":
            suggest = "prioritize_unhealthy_instances_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetRollingUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetRollingUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetRollingUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_batch_instance_percent: int,
                 max_unhealthy_instance_percent: int,
                 max_unhealthy_upgraded_instance_percent: int,
                 pause_time_between_batches: str,
                 cross_zone_upgrades_enabled: Optional[bool] = None,
                 prioritize_unhealthy_instances_enabled: Optional[bool] = None):
        """
        :param int max_batch_instance_percent: The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
        :param int max_unhealthy_instance_percent: The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
        :param int max_unhealthy_upgraded_instance_percent: The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
        :param str pause_time_between_batches: The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
        :param bool cross_zone_upgrades_enabled: Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`. Defaults to `false`.
        :param bool prioritize_unhealthy_instances_enabled: Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`. Defaults to `false`.
        """
        pulumi.set(__self__, "max_batch_instance_percent", max_batch_instance_percent)
        pulumi.set(__self__, "max_unhealthy_instance_percent", max_unhealthy_instance_percent)
        pulumi.set(__self__, "max_unhealthy_upgraded_instance_percent", max_unhealthy_upgraded_instance_percent)
        pulumi.set(__self__, "pause_time_between_batches", pause_time_between_batches)
        if cross_zone_upgrades_enabled is not None:
            pulumi.set(__self__, "cross_zone_upgrades_enabled", cross_zone_upgrades_enabled)
        if prioritize_unhealthy_instances_enabled is not None:
            pulumi.set(__self__, "prioritize_unhealthy_instances_enabled", prioritize_unhealthy_instances_enabled)

    @property
    @pulumi.getter(name="maxBatchInstancePercent")
    def max_batch_instance_percent(self) -> int:
        """
        The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
        """
        return pulumi.get(self, "max_batch_instance_percent")

    @property
    @pulumi.getter(name="maxUnhealthyInstancePercent")
    def max_unhealthy_instance_percent(self) -> int:
        """
        The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
        """
        return pulumi.get(self, "max_unhealthy_instance_percent")

    @property
    @pulumi.getter(name="maxUnhealthyUpgradedInstancePercent")
    def max_unhealthy_upgraded_instance_percent(self) -> int:
        """
        The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
        """
        return pulumi.get(self, "max_unhealthy_upgraded_instance_percent")

    @property
    @pulumi.getter(name="pauseTimeBetweenBatches")
    def pause_time_between_batches(self) -> str:
        """
        The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "pause_time_between_batches")

    @property
    @pulumi.getter(name="crossZoneUpgradesEnabled")
    def cross_zone_upgrades_enabled(self) -> Optional[bool]:
        """
        Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "cross_zone_upgrades_enabled")

    @property
    @pulumi.getter(name="prioritizeUnhealthyInstancesEnabled")
    def prioritize_unhealthy_instances_enabled(self) -> Optional[bool]:
        """
        Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "prioritize_unhealthy_instances_enabled")


@pulumi.output_type
class LinuxVirtualMachineScaleSetScaleIn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forceDeletionEnabled":
            suggest = "force_deletion_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetScaleIn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetScaleIn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetScaleIn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 force_deletion_enabled: Optional[bool] = None,
                 rule: Optional[str] = None):
        """
        :param bool force_deletion_enabled: Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
        :param str rule: The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
        """
        if force_deletion_enabled is not None:
            pulumi.set(__self__, "force_deletion_enabled", force_deletion_enabled)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter(name="forceDeletionEnabled")
    def force_deletion_enabled(self) -> Optional[bool]:
        """
        Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "force_deletion_enabled")

    @property
    @pulumi.getter
    def rule(self) -> Optional[str]:
        """
        The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
        """
        return pulumi.get(self, "rule")


@pulumi.output_type
class LinuxVirtualMachineScaleSetSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineScaleSetSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineScaleSetSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineScaleSetSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificates: Sequence['outputs.LinuxVirtualMachineScaleSetSecretCertificate'],
                 key_vault_id: str):
        """
        :param Sequence['LinuxVirtualMachineScaleSetSecretCertificateArgs'] certificates: One or more `certificate` blocks as defined above.
        :param str key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.LinuxVirtualMachineScaleSetSecretCertificate']:
        """
        One or more `certificate` blocks as defined above.
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")


@pulumi.output_type
class LinuxVirtualMachineScaleSetSecretCertificate(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The Secret URL of a Key Vault Certificate.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The Secret URL of a Key Vault Certificate.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class LinuxVirtualMachineScaleSetSourceImageReference(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str,
                 version: str):
        """
        :param str offer: Specifies the offer of the image used to create the virtual machines.
        :param str publisher: Specifies the publisher of the image used to create the virtual machines.
        :param str sku: Specifies the SKU of the image used to create the virtual machines.
        :param str version: Specifies the version of the image used to create the virtual machines.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> str:
        """
        Specifies the offer of the image used to create the virtual machines.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the publisher of the image used to create the virtual machines.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class LinuxVirtualMachineScaleSetSpotRestore(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 timeout: Optional[str] = None):
        """
        :param bool enabled: Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        :param str timeout: The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class LinuxVirtualMachineScaleSetTerminateNotification(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 timeout: Optional[str] = None):
        """
        :param bool enabled: Should the terminate notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
        :param str timeout: Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the terminate notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class LinuxVirtualMachineScaleSetTerminationNotification(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 timeout: Optional[str] = None):
        """
        :param bool enabled: Should the termination notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
        :param str timeout: Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the termination notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class LinuxVirtualMachineSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxVirtualMachineSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxVirtualMachineSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxVirtualMachineSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificates: Sequence['outputs.LinuxVirtualMachineSecretCertificate'],
                 key_vault_id: str):
        """
        :param Sequence['LinuxVirtualMachineSecretCertificateArgs'] certificates: One or more `certificate` blocks as defined above.
        :param str key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.LinuxVirtualMachineSecretCertificate']:
        """
        One or more `certificate` blocks as defined above.
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")


@pulumi.output_type
class LinuxVirtualMachineSecretCertificate(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The Secret URL of a Key Vault Certificate.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The Secret URL of a Key Vault Certificate.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class LinuxVirtualMachineSourceImageReference(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str,
                 version: str):
        """
        :param str offer: Specifies the offer of the image used to create the virtual machines.
        :param str publisher: Specifies the publisher of the image used to create the virtual machines.
        :param str sku: Specifies the SKU of the image used to create the virtual machines.
        :param str version: Specifies the version of the image used to create the virtual machines.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> str:
        """
        Specifies the offer of the image used to create the virtual machines.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the publisher of the image used to create the virtual machines.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class LinuxVirtualMachineTerminationNotification(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 timeout: Optional[str] = None):
        """
        :param bool enabled: Should the termination notification be enabled on this Virtual Machine? Defaults to `false`.
        :param str timeout: Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the termination notification be enabled on this Virtual Machine? Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ManagedDiskEncryptionSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskEncryptionKey":
            suggest = "disk_encryption_key"
        elif key == "keyEncryptionKey":
            suggest = "key_encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDiskEncryptionSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDiskEncryptionSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDiskEncryptionSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_encryption_key: Optional['outputs.ManagedDiskEncryptionSettingsDiskEncryptionKey'] = None,
                 enabled: Optional[bool] = None,
                 key_encryption_key: Optional['outputs.ManagedDiskEncryptionSettingsKeyEncryptionKey'] = None):
        """
        :param 'ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs' disk_encryption_key: A `disk_encryption_key` block as defined above.
        :param 'ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs' key_encryption_key: A `key_encryption_key` block as defined below.
        """
        if disk_encryption_key is not None:
            pulumi.set(__self__, "disk_encryption_key", disk_encryption_key)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_encryption_key is not None:
            pulumi.set(__self__, "key_encryption_key", key_encryption_key)

    @property
    @pulumi.getter(name="diskEncryptionKey")
    def disk_encryption_key(self) -> Optional['outputs.ManagedDiskEncryptionSettingsDiskEncryptionKey']:
        """
        A `disk_encryption_key` block as defined above.
        """
        return pulumi.get(self, "disk_encryption_key")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyEncryptionKey")
    def key_encryption_key(self) -> Optional['outputs.ManagedDiskEncryptionSettingsKeyEncryptionKey']:
        """
        A `key_encryption_key` block as defined below.
        """
        return pulumi.get(self, "key_encryption_key")


@pulumi.output_type
class ManagedDiskEncryptionSettingsDiskEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretUrl":
            suggest = "secret_url"
        elif key == "sourceVaultId":
            suggest = "source_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDiskEncryptionSettingsDiskEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDiskEncryptionSettingsDiskEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDiskEncryptionSettingsDiskEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_url: str,
                 source_vault_id: str):
        """
        :param str secret_url: The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `keyvault.Secret` resource.
        :param str source_vault_id: The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> str:
        """
        The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `keyvault.Secret` resource.
        """
        return pulumi.get(self, "secret_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class ManagedDiskEncryptionSettingsKeyEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyUrl":
            suggest = "key_url"
        elif key == "sourceVaultId":
            suggest = "source_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDiskEncryptionSettingsKeyEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDiskEncryptionSettingsKeyEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDiskEncryptionSettingsKeyEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_url: str,
                 source_vault_id: str):
        """
        :param str key_url: The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `keyvault.Key` resource.
        :param str source_vault_id: The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        pulumi.set(__self__, "key_url", key_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="keyUrl")
    def key_url(self) -> str:
        """
        The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `keyvault.Key` resource.
        """
        return pulumi.get(self, "key_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetAdditionalCapabilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ultraSsdEnabled":
            suggest = "ultra_ssd_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetAdditionalCapabilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetAdditionalCapabilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetAdditionalCapabilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[bool] = None):
        """
        :param bool ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Orchestrated Virtual Machine Scale Set? Defaults to `false`. Changing this forces a new resource to be created.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[bool]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Orchestrated Virtual Machine Scale Set? Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ultra_ssd_enabled")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetAutomaticInstanceRepair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetAutomaticInstanceRepair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetAutomaticInstanceRepair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetAutomaticInstanceRepair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 grace_period: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[str]:
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetBootDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUri":
            suggest = "storage_account_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetBootDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetBootDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetBootDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_account_uri: Optional[str] = None):
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[str]:
        return pulumi.get(self, "storage_account_uri")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "storageAccountType":
            suggest = "storage_account_type"
        elif key == "createOption":
            suggest = "create_option"
        elif key == "diskEncryptionSetId":
            suggest = "disk_encryption_set_id"
        elif key == "ultraSsdDiskIopsReadWrite":
            suggest = "ultra_ssd_disk_iops_read_write"
        elif key == "ultraSsdDiskMbpsReadWrite":
            suggest = "ultra_ssd_disk_mbps_read_write"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: str,
                 disk_size_gb: int,
                 lun: int,
                 storage_account_type: str,
                 create_option: Optional[str] = None,
                 disk_encryption_set_id: Optional[str] = None,
                 ultra_ssd_disk_iops_read_write: Optional[int] = None,
                 ultra_ssd_disk_mbps_read_write: Optional[int] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if create_option is not None:
            pulumi.set(__self__, "create_option", create_option)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if ultra_ssd_disk_iops_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_iops_read_write", ultra_ssd_disk_iops_read_write)
        if ultra_ssd_disk_mbps_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_mbps_read_write", ultra_ssd_disk_mbps_read_write)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> str:
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> int:
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter
    def lun(self) -> int:
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> Optional[str]:
        return pulumi.get(self, "create_option")

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_set_id")

    @property
    @pulumi.getter(name="ultraSsdDiskIopsReadWrite")
    def ultra_ssd_disk_iops_read_write(self) -> Optional[int]:
        return pulumi.get(self, "ultra_ssd_disk_iops_read_write")

    @property
    @pulumi.getter(name="ultraSsdDiskMbpsReadWrite")
    def ultra_ssd_disk_mbps_read_write(self) -> Optional[int]:
        return pulumi.get(self, "ultra_ssd_disk_mbps_read_write")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeHandlerVersion":
            suggest = "type_handler_version"
        elif key == "autoUpgradeMinorVersionEnabled":
            suggest = "auto_upgrade_minor_version_enabled"
        elif key == "extensionsToProvisionAfterVmCreations":
            suggest = "extensions_to_provision_after_vm_creations"
        elif key == "failureSuppressionEnabled":
            suggest = "failure_suppression_enabled"
        elif key == "forceExtensionExecutionOnChange":
            suggest = "force_extension_execution_on_change"
        elif key == "protectedSettings":
            suggest = "protected_settings"
        elif key == "protectedSettingsFromKeyVault":
            suggest = "protected_settings_from_key_vault"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 publisher: str,
                 type: str,
                 type_handler_version: str,
                 auto_upgrade_minor_version_enabled: Optional[bool] = None,
                 extensions_to_provision_after_vm_creations: Optional[Sequence[str]] = None,
                 failure_suppression_enabled: Optional[bool] = None,
                 force_extension_execution_on_change: Optional[str] = None,
                 protected_settings: Optional[str] = None,
                 protected_settings_from_key_vault: Optional['outputs.OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault'] = None,
                 settings: Optional[str] = None):
        """
        :param str name: The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        :param Sequence[str] extensions_to_provision_after_vm_creations: An ordered list of Extension names which Orchestrated Virtual Machine Scale Set should provision after VM creation.
        :param bool failure_suppression_enabled: Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
        :param 'OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs' protected_settings_from_key_vault: A `protected_settings_from_key_vault` block as defined below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version_enabled is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version_enabled", auto_upgrade_minor_version_enabled)
        if extensions_to_provision_after_vm_creations is not None:
            pulumi.set(__self__, "extensions_to_provision_after_vm_creations", extensions_to_provision_after_vm_creations)
        if failure_suppression_enabled is not None:
            pulumi.set(__self__, "failure_suppression_enabled", failure_suppression_enabled)
        if force_extension_execution_on_change is not None:
            pulumi.set(__self__, "force_extension_execution_on_change", force_extension_execution_on_change)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if protected_settings_from_key_vault is not None:
            pulumi.set(__self__, "protected_settings_from_key_vault", protected_settings_from_key_vault)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> str:
        return pulumi.get(self, "type_handler_version")

    @property
    @pulumi.getter(name="autoUpgradeMinorVersionEnabled")
    def auto_upgrade_minor_version_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "auto_upgrade_minor_version_enabled")

    @property
    @pulumi.getter(name="extensionsToProvisionAfterVmCreations")
    def extensions_to_provision_after_vm_creations(self) -> Optional[Sequence[str]]:
        """
        An ordered list of Extension names which Orchestrated Virtual Machine Scale Set should provision after VM creation.
        """
        return pulumi.get(self, "extensions_to_provision_after_vm_creations")

    @property
    @pulumi.getter(name="failureSuppressionEnabled")
    def failure_suppression_enabled(self) -> Optional[bool]:
        """
        Should failures from the extension be suppressed? Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "failure_suppression_enabled")

    @property
    @pulumi.getter(name="forceExtensionExecutionOnChange")
    def force_extension_execution_on_change(self) -> Optional[str]:
        return pulumi.get(self, "force_extension_execution_on_change")

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[str]:
        return pulumi.get(self, "protected_settings")

    @property
    @pulumi.getter(name="protectedSettingsFromKeyVault")
    def protected_settings_from_key_vault(self) -> Optional['outputs.OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault']:
        """
        A `protected_settings_from_key_vault` block as defined below.
        """
        return pulumi.get(self, "protected_settings_from_key_vault")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        return pulumi.get(self, "settings")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretUrl":
            suggest = "secret_url"
        elif key == "sourceVaultId":
            suggest = "source_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_url: str,
                 source_vault_id: str):
        """
        :param str secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param str source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> str:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 type: str):
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipConfigurations":
            suggest = "ip_configurations"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "enableAcceleratedNetworking":
            suggest = "enable_accelerated_networking"
        elif key == "enableIpForwarding":
            suggest = "enable_ip_forwarding"
        elif key == "networkSecurityGroupId":
            suggest = "network_security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_configurations: Sequence['outputs.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration'],
                 name: str,
                 dns_servers: Optional[Sequence[str]] = None,
                 enable_accelerated_networking: Optional[bool] = None,
                 enable_ip_forwarding: Optional[bool] = None,
                 network_security_group_id: Optional[str] = None,
                 primary: Optional[bool] = None):
        """
        :param str name: The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if enable_accelerated_networking is not None:
            pulumi.set(__self__, "enable_accelerated_networking", enable_accelerated_networking)
        if enable_ip_forwarding is not None:
            pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration']:
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="enableAcceleratedNetworking")
    def enable_accelerated_networking(self) -> Optional[bool]:
        return pulumi.get(self, "enable_accelerated_networking")

    @property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[bool]:
        return pulumi.get(self, "enable_ip_forwarding")

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "network_security_group_id")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        return pulumi.get(self, "primary")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationGatewayBackendAddressPoolIds":
            suggest = "application_gateway_backend_address_pool_ids"
        elif key == "applicationSecurityGroupIds":
            suggest = "application_security_group_ids"
        elif key == "loadBalancerBackendAddressPoolIds":
            suggest = "load_balancer_backend_address_pool_ids"
        elif key == "publicIpAddresses":
            suggest = "public_ip_addresses"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 application_gateway_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 application_security_group_ids: Optional[Sequence[str]] = None,
                 load_balancer_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 primary: Optional[bool] = None,
                 public_ip_addresses: Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress']] = None,
                 subnet_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        :param str version: The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        if application_gateway_backend_address_pool_ids is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if load_balancer_backend_address_pool_ids is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if public_ip_addresses is not None:
            pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "application_security_group_ids")

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress']]:
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNameLabel":
            suggest = "domain_name_label"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "ipTags":
            suggest = "ip_tags"
        elif key == "publicIpPrefixId":
            suggest = "public_ip_prefix_id"
        elif key == "skuName":
            suggest = "sku_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 domain_name_label: Optional[str] = None,
                 idle_timeout_in_minutes: Optional[int] = None,
                 ip_tags: Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag']] = None,
                 public_ip_prefix_id: Optional[str] = None,
                 sku_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        :param str sku_name: Specifies what Public IP Address SKU the Public IP Address should be provisioned as. Possible vaules include `Basic_Regional`, `Basic_Global`, `Standard_Regional` or `Standard_Global`. Defaults to `Basic_Regional`. For more information about Public IP Address SKU's and their capabilities, please see the [product documentation](https://docs.microsoft.com/azure/virtual-network/ip-services/public-ip-addresses#sku). Changing this forces a new resource to be created.
        :param str version: The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        if domain_name_label is not None:
            pulumi.set(__self__, "domain_name_label", domain_name_label)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if public_ip_prefix_id is not None:
            pulumi.set(__self__, "public_ip_prefix_id", public_ip_prefix_id)
        if sku_name is not None:
            pulumi.set(__self__, "sku_name", sku_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> Optional[str]:
        return pulumi.get(self, "domain_name_label")

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[int]:
        return pulumi.get(self, "idle_timeout_in_minutes")

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag']]:
        return pulumi.get(self, "ip_tags")

    @property
    @pulumi.getter(name="publicIpPrefixId")
    def public_ip_prefix_id(self) -> Optional[str]:
        return pulumi.get(self, "public_ip_prefix_id")

    @property
    @pulumi.getter(name="skuName")
    def sku_name(self) -> Optional[str]:
        """
        Specifies what Public IP Address SKU the Public IP Address should be provisioned as. Possible vaules include `Basic_Regional`, `Basic_Global`, `Standard_Regional` or `Standard_Global`. Defaults to `Basic_Regional`. For more information about Public IP Address SKU's and their capabilities, please see the [product documentation](https://docs.microsoft.com/azure/virtual-network/ip-services/public-ip-addresses#sku). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag(dict):
    def __init__(__self__, *,
                 tag: str,
                 type: str):
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def tag(self) -> str:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountType":
            suggest = "storage_account_type"
        elif key == "diffDiskSettings":
            suggest = "diff_disk_settings"
        elif key == "diskEncryptionSetId":
            suggest = "disk_encryption_set_id"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: str,
                 storage_account_type: str,
                 diff_disk_settings: Optional['outputs.OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettings'] = None,
                 disk_encryption_set_id: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> str:
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional['outputs.OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettings']:
        return pulumi.get(self, "diff_disk_settings")

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_set_id")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettings(dict):
    def __init__(__self__, *,
                 option: str,
                 placement: Optional[str] = None):
        """
        :param str option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param str placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> str:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @property
    @pulumi.getter
    def placement(self) -> Optional[str]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customData":
            suggest = "custom_data"
        elif key == "linuxConfiguration":
            suggest = "linux_configuration"
        elif key == "windowsConfiguration":
            suggest = "windows_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetOsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_data: Optional[str] = None,
                 linux_configuration: Optional['outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration'] = None,
                 windows_configuration: Optional['outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration'] = None):
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)
        if linux_configuration is not None:
            pulumi.set(__self__, "linux_configuration", linux_configuration)
        if windows_configuration is not None:
            pulumi.set(__self__, "windows_configuration", windows_configuration)

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[str]:
        return pulumi.get(self, "custom_data")

    @property
    @pulumi.getter(name="linuxConfiguration")
    def linux_configuration(self) -> Optional['outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration']:
        return pulumi.get(self, "linux_configuration")

    @property
    @pulumi.getter(name="windowsConfiguration")
    def windows_configuration(self) -> Optional['outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration']:
        return pulumi.get(self, "windows_configuration")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminSshKeys":
            suggest = "admin_ssh_keys"
        elif key == "computerNamePrefix":
            suggest = "computer_name_prefix"
        elif key == "disablePasswordAuthentication":
            suggest = "disable_password_authentication"
        elif key == "patchAssessmentMode":
            suggest = "patch_assessment_mode"
        elif key == "patchMode":
            suggest = "patch_mode"
        elif key == "provisionVmAgent":
            suggest = "provision_vm_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: str,
                 admin_password: Optional[str] = None,
                 admin_ssh_keys: Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey']] = None,
                 computer_name_prefix: Optional[str] = None,
                 disable_password_authentication: Optional[bool] = None,
                 patch_assessment_mode: Optional[str] = None,
                 patch_mode: Optional[str] = None,
                 provision_vm_agent: Optional[bool] = None,
                 secrets: Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret']] = None):
        """
        :param bool disable_password_authentication: When an `admin_password` is specified `disable_password_authentication` must be set to `false`. Defaults to `true`.
        :param str patch_assessment_mode: Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.
        :param str patch_mode: Specifies the mode of in-guest patching of this Windows Virtual Machine. Possible values are `ImageDefault` or `AutomaticByPlatform`. Defaults to `ImageDefault`. For more information on patch modes please see the [product documentation](https://docs.microsoft.com/azure/virtual-machines/automatic-vm-guest-patching#patch-orchestration-modes).
        """
        pulumi.set(__self__, "admin_username", admin_username)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_ssh_keys is not None:
            pulumi.set(__self__, "admin_ssh_keys", admin_ssh_keys)
        if computer_name_prefix is not None:
            pulumi.set(__self__, "computer_name_prefix", computer_name_prefix)
        if disable_password_authentication is not None:
            pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if patch_assessment_mode is not None:
            pulumi.set(__self__, "patch_assessment_mode", patch_assessment_mode)
        if patch_mode is not None:
            pulumi.set(__self__, "patch_mode", patch_mode)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminSshKeys")
    def admin_ssh_keys(self) -> Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey']]:
        return pulumi.get(self, "admin_ssh_keys")

    @property
    @pulumi.getter(name="computerNamePrefix")
    def computer_name_prefix(self) -> Optional[str]:
        return pulumi.get(self, "computer_name_prefix")

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> Optional[bool]:
        """
        When an `admin_password` is specified `disable_password_authentication` must be set to `false`. Defaults to `true`.
        """
        return pulumi.get(self, "disable_password_authentication")

    @property
    @pulumi.getter(name="patchAssessmentMode")
    def patch_assessment_mode(self) -> Optional[str]:
        """
        Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.
        """
        return pulumi.get(self, "patch_assessment_mode")

    @property
    @pulumi.getter(name="patchMode")
    def patch_mode(self) -> Optional[str]:
        """
        Specifies the mode of in-guest patching of this Windows Virtual Machine. Possible values are `ImageDefault` or `AutomaticByPlatform`. Defaults to `ImageDefault`. For more information on patch modes please see the [product documentation](https://docs.microsoft.com/azure/virtual-machines/automatic-vm-guest-patching#patch-orchestration-modes).
        """
        return pulumi.get(self, "patch_mode")

    @property
    @pulumi.getter(name="provisionVmAgent")
    def provision_vm_agent(self) -> Optional[bool]:
        return pulumi.get(self, "provision_vm_agent")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret']]:
        return pulumi.get(self, "secrets")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_key: str,
                 username: str):
        """
        :param str public_key: The Public Key which should be used for authentication, which needs to be at least 2048-bit and in ssh-rsa format. Changing this forces a new resource to be created.
        :param str username: The Username for which this Public SSH Key should be configured. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The Public Key which should be used for authentication, which needs to be at least 2048-bit and in ssh-rsa format. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username for which this Public SSH Key should be configured. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificates: Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificate'],
                 key_vault_id: str):
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificate']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        return pulumi.get(self, "key_vault_id")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificate(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The Secret URL of a Key Vault Certificate.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The Secret URL of a Key Vault Certificate.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "computerNamePrefix":
            suggest = "computer_name_prefix"
        elif key == "enableAutomaticUpdates":
            suggest = "enable_automatic_updates"
        elif key == "hotpatchingEnabled":
            suggest = "hotpatching_enabled"
        elif key == "patchAssessmentMode":
            suggest = "patch_assessment_mode"
        elif key == "patchMode":
            suggest = "patch_mode"
        elif key == "provisionVmAgent":
            suggest = "provision_vm_agent"
        elif key == "winrmListeners":
            suggest = "winrm_listeners"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: str,
                 admin_username: str,
                 computer_name_prefix: Optional[str] = None,
                 enable_automatic_updates: Optional[bool] = None,
                 hotpatching_enabled: Optional[bool] = None,
                 patch_assessment_mode: Optional[str] = None,
                 patch_mode: Optional[str] = None,
                 provision_vm_agent: Optional[bool] = None,
                 secrets: Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret']] = None,
                 timezone: Optional[str] = None,
                 winrm_listeners: Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener']] = None):
        """
        :param bool hotpatching_enabled: Should the VM be patched without requiring a reboot? Possible values are `true` or `false`. Defaults to `false`. For more information about hot patching please see the [product documentation](https://docs.microsoft.com/azure/automanage/automanage-hotpatch).
        :param str patch_assessment_mode: Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.
        :param str patch_mode: Specifies the mode of in-guest patching of this Windows Virtual Machine. Possible values are `Manual`, `AutomaticByOS` and `AutomaticByPlatform`. Defaults to `AutomaticByOS`. For more information on patch modes please see the [product documentation](https://docs.microsoft.com/azure/virtual-machines/automatic-vm-guest-patching#patch-orchestration-modes).
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "admin_username", admin_username)
        if computer_name_prefix is not None:
            pulumi.set(__self__, "computer_name_prefix", computer_name_prefix)
        if enable_automatic_updates is not None:
            pulumi.set(__self__, "enable_automatic_updates", enable_automatic_updates)
        if hotpatching_enabled is not None:
            pulumi.set(__self__, "hotpatching_enabled", hotpatching_enabled)
        if patch_assessment_mode is not None:
            pulumi.set(__self__, "patch_assessment_mode", patch_assessment_mode)
        if patch_mode is not None:
            pulumi.set(__self__, "patch_mode", patch_mode)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if winrm_listeners is not None:
            pulumi.set(__self__, "winrm_listeners", winrm_listeners)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="computerNamePrefix")
    def computer_name_prefix(self) -> Optional[str]:
        return pulumi.get(self, "computer_name_prefix")

    @property
    @pulumi.getter(name="enableAutomaticUpdates")
    def enable_automatic_updates(self) -> Optional[bool]:
        return pulumi.get(self, "enable_automatic_updates")

    @property
    @pulumi.getter(name="hotpatchingEnabled")
    def hotpatching_enabled(self) -> Optional[bool]:
        """
        Should the VM be patched without requiring a reboot? Possible values are `true` or `false`. Defaults to `false`. For more information about hot patching please see the [product documentation](https://docs.microsoft.com/azure/automanage/automanage-hotpatch).
        """
        return pulumi.get(self, "hotpatching_enabled")

    @property
    @pulumi.getter(name="patchAssessmentMode")
    def patch_assessment_mode(self) -> Optional[str]:
        """
        Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.
        """
        return pulumi.get(self, "patch_assessment_mode")

    @property
    @pulumi.getter(name="patchMode")
    def patch_mode(self) -> Optional[str]:
        """
        Specifies the mode of in-guest patching of this Windows Virtual Machine. Possible values are `Manual`, `AutomaticByOS` and `AutomaticByPlatform`. Defaults to `AutomaticByOS`. For more information on patch modes please see the [product documentation](https://docs.microsoft.com/azure/virtual-machines/automatic-vm-guest-patching#patch-orchestration-modes).
        """
        return pulumi.get(self, "patch_mode")

    @property
    @pulumi.getter(name="provisionVmAgent")
    def provision_vm_agent(self) -> Optional[bool]:
        return pulumi.get(self, "provision_vm_agent")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret']]:
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="winrmListeners")
    def winrm_listeners(self) -> Optional[Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener']]:
        return pulumi.get(self, "winrm_listeners")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificates: Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificate'],
                 key_vault_id: str):
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificate']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        return pulumi.get(self, "key_vault_id")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificate(dict):
    def __init__(__self__, *,
                 store: str,
                 url: str):
        """
        :param str url: The Secret URL of a Key Vault Certificate.
        """
        pulumi.set(__self__, "store", store)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def store(self) -> str:
        return pulumi.get(self, "store")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The Secret URL of a Key Vault Certificate.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateUrl":
            suggest = "certificate_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 certificate_url: Optional[str] = None):
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[str]:
        return pulumi.get(self, "certificate_url")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetPlan(dict):
    def __init__(__self__, *,
                 name: str,
                 product: str,
                 publisher: str):
        """
        :param str name: The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Orchestrated Virtual Machine Scale Set. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> str:
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        return pulumi.get(self, "publisher")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetSourceImageReference(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str,
                 version: str):
        """
        :param str version: The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> str:
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class OrchestratedVirtualMachineScaleSetTerminationNotification(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 timeout: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ScaleSetBootDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageUri":
            suggest = "storage_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetBootDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetBootDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetBootDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_uri: str,
                 enabled: Optional[bool] = None):
        pulumi.set(__self__, "storage_uri", storage_uri)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> str:
        return pulumi.get(self, "storage_uri")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ScaleSetExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeHandlerVersion":
            suggest = "type_handler_version"
        elif key == "autoUpgradeMinorVersion":
            suggest = "auto_upgrade_minor_version"
        elif key == "protectedSettings":
            suggest = "protected_settings"
        elif key == "provisionAfterExtensions":
            suggest = "provision_after_extensions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 publisher: str,
                 type: str,
                 type_handler_version: str,
                 auto_upgrade_minor_version: Optional[bool] = None,
                 protected_settings: Optional[str] = None,
                 provision_after_extensions: Optional[Sequence[str]] = None,
                 settings: Optional[str] = None):
        """
        :param str name: Specifies the name of the extension. Changing this forces a new resource to be created.
        :param str publisher: The publisher of the extension, available publishers can be found by using the Azure CLI.
        :param str type: The type of extension, available types for a publisher can be found using the Azure CLI.
        :param str type_handler_version: Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        :param bool auto_upgrade_minor_version: Specifies whether or not to use the latest minor version available.
        :param str protected_settings: The protected_settings passed to the extension, like settings, these are specified as a JSON object in a string.
        :param Sequence[str] provision_after_extensions: Specifies a dependency array of extensions required to be executed before, the array stores the name of each extension.
        :param str settings: The settings passed to the extension, these are specified as a JSON object in a string.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version", auto_upgrade_minor_version)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if provision_after_extensions is not None:
            pulumi.set(__self__, "provision_after_extensions", provision_after_extensions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the extension. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        The publisher of the extension, available publishers can be found by using the Azure CLI.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of extension, available types for a publisher can be found using the Azure CLI.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> str:
        """
        Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        """
        return pulumi.get(self, "type_handler_version")

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[bool]:
        """
        Specifies whether or not to use the latest minor version available.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[str]:
        """
        The protected_settings passed to the extension, like settings, these are specified as a JSON object in a string.
        """
        return pulumi.get(self, "protected_settings")

    @property
    @pulumi.getter(name="provisionAfterExtensions")
    def provision_after_extensions(self) -> Optional[Sequence[str]]:
        """
        Specifies a dependency array of extensions required to be executed before, the array stores the name of each extension.
        """
        return pulumi.get(self, "provision_after_extensions")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        """
        The settings passed to the extension, these are specified as a JSON object in a string.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class ScaleSetIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type to be assigned to the scale set. Allowable values are `SystemAssigned` and `UserAssigned`. For the `SystemAssigned` identity the scale set's Service Principal ID (SPN) can be retrieved after the scale set has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned to the VMSS. Required if `type` is `UserAssigned`.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type to be assigned to the scale set. Allowable values are `SystemAssigned` and `UserAssigned`. For the `SystemAssigned` identity the scale set's Service Principal ID (SPN) can be retrieved after the scale set has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned to the VMSS. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class ScaleSetNetworkProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipConfigurations":
            suggest = "ip_configurations"
        elif key == "acceleratedNetworking":
            suggest = "accelerated_networking"
        elif key == "dnsSettings":
            suggest = "dns_settings"
        elif key == "ipForwarding":
            suggest = "ip_forwarding"
        elif key == "networkSecurityGroupId":
            suggest = "network_security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetNetworkProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetNetworkProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetNetworkProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_configurations: Sequence['outputs.ScaleSetNetworkProfileIpConfiguration'],
                 name: str,
                 primary: bool,
                 accelerated_networking: Optional[bool] = None,
                 dns_settings: Optional['outputs.ScaleSetNetworkProfileDnsSettings'] = None,
                 ip_forwarding: Optional[bool] = None,
                 network_security_group_id: Optional[str] = None):
        """
        :param Sequence['ScaleSetNetworkProfileIpConfigurationArgs'] ip_configurations: An ip_configuration block as documented below.
        :param str name: Specifies the name of the network interface configuration. Changing this forces a new resource to be created.
        :param bool primary: Indicates whether network interfaces created from the network interface configuration will be the primary NIC of the VM.
        :param bool accelerated_networking: Specifies whether to enable accelerated networking or not. Defaults to `false`.
        :param 'ScaleSetNetworkProfileDnsSettingsArgs' dns_settings: A dns_settings block as documented below.
        :param bool ip_forwarding: Whether IP forwarding is enabled on this NIC. Defaults to `false`.
        :param str network_security_group_id: Specifies the identifier for the network security group.
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if dns_settings is not None:
            pulumi.set(__self__, "dns_settings", dns_settings)
        if ip_forwarding is not None:
            pulumi.set(__self__, "ip_forwarding", ip_forwarding)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.ScaleSetNetworkProfileIpConfiguration']:
        """
        An ip_configuration block as documented below.
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the network interface configuration. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        Indicates whether network interfaces created from the network interface configuration will be the primary NIC of the VM.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[bool]:
        """
        Specifies whether to enable accelerated networking or not. Defaults to `false`.
        """
        return pulumi.get(self, "accelerated_networking")

    @property
    @pulumi.getter(name="dnsSettings")
    def dns_settings(self) -> Optional['outputs.ScaleSetNetworkProfileDnsSettings']:
        """
        A dns_settings block as documented below.
        """
        return pulumi.get(self, "dns_settings")

    @property
    @pulumi.getter(name="ipForwarding")
    def ip_forwarding(self) -> Optional[bool]:
        """
        Whether IP forwarding is enabled on this NIC. Defaults to `false`.
        """
        return pulumi.get(self, "ip_forwarding")

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[str]:
        """
        Specifies the identifier for the network security group.
        """
        return pulumi.get(self, "network_security_group_id")


@pulumi.output_type
class ScaleSetNetworkProfileDnsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetNetworkProfileDnsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetNetworkProfileDnsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetNetworkProfileDnsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_servers: Sequence[str]):
        """
        :param Sequence[str] dns_servers: Specifies an array of DNS servers.
        """
        pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        Specifies an array of DNS servers.
        """
        return pulumi.get(self, "dns_servers")


@pulumi.output_type
class ScaleSetNetworkProfileIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "applicationGatewayBackendAddressPoolIds":
            suggest = "application_gateway_backend_address_pool_ids"
        elif key == "applicationSecurityGroupIds":
            suggest = "application_security_group_ids"
        elif key == "loadBalancerBackendAddressPoolIds":
            suggest = "load_balancer_backend_address_pool_ids"
        elif key == "loadBalancerInboundNatRulesIds":
            suggest = "load_balancer_inbound_nat_rules_ids"
        elif key == "publicIpAddressConfiguration":
            suggest = "public_ip_address_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetNetworkProfileIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetNetworkProfileIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetNetworkProfileIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 primary: bool,
                 subnet_id: str,
                 application_gateway_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 application_security_group_ids: Optional[Sequence[str]] = None,
                 load_balancer_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 load_balancer_inbound_nat_rules_ids: Optional[Sequence[str]] = None,
                 public_ip_address_configuration: Optional['outputs.ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration'] = None):
        """
        :param str name: Specifies name of the IP configuration. Changing this forces a new resource to be created.
        :param bool primary: Specifies if this ip_configuration is the primary one.
        :param str subnet_id: Specifies the identifier of the subnet.
        :param Sequence[str] application_gateway_backend_address_pool_ids: Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets can use the same application gateway.
        :param Sequence[str] application_security_group_ids: Specifies up to `20` application security group IDs.
        :param Sequence[str] load_balancer_backend_address_pool_ids: Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
        :param Sequence[str] load_balancer_inbound_nat_rules_ids: Specifies an array of references to inbound NAT pools for load balancers. A scale set can reference inbound NAT pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
        :param 'ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs' public_ip_address_configuration: Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration. The public_ip_address_configuration is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if application_gateway_backend_address_pool_ids is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if load_balancer_backend_address_pool_ids is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        if load_balancer_inbound_nat_rules_ids is not None:
            pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        if public_ip_address_configuration is not None:
            pulumi.set(__self__, "public_ip_address_configuration", public_ip_address_configuration)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies name of the IP configuration. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        Specifies if this ip_configuration is the primary one.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Specifies the identifier of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets can use the same application gateway.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies up to `20` application security group IDs.
        """
        return pulumi.get(self, "application_security_group_ids")

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies an array of references to inbound NAT pools for load balancers. A scale set can reference inbound NAT pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @property
    @pulumi.getter(name="publicIpAddressConfiguration")
    def public_ip_address_configuration(self) -> Optional['outputs.ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration']:
        """
        Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration. The public_ip_address_configuration is documented below.
        """
        return pulumi.get(self, "public_ip_address_configuration")


@pulumi.output_type
class ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNameLabel":
            suggest = "domain_name_label"
        elif key == "idleTimeout":
            suggest = "idle_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name_label: str,
                 idle_timeout: int,
                 name: str):
        """
        :param str domain_name_label: The domain name label for the DNS settings.
        :param int idle_timeout: The idle timeout in minutes. This value must be between 4 and 30.
        :param str name: The name of the public IP address configuration Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "domain_name_label", domain_name_label)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> str:
        """
        The domain name label for the DNS settings.
        """
        return pulumi.get(self, "domain_name_label")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> int:
        """
        The idle timeout in minutes. This value must be between 4 and 30.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the public IP address configuration Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ScaleSetOsProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "computerNamePrefix":
            suggest = "computer_name_prefix"
        elif key == "adminPassword":
            suggest = "admin_password"
        elif key == "customData":
            suggest = "custom_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetOsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetOsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetOsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: str,
                 computer_name_prefix: str,
                 admin_password: Optional[str] = None,
                 custom_data: Optional[str] = None):
        """
        :param str admin_username: Specifies the administrator account name to use for all the instances of virtual machines in the scale set.
        :param str computer_name_prefix: Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 9 characters long for windows images and 1 - 58 for Linux. Changing this forces a new resource to be created.
        :param str admin_password: Specifies the administrator password to use for all the instances of virtual machines in a scale set.
        :param str custom_data: Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "computer_name_prefix", computer_name_prefix)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        Specifies the administrator account name to use for all the instances of virtual machines in the scale set.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="computerNamePrefix")
    def computer_name_prefix(self) -> str:
        """
        Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 9 characters long for windows images and 1 - 58 for Linux. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "computer_name_prefix")

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        Specifies the administrator password to use for all the instances of virtual machines in a scale set.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[str]:
        """
        Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes.
        """
        return pulumi.get(self, "custom_data")


@pulumi.output_type
class ScaleSetOsProfileLinuxConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePasswordAuthentication":
            suggest = "disable_password_authentication"
        elif key == "sshKeys":
            suggest = "ssh_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetOsProfileLinuxConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetOsProfileLinuxConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetOsProfileLinuxConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_password_authentication: Optional[bool] = None,
                 ssh_keys: Optional[Sequence['outputs.ScaleSetOsProfileLinuxConfigSshKey']] = None):
        """
        :param bool disable_password_authentication: Specifies whether password authentication should be disabled. Defaults to `false`. Changing this forces a new resource to be created.
        :param Sequence['ScaleSetOsProfileLinuxConfigSshKeyArgs'] ssh_keys: Specifies a collection of `path` and `key_data` to be placed on the virtual machine.
        """
        if disable_password_authentication is not None:
            pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> Optional[bool]:
        """
        Specifies whether password authentication should be disabled. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "disable_password_authentication")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence['outputs.ScaleSetOsProfileLinuxConfigSshKey']]:
        """
        Specifies a collection of `path` and `key_data` to be placed on the virtual machine.
        """
        return pulumi.get(self, "ssh_keys")


@pulumi.output_type
class ScaleSetOsProfileLinuxConfigSshKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyData":
            suggest = "key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetOsProfileLinuxConfigSshKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetOsProfileLinuxConfigSshKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetOsProfileLinuxConfigSshKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 key_data: Optional[str] = None):
        pulumi.set(__self__, "path", path)
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[str]:
        return pulumi.get(self, "key_data")


@pulumi.output_type
class ScaleSetOsProfileSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceVaultId":
            suggest = "source_vault_id"
        elif key == "vaultCertificates":
            suggest = "vault_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetOsProfileSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetOsProfileSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetOsProfileSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_vault_id: str,
                 vault_certificates: Optional[Sequence['outputs.ScaleSetOsProfileSecretVaultCertificate']] = None):
        """
        :param str source_vault_id: Specifies the key vault to use.
        :param Sequence['ScaleSetOsProfileSecretVaultCertificateArgs'] vault_certificates: A collection of Vault Certificates as documented below
        """
        pulumi.set(__self__, "source_vault_id", source_vault_id)
        if vault_certificates is not None:
            pulumi.set(__self__, "vault_certificates", vault_certificates)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        Specifies the key vault to use.
        """
        return pulumi.get(self, "source_vault_id")

    @property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> Optional[Sequence['outputs.ScaleSetOsProfileSecretVaultCertificate']]:
        """
        A collection of Vault Certificates as documented below
        """
        return pulumi.get(self, "vault_certificates")


@pulumi.output_type
class ScaleSetOsProfileSecretVaultCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateUrl":
            suggest = "certificate_url"
        elif key == "certificateStore":
            suggest = "certificate_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetOsProfileSecretVaultCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetOsProfileSecretVaultCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetOsProfileSecretVaultCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_url: str,
                 certificate_store: Optional[str] = None):
        """
        :param str certificate_url: It is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be `data`, `dataType` and `password`.
        :param str certificate_store: Specifies the certificate store on the Virtual Machine where the certificate should be added to.
        """
        pulumi.set(__self__, "certificate_url", certificate_url)
        if certificate_store is not None:
            pulumi.set(__self__, "certificate_store", certificate_store)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> str:
        """
        It is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be `data`, `dataType` and `password`.
        """
        return pulumi.get(self, "certificate_url")

    @property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> Optional[str]:
        """
        Specifies the certificate store on the Virtual Machine where the certificate should be added to.
        """
        return pulumi.get(self, "certificate_store")


@pulumi.output_type
class ScaleSetOsProfileWindowsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalUnattendConfigs":
            suggest = "additional_unattend_configs"
        elif key == "enableAutomaticUpgrades":
            suggest = "enable_automatic_upgrades"
        elif key == "provisionVmAgent":
            suggest = "provision_vm_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetOsProfileWindowsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetOsProfileWindowsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetOsProfileWindowsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_unattend_configs: Optional[Sequence['outputs.ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig']] = None,
                 enable_automatic_upgrades: Optional[bool] = None,
                 provision_vm_agent: Optional[bool] = None,
                 winrms: Optional[Sequence['outputs.ScaleSetOsProfileWindowsConfigWinrm']] = None):
        """
        :param Sequence['ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs'] additional_unattend_configs: An Additional Unattended Config block as documented below.
        :param bool enable_automatic_upgrades: Indicates whether virtual machines in the scale set are enabled for automatic updates.
        :param bool provision_vm_agent: Indicates whether virtual machine agent should be provisioned on the virtual machines in the scale set.
        :param Sequence['ScaleSetOsProfileWindowsConfigWinrmArgs'] winrms: A collection of WinRM configuration blocks as documented below.
        """
        if additional_unattend_configs is not None:
            pulumi.set(__self__, "additional_unattend_configs", additional_unattend_configs)
        if enable_automatic_upgrades is not None:
            pulumi.set(__self__, "enable_automatic_upgrades", enable_automatic_upgrades)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if winrms is not None:
            pulumi.set(__self__, "winrms", winrms)

    @property
    @pulumi.getter(name="additionalUnattendConfigs")
    def additional_unattend_configs(self) -> Optional[Sequence['outputs.ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig']]:
        """
        An Additional Unattended Config block as documented below.
        """
        return pulumi.get(self, "additional_unattend_configs")

    @property
    @pulumi.getter(name="enableAutomaticUpgrades")
    def enable_automatic_upgrades(self) -> Optional[bool]:
        """
        Indicates whether virtual machines in the scale set are enabled for automatic updates.
        """
        return pulumi.get(self, "enable_automatic_upgrades")

    @property
    @pulumi.getter(name="provisionVmAgent")
    def provision_vm_agent(self) -> Optional[bool]:
        """
        Indicates whether virtual machine agent should be provisioned on the virtual machines in the scale set.
        """
        return pulumi.get(self, "provision_vm_agent")

    @property
    @pulumi.getter
    def winrms(self) -> Optional[Sequence['outputs.ScaleSetOsProfileWindowsConfigWinrm']]:
        """
        A collection of WinRM configuration blocks as documented below.
        """
        return pulumi.get(self, "winrms")


@pulumi.output_type
class ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pass":
            suggest = "pass_"
        elif key == "settingName":
            suggest = "setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: str,
                 content: str,
                 pass_: str,
                 setting_name: str):
        """
        :param str component: Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        :param str content: Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        :param str pass_: Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        :param str setting_name: Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "pass_", pass_)
        pulumi.set(__self__, "setting_name", setting_name)

    @property
    @pulumi.getter
    def component(self) -> str:
        """
        Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="pass")
    def pass_(self) -> str:
        """
        Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        """
        return pulumi.get(self, "pass_")

    @property
    @pulumi.getter(name="settingName")
    def setting_name(self) -> str:
        """
        Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        return pulumi.get(self, "setting_name")


@pulumi.output_type
class ScaleSetOsProfileWindowsConfigWinrm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateUrl":
            suggest = "certificate_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetOsProfileWindowsConfigWinrm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetOsProfileWindowsConfigWinrm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetOsProfileWindowsConfigWinrm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 certificate_url: Optional[str] = None):
        """
        :param str protocol: Specifies the protocol of listener
        :param str certificate_url: Specifies URL of the certificate with which new Virtual Machines is provisioned.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Specifies the protocol of listener
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[str]:
        """
        Specifies URL of the certificate with which new Virtual Machines is provisioned.
        """
        return pulumi.get(self, "certificate_url")


@pulumi.output_type
class ScaleSetPlan(dict):
    def __init__(__self__, *,
                 name: str,
                 product: str,
                 publisher: str):
        """
        :param str name: Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        :param str product: Specifies the product of the image from the marketplace.
        :param str publisher: Specifies the publisher of the image.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        Specifies the product of the image from the marketplace.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the publisher of the image.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class ScaleSetRollingUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBatchInstancePercent":
            suggest = "max_batch_instance_percent"
        elif key == "maxUnhealthyInstancePercent":
            suggest = "max_unhealthy_instance_percent"
        elif key == "maxUnhealthyUpgradedInstancePercent":
            suggest = "max_unhealthy_upgraded_instance_percent"
        elif key == "pauseTimeBetweenBatches":
            suggest = "pause_time_between_batches"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetRollingUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetRollingUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetRollingUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_batch_instance_percent: Optional[int] = None,
                 max_unhealthy_instance_percent: Optional[int] = None,
                 max_unhealthy_upgraded_instance_percent: Optional[int] = None,
                 pause_time_between_batches: Optional[str] = None):
        """
        :param int max_batch_instance_percent: The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. Defaults to `20`.
        :param int max_unhealthy_instance_percent: The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. Defaults to `20`.
        :param int max_unhealthy_upgraded_instance_percent: The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. Defaults to `20`.
        :param str pause_time_between_batches: The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format for duration (<https://en.wikipedia.org/wiki/ISO_8601#Durations>). Defaults to `0` seconds represented as `PT0S`.
        """
        if max_batch_instance_percent is not None:
            pulumi.set(__self__, "max_batch_instance_percent", max_batch_instance_percent)
        if max_unhealthy_instance_percent is not None:
            pulumi.set(__self__, "max_unhealthy_instance_percent", max_unhealthy_instance_percent)
        if max_unhealthy_upgraded_instance_percent is not None:
            pulumi.set(__self__, "max_unhealthy_upgraded_instance_percent", max_unhealthy_upgraded_instance_percent)
        if pause_time_between_batches is not None:
            pulumi.set(__self__, "pause_time_between_batches", pause_time_between_batches)

    @property
    @pulumi.getter(name="maxBatchInstancePercent")
    def max_batch_instance_percent(self) -> Optional[int]:
        """
        The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. Defaults to `20`.
        """
        return pulumi.get(self, "max_batch_instance_percent")

    @property
    @pulumi.getter(name="maxUnhealthyInstancePercent")
    def max_unhealthy_instance_percent(self) -> Optional[int]:
        """
        The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. Defaults to `20`.
        """
        return pulumi.get(self, "max_unhealthy_instance_percent")

    @property
    @pulumi.getter(name="maxUnhealthyUpgradedInstancePercent")
    def max_unhealthy_upgraded_instance_percent(self) -> Optional[int]:
        """
        The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. Defaults to `20`.
        """
        return pulumi.get(self, "max_unhealthy_upgraded_instance_percent")

    @property
    @pulumi.getter(name="pauseTimeBetweenBatches")
    def pause_time_between_batches(self) -> Optional[str]:
        """
        The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format for duration (<https://en.wikipedia.org/wiki/ISO_8601#Durations>). Defaults to `0` seconds represented as `PT0S`.
        """
        return pulumi.get(self, "pause_time_between_batches")


@pulumi.output_type
class ScaleSetSku(dict):
    def __init__(__self__, *,
                 capacity: int,
                 name: str,
                 tier: Optional[str] = None):
        """
        :param int capacity: Specifies the number of virtual machines in the scale set.
        :param str name: Specifies the size of virtual machines in a scale set. Changing this forces a new resource to be created.
        :param str tier: Specifies the tier of virtual machines in a scale set. Possible values, `standard` or `basic`.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Specifies the number of virtual machines in the scale set.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the size of virtual machines in a scale set. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        Specifies the tier of virtual machines in a scale set. Possible values, `standard` or `basic`.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class ScaleSetStorageProfileDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createOption":
            suggest = "create_option"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "managedDiskType":
            suggest = "managed_disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetStorageProfileDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetStorageProfileDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetStorageProfileDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_option: str,
                 lun: int,
                 caching: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 managed_disk_type: Optional[str] = None):
        """
        :param str create_option: Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
        :param int lun: Specifies the Logical Unit Number of the disk in each virtual machine in the scale set.
        :param str caching: Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        :param int disk_size_gb: Specifies the size of the disk in GB. This element is required when creating an empty disk.
        :param str managed_disk_type: Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
        """
        pulumi.set(__self__, "create_option", create_option)
        pulumi.set(__self__, "lun", lun)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> str:
        """
        Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
        """
        return pulumi.get(self, "create_option")

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        Specifies the Logical Unit Number of the disk in each virtual machine in the scale set.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter
    def caching(self) -> Optional[str]:
        """
        Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        """
        Specifies the size of the disk in GB. This element is required when creating an empty disk.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[str]:
        """
        Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
        """
        return pulumi.get(self, "managed_disk_type")


@pulumi.output_type
class ScaleSetStorageProfileImageReference(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 offer: Optional[str] = None,
                 publisher: Optional[str] = None,
                 sku: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: Specifies the ID of the (custom) image to use to create the virtual
               machine scale set, as in the example below.
        :param str offer: Specifies the offer of the image used to create the virtual machines.
        :param str publisher: Specifies the publisher of the image used to create the virtual machines.
        :param str sku: Specifies the SKU of the image used to create the virtual machines.
        :param str version: Specifies the version of the image used to create the virtual machines.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if offer is not None:
            pulumi.set(__self__, "offer", offer)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Specifies the ID of the (custom) image to use to create the virtual
        machine scale set, as in the example below.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def offer(self) -> Optional[str]:
        """
        Specifies the offer of the image used to create the virtual machines.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Specifies the publisher of the image used to create the virtual machines.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ScaleSetStorageProfileOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createOption":
            suggest = "create_option"
        elif key == "managedDiskType":
            suggest = "managed_disk_type"
        elif key == "osType":
            suggest = "os_type"
        elif key == "vhdContainers":
            suggest = "vhd_containers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSetStorageProfileOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSetStorageProfileOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSetStorageProfileOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_option: str,
                 caching: Optional[str] = None,
                 image: Optional[str] = None,
                 managed_disk_type: Optional[str] = None,
                 name: Optional[str] = None,
                 os_type: Optional[str] = None,
                 vhd_containers: Optional[Sequence[str]] = None):
        """
        :param str create_option: Specifies how the virtual machine should be created. The only possible option is `FromImage`.
        :param str caching: Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        :param str image: Specifies the blob URI for user image. A virtual machine scale set creates an os disk in the same container as the user image.
               Updating the osDisk image causes the existing disk to be deleted and a new one created with the new image. If the VM scale set is in Manual upgrade mode then the virtual machines are not updated until they have manualUpgrade applied to them.
               When setting this field `os_type` needs to be specified. Cannot be used when `vhd_containers`, `managed_disk_type` or `storage_profile_image_reference` are specified.
        :param str managed_disk_type: Specifies the type of managed disk to create. Value you must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`. Cannot be used when `vhd_containers` or `image` is specified.
        :param str name: Specifies the disk name. Must be specified when using unmanaged disk ('managed_disk_type' property not set). Changing this forces a new resource to be created.
        :param str os_type: Specifies the operating system Type, valid values are windows, Linux.
        :param Sequence[str] vhd_containers: Specifies the VHD URI. Cannot be used when `image` or `managed_disk_type` is specified.
        """
        pulumi.set(__self__, "create_option", create_option)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if vhd_containers is not None:
            pulumi.set(__self__, "vhd_containers", vhd_containers)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> str:
        """
        Specifies how the virtual machine should be created. The only possible option is `FromImage`.
        """
        return pulumi.get(self, "create_option")

    @property
    @pulumi.getter
    def caching(self) -> Optional[str]:
        """
        Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Specifies the blob URI for user image. A virtual machine scale set creates an os disk in the same container as the user image.
        Updating the osDisk image causes the existing disk to be deleted and a new one created with the new image. If the VM scale set is in Manual upgrade mode then the virtual machines are not updated until they have manualUpgrade applied to them.
        When setting this field `os_type` needs to be specified. Cannot be used when `vhd_containers`, `managed_disk_type` or `storage_profile_image_reference` are specified.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[str]:
        """
        Specifies the type of managed disk to create. Value you must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`. Cannot be used when `vhd_containers` or `image` is specified.
        """
        return pulumi.get(self, "managed_disk_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Specifies the disk name. Must be specified when using unmanaged disk ('managed_disk_type' property not set). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[str]:
        """
        Specifies the operating system Type, valid values are windows, Linux.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="vhdContainers")
    def vhd_containers(self) -> Optional[Sequence[str]]:
        """
        Specifies the VHD URI. Cannot be used when `image` or `managed_disk_type` is specified.
        """
        return pulumi.get(self, "vhd_containers")


@pulumi.output_type
class SharedImageIdentifier(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str):
        """
        :param str offer: The Offer Name for this Shared Image. Changing this forces a new resource to be created.
        :param str publisher: The Publisher Name for this Gallery Image. Changing this forces a new resource to be created.
        :param str sku: The Name of the SKU for this Gallery Image. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def offer(self) -> str:
        """
        The Offer Name for this Shared Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        The Publisher Name for this Gallery Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        """
        The Name of the SKU for this Gallery Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku")


@pulumi.output_type
class SharedImagePurchasePlan(dict):
    def __init__(__self__, *,
                 name: str,
                 product: Optional[str] = None,
                 publisher: Optional[str] = None):
        """
        :param str name: The Purchase Plan Name for this Shared Image. Changing this forces a new resource to be created.
        :param str product: The Purchase Plan Product for this Gallery Image. Changing this forces a new resource to be created.
        :param str publisher: The Purchase Plan Publisher for this Gallery Image. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Purchase Plan Name for this Shared Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> Optional[str]:
        """
        The Purchase Plan Product for this Gallery Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        The Purchase Plan Publisher for this Gallery Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class SharedImageVersionTargetRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionalReplicaCount":
            suggest = "regional_replica_count"
        elif key == "diskEncryptionSetId":
            suggest = "disk_encryption_set_id"
        elif key == "storageAccountType":
            suggest = "storage_account_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SharedImageVersionTargetRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SharedImageVersionTargetRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SharedImageVersionTargetRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 regional_replica_count: int,
                 disk_encryption_set_id: Optional[str] = None,
                 storage_account_type: Optional[str] = None):
        """
        :param str name: The Azure Region in which this Image Version should exist. Changing this forces a new resource to be created.
        :param int regional_replica_count: The number of replicas of the Image Version to be created per region.
        :param str disk_encryption_set_id: The ID of the Disk Encryption Set to encrypt the Image Version in the target region. Changing this forces a new resource to be created.
        :param str storage_account_type: The storage account type for the image version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`. You can store all of your image version replicas in Zone Redundant Storage by specifying `Standard_ZRS`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regional_replica_count", regional_replica_count)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if storage_account_type is not None:
            pulumi.set(__self__, "storage_account_type", storage_account_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Azure Region in which this Image Version should exist. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="regionalReplicaCount")
    def regional_replica_count(self) -> int:
        """
        The number of replicas of the Image Version to be created per region.
        """
        return pulumi.get(self, "regional_replica_count")

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set to encrypt the Image Version in the target region. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> Optional[str]:
        """
        The storage account type for the image version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`. You can store all of your image version replicas in Zone Redundant Storage by specifying `Standard_ZRS`.
        """
        return pulumi.get(self, "storage_account_type")


@pulumi.output_type
class SnapshotEncryptionSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskEncryptionKey":
            suggest = "disk_encryption_key"
        elif key == "keyEncryptionKey":
            suggest = "key_encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnapshotEncryptionSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnapshotEncryptionSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnapshotEncryptionSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_encryption_key: Optional['outputs.SnapshotEncryptionSettingsDiskEncryptionKey'] = None,
                 enabled: Optional[bool] = None,
                 key_encryption_key: Optional['outputs.SnapshotEncryptionSettingsKeyEncryptionKey'] = None):
        """
        :param 'SnapshotEncryptionSettingsDiskEncryptionKeyArgs' disk_encryption_key: A `disk_encryption_key` block as defined below.
        :param 'SnapshotEncryptionSettingsKeyEncryptionKeyArgs' key_encryption_key: A `key_encryption_key` block as defined below.
        """
        if disk_encryption_key is not None:
            pulumi.set(__self__, "disk_encryption_key", disk_encryption_key)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_encryption_key is not None:
            pulumi.set(__self__, "key_encryption_key", key_encryption_key)

    @property
    @pulumi.getter(name="diskEncryptionKey")
    def disk_encryption_key(self) -> Optional['outputs.SnapshotEncryptionSettingsDiskEncryptionKey']:
        """
        A `disk_encryption_key` block as defined below.
        """
        return pulumi.get(self, "disk_encryption_key")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyEncryptionKey")
    def key_encryption_key(self) -> Optional['outputs.SnapshotEncryptionSettingsKeyEncryptionKey']:
        """
        A `key_encryption_key` block as defined below.
        """
        return pulumi.get(self, "key_encryption_key")


@pulumi.output_type
class SnapshotEncryptionSettingsDiskEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretUrl":
            suggest = "secret_url"
        elif key == "sourceVaultId":
            suggest = "source_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnapshotEncryptionSettingsDiskEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnapshotEncryptionSettingsDiskEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnapshotEncryptionSettingsDiskEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_url: str,
                 source_vault_id: str):
        """
        :param str secret_url: The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `keyvault.Secret` resource.
        :param str source_vault_id: The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> str:
        """
        The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `keyvault.Secret` resource.
        """
        return pulumi.get(self, "secret_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class SnapshotEncryptionSettingsKeyEncryptionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyUrl":
            suggest = "key_url"
        elif key == "sourceVaultId":
            suggest = "source_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnapshotEncryptionSettingsKeyEncryptionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnapshotEncryptionSettingsKeyEncryptionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnapshotEncryptionSettingsKeyEncryptionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_url: str,
                 source_vault_id: str):
        """
        :param str key_url: The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `keyvault.Key` resource.
        :param str source_vault_id: The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        pulumi.set(__self__, "key_url", key_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="keyUrl")
    def key_url(self) -> str:
        """
        The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `keyvault.Key` resource.
        """
        return pulumi.get(self, "key_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class VirtualMachineAdditionalCapabilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ultraSsdEnabled":
            suggest = "ultra_ssd_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineAdditionalCapabilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineAdditionalCapabilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineAdditionalCapabilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ultra_ssd_enabled: bool):
        """
        :param bool ultra_ssd_enabled: Should Ultra SSD disk be enabled for this Virtual Machine? Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> bool:
        """
        Should Ultra SSD disk be enabled for this Virtual Machine? Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ultra_ssd_enabled")


@pulumi.output_type
class VirtualMachineBootDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageUri":
            suggest = "storage_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineBootDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineBootDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineBootDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 storage_uri: str):
        """
        :param bool enabled: Should Boot Diagnostics be enabled for this Virtual Machine?
        :param str storage_uri: The Storage Account's Blob Endpoint which should hold the virtual machine's diagnostic files.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "storage_uri", storage_uri)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should Boot Diagnostics be enabled for this Virtual Machine?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> str:
        """
        The Storage Account's Blob Endpoint which should hold the virtual machine's diagnostic files.
        """
        return pulumi.get(self, "storage_uri")


@pulumi.output_type
class VirtualMachineIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Virtual Machine.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Virtual Machine.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VirtualMachineOsProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "computerName":
            suggest = "computer_name"
        elif key == "adminPassword":
            suggest = "admin_password"
        elif key == "customData":
            suggest = "custom_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: str,
                 computer_name: str,
                 admin_password: Optional[str] = None,
                 custom_data: Optional[str] = None):
        """
        :param str admin_username: Specifies the name of the local administrator account.
        :param str computer_name: Specifies the name of the Virtual Machine. Changing this forces a new resource to be created.
        :param str admin_password: The password associated with the local administrator account.
        :param str custom_data: Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "computer_name", computer_name)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        Specifies the name of the local administrator account.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> str:
        """
        Specifies the name of the Virtual Machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "computer_name")

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        The password associated with the local administrator account.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[str]:
        """
        Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "custom_data")


@pulumi.output_type
class VirtualMachineOsProfileLinuxConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePasswordAuthentication":
            suggest = "disable_password_authentication"
        elif key == "sshKeys":
            suggest = "ssh_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOsProfileLinuxConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOsProfileLinuxConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOsProfileLinuxConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_password_authentication: bool,
                 ssh_keys: Optional[Sequence['outputs.VirtualMachineOsProfileLinuxConfigSshKey']] = None):
        """
        :param bool disable_password_authentication: Specifies whether password authentication should be disabled. If set to `false`, an `admin_password` must be specified.
        :param Sequence['VirtualMachineOsProfileLinuxConfigSshKeyArgs'] ssh_keys: One or more `ssh_keys` blocks. This field is required if `disable_password_authentication` is set to `true`.
        """
        pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> bool:
        """
        Specifies whether password authentication should be disabled. If set to `false`, an `admin_password` must be specified.
        """
        return pulumi.get(self, "disable_password_authentication")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence['outputs.VirtualMachineOsProfileLinuxConfigSshKey']]:
        """
        One or more `ssh_keys` blocks. This field is required if `disable_password_authentication` is set to `true`.
        """
        return pulumi.get(self, "ssh_keys")


@pulumi.output_type
class VirtualMachineOsProfileLinuxConfigSshKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyData":
            suggest = "key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOsProfileLinuxConfigSshKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOsProfileLinuxConfigSshKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOsProfileLinuxConfigSshKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_data: str,
                 path: str):
        """
        :param str key_data: The Public SSH Key which should be written to the `path` defined above.
        :param str path: The path of the destination file on the virtual machine
        """
        pulumi.set(__self__, "key_data", key_data)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> str:
        """
        The Public SSH Key which should be written to the `path` defined above.
        """
        return pulumi.get(self, "key_data")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path of the destination file on the virtual machine
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class VirtualMachineOsProfileSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceVaultId":
            suggest = "source_vault_id"
        elif key == "vaultCertificates":
            suggest = "vault_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOsProfileSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOsProfileSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOsProfileSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_vault_id: str,
                 vault_certificates: Optional[Sequence['outputs.VirtualMachineOsProfileSecretVaultCertificate']] = None):
        """
        :param str source_vault_id: Specifies the ID of the Key Vault to use.
        :param Sequence['VirtualMachineOsProfileSecretVaultCertificateArgs'] vault_certificates: One or more `vault_certificates` blocks.
        """
        pulumi.set(__self__, "source_vault_id", source_vault_id)
        if vault_certificates is not None:
            pulumi.set(__self__, "vault_certificates", vault_certificates)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        Specifies the ID of the Key Vault to use.
        """
        return pulumi.get(self, "source_vault_id")

    @property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> Optional[Sequence['outputs.VirtualMachineOsProfileSecretVaultCertificate']]:
        """
        One or more `vault_certificates` blocks.
        """
        return pulumi.get(self, "vault_certificates")


@pulumi.output_type
class VirtualMachineOsProfileSecretVaultCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateUrl":
            suggest = "certificate_url"
        elif key == "certificateStore":
            suggest = "certificate_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOsProfileSecretVaultCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOsProfileSecretVaultCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOsProfileSecretVaultCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_url: str,
                 certificate_store: Optional[str] = None):
        """
        :param str certificate_url: The ID of the Key Vault Secret. Stored secret is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be:
        :param str certificate_store: Specifies the certificate store on the Virtual Machine where the certificate should be added to, such as `My`.
        """
        pulumi.set(__self__, "certificate_url", certificate_url)
        if certificate_store is not None:
            pulumi.set(__self__, "certificate_store", certificate_store)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> str:
        """
        The ID of the Key Vault Secret. Stored secret is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be:
        """
        return pulumi.get(self, "certificate_url")

    @property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> Optional[str]:
        """
        Specifies the certificate store on the Virtual Machine where the certificate should be added to, such as `My`.
        """
        return pulumi.get(self, "certificate_store")


@pulumi.output_type
class VirtualMachineOsProfileWindowsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalUnattendConfigs":
            suggest = "additional_unattend_configs"
        elif key == "enableAutomaticUpgrades":
            suggest = "enable_automatic_upgrades"
        elif key == "provisionVmAgent":
            suggest = "provision_vm_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOsProfileWindowsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOsProfileWindowsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOsProfileWindowsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_unattend_configs: Optional[Sequence['outputs.VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig']] = None,
                 enable_automatic_upgrades: Optional[bool] = None,
                 provision_vm_agent: Optional[bool] = None,
                 timezone: Optional[str] = None,
                 winrms: Optional[Sequence['outputs.VirtualMachineOsProfileWindowsConfigWinrm']] = None):
        """
        :param Sequence['VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs'] additional_unattend_configs: An `additional_unattend_config` block as defined below.
        :param bool enable_automatic_upgrades: Are automatic updates enabled on this Virtual Machine? Defaults to `false.`
        :param bool provision_vm_agent: Should the Azure Virtual Machine Guest Agent be installed on this Virtual Machine? Defaults to `false`.
        :param str timezone: Specifies the time zone of the virtual machine, [the possible values are defined here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/). Changing this forces a new resource to be created.
        :param Sequence['VirtualMachineOsProfileWindowsConfigWinrmArgs'] winrms: One or more `winrm` blocks as defined below.
        """
        if additional_unattend_configs is not None:
            pulumi.set(__self__, "additional_unattend_configs", additional_unattend_configs)
        if enable_automatic_upgrades is not None:
            pulumi.set(__self__, "enable_automatic_upgrades", enable_automatic_upgrades)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if winrms is not None:
            pulumi.set(__self__, "winrms", winrms)

    @property
    @pulumi.getter(name="additionalUnattendConfigs")
    def additional_unattend_configs(self) -> Optional[Sequence['outputs.VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig']]:
        """
        An `additional_unattend_config` block as defined below.
        """
        return pulumi.get(self, "additional_unattend_configs")

    @property
    @pulumi.getter(name="enableAutomaticUpgrades")
    def enable_automatic_upgrades(self) -> Optional[bool]:
        """
        Are automatic updates enabled on this Virtual Machine? Defaults to `false.`
        """
        return pulumi.get(self, "enable_automatic_upgrades")

    @property
    @pulumi.getter(name="provisionVmAgent")
    def provision_vm_agent(self) -> Optional[bool]:
        """
        Should the Azure Virtual Machine Guest Agent be installed on this Virtual Machine? Defaults to `false`.
        """
        return pulumi.get(self, "provision_vm_agent")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Specifies the time zone of the virtual machine, [the possible values are defined here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def winrms(self) -> Optional[Sequence['outputs.VirtualMachineOsProfileWindowsConfigWinrm']]:
        """
        One or more `winrm` blocks as defined below.
        """
        return pulumi.get(self, "winrms")


@pulumi.output_type
class VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pass":
            suggest = "pass_"
        elif key == "settingName":
            suggest = "setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: str,
                 content: str,
                 pass_: str,
                 setting_name: str):
        """
        :param str component: Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        :param str content: Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        :param str pass_: Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        :param str setting_name: Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "pass_", pass_)
        pulumi.set(__self__, "setting_name", setting_name)

    @property
    @pulumi.getter
    def component(self) -> str:
        """
        Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="pass")
    def pass_(self) -> str:
        """
        Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        """
        return pulumi.get(self, "pass_")

    @property
    @pulumi.getter(name="settingName")
    def setting_name(self) -> str:
        """
        Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        return pulumi.get(self, "setting_name")


@pulumi.output_type
class VirtualMachineOsProfileWindowsConfigWinrm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateUrl":
            suggest = "certificate_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOsProfileWindowsConfigWinrm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOsProfileWindowsConfigWinrm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOsProfileWindowsConfigWinrm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 certificate_url: Optional[str] = None):
        """
        :param str protocol: Specifies the protocol of listener. Possible values are `HTTP` or `HTTPS`.
        :param str certificate_url: The ID of the Key Vault Secret which contains the encrypted Certificate which should be installed on the Virtual Machine. This certificate must also be specified in the `vault_certificates` block within the `os_profile_secrets` block.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Specifies the protocol of listener. Possible values are `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[str]:
        """
        The ID of the Key Vault Secret which contains the encrypted Certificate which should be installed on the Virtual Machine. This certificate must also be specified in the `vault_certificates` block within the `os_profile_secrets` block.
        """
        return pulumi.get(self, "certificate_url")


@pulumi.output_type
class VirtualMachinePlan(dict):
    def __init__(__self__, *,
                 name: str,
                 product: str,
                 publisher: str):
        """
        :param str name: Specifies the name of the image from the marketplace.
        :param str product: Specifies the product of the image from the marketplace.
        :param str publisher: Specifies the publisher of the image.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the image from the marketplace.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        Specifies the product of the image from the marketplace.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the publisher of the image.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretUrl":
            suggest = "secret_url"
        elif key == "sourceVaultId":
            suggest = "source_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_url: str,
                 source_vault_id: str):
        """
        :param str secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param str source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> str:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class VirtualMachineStorageDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createOption":
            suggest = "create_option"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "managedDiskId":
            suggest = "managed_disk_id"
        elif key == "managedDiskType":
            suggest = "managed_disk_type"
        elif key == "vhdUri":
            suggest = "vhd_uri"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineStorageDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineStorageDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineStorageDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_option: str,
                 lun: int,
                 name: str,
                 caching: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 managed_disk_id: Optional[str] = None,
                 managed_disk_type: Optional[str] = None,
                 vhd_uri: Optional[str] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        """
        :param str create_option: Specifies how the data disk should be created. Possible values are `Attach`, `FromImage` and `Empty`.
        :param int lun: Specifies the logical unit number of the data disk. This needs to be unique within all the Data Disks on the Virtual Machine.
        :param str name: The name of the Data Disk.
        :param str caching: Specifies the caching requirements for the Data Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
        :param int disk_size_gb: Specifies the size of the data disk in gigabytes.
        :param str managed_disk_id: Specifies the ID of an Existing Managed Disk which should be attached to this Virtual Machine. When this field is set `create_option` must be set to `Attach`.
        :param str managed_disk_type: Specifies the type of managed disk to create. Possible values are either `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS` or `UltraSSD_LRS`.
        :param str vhd_uri: Specifies the URI of the VHD file backing this Unmanaged Data Disk.
        :param bool write_accelerator_enabled: Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
        """
        pulumi.set(__self__, "create_option", create_option)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "name", name)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if managed_disk_id is not None:
            pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)
        if vhd_uri is not None:
            pulumi.set(__self__, "vhd_uri", vhd_uri)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> str:
        """
        Specifies how the data disk should be created. Possible values are `Attach`, `FromImage` and `Empty`.
        """
        return pulumi.get(self, "create_option")

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        Specifies the logical unit number of the data disk. This needs to be unique within all the Data Disks on the Virtual Machine.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Data Disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def caching(self) -> Optional[str]:
        """
        Specifies the caching requirements for the Data Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        """
        Specifies the size of the data disk in gigabytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> Optional[str]:
        """
        Specifies the ID of an Existing Managed Disk which should be attached to this Virtual Machine. When this field is set `create_option` must be set to `Attach`.
        """
        return pulumi.get(self, "managed_disk_id")

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[str]:
        """
        Specifies the type of managed disk to create. Possible values are either `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS` or `UltraSSD_LRS`.
        """
        return pulumi.get(self, "managed_disk_type")

    @property
    @pulumi.getter(name="vhdUri")
    def vhd_uri(self) -> Optional[str]:
        """
        Specifies the URI of the VHD file backing this Unmanaged Data Disk.
        """
        return pulumi.get(self, "vhd_uri")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        """
        Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class VirtualMachineStorageImageReference(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 offer: Optional[str] = None,
                 publisher: Optional[str] = None,
                 sku: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: Specifies the ID of the Custom Image which the Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param str offer: Specifies the offer of the image used to create the virtual machine. Changing this forces a new resource to be created.
        :param str publisher: Specifies the publisher of the image used to create the virtual machine. Changing this forces a new resource to be created.
        :param str sku: Specifies the SKU of the image used to create the virtual machine. Changing this forces a new resource to be created.
        :param str version: Specifies the version of the image used to create the virtual machine. Changing this forces a new resource to be created.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if offer is not None:
            pulumi.set(__self__, "offer", offer)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Specifies the ID of the Custom Image which the Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def offer(self) -> Optional[str]:
        """
        Specifies the offer of the image used to create the virtual machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Specifies the publisher of the image used to create the virtual machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        """
        Specifies the SKU of the image used to create the virtual machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Specifies the version of the image used to create the virtual machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class VirtualMachineStorageOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createOption":
            suggest = "create_option"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "imageUri":
            suggest = "image_uri"
        elif key == "managedDiskId":
            suggest = "managed_disk_id"
        elif key == "managedDiskType":
            suggest = "managed_disk_type"
        elif key == "osType":
            suggest = "os_type"
        elif key == "vhdUri":
            suggest = "vhd_uri"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineStorageOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineStorageOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineStorageOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_option: str,
                 name: str,
                 caching: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 image_uri: Optional[str] = None,
                 managed_disk_id: Optional[str] = None,
                 managed_disk_type: Optional[str] = None,
                 os_type: Optional[str] = None,
                 vhd_uri: Optional[str] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        """
        :param str create_option: Specifies how the OS Disk should be created. Possible values are `Attach` (managed disks only) and `FromImage`.
        :param str name: Specifies the name of the OS Disk.
        :param str caching: Specifies the caching requirements for the OS Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
        :param int disk_size_gb: Specifies the size of the OS Disk in gigabytes.
        :param str image_uri: Specifies the Image URI in the format `publisherName:offer:skus:version`. This field can also specify the [VHD URI](https://docs.microsoft.com/azure/virtual-machines/linux/tutorial-custom-images) of a custom VM image to clone. When cloning a Custom (Unmanaged) Disk Image the `os_type` field must be set.
        :param str managed_disk_id: Specifies the ID of an existing Managed Disk which should be attached as the OS Disk of this Virtual Machine. If this is set then the `create_option` must be set to `Attach`. Changing this forces a new resource to be created.
        :param str managed_disk_type: Specifies the type of Managed Disk which should be created. Possible values are `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
        :param str os_type: Specifies the Operating System on the OS Disk. Possible values are `Linux` and `Windows`.
        :param str vhd_uri: Specifies the URI of the VHD file backing this Unmanaged OS Disk. Changing this forces a new resource to be created.
        :param bool write_accelerator_enabled: Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
        """
        pulumi.set(__self__, "create_option", create_option)
        pulumi.set(__self__, "name", name)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if managed_disk_id is not None:
            pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if vhd_uri is not None:
            pulumi.set(__self__, "vhd_uri", vhd_uri)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> str:
        """
        Specifies how the OS Disk should be created. Possible values are `Attach` (managed disks only) and `FromImage`.
        """
        return pulumi.get(self, "create_option")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the OS Disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def caching(self) -> Optional[str]:
        """
        Specifies the caching requirements for the OS Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        """
        Specifies the size of the OS Disk in gigabytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[str]:
        """
        Specifies the Image URI in the format `publisherName:offer:skus:version`. This field can also specify the [VHD URI](https://docs.microsoft.com/azure/virtual-machines/linux/tutorial-custom-images) of a custom VM image to clone. When cloning a Custom (Unmanaged) Disk Image the `os_type` field must be set.
        """
        return pulumi.get(self, "image_uri")

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> Optional[str]:
        """
        Specifies the ID of an existing Managed Disk which should be attached as the OS Disk of this Virtual Machine. If this is set then the `create_option` must be set to `Attach`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "managed_disk_id")

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[str]:
        """
        Specifies the type of Managed Disk which should be created. Possible values are `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
        """
        return pulumi.get(self, "managed_disk_type")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[str]:
        """
        Specifies the Operating System on the OS Disk. Possible values are `Linux` and `Windows`.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="vhdUri")
    def vhd_uri(self) -> Optional[str]:
        """
        Specifies the URI of the VHD file backing this Unmanaged OS Disk. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vhd_uri")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        """
        Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class WindowsVirtualMachineAdditionalCapabilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ultraSsdEnabled":
            suggest = "ultra_ssd_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineAdditionalCapabilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineAdditionalCapabilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineAdditionalCapabilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[bool] = None):
        """
        :param bool ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[bool]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
        """
        return pulumi.get(self, "ultra_ssd_enabled")


@pulumi.output_type
class WindowsVirtualMachineAdditionalUnattendContent(dict):
    def __init__(__self__, *,
                 content: str,
                 setting: str):
        """
        :param str content: The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
        :param str setting: The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "setting", setting)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def setting(self) -> str:
        """
        The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "setting")


@pulumi.output_type
class WindowsVirtualMachineBootDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUri":
            suggest = "storage_account_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineBootDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineBootDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineBootDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_account_uri: Optional[str] = None):
        """
        :param str storage_account_uri: The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
        """
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[str]:
        """
        The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
        """
        return pulumi.get(self, "storage_account_uri")


@pulumi.output_type
class WindowsVirtualMachineGalleryApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "versionId":
            suggest = "version_id"
        elif key == "configurationBlobUri":
            suggest = "configuration_blob_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineGalleryApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineGalleryApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineGalleryApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version_id: str,
                 configuration_blob_uri: Optional[str] = None,
                 order: Optional[int] = None,
                 tag: Optional[str] = None):
        """
        :param str version_id: Specifies the Gallery Application Version resource ID.
        :param str configuration_blob_uri: Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
        :param int order: Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
        :param str tag: Specifies a passthrough value for more generic context. This field can be any valid `string` value.
        """
        pulumi.set(__self__, "version_id", version_id)
        if configuration_blob_uri is not None:
            pulumi.set(__self__, "configuration_blob_uri", configuration_blob_uri)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> str:
        """
        Specifies the Gallery Application Version resource ID.
        """
        return pulumi.get(self, "version_id")

    @property
    @pulumi.getter(name="configurationBlobUri")
    def configuration_blob_uri(self) -> Optional[str]:
        """
        Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
        """
        return pulumi.get(self, "configuration_blob_uri")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Specifies a passthrough value for more generic context. This field can be any valid `string` value.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class WindowsVirtualMachineIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsVirtualMachineOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountType":
            suggest = "storage_account_type"
        elif key == "diffDiskSettings":
            suggest = "diff_disk_settings"
        elif key == "diskEncryptionSetId":
            suggest = "disk_encryption_set_id"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "secureVmDiskEncryptionSetId":
            suggest = "secure_vm_disk_encryption_set_id"
        elif key == "securityEncryptionType":
            suggest = "security_encryption_type"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: str,
                 storage_account_type: str,
                 diff_disk_settings: Optional['outputs.WindowsVirtualMachineOsDiskDiffDiskSettings'] = None,
                 disk_encryption_set_id: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 name: Optional[str] = None,
                 secure_vm_disk_encryption_set_id: Optional[str] = None,
                 security_encryption_type: Optional[str] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        """
        :param str caching: The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param str storage_account_type: The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        :param 'WindowsVirtualMachineOsDiskDiffDiskSettingsArgs' diff_disk_settings: A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        :param str disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`.
        :param int disk_size_gb: The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
        :param str name: The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
        :param str secure_vm_disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
        :param str security_encryption_type: Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
        :param bool write_accelerator_enabled: Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure_vm_disk_encryption_set_id is not None:
            pulumi.set(__self__, "secure_vm_disk_encryption_set_id", secure_vm_disk_encryption_set_id)
        if security_encryption_type is not None:
            pulumi.set(__self__, "security_encryption_type", security_encryption_type)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        """
        The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional['outputs.WindowsVirtualMachineOsDiskDiffDiskSettings']:
        """
        A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "diff_disk_settings")

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        """
        The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secureVmDiskEncryptionSetId")
    def secure_vm_disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secure_vm_disk_encryption_set_id")

    @property
    @pulumi.getter(name="securityEncryptionType")
    def security_encryption_type(self) -> Optional[str]:
        """
        Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "security_encryption_type")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        """
        Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class WindowsVirtualMachineOsDiskDiffDiskSettings(dict):
    def __init__(__self__, *,
                 option: str,
                 placement: Optional[str] = None):
        """
        :param str option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param str placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> str:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @property
    @pulumi.getter
    def placement(self) -> Optional[str]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")


@pulumi.output_type
class WindowsVirtualMachinePlan(dict):
    def __init__(__self__, *,
                 name: str,
                 product: str,
                 publisher: str):
        """
        :param str name: Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param str product: Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param str publisher: Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class WindowsVirtualMachineScaleSetAdditionalCapabilities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ultraSsdEnabled":
            suggest = "ultra_ssd_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetAdditionalCapabilities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetAdditionalCapabilities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetAdditionalCapabilities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[bool] = None):
        """
        :param bool ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[bool]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ultra_ssd_enabled")


@pulumi.output_type
class WindowsVirtualMachineScaleSetAdditionalUnattendContent(dict):
    def __init__(__self__, *,
                 content: str,
                 setting: str):
        """
        :param str content: The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
        :param str setting: The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "setting", setting)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def setting(self) -> str:
        """
        The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "setting")


@pulumi.output_type
class WindowsVirtualMachineScaleSetAutomaticInstanceRepair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetAutomaticInstanceRepair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetAutomaticInstanceRepair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetAutomaticInstanceRepair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 grace_period: Optional[str] = None):
        """
        :param bool enabled: Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
        :param str grace_period: Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[str]:
        """
        Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableAutomaticRollback":
            suggest = "disable_automatic_rollback"
        elif key == "enableAutomaticOsUpgrade":
            suggest = "enable_automatic_os_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_automatic_rollback: bool,
                 enable_automatic_os_upgrade: bool):
        """
        :param bool disable_automatic_rollback: Should automatic rollbacks be disabled?
        :param bool enable_automatic_os_upgrade: Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
        """
        pulumi.set(__self__, "disable_automatic_rollback", disable_automatic_rollback)
        pulumi.set(__self__, "enable_automatic_os_upgrade", enable_automatic_os_upgrade)

    @property
    @pulumi.getter(name="disableAutomaticRollback")
    def disable_automatic_rollback(self) -> bool:
        """
        Should automatic rollbacks be disabled?
        """
        return pulumi.get(self, "disable_automatic_rollback")

    @property
    @pulumi.getter(name="enableAutomaticOsUpgrade")
    def enable_automatic_os_upgrade(self) -> bool:
        """
        Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
        """
        return pulumi.get(self, "enable_automatic_os_upgrade")


@pulumi.output_type
class WindowsVirtualMachineScaleSetBootDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountUri":
            suggest = "storage_account_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetBootDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetBootDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetBootDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_account_uri: Optional[str] = None):
        """
        :param str storage_account_uri: The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
        """
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[str]:
        """
        The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
        """
        return pulumi.get(self, "storage_account_uri")


@pulumi.output_type
class WindowsVirtualMachineScaleSetDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "storageAccountType":
            suggest = "storage_account_type"
        elif key == "createOption":
            suggest = "create_option"
        elif key == "diskEncryptionSetId":
            suggest = "disk_encryption_set_id"
        elif key == "ultraSsdDiskIopsReadWrite":
            suggest = "ultra_ssd_disk_iops_read_write"
        elif key == "ultraSsdDiskMbpsReadWrite":
            suggest = "ultra_ssd_disk_mbps_read_write"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: str,
                 disk_size_gb: int,
                 lun: int,
                 storage_account_type: str,
                 create_option: Optional[str] = None,
                 disk_encryption_set_id: Optional[str] = None,
                 name: Optional[str] = None,
                 ultra_ssd_disk_iops_read_write: Optional[int] = None,
                 ultra_ssd_disk_mbps_read_write: Optional[int] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        """
        :param str caching: The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param int disk_size_gb: The size of the Data Disk which should be created.
        :param int lun: The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        :param str storage_account_type: The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
        :param str create_option: The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
        :param str disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.
        :param str name: The name of the Data Disk.
        :param bool write_accelerator_enabled: Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if create_option is not None:
            pulumi.set(__self__, "create_option", create_option)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ultra_ssd_disk_iops_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_iops_read_write", ultra_ssd_disk_iops_read_write)
        if ultra_ssd_disk_mbps_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_mbps_read_write", ultra_ssd_disk_mbps_read_write)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> int:
        """
        The size of the Data Disk which should be created.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        """
        The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
        """
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> Optional[str]:
        """
        The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
        """
        return pulumi.get(self, "create_option")

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Data Disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ultraSsdDiskIopsReadWrite")
    def ultra_ssd_disk_iops_read_write(self) -> Optional[int]:
        return pulumi.get(self, "ultra_ssd_disk_iops_read_write")

    @property
    @pulumi.getter(name="ultraSsdDiskMbpsReadWrite")
    def ultra_ssd_disk_mbps_read_write(self) -> Optional[int]:
        return pulumi.get(self, "ultra_ssd_disk_mbps_read_write")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        """
        Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class WindowsVirtualMachineScaleSetExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeHandlerVersion":
            suggest = "type_handler_version"
        elif key == "autoUpgradeMinorVersion":
            suggest = "auto_upgrade_minor_version"
        elif key == "automaticUpgradeEnabled":
            suggest = "automatic_upgrade_enabled"
        elif key == "forceUpdateTag":
            suggest = "force_update_tag"
        elif key == "protectedSettings":
            suggest = "protected_settings"
        elif key == "protectedSettingsFromKeyVault":
            suggest = "protected_settings_from_key_vault"
        elif key == "provisionAfterExtensions":
            suggest = "provision_after_extensions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 publisher: str,
                 type: str,
                 type_handler_version: str,
                 auto_upgrade_minor_version: Optional[bool] = None,
                 automatic_upgrade_enabled: Optional[bool] = None,
                 force_update_tag: Optional[str] = None,
                 protected_settings: Optional[str] = None,
                 protected_settings_from_key_vault: Optional['outputs.WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault'] = None,
                 provision_after_extensions: Optional[Sequence[str]] = None,
                 settings: Optional[str] = None):
        """
        :param str name: The name for the Virtual Machine Scale Set Extension.
        :param str publisher: Specifies the Publisher of the Extension.
        :param str type: Specifies the Type of the Extension.
        :param str type_handler_version: Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        :param bool auto_upgrade_minor_version: Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        :param bool automatic_upgrade_enabled: Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension? Defaults to `false`.
        :param str force_update_tag: A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        :param str protected_settings: A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
        :param Sequence[str] provision_after_extensions: An ordered list of Extension names which this should be provisioned after.
        :param str settings: A JSON String which specifies Settings for the Extension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version", auto_upgrade_minor_version)
        if automatic_upgrade_enabled is not None:
            pulumi.set(__self__, "automatic_upgrade_enabled", automatic_upgrade_enabled)
        if force_update_tag is not None:
            pulumi.set(__self__, "force_update_tag", force_update_tag)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if protected_settings_from_key_vault is not None:
            pulumi.set(__self__, "protected_settings_from_key_vault", protected_settings_from_key_vault)
        if provision_after_extensions is not None:
            pulumi.set(__self__, "provision_after_extensions", provision_after_extensions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the Virtual Machine Scale Set Extension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the Publisher of the Extension.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the Type of the Extension.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> str:
        """
        Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        """
        return pulumi.get(self, "type_handler_version")

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[bool]:
        """
        Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @property
    @pulumi.getter(name="automaticUpgradeEnabled")
    def automatic_upgrade_enabled(self) -> Optional[bool]:
        """
        Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension? Defaults to `false`.
        """
        return pulumi.get(self, "automatic_upgrade_enabled")

    @property
    @pulumi.getter(name="forceUpdateTag")
    def force_update_tag(self) -> Optional[str]:
        """
        A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        """
        return pulumi.get(self, "force_update_tag")

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[str]:
        """
        A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
        """
        return pulumi.get(self, "protected_settings")

    @property
    @pulumi.getter(name="protectedSettingsFromKeyVault")
    def protected_settings_from_key_vault(self) -> Optional['outputs.WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault']:
        return pulumi.get(self, "protected_settings_from_key_vault")

    @property
    @pulumi.getter(name="provisionAfterExtensions")
    def provision_after_extensions(self) -> Optional[Sequence[str]]:
        """
        An ordered list of Extension names which this should be provisioned after.
        """
        return pulumi.get(self, "provision_after_extensions")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        """
        A JSON String which specifies Settings for the Extension.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretUrl":
            suggest = "secret_url"
        elif key == "sourceVaultId":
            suggest = "source_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_url: str,
                 source_vault_id: str):
        """
        :param str secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param str source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> str:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class WindowsVirtualMachineScaleSetGalleryApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packageReferenceId":
            suggest = "package_reference_id"
        elif key == "configurationReferenceBlobUri":
            suggest = "configuration_reference_blob_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetGalleryApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetGalleryApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetGalleryApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 package_reference_id: str,
                 configuration_reference_blob_uri: Optional[str] = None,
                 order: Optional[int] = None,
                 tag: Optional[str] = None):
        """
        :param int order: Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
        :param str tag: Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "package_reference_id", package_reference_id)
        if configuration_reference_blob_uri is not None:
            pulumi.set(__self__, "configuration_reference_blob_uri", configuration_reference_blob_uri)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="packageReferenceId")
    def package_reference_id(self) -> str:
        return pulumi.get(self, "package_reference_id")

    @property
    @pulumi.getter(name="configurationReferenceBlobUri")
    def configuration_reference_blob_uri(self) -> Optional[str]:
        return pulumi.get(self, "configuration_reference_blob_uri")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class WindowsVirtualMachineScaleSetIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine Scale Set.
        :param str principal_id: The Principal ID associated with this Managed Service Identity.
        :param str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine Scale Set.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WindowsVirtualMachineScaleSetNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipConfigurations":
            suggest = "ip_configurations"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "enableAcceleratedNetworking":
            suggest = "enable_accelerated_networking"
        elif key == "enableIpForwarding":
            suggest = "enable_ip_forwarding"
        elif key == "networkSecurityGroupId":
            suggest = "network_security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_configurations: Sequence['outputs.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration'],
                 name: str,
                 dns_servers: Optional[Sequence[str]] = None,
                 enable_accelerated_networking: Optional[bool] = None,
                 enable_ip_forwarding: Optional[bool] = None,
                 network_security_group_id: Optional[str] = None,
                 primary: Optional[bool] = None):
        """
        :param Sequence['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs'] ip_configurations: One or more `ip_configuration` blocks as defined above.
        :param str name: The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        :param Sequence[str] dns_servers: A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        :param bool enable_accelerated_networking: Does this Network Interface support Accelerated Networking? Defaults to `false`.
        :param bool enable_ip_forwarding: Does this Network Interface support IP Forwarding? Defaults to `false`.
        :param str network_security_group_id: The ID of a Network Security Group which should be assigned to this Network Interface.
        :param bool primary: Is this the Primary IP Configuration?
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if enable_accelerated_networking is not None:
            pulumi.set(__self__, "enable_accelerated_networking", enable_accelerated_networking)
        if enable_ip_forwarding is not None:
            pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration']:
        """
        One or more `ip_configuration` blocks as defined above.
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="enableAcceleratedNetworking")
    def enable_accelerated_networking(self) -> Optional[bool]:
        """
        Does this Network Interface support Accelerated Networking? Defaults to `false`.
        """
        return pulumi.get(self, "enable_accelerated_networking")

    @property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[bool]:
        """
        Does this Network Interface support IP Forwarding? Defaults to `false`.
        """
        return pulumi.get(self, "enable_ip_forwarding")

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[str]:
        """
        The ID of a Network Security Group which should be assigned to this Network Interface.
        """
        return pulumi.get(self, "network_security_group_id")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Is this the Primary IP Configuration?
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationGatewayBackendAddressPoolIds":
            suggest = "application_gateway_backend_address_pool_ids"
        elif key == "applicationSecurityGroupIds":
            suggest = "application_security_group_ids"
        elif key == "loadBalancerBackendAddressPoolIds":
            suggest = "load_balancer_backend_address_pool_ids"
        elif key == "loadBalancerInboundNatRulesIds":
            suggest = "load_balancer_inbound_nat_rules_ids"
        elif key == "publicIpAddresses":
            suggest = "public_ip_addresses"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 application_gateway_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 application_security_group_ids: Optional[Sequence[str]] = None,
                 load_balancer_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 load_balancer_inbound_nat_rules_ids: Optional[Sequence[str]] = None,
                 primary: Optional[bool] = None,
                 public_ip_addresses: Optional[Sequence['outputs.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress']] = None,
                 subnet_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: The Name which should be used for this IP Configuration.
        :param Sequence[str] application_gateway_backend_address_pool_ids: A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
        :param Sequence[str] application_security_group_ids: A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
        :param Sequence[str] load_balancer_backend_address_pool_ids: A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
        :param Sequence[str] load_balancer_inbound_nat_rules_ids: A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
        :param bool primary: Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
        :param Sequence['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs'] public_ip_addresses: A `public_ip_address` block as defined below.
        :param str subnet_id: The ID of the Subnet which this IP Configuration should be connected to.
        :param str version: The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        pulumi.set(__self__, "name", name)
        if application_gateway_backend_address_pool_ids is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if load_balancer_backend_address_pool_ids is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        if load_balancer_inbound_nat_rules_ids is not None:
            pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if public_ip_addresses is not None:
            pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name which should be used for this IP Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_security_group_ids")

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Optional[Sequence[str]]:
        """
        A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Optional[Sequence['outputs.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress']]:
        """
        A `public_ip_address` block as defined below.
        """
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the Subnet which this IP Configuration should be connected to.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNameLabel":
            suggest = "domain_name_label"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "ipTags":
            suggest = "ip_tags"
        elif key == "publicIpPrefixId":
            suggest = "public_ip_prefix_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 domain_name_label: Optional[str] = None,
                 idle_timeout_in_minutes: Optional[int] = None,
                 ip_tags: Optional[Sequence['outputs.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag']] = None,
                 public_ip_prefix_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: The Name of the Public IP Address Configuration.
        :param str domain_name_label: The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
        :param int idle_timeout_in_minutes: The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        :param Sequence['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs'] ip_tags: One or more `ip_tag` blocks as defined above.
        :param str public_ip_prefix_id: The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
        :param str version: The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        pulumi.set(__self__, "name", name)
        if domain_name_label is not None:
            pulumi.set(__self__, "domain_name_label", domain_name_label)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if public_ip_prefix_id is not None:
            pulumi.set(__self__, "public_ip_prefix_id", public_ip_prefix_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Public IP Address Configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> Optional[str]:
        """
        The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
        """
        return pulumi.get(self, "domain_name_label")

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[int]:
        """
        The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[Sequence['outputs.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag']]:
        """
        One or more `ip_tag` blocks as defined above.
        """
        return pulumi.get(self, "ip_tags")

    @property
    @pulumi.getter(name="publicIpPrefixId")
    def public_ip_prefix_id(self) -> Optional[str]:
        """
        The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "public_ip_prefix_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag(dict):
    def __init__(__self__, *,
                 tag: str,
                 type: str):
        """
        :param str tag: The IP Tag associated with the Public IP, such as `SQL` or `Storage`.
        :param str type: The Type of IP Tag, such as `FirstPartyUsage`.
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        The IP Tag associated with the Public IP, such as `SQL` or `Storage`.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Type of IP Tag, such as `FirstPartyUsage`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WindowsVirtualMachineScaleSetOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountType":
            suggest = "storage_account_type"
        elif key == "diffDiskSettings":
            suggest = "diff_disk_settings"
        elif key == "diskEncryptionSetId":
            suggest = "disk_encryption_set_id"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "secureVmDiskEncryptionSetId":
            suggest = "secure_vm_disk_encryption_set_id"
        elif key == "securityEncryptionType":
            suggest = "security_encryption_type"
        elif key == "writeAcceleratorEnabled":
            suggest = "write_accelerator_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: str,
                 storage_account_type: str,
                 diff_disk_settings: Optional['outputs.WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings'] = None,
                 disk_encryption_set_id: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 secure_vm_disk_encryption_set_id: Optional[str] = None,
                 security_encryption_type: Optional[str] = None,
                 write_accelerator_enabled: Optional[bool] = None):
        """
        :param str caching: The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param str storage_account_type: The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        :param 'WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs' diff_disk_settings: A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        :param str disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`. Changing this forces a new resource to be created.
        :param int disk_size_gb: The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
        :param str secure_vm_disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
        :param str security_encryption_type: Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
        :param bool write_accelerator_enabled: Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if secure_vm_disk_encryption_set_id is not None:
            pulumi.set(__self__, "secure_vm_disk_encryption_set_id", secure_vm_disk_encryption_set_id)
        if security_encryption_type is not None:
            pulumi.set(__self__, "security_encryption_type", security_encryption_type)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        """
        The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional['outputs.WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings']:
        """
        A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "diff_disk_settings")

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        """
        The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="secureVmDiskEncryptionSetId")
    def secure_vm_disk_encryption_set_id(self) -> Optional[str]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secure_vm_disk_encryption_set_id")

    @property
    @pulumi.getter(name="securityEncryptionType")
    def security_encryption_type(self) -> Optional[str]:
        """
        Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "security_encryption_type")

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[bool]:
        """
        Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")


@pulumi.output_type
class WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings(dict):
    def __init__(__self__, *,
                 option: str,
                 placement: Optional[str] = None):
        """
        :param str option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param str placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> str:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @property
    @pulumi.getter
    def placement(self) -> Optional[str]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")


@pulumi.output_type
class WindowsVirtualMachineScaleSetPlan(dict):
    def __init__(__self__, *,
                 name: str,
                 product: str,
                 publisher: str):
        """
        :param str name: Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        :param str product: Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        :param str publisher: Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class WindowsVirtualMachineScaleSetRollingUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBatchInstancePercent":
            suggest = "max_batch_instance_percent"
        elif key == "maxUnhealthyInstancePercent":
            suggest = "max_unhealthy_instance_percent"
        elif key == "maxUnhealthyUpgradedInstancePercent":
            suggest = "max_unhealthy_upgraded_instance_percent"
        elif key == "pauseTimeBetweenBatches":
            suggest = "pause_time_between_batches"
        elif key == "crossZoneUpgradesEnabled":
            suggest = "cross_zone_upgrades_enabled"
        elif key == "prioritizeUnhealthyInstancesEnabled":
            suggest = "prioritize_unhealthy_instances_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetRollingUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetRollingUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetRollingUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_batch_instance_percent: int,
                 max_unhealthy_instance_percent: int,
                 max_unhealthy_upgraded_instance_percent: int,
                 pause_time_between_batches: str,
                 cross_zone_upgrades_enabled: Optional[bool] = None,
                 prioritize_unhealthy_instances_enabled: Optional[bool] = None):
        """
        :param int max_batch_instance_percent: The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
        :param int max_unhealthy_instance_percent: The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
        :param int max_unhealthy_upgraded_instance_percent: The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
        :param str pause_time_between_batches: The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
        :param bool cross_zone_upgrades_enabled: Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`. Defaults to `false`.
        :param bool prioritize_unhealthy_instances_enabled: Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`. Defaults to `false`.
        """
        pulumi.set(__self__, "max_batch_instance_percent", max_batch_instance_percent)
        pulumi.set(__self__, "max_unhealthy_instance_percent", max_unhealthy_instance_percent)
        pulumi.set(__self__, "max_unhealthy_upgraded_instance_percent", max_unhealthy_upgraded_instance_percent)
        pulumi.set(__self__, "pause_time_between_batches", pause_time_between_batches)
        if cross_zone_upgrades_enabled is not None:
            pulumi.set(__self__, "cross_zone_upgrades_enabled", cross_zone_upgrades_enabled)
        if prioritize_unhealthy_instances_enabled is not None:
            pulumi.set(__self__, "prioritize_unhealthy_instances_enabled", prioritize_unhealthy_instances_enabled)

    @property
    @pulumi.getter(name="maxBatchInstancePercent")
    def max_batch_instance_percent(self) -> int:
        """
        The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
        """
        return pulumi.get(self, "max_batch_instance_percent")

    @property
    @pulumi.getter(name="maxUnhealthyInstancePercent")
    def max_unhealthy_instance_percent(self) -> int:
        """
        The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
        """
        return pulumi.get(self, "max_unhealthy_instance_percent")

    @property
    @pulumi.getter(name="maxUnhealthyUpgradedInstancePercent")
    def max_unhealthy_upgraded_instance_percent(self) -> int:
        """
        The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
        """
        return pulumi.get(self, "max_unhealthy_upgraded_instance_percent")

    @property
    @pulumi.getter(name="pauseTimeBetweenBatches")
    def pause_time_between_batches(self) -> str:
        """
        The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "pause_time_between_batches")

    @property
    @pulumi.getter(name="crossZoneUpgradesEnabled")
    def cross_zone_upgrades_enabled(self) -> Optional[bool]:
        """
        Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "cross_zone_upgrades_enabled")

    @property
    @pulumi.getter(name="prioritizeUnhealthyInstancesEnabled")
    def prioritize_unhealthy_instances_enabled(self) -> Optional[bool]:
        """
        Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "prioritize_unhealthy_instances_enabled")


@pulumi.output_type
class WindowsVirtualMachineScaleSetScaleIn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forceDeletionEnabled":
            suggest = "force_deletion_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetScaleIn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetScaleIn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetScaleIn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 force_deletion_enabled: Optional[bool] = None,
                 rule: Optional[str] = None):
        """
        :param bool force_deletion_enabled: Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
        :param str rule: The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
        """
        if force_deletion_enabled is not None:
            pulumi.set(__self__, "force_deletion_enabled", force_deletion_enabled)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter(name="forceDeletionEnabled")
    def force_deletion_enabled(self) -> Optional[bool]:
        """
        Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "force_deletion_enabled")

    @property
    @pulumi.getter
    def rule(self) -> Optional[str]:
        """
        The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
        """
        return pulumi.get(self, "rule")


@pulumi.output_type
class WindowsVirtualMachineScaleSetSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificates: Sequence['outputs.WindowsVirtualMachineScaleSetSecretCertificate'],
                 key_vault_id: str):
        """
        :param Sequence['WindowsVirtualMachineScaleSetSecretCertificateArgs'] certificates: One or more `certificate` blocks as defined above.
        :param str key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.WindowsVirtualMachineScaleSetSecretCertificate']:
        """
        One or more `certificate` blocks as defined above.
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")


@pulumi.output_type
class WindowsVirtualMachineScaleSetSecretCertificate(dict):
    def __init__(__self__, *,
                 store: str,
                 url: str):
        """
        :param str store: The certificate store on the Virtual Machine where the certificate should be added.
        :param str url: The Secret URL of a Key Vault Certificate.
        """
        pulumi.set(__self__, "store", store)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def store(self) -> str:
        """
        The certificate store on the Virtual Machine where the certificate should be added.
        """
        return pulumi.get(self, "store")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The Secret URL of a Key Vault Certificate.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WindowsVirtualMachineScaleSetSourceImageReference(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str,
                 version: str):
        """
        :param str offer: Specifies the offer of the image used to create the virtual machines.
        :param str publisher: Specifies the publisher of the image used to create the virtual machines.
        :param str sku: Specifies the SKU of the image used to create the virtual machines.
        :param str version: Specifies the version of the image used to create the virtual machines.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> str:
        """
        Specifies the offer of the image used to create the virtual machines.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the publisher of the image used to create the virtual machines.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WindowsVirtualMachineScaleSetSpotRestore(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 timeout: Optional[str] = None):
        """
        :param bool enabled: Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        :param str timeout: The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class WindowsVirtualMachineScaleSetTerminateNotification(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 timeout: Optional[str] = None):
        """
        :param bool enabled: Should the terminate notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
        :param str timeout: Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the terminate notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class WindowsVirtualMachineScaleSetTerminationNotification(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 timeout: Optional[str] = None):
        """
        :param bool enabled: Should the termination notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
        :param str timeout: Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the termination notification be enabled on this Virtual Machine Scale Set? Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class WindowsVirtualMachineScaleSetWinrmListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateUrl":
            suggest = "certificate_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineScaleSetWinrmListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineScaleSetWinrmListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineScaleSetWinrmListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 certificate_url: Optional[str] = None):
        """
        :param str protocol: The Protocol of the WinRM Listener. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        :param str certificate_url: The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The Protocol of the WinRM Listener. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[str]:
        """
        The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "certificate_url")


@pulumi.output_type
class WindowsVirtualMachineSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificates: Sequence['outputs.WindowsVirtualMachineSecretCertificate'],
                 key_vault_id: str):
        """
        :param Sequence['WindowsVirtualMachineSecretCertificateArgs'] certificates: One or more `certificate` blocks as defined above.
        :param str key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.WindowsVirtualMachineSecretCertificate']:
        """
        One or more `certificate` blocks as defined above.
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")


@pulumi.output_type
class WindowsVirtualMachineSecretCertificate(dict):
    def __init__(__self__, *,
                 store: str,
                 url: str):
        """
        :param str store: The certificate store on the Virtual Machine where the certificate should be added.
        :param str url: The Secret URL of a Key Vault Certificate.
        """
        pulumi.set(__self__, "store", store)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def store(self) -> str:
        """
        The certificate store on the Virtual Machine where the certificate should be added.
        """
        return pulumi.get(self, "store")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The Secret URL of a Key Vault Certificate.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WindowsVirtualMachineSourceImageReference(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str,
                 version: str):
        """
        :param str offer: Specifies the offer of the image used to create the virtual machines.
        :param str publisher: Specifies the publisher of the image used to create the virtual machines.
        :param str sku: Specifies the SKU of the image used to create the virtual machines.
        :param str version: Specifies the version of the image used to create the virtual machines.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> str:
        """
        Specifies the offer of the image used to create the virtual machines.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the publisher of the image used to create the virtual machines.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WindowsVirtualMachineTerminationNotification(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 timeout: Optional[str] = None):
        """
        :param bool enabled: Should the termination notification be enabled on this Virtual Machine? Defaults to `false`.
        :param str timeout: Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Should the termination notification be enabled on this Virtual Machine? Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class WindowsVirtualMachineWinrmListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateUrl":
            suggest = "certificate_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsVirtualMachineWinrmListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsVirtualMachineWinrmListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsVirtualMachineWinrmListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 certificate_url: Optional[str] = None):
        """
        :param str certificate_url: The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[str]:
        """
        The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "certificate_url")


@pulumi.output_type
class GetConfidentialLedgerAzureadBasedServicePrincipalResult(dict):
    def __init__(__self__, *,
                 ledger_role_name: str,
                 principal_id: str,
                 tenant_id: str):
        """
        :param str ledger_role_name: The Ledger Role to grant this Certificate Security Principal.
        :param str principal_id: The Principal ID of the AzureAD Service Principal.
        :param str tenant_id: The Tenant ID for this AzureAD Service Principal.
        """
        pulumi.set(__self__, "ledger_role_name", ledger_role_name)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="ledgerRoleName")
    def ledger_role_name(self) -> str:
        """
        The Ledger Role to grant this Certificate Security Principal.
        """
        return pulumi.get(self, "ledger_role_name")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID of the AzureAD Service Principal.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID for this AzureAD Service Principal.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetConfidentialLedgerCertificateBasedSecurityPrincipalResult(dict):
    def __init__(__self__, *,
                 ledger_role_name: str,
                 pem_public_key: str):
        """
        :param str ledger_role_name: The Ledger Role to grant this Certificate Security Principal.
        :param str pem_public_key: The public key, in PEM format, of the certificate used by this identity to authenticate with the Confidential Ledger.
        """
        pulumi.set(__self__, "ledger_role_name", ledger_role_name)
        pulumi.set(__self__, "pem_public_key", pem_public_key)

    @property
    @pulumi.getter(name="ledgerRoleName")
    def ledger_role_name(self) -> str:
        """
        The Ledger Role to grant this Certificate Security Principal.
        """
        return pulumi.get(self, "ledger_role_name")

    @property
    @pulumi.getter(name="pemPublicKey")
    def pem_public_key(self) -> str:
        """
        The public key, in PEM format, of the certificate used by this identity to authenticate with the Confidential Ledger.
        """
        return pulumi.get(self, "pem_public_key")


@pulumi.output_type
class GetImageDataDiskResult(dict):
    def __init__(__self__, *,
                 blob_uri: str,
                 caching: str,
                 lun: int,
                 managed_disk_id: str,
                 size_gb: int):
        """
        :param str blob_uri: the URI in Azure storage of the blob used to create the image.
        :param str caching: the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
        :param int lun: the logical unit number of the data disk.
        :param str managed_disk_id: the ID of the Managed Disk used as the Data Disk Image.
        :param int size_gb: the size of this Data Disk in GB.
        """
        pulumi.set(__self__, "blob_uri", blob_uri)
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blobUri")
    def blob_uri(self) -> str:
        """
        the URI in Azure storage of the blob used to create the image.
        """
        return pulumi.get(self, "blob_uri")

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        the logical unit number of the data disk.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> str:
        """
        the ID of the Managed Disk used as the Data Disk Image.
        """
        return pulumi.get(self, "managed_disk_id")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        the size of this Data Disk in GB.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class GetImageOsDiskResult(dict):
    def __init__(__self__, *,
                 blob_uri: str,
                 caching: str,
                 managed_disk_id: str,
                 os_state: str,
                 os_type: str,
                 size_gb: int):
        """
        :param str blob_uri: the URI in Azure storage of the blob used to create the image.
        :param str caching: the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
        :param str managed_disk_id: the ID of the Managed Disk used as the Data Disk Image.
        :param str os_state: the State of the OS used in the Image, such as `Generalized`.
        :param str os_type: the type of Operating System used on the OS Disk. such as `Linux` or `Windows`.
        :param int size_gb: the size of this Data Disk in GB.
        """
        pulumi.set(__self__, "blob_uri", blob_uri)
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        pulumi.set(__self__, "os_state", os_state)
        pulumi.set(__self__, "os_type", os_type)
        pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blobUri")
    def blob_uri(self) -> str:
        """
        the URI in Azure storage of the blob used to create the image.
        """
        return pulumi.get(self, "blob_uri")

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> str:
        """
        the ID of the Managed Disk used as the Data Disk Image.
        """
        return pulumi.get(self, "managed_disk_id")

    @property
    @pulumi.getter(name="osState")
    def os_state(self) -> str:
        """
        the State of the OS used in the Image, such as `Generalized`.
        """
        return pulumi.get(self, "os_state")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> str:
        """
        the type of Operating System used on the OS Disk. such as `Linux` or `Windows`.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        the size of this Data Disk in GB.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class GetImagesImageResult(dict):
    def __init__(__self__, *,
                 data_disks: Sequence['outputs.GetImagesImageDataDiskResult'],
                 location: str,
                 name: str,
                 os_disks: Sequence['outputs.GetImagesImageOsDiskResult'],
                 tags: Mapping[str, str],
                 zone_resilient: bool):
        """
        :param Sequence['GetImagesImageDataDiskArgs'] data_disks: One or more `data_disk` blocks as defined below.
        :param str location: The supported Azure location where the Image exists.
        :param str name: The name of the Image.
        :param Sequence['GetImagesImageOsDiskArgs'] os_disks: An `os_disk` block as defined below.
        :param Mapping[str, str] tags: A mapping of tags assigned to the Image.
        :param bool zone_resilient: Is zone resiliency enabled?
        """
        pulumi.set(__self__, "data_disks", data_disks)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "os_disks", os_disks)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "zone_resilient", zone_resilient)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Sequence['outputs.GetImagesImageDataDiskResult']:
        """
        One or more `data_disk` blocks as defined below.
        """
        return pulumi.get(self, "data_disks")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The supported Azure location where the Image exists.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Image.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osDisks")
    def os_disks(self) -> Sequence['outputs.GetImagesImageOsDiskResult']:
        """
        An `os_disk` block as defined below.
        """
        return pulumi.get(self, "os_disks")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        A mapping of tags assigned to the Image.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="zoneResilient")
    def zone_resilient(self) -> bool:
        """
        Is zone resiliency enabled?
        """
        return pulumi.get(self, "zone_resilient")


@pulumi.output_type
class GetImagesImageDataDiskResult(dict):
    def __init__(__self__, *,
                 blob_uri: str,
                 caching: str,
                 lun: int,
                 managed_disk_id: str,
                 size_gb: int):
        """
        :param str blob_uri: the URI in Azure storage of the blob used to create the image.
        :param str caching: the caching mode for the Data Disk.
        :param int lun: the logical unit number of the data disk.
        :param str managed_disk_id: the ID of the Managed Disk used as the Data Disk Image.
        :param int size_gb: the size of this Data Disk in GB.
        """
        pulumi.set(__self__, "blob_uri", blob_uri)
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blobUri")
    def blob_uri(self) -> str:
        """
        the URI in Azure storage of the blob used to create the image.
        """
        return pulumi.get(self, "blob_uri")

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        the caching mode for the Data Disk.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        the logical unit number of the data disk.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> str:
        """
        the ID of the Managed Disk used as the Data Disk Image.
        """
        return pulumi.get(self, "managed_disk_id")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        the size of this Data Disk in GB.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class GetImagesImageOsDiskResult(dict):
    def __init__(__self__, *,
                 blob_uri: str,
                 caching: str,
                 managed_disk_id: str,
                 os_state: str,
                 os_type: str,
                 size_gb: int):
        """
        :param str blob_uri: the URI in Azure storage of the blob used to create the image.
        :param str caching: the caching mode for the Data Disk.
        :param str managed_disk_id: the ID of the Managed Disk used as the Data Disk Image.
        :param str os_state: the State of the OS used in the Image.
        :param str os_type: the type of Operating System used on the OS Disk.
        :param int size_gb: the size of this Data Disk in GB.
        """
        pulumi.set(__self__, "blob_uri", blob_uri)
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        pulumi.set(__self__, "os_state", os_state)
        pulumi.set(__self__, "os_type", os_type)
        pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blobUri")
    def blob_uri(self) -> str:
        """
        the URI in Azure storage of the blob used to create the image.
        """
        return pulumi.get(self, "blob_uri")

    @property
    @pulumi.getter
    def caching(self) -> str:
        """
        the caching mode for the Data Disk.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> str:
        """
        the ID of the Managed Disk used as the Data Disk Image.
        """
        return pulumi.get(self, "managed_disk_id")

    @property
    @pulumi.getter(name="osState")
    def os_state(self) -> str:
        """
        the State of the OS used in the Image.
        """
        return pulumi.get(self, "os_state")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> str:
        """
        the type of Operating System used on the OS Disk.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        the size of this Data Disk in GB.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class GetManagedDiskEncryptionSettingResult(dict):
    def __init__(__self__, *,
                 disk_encryption_keys: Sequence['outputs.GetManagedDiskEncryptionSettingDiskEncryptionKeyResult'],
                 enabled: bool,
                 key_encryption_keys: Sequence['outputs.GetManagedDiskEncryptionSettingKeyEncryptionKeyResult']):
        """
        :param Sequence['GetManagedDiskEncryptionSettingDiskEncryptionKeyArgs'] disk_encryption_keys: A `disk_encryption_key` block as defined above.
        :param Sequence['GetManagedDiskEncryptionSettingKeyEncryptionKeyArgs'] key_encryption_keys: A `key_encryption_key` block as defined below.
        """
        pulumi.set(__self__, "disk_encryption_keys", disk_encryption_keys)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "key_encryption_keys", key_encryption_keys)

    @property
    @pulumi.getter(name="diskEncryptionKeys")
    def disk_encryption_keys(self) -> Sequence['outputs.GetManagedDiskEncryptionSettingDiskEncryptionKeyResult']:
        """
        A `disk_encryption_key` block as defined above.
        """
        return pulumi.get(self, "disk_encryption_keys")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyEncryptionKeys")
    def key_encryption_keys(self) -> Sequence['outputs.GetManagedDiskEncryptionSettingKeyEncryptionKeyResult']:
        """
        A `key_encryption_key` block as defined below.
        """
        return pulumi.get(self, "key_encryption_keys")


@pulumi.output_type
class GetManagedDiskEncryptionSettingDiskEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 secret_url: str,
                 source_vault_id: str):
        """
        :param str secret_url: The URL to the Key Vault Secret used as the Disk Encryption Key.
        :param str source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> str:
        """
        The URL to the Key Vault Secret used as the Disk Encryption Key.
        """
        return pulumi.get(self, "secret_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class GetManagedDiskEncryptionSettingKeyEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 key_url: str,
                 source_vault_id: str):
        """
        :param str key_url: The URL to the Key Vault Key used as the Key Encryption Key.
        :param str source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "key_url", key_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="keyUrl")
    def key_url(self) -> str:
        """
        The URL to the Key Vault Key used as the Key Encryption Key.
        """
        return pulumi.get(self, "key_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class GetSharedImageIdentifierResult(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str):
        """
        :param str offer: The Offer Name for this Shared Image.
        :param str publisher: The Publisher Name for this Gallery Image.
        :param str sku: The Name of the SKU for this Gallery Image.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def offer(self) -> str:
        """
        The Offer Name for this Shared Image.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        The Publisher Name for this Gallery Image.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        """
        The Name of the SKU for this Gallery Image.
        """
        return pulumi.get(self, "sku")


@pulumi.output_type
class GetSharedImageVersionTargetRegionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 regional_replica_count: int,
                 storage_account_type: str):
        """
        :param str name: The name of the Image Version.
        :param int regional_replica_count: The number of replicas of the Image Version to be created per region.
        :param str storage_account_type: The storage account type for the image version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regional_replica_count", regional_replica_count)
        pulumi.set(__self__, "storage_account_type", storage_account_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Image Version.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="regionalReplicaCount")
    def regional_replica_count(self) -> int:
        """
        The number of replicas of the Image Version to be created per region.
        """
        return pulumi.get(self, "regional_replica_count")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        """
        The storage account type for the image version.
        """
        return pulumi.get(self, "storage_account_type")


@pulumi.output_type
class GetSharedImageVersionsImageResult(dict):
    def __init__(__self__, *,
                 exclude_from_latest: bool,
                 location: str,
                 managed_image_id: str,
                 name: str,
                 tags: Mapping[str, str],
                 target_regions: Sequence['outputs.GetSharedImageVersionsImageTargetRegionResult']):
        """
        :param bool exclude_from_latest: Is this Image Version excluded from the `latest` filter?
        :param str location: The supported Azure location where the Shared Image Gallery exists.
        :param str managed_image_id: The ID of the Managed Image which was the source of this Shared Image Version.
        :param str name: The Azure Region in which this Image Version exists.
        :param Mapping[str, str] tags: A mapping of tags assigned to the Shared Image.
        :param Sequence['GetSharedImageVersionsImageTargetRegionArgs'] target_regions: One or more `target_region` blocks as documented below.
        """
        pulumi.set(__self__, "exclude_from_latest", exclude_from_latest)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "managed_image_id", managed_image_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "target_regions", target_regions)

    @property
    @pulumi.getter(name="excludeFromLatest")
    def exclude_from_latest(self) -> bool:
        """
        Is this Image Version excluded from the `latest` filter?
        """
        return pulumi.get(self, "exclude_from_latest")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The supported Azure location where the Shared Image Gallery exists.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="managedImageId")
    def managed_image_id(self) -> str:
        """
        The ID of the Managed Image which was the source of this Shared Image Version.
        """
        return pulumi.get(self, "managed_image_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Azure Region in which this Image Version exists.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        A mapping of tags assigned to the Shared Image.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="targetRegions")
    def target_regions(self) -> Sequence['outputs.GetSharedImageVersionsImageTargetRegionResult']:
        """
        One or more `target_region` blocks as documented below.
        """
        return pulumi.get(self, "target_regions")


@pulumi.output_type
class GetSharedImageVersionsImageTargetRegionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 regional_replica_count: int,
                 storage_account_type: str):
        """
        :param str name: The Azure Region in which this Image Version exists.
        :param int regional_replica_count: The number of replicas of the Image Version to be created per region.
        :param str storage_account_type: The storage account type for the image version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regional_replica_count", regional_replica_count)
        pulumi.set(__self__, "storage_account_type", storage_account_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Azure Region in which this Image Version exists.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="regionalReplicaCount")
    def regional_replica_count(self) -> int:
        """
        The number of replicas of the Image Version to be created per region.
        """
        return pulumi.get(self, "regional_replica_count")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        """
        The storage account type for the image version.
        """
        return pulumi.get(self, "storage_account_type")


@pulumi.output_type
class GetSnapshotEncryptionSettingResult(dict):
    def __init__(__self__, *,
                 disk_encryption_keys: Sequence['outputs.GetSnapshotEncryptionSettingDiskEncryptionKeyResult'],
                 enabled: bool,
                 key_encryption_keys: Sequence['outputs.GetSnapshotEncryptionSettingKeyEncryptionKeyResult']):
        pulumi.set(__self__, "disk_encryption_keys", disk_encryption_keys)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "key_encryption_keys", key_encryption_keys)

    @property
    @pulumi.getter(name="diskEncryptionKeys")
    def disk_encryption_keys(self) -> Sequence['outputs.GetSnapshotEncryptionSettingDiskEncryptionKeyResult']:
        return pulumi.get(self, "disk_encryption_keys")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyEncryptionKeys")
    def key_encryption_keys(self) -> Sequence['outputs.GetSnapshotEncryptionSettingKeyEncryptionKeyResult']:
        return pulumi.get(self, "key_encryption_keys")


@pulumi.output_type
class GetSnapshotEncryptionSettingDiskEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 secret_url: str,
                 source_vault_id: str):
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> str:
        return pulumi.get(self, "secret_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class GetSnapshotEncryptionSettingKeyEncryptionKeyResult(dict):
    def __init__(__self__, *,
                 key_url: str,
                 source_vault_id: str):
        pulumi.set(__self__, "key_url", key_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="keyUrl")
    def key_url(self) -> str:
        return pulumi.get(self, "key_url")

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        return pulumi.get(self, "source_vault_id")


@pulumi.output_type
class GetVirtualMachineIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: The list of User Managed Identity IDs which are assigned to the Virtual Machine.
        :param str principal_id: The ID of the System Managed Service Principal assigned to the Virtual Machine.
        :param str tenant_id: The ID of the Tenant of the System Managed Service Principal assigned to the Virtual Machine.
        :param str type: The identity type of the Managed Identity assigned to the Virtual Machine.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        The list of User Managed Identity IDs which are assigned to the Virtual Machine.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The ID of the System Managed Service Principal assigned to the Virtual Machine.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The ID of the Tenant of the System Managed Service Principal assigned to the Virtual Machine.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type of the Managed Identity assigned to the Virtual Machine.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVirtualMachineScaleSetIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[str],
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param Sequence[str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Virtual Machine Scale Set.
        :param str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Virtual Machine Scale Set.
        :param str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Virtual Machine Scale Set.
        :param str type: The Type of IP Tag.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Virtual Machine Scale Set.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Virtual Machine Scale Set.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Virtual Machine Scale Set.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Type of IP Tag.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVirtualMachineScaleSetInstanceResult(dict):
    def __init__(__self__, *,
                 computer_name: str,
                 instance_id: str,
                 latest_model_applied: bool,
                 name: str,
                 private_ip_address: str,
                 private_ip_addresses: Sequence[str],
                 public_ip_address: str,
                 public_ip_addresses: Sequence[str],
                 virtual_machine_id: str,
                 zone: str):
        """
        :param str computer_name: The Hostname of this Virtual Machine.
        :param str instance_id: The Instance ID of this Virtual Machine.
        :param bool latest_model_applied: Whether the latest model has been applied to this Virtual Machine.
        :param str name: The name of this Virtual Machine Scale Set.
        :param str private_ip_address: The Primary Private IP Address assigned to this Virtual Machine.
        :param Sequence[str] private_ip_addresses: A list of Private IP Addresses assigned to this Virtual Machine.
        :param str public_ip_address: The virtual machines scale set IP Configuration's PublicIPAddress configuration. The `public_ip_address` is documented below.
        :param Sequence[str] public_ip_addresses: A list of the Public IP Addresses assigned to this Virtual Machine.
        :param str virtual_machine_id: The unique ID of the virtual machine.
        :param str zone: The zones of the virtual machine.
        """
        pulumi.set(__self__, "computer_name", computer_name)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "latest_model_applied", latest_model_applied)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        pulumi.set(__self__, "virtual_machine_id", virtual_machine_id)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> str:
        """
        The Hostname of this Virtual Machine.
        """
        return pulumi.get(self, "computer_name")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The Instance ID of this Virtual Machine.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="latestModelApplied")
    def latest_model_applied(self) -> bool:
        """
        Whether the latest model has been applied to this Virtual Machine.
        """
        return pulumi.get(self, "latest_model_applied")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Virtual Machine Scale Set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The Primary Private IP Address assigned to this Virtual Machine.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Sequence[str]:
        """
        A list of Private IP Addresses assigned to this Virtual Machine.
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        The virtual machines scale set IP Configuration's PublicIPAddress configuration. The `public_ip_address` is documented below.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Sequence[str]:
        """
        A list of the Public IP Addresses assigned to this Virtual Machine.
        """
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter(name="virtualMachineId")
    def virtual_machine_id(self) -> str:
        """
        The unique ID of the virtual machine.
        """
        return pulumi.get(self, "virtual_machine_id")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The zones of the virtual machine.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetVirtualMachineScaleSetNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 dns_servers: Sequence[str],
                 enable_accelerated_networking: bool,
                 enable_ip_forwarding: bool,
                 ip_configurations: Sequence['outputs.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationResult'],
                 name: str,
                 network_security_group_id: str,
                 primary: bool):
        """
        :param Sequence[str] dns_servers: An array of the DNS servers in use.
        :param bool enable_accelerated_networking: Whether to enable accelerated networking or not.
        :param bool enable_ip_forwarding: Whether IP forwarding is enabled on this NIC.
        :param Sequence['GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs'] ip_configurations: An `ip_configuration` block as documented below.
        :param str name: The name of this Virtual Machine Scale Set.
        :param str network_security_group_id: The identifier for the network security group.
        :param bool primary: If this ip_configuration is the primary one.
        """
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "enable_accelerated_networking", enable_accelerated_networking)
        pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_security_group_id", network_security_group_id)
        pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        An array of the DNS servers in use.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="enableAcceleratedNetworking")
    def enable_accelerated_networking(self) -> bool:
        """
        Whether to enable accelerated networking or not.
        """
        return pulumi.get(self, "enable_accelerated_networking")

    @property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> bool:
        """
        Whether IP forwarding is enabled on this NIC.
        """
        return pulumi.get(self, "enable_ip_forwarding")

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationResult']:
        """
        An `ip_configuration` block as documented below.
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Virtual Machine Scale Set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> str:
        """
        The identifier for the network security group.
        """
        return pulumi.get(self, "network_security_group_id")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        If this ip_configuration is the primary one.
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationResult(dict):
    def __init__(__self__, *,
                 application_gateway_backend_address_pool_ids: Sequence[str],
                 application_security_group_ids: Sequence[str],
                 load_balancer_backend_address_pool_ids: Sequence[str],
                 load_balancer_inbound_nat_rules_ids: Sequence[str],
                 name: str,
                 primary: bool,
                 public_ip_addresses: Sequence['outputs.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressResult'],
                 subnet_id: str,
                 version: str):
        """
        :param Sequence[str] application_gateway_backend_address_pool_ids: An array of references to backend address pools of application gateways.
        :param Sequence[str] application_security_group_ids: The application security group IDs to use.
        :param Sequence[str] load_balancer_backend_address_pool_ids: An array of references to backend address pools of load balancers.
        :param Sequence[str] load_balancer_inbound_nat_rules_ids: An array of references to inbound NAT pools for load balancers.
        :param str name: The name of this Virtual Machine Scale Set.
        :param bool primary: If this ip_configuration is the primary one.
        :param Sequence['GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs'] public_ip_addresses: The virtual machines scale set IP Configuration's PublicIPAddress configuration. The `public_ip_address` is documented below.
        :param str subnet_id: The the identifier of the subnet.
        :param str version: The Internet Protocol Version of the public IP address.
        """
        pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Sequence[str]:
        """
        An array of references to backend address pools of application gateways.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Sequence[str]:
        """
        The application security group IDs to use.
        """
        return pulumi.get(self, "application_security_group_ids")

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Sequence[str]:
        """
        An array of references to backend address pools of load balancers.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Sequence[str]:
        """
        An array of references to inbound NAT pools for load balancers.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Virtual Machine Scale Set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        If this ip_configuration is the primary one.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Sequence['outputs.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressResult']:
        """
        The virtual machines scale set IP Configuration's PublicIPAddress configuration. The `public_ip_address` is documented below.
        """
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The the identifier of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The Internet Protocol Version of the public IP address.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressResult(dict):
    def __init__(__self__, *,
                 domain_name_label: str,
                 idle_timeout_in_minutes: int,
                 ip_tags: Sequence['outputs.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagResult'],
                 name: str,
                 public_ip_prefix_id: str,
                 version: str):
        """
        :param str domain_name_label: The domain name label for the DNS settings.
        :param int idle_timeout_in_minutes: The idle timeout in minutes.
        :param Sequence['GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs'] ip_tags: A list of `ip_tag` blocks as defined below.
        :param str name: The name of this Virtual Machine Scale Set.
        :param str public_ip_prefix_id: The ID of the public IP prefix.
        :param str version: The Internet Protocol Version of the public IP address.
        """
        pulumi.set(__self__, "domain_name_label", domain_name_label)
        pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        pulumi.set(__self__, "ip_tags", ip_tags)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_prefix_id", public_ip_prefix_id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> str:
        """
        The domain name label for the DNS settings.
        """
        return pulumi.get(self, "domain_name_label")

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> int:
        """
        The idle timeout in minutes.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Sequence['outputs.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagResult']:
        """
        A list of `ip_tag` blocks as defined below.
        """
        return pulumi.get(self, "ip_tags")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of this Virtual Machine Scale Set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpPrefixId")
    def public_ip_prefix_id(self) -> str:
        """
        The ID of the public IP prefix.
        """
        return pulumi.get(self, "public_ip_prefix_id")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The Internet Protocol Version of the public IP address.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagResult(dict):
    def __init__(__self__, *,
                 tag: str,
                 type: str):
        """
        :param str tag: The IP Tag associated with the Public IP.
        :param str type: The Type of IP Tag.
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        The IP Tag associated with the Public IP.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Type of IP Tag.
        """
        return pulumi.get(self, "type")


