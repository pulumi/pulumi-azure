# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'BastionHostIpConfigurationArgs',
    'CapacityReservationSkuArgs',
    'DiskEncryptionSetIdentityArgs',
    'ExtensionProtectedSettingsFromKeyVaultArgs',
    'GalleryApplicationVersionManageActionArgs',
    'GalleryApplicationVersionSourceArgs',
    'GalleryApplicationVersionTargetRegionArgs',
    'ImageDataDiskArgs',
    'ImageOsDiskArgs',
    'LinuxVirtualMachineAdditionalCapabilitiesArgs',
    'LinuxVirtualMachineAdminSshKeyArgs',
    'LinuxVirtualMachineBootDiagnosticsArgs',
    'LinuxVirtualMachineGalleryApplicationArgs',
    'LinuxVirtualMachineIdentityArgs',
    'LinuxVirtualMachineOsDiskArgs',
    'LinuxVirtualMachineOsDiskDiffDiskSettingsArgs',
    'LinuxVirtualMachinePlanArgs',
    'LinuxVirtualMachineScaleSetAdditionalCapabilitiesArgs',
    'LinuxVirtualMachineScaleSetAdminSshKeyArgs',
    'LinuxVirtualMachineScaleSetAutomaticInstanceRepairArgs',
    'LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs',
    'LinuxVirtualMachineScaleSetBootDiagnosticsArgs',
    'LinuxVirtualMachineScaleSetDataDiskArgs',
    'LinuxVirtualMachineScaleSetExtensionArgs',
    'LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs',
    'LinuxVirtualMachineScaleSetGalleryApplicationArgs',
    'LinuxVirtualMachineScaleSetIdentityArgs',
    'LinuxVirtualMachineScaleSetNetworkInterfaceArgs',
    'LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs',
    'LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs',
    'LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs',
    'LinuxVirtualMachineScaleSetOsDiskArgs',
    'LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs',
    'LinuxVirtualMachineScaleSetPlanArgs',
    'LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs',
    'LinuxVirtualMachineScaleSetScaleInArgs',
    'LinuxVirtualMachineScaleSetSecretArgs',
    'LinuxVirtualMachineScaleSetSecretCertificateArgs',
    'LinuxVirtualMachineScaleSetSourceImageReferenceArgs',
    'LinuxVirtualMachineScaleSetSpotRestoreArgs',
    'LinuxVirtualMachineScaleSetTerminateNotificationArgs',
    'LinuxVirtualMachineScaleSetTerminationNotificationArgs',
    'LinuxVirtualMachineSecretArgs',
    'LinuxVirtualMachineSecretCertificateArgs',
    'LinuxVirtualMachineSourceImageReferenceArgs',
    'LinuxVirtualMachineTerminationNotificationArgs',
    'ManagedDiskEncryptionSettingsArgs',
    'ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs',
    'ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs',
    'OrchestratedVirtualMachineScaleSetAdditionalCapabilitiesArgs',
    'OrchestratedVirtualMachineScaleSetAutomaticInstanceRepairArgs',
    'OrchestratedVirtualMachineScaleSetBootDiagnosticsArgs',
    'OrchestratedVirtualMachineScaleSetDataDiskArgs',
    'OrchestratedVirtualMachineScaleSetExtensionArgs',
    'OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs',
    'OrchestratedVirtualMachineScaleSetIdentityArgs',
    'OrchestratedVirtualMachineScaleSetNetworkInterfaceArgs',
    'OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs',
    'OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs',
    'OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs',
    'OrchestratedVirtualMachineScaleSetOsDiskArgs',
    'OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs',
    'OrchestratedVirtualMachineScaleSetOsProfileArgs',
    'OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationArgs',
    'OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKeyArgs',
    'OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretArgs',
    'OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificateArgs',
    'OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationArgs',
    'OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretArgs',
    'OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificateArgs',
    'OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListenerArgs',
    'OrchestratedVirtualMachineScaleSetPlanArgs',
    'OrchestratedVirtualMachineScaleSetPriorityMixArgs',
    'OrchestratedVirtualMachineScaleSetSourceImageReferenceArgs',
    'OrchestratedVirtualMachineScaleSetTerminationNotificationArgs',
    'PacketCaptureFilterArgs',
    'PacketCaptureStorageLocationArgs',
    'ScaleSetBootDiagnosticsArgs',
    'ScaleSetExtensionArgs',
    'ScaleSetIdentityArgs',
    'ScaleSetNetworkProfileArgs',
    'ScaleSetNetworkProfileDnsSettingsArgs',
    'ScaleSetNetworkProfileIpConfigurationArgs',
    'ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs',
    'ScaleSetOsProfileArgs',
    'ScaleSetOsProfileLinuxConfigArgs',
    'ScaleSetOsProfileLinuxConfigSshKeyArgs',
    'ScaleSetOsProfileSecretArgs',
    'ScaleSetOsProfileSecretVaultCertificateArgs',
    'ScaleSetOsProfileWindowsConfigArgs',
    'ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs',
    'ScaleSetOsProfileWindowsConfigWinrmArgs',
    'ScaleSetPacketCaptureFilterArgs',
    'ScaleSetPacketCaptureMachineScopeArgs',
    'ScaleSetPacketCaptureStorageLocationArgs',
    'ScaleSetPlanArgs',
    'ScaleSetRollingUpgradePolicyArgs',
    'ScaleSetSkuArgs',
    'ScaleSetStorageProfileDataDiskArgs',
    'ScaleSetStorageProfileImageReferenceArgs',
    'ScaleSetStorageProfileOsDiskArgs',
    'SharedImageGallerySharingArgs',
    'SharedImageGallerySharingCommunityGalleryArgs',
    'SharedImageIdentifierArgs',
    'SharedImagePurchasePlanArgs',
    'SharedImageVersionTargetRegionArgs',
    'SnapshotEncryptionSettingsArgs',
    'SnapshotEncryptionSettingsDiskEncryptionKeyArgs',
    'SnapshotEncryptionSettingsKeyEncryptionKeyArgs',
    'VirtualMachineAdditionalCapabilitiesArgs',
    'VirtualMachineBootDiagnosticsArgs',
    'VirtualMachineIdentityArgs',
    'VirtualMachineOsProfileArgs',
    'VirtualMachineOsProfileLinuxConfigArgs',
    'VirtualMachineOsProfileLinuxConfigSshKeyArgs',
    'VirtualMachineOsProfileSecretArgs',
    'VirtualMachineOsProfileSecretVaultCertificateArgs',
    'VirtualMachineOsProfileWindowsConfigArgs',
    'VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs',
    'VirtualMachineOsProfileWindowsConfigWinrmArgs',
    'VirtualMachinePlanArgs',
    'VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs',
    'VirtualMachineStorageDataDiskArgs',
    'VirtualMachineStorageImageReferenceArgs',
    'VirtualMachineStorageOsDiskArgs',
    'WindowsVirtualMachineAdditionalCapabilitiesArgs',
    'WindowsVirtualMachineAdditionalUnattendContentArgs',
    'WindowsVirtualMachineBootDiagnosticsArgs',
    'WindowsVirtualMachineGalleryApplicationArgs',
    'WindowsVirtualMachineIdentityArgs',
    'WindowsVirtualMachineOsDiskArgs',
    'WindowsVirtualMachineOsDiskDiffDiskSettingsArgs',
    'WindowsVirtualMachinePlanArgs',
    'WindowsVirtualMachineScaleSetAdditionalCapabilitiesArgs',
    'WindowsVirtualMachineScaleSetAdditionalUnattendContentArgs',
    'WindowsVirtualMachineScaleSetAutomaticInstanceRepairArgs',
    'WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs',
    'WindowsVirtualMachineScaleSetBootDiagnosticsArgs',
    'WindowsVirtualMachineScaleSetDataDiskArgs',
    'WindowsVirtualMachineScaleSetExtensionArgs',
    'WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs',
    'WindowsVirtualMachineScaleSetGalleryApplicationArgs',
    'WindowsVirtualMachineScaleSetIdentityArgs',
    'WindowsVirtualMachineScaleSetNetworkInterfaceArgs',
    'WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs',
    'WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs',
    'WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs',
    'WindowsVirtualMachineScaleSetOsDiskArgs',
    'WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs',
    'WindowsVirtualMachineScaleSetPlanArgs',
    'WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs',
    'WindowsVirtualMachineScaleSetScaleInArgs',
    'WindowsVirtualMachineScaleSetSecretArgs',
    'WindowsVirtualMachineScaleSetSecretCertificateArgs',
    'WindowsVirtualMachineScaleSetSourceImageReferenceArgs',
    'WindowsVirtualMachineScaleSetSpotRestoreArgs',
    'WindowsVirtualMachineScaleSetTerminateNotificationArgs',
    'WindowsVirtualMachineScaleSetTerminationNotificationArgs',
    'WindowsVirtualMachineScaleSetWinrmListenerArgs',
    'WindowsVirtualMachineSecretArgs',
    'WindowsVirtualMachineSecretCertificateArgs',
    'WindowsVirtualMachineSourceImageReferenceArgs',
    'WindowsVirtualMachineTerminationNotificationArgs',
    'WindowsVirtualMachineWinrmListenerArgs',
]

@pulumi.input_type
class BastionHostIpConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 public_ip_address_id: pulumi.Input[str],
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the IP configuration. Changing this forces a new resource to be created.
        :param pulumi.Input[str] public_ip_address_id: Reference to a Public IP Address to associate with this Bastion Host. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subnet_id: Reference to a subnet in which this Bastion Host has been created. Changing this forces a new resource to be created.
               
               > **Note:** The Subnet used for the Bastion Host must have the name `AzureBastionSubnet` and the subnet mask must be at least a `/26`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_address_id", public_ip_address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the IP configuration. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> pulumi.Input[str]:
        """
        Reference to a Public IP Address to associate with this Bastion Host. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "public_ip_address_id")

    @public_ip_address_id.setter
    def public_ip_address_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_ip_address_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        Reference to a subnet in which this Bastion Host has been created. Changing this forces a new resource to be created.

        > **Note:** The Subnet used for the Bastion Host must have the name `AzureBastionSubnet` and the subnet mask must be at least a `/26`.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class CapacityReservationSkuArgs:
    def __init__(__self__, *,
                 capacity: pulumi.Input[int],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[int] capacity: Specifies the number of instances to be reserved. It must be a positive `integer` and not exceed the quota in the subscription.
        :param pulumi.Input[str] name: Name of the sku, such as `Standard_F2`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def capacity(self) -> pulumi.Input[int]:
        """
        Specifies the number of instances to be reserved. It must be a positive `integer` and not exceed the quota in the subscription.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the sku, such as `Standard_F2`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DiskEncryptionSetIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of Managed Service Identity that is configured on this Disk Encryption Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Disk Encryption Set.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The (Client) ID of the Service Principal.
        :param pulumi.Input[str] tenant_id: The ID of the Tenant the Service Principal is assigned in.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of Managed Service Identity that is configured on this Disk Encryption Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Disk Encryption Set.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The (Client) ID of the Service Principal.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Tenant the Service Principal is assigned in.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class ExtensionProtectedSettingsFromKeyVaultArgs:
    def __init__(__self__, *,
                 secret_url: pulumi.Input[str],
                 source_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param pulumi.Input[str] source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> pulumi.Input[str]:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @secret_url.setter
    def secret_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_url", value)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)


@pulumi.input_type
class GalleryApplicationVersionManageActionArgs:
    def __init__(__self__, *,
                 install: pulumi.Input[str],
                 remove: pulumi.Input[str],
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] install: The command to install the Gallery Application. Changing this forces a new resource to be created.
        :param pulumi.Input[str] remove: The command to remove the Gallery Application. Changing this forces a new resource to be created.
        :param pulumi.Input[str] update: The command to update the Gallery Application. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "install", install)
        pulumi.set(__self__, "remove", remove)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def install(self) -> pulumi.Input[str]:
        """
        The command to install the Gallery Application. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "install")

    @install.setter
    def install(self, value: pulumi.Input[str]):
        pulumi.set(self, "install", value)

    @property
    @pulumi.getter
    def remove(self) -> pulumi.Input[str]:
        """
        The command to remove the Gallery Application. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: pulumi.Input[str]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        The command to update the Gallery Application. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


@pulumi.input_type
class GalleryApplicationVersionSourceArgs:
    def __init__(__self__, *,
                 media_link: pulumi.Input[str],
                 default_configuration_link: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] media_link: The Storage Blob URI of the source application package. Changing this forces a new resource to be created.
        :param pulumi.Input[str] default_configuration_link: The Storage Blob URI of the default configuration. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "media_link", media_link)
        if default_configuration_link is not None:
            pulumi.set(__self__, "default_configuration_link", default_configuration_link)

    @property
    @pulumi.getter(name="mediaLink")
    def media_link(self) -> pulumi.Input[str]:
        """
        The Storage Blob URI of the source application package. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "media_link")

    @media_link.setter
    def media_link(self, value: pulumi.Input[str]):
        pulumi.set(self, "media_link", value)

    @property
    @pulumi.getter(name="defaultConfigurationLink")
    def default_configuration_link(self) -> Optional[pulumi.Input[str]]:
        """
        The Storage Blob URI of the default configuration. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "default_configuration_link")

    @default_configuration_link.setter
    def default_configuration_link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_configuration_link", value)


@pulumi.input_type
class GalleryApplicationVersionTargetRegionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 regional_replica_count: pulumi.Input[int],
                 storage_account_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Azure Region in which the Gallery Application Version exists.
        :param pulumi.Input[int] regional_replica_count: The number of replicas of the Gallery Application Version to be created per region. Possible values are between `1` and `10`.
        :param pulumi.Input[str] storage_account_type: The storage account type for the Gallery Application Version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regional_replica_count", regional_replica_count)
        if storage_account_type is not None:
            pulumi.set(__self__, "storage_account_type", storage_account_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Azure Region in which the Gallery Application Version exists.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="regionalReplicaCount")
    def regional_replica_count(self) -> pulumi.Input[int]:
        """
        The number of replicas of the Gallery Application Version to be created per region. Possible values are between `1` and `10`.
        """
        return pulumi.get(self, "regional_replica_count")

    @regional_replica_count.setter
    def regional_replica_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "regional_replica_count", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> Optional[pulumi.Input[str]]:
        """
        The storage account type for the Gallery Application Version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_type", value)


@pulumi.input_type
class ImageDataDiskArgs:
    def __init__(__self__, *,
                 blob_uri: Optional[pulumi.Input[str]] = None,
                 caching: Optional[pulumi.Input[str]] = None,
                 lun: Optional[pulumi.Input[int]] = None,
                 managed_disk_id: Optional[pulumi.Input[str]] = None,
                 size_gb: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] blob_uri: Specifies the URI in Azure storage of the blob that you want to use to create the image.
        :param pulumi.Input[str] caching: Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
        :param pulumi.Input[int] lun: Specifies the logical unit number of the data disk.
        :param pulumi.Input[str] managed_disk_id: Specifies the ID of the managed disk resource that you want to use to create the image. Changing this forces a new resource to be created.
        :param pulumi.Input[int] size_gb: Specifies the size of the image to be created. The target size can't be smaller than the source size.
        """
        if blob_uri is not None:
            pulumi.set(__self__, "blob_uri", blob_uri)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if lun is not None:
            pulumi.set(__self__, "lun", lun)
        if managed_disk_id is not None:
            pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blobUri")
    def blob_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the URI in Azure storage of the blob that you want to use to create the image.
        """
        return pulumi.get(self, "blob_uri")

    @blob_uri.setter
    def blob_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "blob_uri", value)

    @property
    @pulumi.getter
    def caching(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter
    def lun(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the logical unit number of the data disk.
        """
        return pulumi.get(self, "lun")

    @lun.setter
    def lun(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lun", value)

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the managed disk resource that you want to use to create the image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "managed_disk_id")

    @managed_disk_id.setter
    def managed_disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_disk_id", value)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the size of the image to be created. The target size can't be smaller than the source size.
        """
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_gb", value)


@pulumi.input_type
class ImageOsDiskArgs:
    def __init__(__self__, *,
                 blob_uri: Optional[pulumi.Input[str]] = None,
                 caching: Optional[pulumi.Input[str]] = None,
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 managed_disk_id: Optional[pulumi.Input[str]] = None,
                 os_state: Optional[pulumi.Input[str]] = None,
                 os_type: Optional[pulumi.Input[str]] = None,
                 size_gb: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] blob_uri: Specifies the URI in Azure storage of the blob that you want to use to create the image. Changing this forces a new resource to be created.
        :param pulumi.Input[str] caching: Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this image.
        :param pulumi.Input[str] managed_disk_id: Specifies the ID of the managed disk resource that you want to use to create the image.
        :param pulumi.Input[str] os_state: Specifies the state of the operating system contained in the blob. Currently, the only value is Generalized. Possible values are `Generalized` and `Specialized`.
        :param pulumi.Input[str] os_type: Specifies the type of operating system contained in the virtual machine image. Possible values are: `Windows` or `Linux`.
        :param pulumi.Input[int] size_gb: Specifies the size of the image to be created. Changing this forces a new resource to be created.
        """
        if blob_uri is not None:
            pulumi.set(__self__, "blob_uri", blob_uri)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if managed_disk_id is not None:
            pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        if os_state is not None:
            pulumi.set(__self__, "os_state", os_state)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="blobUri")
    def blob_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the URI in Azure storage of the blob that you want to use to create the image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "blob_uri")

    @blob_uri.setter
    def blob_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "blob_uri", value)

    @property
    @pulumi.getter
    def caching(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this image.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the managed disk resource that you want to use to create the image.
        """
        return pulumi.get(self, "managed_disk_id")

    @managed_disk_id.setter
    def managed_disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_disk_id", value)

    @property
    @pulumi.getter(name="osState")
    def os_state(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the state of the operating system contained in the blob. Currently, the only value is Generalized. Possible values are `Generalized` and `Specialized`.
        """
        return pulumi.get(self, "os_state")

    @os_state.setter
    def os_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_state", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of operating system contained in the virtual machine image. Possible values are: `Windows` or `Linux`.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the size of the image to be created. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_gb", value)


@pulumi.input_type
class LinuxVirtualMachineAdditionalCapabilitiesArgs:
    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
        """
        return pulumi.get(self, "ultra_ssd_enabled")

    @ultra_ssd_enabled.setter
    def ultra_ssd_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ultra_ssd_enabled", value)


@pulumi.input_type
class LinuxVirtualMachineAdminSshKeyArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key: The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format. Changing this forces a new resource to be created.
        :param pulumi.Input[str] username: The Username for which this Public SSH Key should be configured. Changing this forces a new resource to be created.
               
               > **NOTE:** The Azure VM Agent only allows creating SSH Keys at the path `/home/{username}/.ssh/authorized_keys` - as such this public key will be written to the authorized keys file.
        """
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username for which this Public SSH Key should be configured. Changing this forces a new resource to be created.

        > **NOTE:** The Azure VM Agent only allows creating SSH Keys at the path `/home/{username}/.ssh/authorized_keys` - as such this public key will be written to the authorized keys file.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class LinuxVirtualMachineBootDiagnosticsArgs:
    def __init__(__self__, *,
                 storage_account_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_account_uri: The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
               
               > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics
        """
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.

        > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics
        """
        return pulumi.get(self, "storage_account_uri")

    @storage_account_uri.setter
    def storage_account_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_uri", value)


@pulumi.input_type
class LinuxVirtualMachineGalleryApplicationArgs:
    def __init__(__self__, *,
                 version_id: pulumi.Input[str],
                 configuration_blob_uri: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] version_id: Specifies the Gallery Application Version resource ID.
        :param pulumi.Input[str] configuration_blob_uri: Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
        :param pulumi.Input[int] order: Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
        :param pulumi.Input[str] tag: Specifies a passthrough value for more generic context. This field can be any valid `string` value.
        """
        pulumi.set(__self__, "version_id", version_id)
        if configuration_blob_uri is not None:
            pulumi.set(__self__, "configuration_blob_uri", configuration_blob_uri)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> pulumi.Input[str]:
        """
        Specifies the Gallery Application Version resource ID.
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "version_id", value)

    @property
    @pulumi.getter(name="configurationBlobUri")
    def configuration_blob_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
        """
        return pulumi.get(self, "configuration_blob_uri")

    @configuration_blob_uri.setter
    def configuration_blob_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration_blob_uri", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a passthrough value for more generic context. This field can be any valid `string` value.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class LinuxVirtualMachineIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class LinuxVirtualMachineOsDiskArgs:
    def __init__(__self__, *,
                 caching: pulumi.Input[str],
                 storage_account_type: pulumi.Input[str],
                 diff_disk_settings: Optional[pulumi.Input['LinuxVirtualMachineOsDiskDiffDiskSettingsArgs']] = None,
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 secure_vm_disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 security_encryption_type: Optional[pulumi.Input[str]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] caching: The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param pulumi.Input[str] storage_account_type: The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        :param pulumi.Input['LinuxVirtualMachineOsDiskDiffDiskSettingsArgs'] diff_disk_settings: A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
               
               > **NOTE:** `diff_disk_settings` can only be set when `caching` is set to `ReadOnly`. More information can be found [here](https://docs.microsoft.com/azure/virtual-machines/ephemeral-os-disks-deploy#vm-template-deployment)
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`.
               
               > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
        :param pulumi.Input[int] disk_size_gb: The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
               
               > **NOTE:** If specified this must be equal to or larger than the size of the Image the Virtual Machine is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
        :param pulumi.Input[str] name: The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
        :param pulumi.Input[str] secure_vm_disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
               
               > **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`.
        :param pulumi.Input[str] security_encryption_type: Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
               
               > **NOTE:** `vtpm_enabled` must be set to `true` when `security_encryption_type` is specified.
               
               > **NOTE:** `encryption_at_host_enabled` cannot be set to `true` when `security_encryption_type` is set to `DiskWithVMGuestState`.
        :param pulumi.Input[bool] write_accelerator_enabled: Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
               
               > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure_vm_disk_encryption_set_id is not None:
            pulumi.set(__self__, "secure_vm_disk_encryption_set_id", secure_vm_disk_encryption_set_id)
        if security_encryption_type is not None:
            pulumi.set(__self__, "security_encryption_type", security_encryption_type)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> pulumi.Input[str]:
        """
        The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: pulumi.Input[str]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> pulumi.Input[str]:
        """
        The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_type", value)

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional[pulumi.Input['LinuxVirtualMachineOsDiskDiffDiskSettingsArgs']]:
        """
        A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.

        > **NOTE:** `diff_disk_settings` can only be set when `caching` is set to `ReadOnly`. More information can be found [here](https://docs.microsoft.com/azure/virtual-machines/ephemeral-os-disks-deploy#vm-template-deployment)
        """
        return pulumi.get(self, "diff_disk_settings")

    @diff_disk_settings.setter
    def diff_disk_settings(self, value: Optional[pulumi.Input['LinuxVirtualMachineOsDiskDiffDiskSettingsArgs']]):
        pulumi.set(self, "diff_disk_settings", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`.

        > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.

        > **NOTE:** If specified this must be equal to or larger than the size of the Image the Virtual Machine is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secureVmDiskEncryptionSetId")
    def secure_vm_disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.

        > **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`.
        """
        return pulumi.get(self, "secure_vm_disk_encryption_set_id")

    @secure_vm_disk_encryption_set_id.setter
    def secure_vm_disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_vm_disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="securityEncryptionType")
    def security_encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.

        > **NOTE:** `vtpm_enabled` must be set to `true` when `security_encryption_type` is specified.

        > **NOTE:** `encryption_at_host_enabled` cannot be set to `true` when `security_encryption_type` is set to `DiskWithVMGuestState`.
        """
        return pulumi.get(self, "security_encryption_type")

    @security_encryption_type.setter
    def security_encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_encryption_type", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.

        > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class LinuxVirtualMachineOsDiskDiffDiskSettingsArgs:
    def __init__(__self__, *,
                 option: pulumi.Input[str],
                 placement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> pulumi.Input[str]:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: pulumi.Input[str]):
        pulumi.set(self, "option", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement", value)


@pulumi.input_type
class LinuxVirtualMachinePlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param pulumi.Input[str] product: Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetAdditionalCapabilitiesArgs:
    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ultra_ssd_enabled")

    @ultra_ssd_enabled.setter
    def ultra_ssd_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ultra_ssd_enabled", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetAdminSshKeyArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key: The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format.
        :param pulumi.Input[str] username: The Username for which this Public SSH Key should be configured.
               
               > **NOTE:** The Azure VM Agent only allows creating SSH Keys at the path `/home/{username}/.ssh/authorized_keys` - as such this public key will be added/appended to the authorized keys file.
        """
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username for which this Public SSH Key should be configured.

        > **NOTE:** The Azure VM Agent only allows creating SSH Keys at the path `/home/{username}/.ssh/authorized_keys` - as such this public key will be added/appended to the authorized keys file.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetAutomaticInstanceRepairArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 grace_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
        :param pulumi.Input[str] grace_period: Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format. Defaults to `PT30M`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[str]]:
        """
        Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format. Defaults to `PT30M`.
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grace_period", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs:
    def __init__(__self__, *,
                 disable_automatic_rollback: pulumi.Input[bool],
                 enable_automatic_os_upgrade: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] disable_automatic_rollback: Should automatic rollbacks be disabled?
        :param pulumi.Input[bool] enable_automatic_os_upgrade: Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
        """
        pulumi.set(__self__, "disable_automatic_rollback", disable_automatic_rollback)
        pulumi.set(__self__, "enable_automatic_os_upgrade", enable_automatic_os_upgrade)

    @property
    @pulumi.getter(name="disableAutomaticRollback")
    def disable_automatic_rollback(self) -> pulumi.Input[bool]:
        """
        Should automatic rollbacks be disabled?
        """
        return pulumi.get(self, "disable_automatic_rollback")

    @disable_automatic_rollback.setter
    def disable_automatic_rollback(self, value: pulumi.Input[bool]):
        pulumi.set(self, "disable_automatic_rollback", value)

    @property
    @pulumi.getter(name="enableAutomaticOsUpgrade")
    def enable_automatic_os_upgrade(self) -> pulumi.Input[bool]:
        """
        Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
        """
        return pulumi.get(self, "enable_automatic_os_upgrade")

    @enable_automatic_os_upgrade.setter
    def enable_automatic_os_upgrade(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_automatic_os_upgrade", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetBootDiagnosticsArgs:
    def __init__(__self__, *,
                 storage_account_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_account_uri: The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
               
               > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics.
        """
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.

        > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics.
        """
        return pulumi.get(self, "storage_account_uri")

    @storage_account_uri.setter
    def storage_account_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_uri", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetDataDiskArgs:
    def __init__(__self__, *,
                 caching: pulumi.Input[str],
                 disk_size_gb: pulumi.Input[int],
                 lun: pulumi.Input[int],
                 storage_account_type: pulumi.Input[str],
                 create_option: Optional[pulumi.Input[str]] = None,
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ultra_ssd_disk_iops_read_write: Optional[pulumi.Input[int]] = None,
                 ultra_ssd_disk_mbps_read_write: Optional[pulumi.Input[int]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] caching: The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param pulumi.Input[int] disk_size_gb: The size of the Data Disk which should be created.
        :param pulumi.Input[int] lun: The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        :param pulumi.Input[str] storage_account_type: The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
               
               > **NOTE:** `UltraSSD_LRS` is only supported when `ultra_ssd_enabled` within the `additional_capabilities` block is enabled.
        :param pulumi.Input[str] create_option: The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.
               
               > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
               
               > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        :param pulumi.Input[str] name: The name of the Data Disk.
        :param pulumi.Input[int] ultra_ssd_disk_iops_read_write: Specifies the Read-Write IOPS for this Data Disk. Only settable when `storage_account_type` is `PremiumV2_LRS` or `UltraSSD_LRS`.
        :param pulumi.Input[int] ultra_ssd_disk_mbps_read_write: Specifies the bandwidth in MB per second for this Data Disk. Only settable when `storage_account_type` is `PremiumV2_LRS` or `UltraSSD_LRS`.
        :param pulumi.Input[bool] write_accelerator_enabled: Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
               
               > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if create_option is not None:
            pulumi.set(__self__, "create_option", create_option)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ultra_ssd_disk_iops_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_iops_read_write", ultra_ssd_disk_iops_read_write)
        if ultra_ssd_disk_mbps_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_mbps_read_write", ultra_ssd_disk_mbps_read_write)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> pulumi.Input[str]:
        """
        The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: pulumi.Input[str]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> pulumi.Input[int]:
        """
        The size of the Data Disk which should be created.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter
    def lun(self) -> pulumi.Input[int]:
        """
        The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        """
        return pulumi.get(self, "lun")

    @lun.setter
    def lun(self, value: pulumi.Input[int]):
        pulumi.set(self, "lun", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> pulumi.Input[str]:
        """
        The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.

        > **NOTE:** `UltraSSD_LRS` is only supported when `ultra_ssd_enabled` within the `additional_capabilities` block is enabled.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_type", value)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> Optional[pulumi.Input[str]]:
        """
        The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
        """
        return pulumi.get(self, "create_option")

    @create_option.setter
    def create_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_option", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.

        > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault

        > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Data Disk.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ultraSsdDiskIopsReadWrite")
    def ultra_ssd_disk_iops_read_write(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the Read-Write IOPS for this Data Disk. Only settable when `storage_account_type` is `PremiumV2_LRS` or `UltraSSD_LRS`.
        """
        return pulumi.get(self, "ultra_ssd_disk_iops_read_write")

    @ultra_ssd_disk_iops_read_write.setter
    def ultra_ssd_disk_iops_read_write(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ultra_ssd_disk_iops_read_write", value)

    @property
    @pulumi.getter(name="ultraSsdDiskMbpsReadWrite")
    def ultra_ssd_disk_mbps_read_write(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the bandwidth in MB per second for this Data Disk. Only settable when `storage_account_type` is `PremiumV2_LRS` or `UltraSSD_LRS`.
        """
        return pulumi.get(self, "ultra_ssd_disk_mbps_read_write")

    @ultra_ssd_disk_mbps_read_write.setter
    def ultra_ssd_disk_mbps_read_write(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ultra_ssd_disk_mbps_read_write", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.

        > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetExtensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 type: pulumi.Input[str],
                 type_handler_version: pulumi.Input[str],
                 auto_upgrade_minor_version: Optional[pulumi.Input[bool]] = None,
                 automatic_upgrade_enabled: Optional[pulumi.Input[bool]] = None,
                 force_update_tag: Optional[pulumi.Input[str]] = None,
                 protected_settings: Optional[pulumi.Input[str]] = None,
                 protected_settings_from_key_vault: Optional[pulumi.Input['LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs']] = None,
                 provision_after_extensions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name for the Virtual Machine Scale Set Extension.
        :param pulumi.Input[str] publisher: Specifies the Publisher of the Extension.
        :param pulumi.Input[str] type: Specifies the Type of the Extension.
        :param pulumi.Input[str] type_handler_version: Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        :param pulumi.Input[bool] auto_upgrade_minor_version: Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        :param pulumi.Input[bool] automatic_upgrade_enabled: Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
        :param pulumi.Input[str] force_update_tag: A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        :param pulumi.Input[str] protected_settings: A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
               
               > **NOTE:** Keys within the `protected_settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] provision_after_extensions: An ordered list of Extension names which this should be provisioned after.
        :param pulumi.Input[str] settings: A JSON String which specifies Settings for the Extension.
               
               > **NOTE:** Keys within the `settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version", auto_upgrade_minor_version)
        if automatic_upgrade_enabled is not None:
            pulumi.set(__self__, "automatic_upgrade_enabled", automatic_upgrade_enabled)
        if force_update_tag is not None:
            pulumi.set(__self__, "force_update_tag", force_update_tag)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if protected_settings_from_key_vault is not None:
            pulumi.set(__self__, "protected_settings_from_key_vault", protected_settings_from_key_vault)
        if provision_after_extensions is not None:
            pulumi.set(__self__, "provision_after_extensions", provision_after_extensions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Virtual Machine Scale Set Extension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the Publisher of the Extension.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the Type of the Extension.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        """
        return pulumi.get(self, "type_handler_version")

    @type_handler_version.setter
    def type_handler_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_handler_version", value)

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @auto_upgrade_minor_version.setter
    def auto_upgrade_minor_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_upgrade_minor_version", value)

    @property
    @pulumi.getter(name="automaticUpgradeEnabled")
    def automatic_upgrade_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
        """
        return pulumi.get(self, "automatic_upgrade_enabled")

    @automatic_upgrade_enabled.setter
    def automatic_upgrade_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_upgrade_enabled", value)

    @property
    @pulumi.getter(name="forceUpdateTag")
    def force_update_tag(self) -> Optional[pulumi.Input[str]]:
        """
        A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        """
        return pulumi.get(self, "force_update_tag")

    @force_update_tag.setter
    def force_update_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "force_update_tag", value)

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.

        > **NOTE:** Keys within the `protected_settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        """
        return pulumi.get(self, "protected_settings")

    @protected_settings.setter
    def protected_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protected_settings", value)

    @property
    @pulumi.getter(name="protectedSettingsFromKeyVault")
    def protected_settings_from_key_vault(self) -> Optional[pulumi.Input['LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs']]:
        return pulumi.get(self, "protected_settings_from_key_vault")

    @protected_settings_from_key_vault.setter
    def protected_settings_from_key_vault(self, value: Optional[pulumi.Input['LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs']]):
        pulumi.set(self, "protected_settings_from_key_vault", value)

    @property
    @pulumi.getter(name="provisionAfterExtensions")
    def provision_after_extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An ordered list of Extension names which this should be provisioned after.
        """
        return pulumi.get(self, "provision_after_extensions")

    @provision_after_extensions.setter
    def provision_after_extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "provision_after_extensions", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON String which specifies Settings for the Extension.

        > **NOTE:** Keys within the `settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs:
    def __init__(__self__, *,
                 secret_url: pulumi.Input[str],
                 source_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param pulumi.Input[str] source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> pulumi.Input[str]:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @secret_url.setter
    def secret_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_url", value)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetGalleryApplicationArgs:
    def __init__(__self__, *,
                 package_reference_id: pulumi.Input[str],
                 configuration_reference_blob_uri: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] order: Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] tag: Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
        """
        if package_reference_id is not None:
            warnings.warn("""`package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0""", DeprecationWarning)
            pulumi.log.warn("""package_reference_id is deprecated: `package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0""")
        pulumi.set(__self__, "package_reference_id", package_reference_id)
        if configuration_reference_blob_uri is not None:
            warnings.warn("""`configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0""", DeprecationWarning)
            pulumi.log.warn("""configuration_reference_blob_uri is deprecated: `configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0""")
        if configuration_reference_blob_uri is not None:
            pulumi.set(__self__, "configuration_reference_blob_uri", configuration_reference_blob_uri)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="packageReferenceId")
    def package_reference_id(self) -> pulumi.Input[str]:
        warnings.warn("""`package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0""", DeprecationWarning)
        pulumi.log.warn("""package_reference_id is deprecated: `package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0""")

        return pulumi.get(self, "package_reference_id")

    @package_reference_id.setter
    def package_reference_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "package_reference_id", value)

    @property
    @pulumi.getter(name="configurationReferenceBlobUri")
    def configuration_reference_blob_uri(self) -> Optional[pulumi.Input[str]]:
        warnings.warn("""`configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0""", DeprecationWarning)
        pulumi.log.warn("""configuration_reference_blob_uri is deprecated: `configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0""")

        return pulumi.get(self, "configuration_reference_blob_uri")

    @configuration_reference_blob_uri.setter
    def configuration_reference_blob_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration_reference_blob_uri", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine Scale Set.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine Scale Set.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetNetworkInterfaceArgs:
    def __init__(__self__, *,
                 ip_configurations: pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]],
                 name: pulumi.Input[str],
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enable_accelerated_networking: Optional[pulumi.Input[bool]] = None,
                 enable_ip_forwarding: Optional[pulumi.Input[bool]] = None,
                 network_security_group_id: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]] ip_configurations: One or more `ip_configuration` blocks as defined above.
        :param pulumi.Input[str] name: The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        :param pulumi.Input[bool] enable_accelerated_networking: Does this Network Interface support Accelerated Networking? Defaults to `false`.
        :param pulumi.Input[bool] enable_ip_forwarding: Does this Network Interface support IP Forwarding? Defaults to `false`.
        :param pulumi.Input[str] network_security_group_id: The ID of a Network Security Group which should be assigned to this Network Interface.
        :param pulumi.Input[bool] primary: Is this the Primary IP Configuration?
               
               > **NOTE:** If multiple `network_interface` blocks are specified, one must be set to `primary`.
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if enable_accelerated_networking is not None:
            pulumi.set(__self__, "enable_accelerated_networking", enable_accelerated_networking)
        if enable_ip_forwarding is not None:
            pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]]:
        """
        One or more `ip_configuration` blocks as defined above.
        """
        return pulumi.get(self, "ip_configurations")

    @ip_configurations.setter
    def ip_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]]):
        pulumi.set(self, "ip_configurations", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="enableAcceleratedNetworking")
    def enable_accelerated_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Does this Network Interface support Accelerated Networking? Defaults to `false`.
        """
        return pulumi.get(self, "enable_accelerated_networking")

    @enable_accelerated_networking.setter
    def enable_accelerated_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_accelerated_networking", value)

    @property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[pulumi.Input[bool]]:
        """
        Does this Network Interface support IP Forwarding? Defaults to `false`.
        """
        return pulumi.get(self, "enable_ip_forwarding")

    @enable_ip_forwarding.setter
    def enable_ip_forwarding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ip_forwarding", value)

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Network Security Group which should be assigned to this Network Interface.
        """
        return pulumi.get(self, "network_security_group_id")

    @network_security_group_id.setter
    def network_security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_security_group_id", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this the Primary IP Configuration?

        > **NOTE:** If multiple `network_interface` blocks are specified, one must be set to `primary`.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 application_gateway_backend_address_pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 application_security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 load_balancer_backend_address_pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 load_balancer_inbound_nat_rules_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 public_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Name which should be used for this IP Configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] application_gateway_backend_address_pool_ids: A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] application_security_group_ids: A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_backend_address_pool_ids: A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
               
               > **NOTE:**  When the Virtual Machine Scale Set is configured to have public IPs per instance are created with a load balancer, the SKU of the Virtual Machine instance IPs is determined by the SKU of the Virtual Machine Scale Sets Load Balancer (e.g. `Basic` or `Standard`). Alternatively, you may use the `public_ip_prefix_id` field to generate instance-level IPs in a virtual machine scale set as well. The zonal properties of the prefix will be passed to the Virtual Machine instance IPs, though they will not be shown in the output. To view the public IP addresses assigned to the Virtual Machine Scale Sets Virtual Machine instances use the **az vmss list-instance-public-ips --resource-group `ResourceGroupName` --name `VirtualMachineScaleSetName`** CLI command.
               
               > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_inbound_nat_rules_ids: A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
               
               > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        :param pulumi.Input[bool] primary: Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
               
               > **NOTE:** One `ip_configuration` block must be marked as Primary for each Network Interface.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]] public_ip_addresses: A `public_ip_address` block as defined below.
        :param pulumi.Input[str] subnet_id: The ID of the Subnet which this IP Configuration should be connected to.
               
               > `subnet_id` is required if `version` is set to `IPv4`.
        :param pulumi.Input[str] version: The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        pulumi.set(__self__, "name", name)
        if application_gateway_backend_address_pool_ids is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if load_balancer_backend_address_pool_ids is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        if load_balancer_inbound_nat_rules_ids is not None:
            pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if public_ip_addresses is not None:
            pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name which should be used for this IP Configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @application_gateway_backend_address_pool_ids.setter
    def application_gateway_backend_address_pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "application_gateway_backend_address_pool_ids", value)

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_security_group_ids")

    @application_security_group_ids.setter
    def application_security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "application_security_group_ids", value)

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.

        > **NOTE:**  When the Virtual Machine Scale Set is configured to have public IPs per instance are created with a load balancer, the SKU of the Virtual Machine instance IPs is determined by the SKU of the Virtual Machine Scale Sets Load Balancer (e.g. `Basic` or `Standard`). Alternatively, you may use the `public_ip_prefix_id` field to generate instance-level IPs in a virtual machine scale set as well. The zonal properties of the prefix will be passed to the Virtual Machine instance IPs, though they will not be shown in the output. To view the public IP addresses assigned to the Virtual Machine Scale Sets Virtual Machine instances use the **az vmss list-instance-public-ips --resource-group `ResourceGroupName` --name `VirtualMachineScaleSetName`** CLI command.

        > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @load_balancer_backend_address_pool_ids.setter
    def load_balancer_backend_address_pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_backend_address_pool_ids", value)

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.

        > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @load_balancer_inbound_nat_rules_ids.setter
    def load_balancer_inbound_nat_rules_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_inbound_nat_rules_ids", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.

        > **NOTE:** One `ip_configuration` block must be marked as Primary for each Network Interface.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]]]:
        """
        A `public_ip_address` block as defined below.
        """
        return pulumi.get(self, "public_ip_addresses")

    @public_ip_addresses.setter
    def public_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]]]):
        pulumi.set(self, "public_ip_addresses", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Subnet which this IP Configuration should be connected to.

        > `subnet_id` is required if `version` is set to `IPv4`.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 domain_name_label: Optional[pulumi.Input[str]] = None,
                 idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 ip_tags: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]]] = None,
                 public_ip_prefix_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Name of the Public IP Address Configuration.
        :param pulumi.Input[str] domain_name_label: The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
        :param pulumi.Input[int] idle_timeout_in_minutes: The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]] ip_tags: One or more `ip_tag` blocks as defined above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] public_ip_prefix_id: The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
               
               > **NOTE:** This functionality is in Preview and must be opted into via `az feature register --namespace Microsoft.Network --name AllowBringYourOwnPublicIpAddress` and then `az provider register -n Microsoft.Network`.
        :param pulumi.Input[str] version: The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        if domain_name_label is not None:
            pulumi.set(__self__, "domain_name_label", domain_name_label)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if public_ip_prefix_id is not None:
            pulumi.set(__self__, "public_ip_prefix_id", public_ip_prefix_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name of the Public IP Address Configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> Optional[pulumi.Input[str]]:
        """
        The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
        """
        return pulumi.get(self, "domain_name_label")

    @domain_name_label.setter
    def domain_name_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name_label", value)

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @idle_timeout_in_minutes.setter
    def idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]]]:
        """
        One or more `ip_tag` blocks as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ip_tags")

    @ip_tags.setter
    def ip_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]]]):
        pulumi.set(self, "ip_tags", value)

    @property
    @pulumi.getter(name="publicIpPrefixId")
    def public_ip_prefix_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.

        > **NOTE:** This functionality is in Preview and must be opted into via `az feature register --namespace Microsoft.Network --name AllowBringYourOwnPublicIpAddress` and then `az provider register -n Microsoft.Network`.
        """
        return pulumi.get(self, "public_ip_prefix_id")

    @public_ip_prefix_id.setter
    def public_ip_prefix_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip_prefix_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs:
    def __init__(__self__, *,
                 tag: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] tag: The IP Tag associated with the Public IP, such as `SQL` or `Storage`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] type: The Type of IP Tag, such as `FirstPartyUsage`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        """
        The IP Tag associated with the Public IP, such as `SQL` or `Storage`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Type of IP Tag, such as `FirstPartyUsage`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetOsDiskArgs:
    def __init__(__self__, *,
                 caching: pulumi.Input[str],
                 storage_account_type: pulumi.Input[str],
                 diff_disk_settings: Optional[pulumi.Input['LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs']] = None,
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 secure_vm_disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 security_encryption_type: Optional[pulumi.Input[str]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] caching: The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param pulumi.Input[str] storage_account_type: The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        :param pulumi.Input['LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs'] diff_disk_settings: A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`. Changing this forces a new resource to be created.
               
               > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
               
               > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        :param pulumi.Input[int] disk_size_gb: The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
               
               > **NOTE:** If specified this must be equal to or larger than the size of the Image the VM Scale Set is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
        :param pulumi.Input[str] secure_vm_disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
               
               > **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`.
        :param pulumi.Input[str] security_encryption_type: Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
               
               > **NOTE:** `vtpm_enabled` must be set to `true` when `security_encryption_type` is specified.
               
               > **NOTE:** `encryption_at_host_enabled` cannot be set to `true` when `security_encryption_type` is set to `DiskWithVMGuestState`.
        :param pulumi.Input[bool] write_accelerator_enabled: Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
               
               > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if secure_vm_disk_encryption_set_id is not None:
            pulumi.set(__self__, "secure_vm_disk_encryption_set_id", secure_vm_disk_encryption_set_id)
        if security_encryption_type is not None:
            pulumi.set(__self__, "security_encryption_type", security_encryption_type)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> pulumi.Input[str]:
        """
        The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: pulumi.Input[str]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> pulumi.Input[str]:
        """
        The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_type", value)

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional[pulumi.Input['LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs']]:
        """
        A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "diff_disk_settings")

    @diff_disk_settings.setter
    def diff_disk_settings(self, value: Optional[pulumi.Input['LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs']]):
        pulumi.set(self, "diff_disk_settings", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`. Changing this forces a new resource to be created.

        > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault

        > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.

        > **NOTE:** If specified this must be equal to or larger than the size of the Image the VM Scale Set is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="secureVmDiskEncryptionSetId")
    def secure_vm_disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.

        > **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`.
        """
        return pulumi.get(self, "secure_vm_disk_encryption_set_id")

    @secure_vm_disk_encryption_set_id.setter
    def secure_vm_disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_vm_disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="securityEncryptionType")
    def security_encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.

        > **NOTE:** `vtpm_enabled` must be set to `true` when `security_encryption_type` is specified.

        > **NOTE:** `encryption_at_host_enabled` cannot be set to `true` when `security_encryption_type` is set to `DiskWithVMGuestState`.
        """
        return pulumi.get(self, "security_encryption_type")

    @security_encryption_type.setter
    def security_encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_encryption_type", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.

        > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs:
    def __init__(__self__, *,
                 option: pulumi.Input[str],
                 placement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> pulumi.Input[str]:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: pulumi.Input[str]):
        pulumi.set(self, "option", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetPlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        :param pulumi.Input[str] product: Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetRollingUpgradePolicyArgs:
    def __init__(__self__, *,
                 max_batch_instance_percent: pulumi.Input[int],
                 max_unhealthy_instance_percent: pulumi.Input[int],
                 max_unhealthy_upgraded_instance_percent: pulumi.Input[int],
                 pause_time_between_batches: pulumi.Input[str],
                 cross_zone_upgrades_enabled: Optional[pulumi.Input[bool]] = None,
                 prioritize_unhealthy_instances_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] max_batch_instance_percent: The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
        :param pulumi.Input[int] max_unhealthy_instance_percent: The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
        :param pulumi.Input[int] max_unhealthy_upgraded_instance_percent: The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
        :param pulumi.Input[str] pause_time_between_batches: The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
        :param pulumi.Input[bool] cross_zone_upgrades_enabled: Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`.
        :param pulumi.Input[bool] prioritize_unhealthy_instances_enabled: Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`.
        """
        pulumi.set(__self__, "max_batch_instance_percent", max_batch_instance_percent)
        pulumi.set(__self__, "max_unhealthy_instance_percent", max_unhealthy_instance_percent)
        pulumi.set(__self__, "max_unhealthy_upgraded_instance_percent", max_unhealthy_upgraded_instance_percent)
        pulumi.set(__self__, "pause_time_between_batches", pause_time_between_batches)
        if cross_zone_upgrades_enabled is not None:
            pulumi.set(__self__, "cross_zone_upgrades_enabled", cross_zone_upgrades_enabled)
        if prioritize_unhealthy_instances_enabled is not None:
            pulumi.set(__self__, "prioritize_unhealthy_instances_enabled", prioritize_unhealthy_instances_enabled)

    @property
    @pulumi.getter(name="maxBatchInstancePercent")
    def max_batch_instance_percent(self) -> pulumi.Input[int]:
        """
        The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
        """
        return pulumi.get(self, "max_batch_instance_percent")

    @max_batch_instance_percent.setter
    def max_batch_instance_percent(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_batch_instance_percent", value)

    @property
    @pulumi.getter(name="maxUnhealthyInstancePercent")
    def max_unhealthy_instance_percent(self) -> pulumi.Input[int]:
        """
        The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
        """
        return pulumi.get(self, "max_unhealthy_instance_percent")

    @max_unhealthy_instance_percent.setter
    def max_unhealthy_instance_percent(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_unhealthy_instance_percent", value)

    @property
    @pulumi.getter(name="maxUnhealthyUpgradedInstancePercent")
    def max_unhealthy_upgraded_instance_percent(self) -> pulumi.Input[int]:
        """
        The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
        """
        return pulumi.get(self, "max_unhealthy_upgraded_instance_percent")

    @max_unhealthy_upgraded_instance_percent.setter
    def max_unhealthy_upgraded_instance_percent(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_unhealthy_upgraded_instance_percent", value)

    @property
    @pulumi.getter(name="pauseTimeBetweenBatches")
    def pause_time_between_batches(self) -> pulumi.Input[str]:
        """
        The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "pause_time_between_batches")

    @pause_time_between_batches.setter
    def pause_time_between_batches(self, value: pulumi.Input[str]):
        pulumi.set(self, "pause_time_between_batches", value)

    @property
    @pulumi.getter(name="crossZoneUpgradesEnabled")
    def cross_zone_upgrades_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`.
        """
        return pulumi.get(self, "cross_zone_upgrades_enabled")

    @cross_zone_upgrades_enabled.setter
    def cross_zone_upgrades_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cross_zone_upgrades_enabled", value)

    @property
    @pulumi.getter(name="prioritizeUnhealthyInstancesEnabled")
    def prioritize_unhealthy_instances_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`.
        """
        return pulumi.get(self, "prioritize_unhealthy_instances_enabled")

    @prioritize_unhealthy_instances_enabled.setter
    def prioritize_unhealthy_instances_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prioritize_unhealthy_instances_enabled", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetScaleInArgs:
    def __init__(__self__, *,
                 force_deletion_enabled: Optional[pulumi.Input[bool]] = None,
                 rule: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] force_deletion_enabled: Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
        :param pulumi.Input[str] rule: The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
        """
        if force_deletion_enabled is not None:
            pulumi.set(__self__, "force_deletion_enabled", force_deletion_enabled)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter(name="forceDeletionEnabled")
    def force_deletion_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "force_deletion_enabled")

    @force_deletion_enabled.setter
    def force_deletion_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_deletion_enabled", value)

    @property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input[str]]:
        """
        The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetSecretArgs:
    def __init__(__self__, *,
                 certificates: pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetSecretCertificateArgs']]],
                 key_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetSecretCertificateArgs']]] certificates: One or more `certificate` blocks as defined above.
        :param pulumi.Input[str] key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetSecretCertificateArgs']]]:
        """
        One or more `certificate` blocks as defined above.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineScaleSetSecretCertificateArgs']]]):
        pulumi.set(self, "certificates", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetSecretCertificateArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: The Secret URL of a Key Vault Certificate.
               
               > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
               
               > **NOTE:** The certificate must have been uploaded/created in PFX format, PEM certificates are not currently supported by Azure.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Secret URL of a Key Vault Certificate.

        > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.

        > **NOTE:** The certificate must have been uploaded/created in PFX format, PEM certificates are not currently supported by Azure.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetSourceImageReferenceArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] offer: Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sku: Specifies the SKU of the image used to create the virtual machines.
        :param pulumi.Input[str] version: Specifies the version of the image used to create the virtual machines.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        """
        Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetSpotRestoreArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] timeout: The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetTerminateNotificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the terminate notification be enabled on this Virtual Machine Scale Set?
        :param pulumi.Input[str] timeout: Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
               
               > **NOTE:** For more information about the terminate notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the terminate notification be enabled on this Virtual Machine Scale Set?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.

        > **NOTE:** For more information about the terminate notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class LinuxVirtualMachineScaleSetTerminationNotificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the termination notification be enabled on this Virtual Machine Scale Set?
        :param pulumi.Input[str] timeout: Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
               
               > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the termination notification be enabled on this Virtual Machine Scale Set?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.

        > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class LinuxVirtualMachineSecretArgs:
    def __init__(__self__, *,
                 certificates: pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineSecretCertificateArgs']]],
                 key_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineSecretCertificateArgs']]] certificates: One or more `certificate` blocks as defined above.
        :param pulumi.Input[str] key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineSecretCertificateArgs']]]:
        """
        One or more `certificate` blocks as defined above.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: pulumi.Input[Sequence[pulumi.Input['LinuxVirtualMachineSecretCertificateArgs']]]):
        pulumi.set(self, "certificates", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)


@pulumi.input_type
class LinuxVirtualMachineSecretCertificateArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: The Secret URL of a Key Vault Certificate.
               
               > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Secret URL of a Key Vault Certificate.

        > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class LinuxVirtualMachineSourceImageReferenceArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] offer: Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sku: Specifies the SKU of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] version: Specifies the version of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        """
        Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        """
        Specifies the SKU of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class LinuxVirtualMachineTerminationNotificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the termination notification be enabled on this Virtual Machine?
        :param pulumi.Input[str] timeout: Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
               
               > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the termination notification be enabled on this Virtual Machine?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.

        > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class ManagedDiskEncryptionSettingsArgs:
    def __init__(__self__, *,
                 disk_encryption_key: Optional[pulumi.Input['ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 key_encryption_key: Optional[pulumi.Input['ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs']] = None):
        """
        :param pulumi.Input['ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs'] disk_encryption_key: A `disk_encryption_key` block as defined above.
        :param pulumi.Input['ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs'] key_encryption_key: A `key_encryption_key` block as defined below.
        """
        if disk_encryption_key is not None:
            pulumi.set(__self__, "disk_encryption_key", disk_encryption_key)
        if enabled is not None:
            warnings.warn("""Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`""", DeprecationWarning)
            pulumi.log.warn("""enabled is deprecated: Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`""")
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_encryption_key is not None:
            pulumi.set(__self__, "key_encryption_key", key_encryption_key)

    @property
    @pulumi.getter(name="diskEncryptionKey")
    def disk_encryption_key(self) -> Optional[pulumi.Input['ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs']]:
        """
        A `disk_encryption_key` block as defined above.
        """
        return pulumi.get(self, "disk_encryption_key")

    @disk_encryption_key.setter
    def disk_encryption_key(self, value: Optional[pulumi.Input['ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs']]):
        pulumi.set(self, "disk_encryption_key", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        warnings.warn("""Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`""", DeprecationWarning)
        pulumi.log.warn("""enabled is deprecated: Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`""")

        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keyEncryptionKey")
    def key_encryption_key(self) -> Optional[pulumi.Input['ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs']]:
        """
        A `key_encryption_key` block as defined below.
        """
        return pulumi.get(self, "key_encryption_key")

    @key_encryption_key.setter
    def key_encryption_key(self, value: Optional[pulumi.Input['ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs']]):
        pulumi.set(self, "key_encryption_key", value)


@pulumi.input_type
class ManagedDiskEncryptionSettingsDiskEncryptionKeyArgs:
    def __init__(__self__, *,
                 secret_url: pulumi.Input[str],
                 source_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_url: The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `keyvault.Secret` resource.
        :param pulumi.Input[str] source_vault_id: The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> pulumi.Input[str]:
        """
        The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `keyvault.Secret` resource.
        """
        return pulumi.get(self, "secret_url")

    @secret_url.setter
    def secret_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_url", value)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)


@pulumi.input_type
class ManagedDiskEncryptionSettingsKeyEncryptionKeyArgs:
    def __init__(__self__, *,
                 key_url: pulumi.Input[str],
                 source_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key_url: The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `keyvault.Key` resource.
        :param pulumi.Input[str] source_vault_id: The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        pulumi.set(__self__, "key_url", key_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="keyUrl")
    def key_url(self) -> pulumi.Input[str]:
        """
        The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `keyvault.Key` resource.
        """
        return pulumi.get(self, "key_url")

    @key_url.setter
    def key_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_url", value)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetAdditionalCapabilitiesArgs:
    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Orchestrated Virtual Machine Scale Set? Defaults to `false`. Changing this forces a new resource to be created.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Orchestrated Virtual Machine Scale Set? Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ultra_ssd_enabled")

    @ultra_ssd_enabled.setter
    def ultra_ssd_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ultra_ssd_enabled", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetAutomaticInstanceRepairArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 grace_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the automatic instance repair be enabled on this Orchestrated Virtual Machine Scale Set? Possible values are `true` and `false`.
        :param pulumi.Input[str] grace_period: Amount of time for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. Possible values are between `30` and `90` minutes. Defaults to `30` minutes. The time duration should be specified in `ISO 8601` format (e.g. `PT30M` to `PT90M`).
        """
        pulumi.set(__self__, "enabled", enabled)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the automatic instance repair be enabled on this Orchestrated Virtual Machine Scale Set? Possible values are `true` and `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[str]]:
        """
        Amount of time for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. Possible values are between `30` and `90` minutes. Defaults to `30` minutes. The time duration should be specified in `ISO 8601` format (e.g. `PT30M` to `PT90M`).
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grace_period", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetBootDiagnosticsArgs:
    def __init__(__self__, *,
                 storage_account_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_account_uri: The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor. By including a `boot_diagnostics` block without passing the `storage_account_uri` field will cause the API to utilize a Managed Storage Account to store the Boot Diagnostics output.
        """
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor. By including a `boot_diagnostics` block without passing the `storage_account_uri` field will cause the API to utilize a Managed Storage Account to store the Boot Diagnostics output.
        """
        return pulumi.get(self, "storage_account_uri")

    @storage_account_uri.setter
    def storage_account_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_uri", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetDataDiskArgs:
    def __init__(__self__, *,
                 caching: pulumi.Input[str],
                 disk_size_gb: pulumi.Input[int],
                 lun: pulumi.Input[int],
                 storage_account_type: pulumi.Input[str],
                 create_option: Optional[pulumi.Input[str]] = None,
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 ultra_ssd_disk_iops_read_write: Optional[pulumi.Input[int]] = None,
                 ultra_ssd_disk_mbps_read_write: Optional[pulumi.Input[int]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] caching: The type of Caching which should be used for this Data Disk. Possible values are None, ReadOnly and ReadWrite.
        :param pulumi.Input[int] disk_size_gb: The size of the Data Disk which should be created.
        :param pulumi.Input[int] lun: The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        :param pulumi.Input[str] storage_account_type: The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
        :param pulumi.Input[str] create_option: The create option which should be used for this Data Disk. Possible values are Empty and FromImage. Defaults to `Empty`. (FromImage should only be used if the source image includes data disks).
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt the Data Disk. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] write_accelerator_enabled: Specifies if Write Accelerator is enabled on the Data Disk. Defaults to `false`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if create_option is not None:
            pulumi.set(__self__, "create_option", create_option)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if ultra_ssd_disk_iops_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_iops_read_write", ultra_ssd_disk_iops_read_write)
        if ultra_ssd_disk_mbps_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_mbps_read_write", ultra_ssd_disk_mbps_read_write)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> pulumi.Input[str]:
        """
        The type of Caching which should be used for this Data Disk. Possible values are None, ReadOnly and ReadWrite.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: pulumi.Input[str]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> pulumi.Input[int]:
        """
        The size of the Data Disk which should be created.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter
    def lun(self) -> pulumi.Input[int]:
        """
        The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        """
        return pulumi.get(self, "lun")

    @lun.setter
    def lun(self, value: pulumi.Input[int]):
        pulumi.set(self, "lun", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> pulumi.Input[str]:
        """
        The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_type", value)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> Optional[pulumi.Input[str]]:
        """
        The create option which should be used for this Data Disk. Possible values are Empty and FromImage. Defaults to `Empty`. (FromImage should only be used if the source image includes data disks).
        """
        return pulumi.get(self, "create_option")

    @create_option.setter
    def create_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_option", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt the Data Disk. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="ultraSsdDiskIopsReadWrite")
    def ultra_ssd_disk_iops_read_write(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ultra_ssd_disk_iops_read_write")

    @ultra_ssd_disk_iops_read_write.setter
    def ultra_ssd_disk_iops_read_write(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ultra_ssd_disk_iops_read_write", value)

    @property
    @pulumi.getter(name="ultraSsdDiskMbpsReadWrite")
    def ultra_ssd_disk_mbps_read_write(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ultra_ssd_disk_mbps_read_write")

    @ultra_ssd_disk_mbps_read_write.setter
    def ultra_ssd_disk_mbps_read_write(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ultra_ssd_disk_mbps_read_write", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if Write Accelerator is enabled on the Data Disk. Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetExtensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 type: pulumi.Input[str],
                 type_handler_version: pulumi.Input[str],
                 auto_upgrade_minor_version_enabled: Optional[pulumi.Input[bool]] = None,
                 extensions_to_provision_after_vm_creations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 failure_suppression_enabled: Optional[pulumi.Input[bool]] = None,
                 force_extension_execution_on_change: Optional[pulumi.Input[str]] = None,
                 protected_settings: Optional[pulumi.Input[str]] = None,
                 protected_settings_from_key_vault: Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs']] = None,
                 settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name for the Virtual Machine Scale Set Extension.
        :param pulumi.Input[str] publisher: Specifies the Publisher of the Extension.
        :param pulumi.Input[str] type: Specifies the Type of the Extension.
        :param pulumi.Input[str] type_handler_version: Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        :param pulumi.Input[bool] auto_upgrade_minor_version_enabled: Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extensions_to_provision_after_vm_creations: An ordered list of Extension names which Orchestrated Virtual Machine Scale Set should provision after VM creation.
        :param pulumi.Input[bool] failure_suppression_enabled: Should failures from the extension be suppressed? Possible values are `true` or `false`.
               
               > **NOTE:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failure_suppression_enabled` value.
        :param pulumi.Input[str] force_extension_execution_on_change: A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        :param pulumi.Input[str] protected_settings: A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
               
               > **NOTE:** Keys within the `protected_settings` block are notoriously case-sensitive, where the casing required (e.g. `TitleCase` vs `snakeCase`) depends on the Extension being used. Please refer to the documentation for the specific Orchestrated Virtual Machine Extension you're looking to use for more information.
        :param pulumi.Input['OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs'] protected_settings_from_key_vault: A `protected_settings_from_key_vault` block as defined below.
               
               > **Note:** `protected_settings_from_key_vault` cannot be used with `protected_settings`
        :param pulumi.Input[str] settings: A JSON String which specifies Settings for the Extension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version_enabled is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version_enabled", auto_upgrade_minor_version_enabled)
        if extensions_to_provision_after_vm_creations is not None:
            pulumi.set(__self__, "extensions_to_provision_after_vm_creations", extensions_to_provision_after_vm_creations)
        if failure_suppression_enabled is not None:
            pulumi.set(__self__, "failure_suppression_enabled", failure_suppression_enabled)
        if force_extension_execution_on_change is not None:
            pulumi.set(__self__, "force_extension_execution_on_change", force_extension_execution_on_change)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if protected_settings_from_key_vault is not None:
            pulumi.set(__self__, "protected_settings_from_key_vault", protected_settings_from_key_vault)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Virtual Machine Scale Set Extension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the Publisher of the Extension.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the Type of the Extension.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        """
        return pulumi.get(self, "type_handler_version")

    @type_handler_version.setter
    def type_handler_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_handler_version", value)

    @property
    @pulumi.getter(name="autoUpgradeMinorVersionEnabled")
    def auto_upgrade_minor_version_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        """
        return pulumi.get(self, "auto_upgrade_minor_version_enabled")

    @auto_upgrade_minor_version_enabled.setter
    def auto_upgrade_minor_version_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_upgrade_minor_version_enabled", value)

    @property
    @pulumi.getter(name="extensionsToProvisionAfterVmCreations")
    def extensions_to_provision_after_vm_creations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An ordered list of Extension names which Orchestrated Virtual Machine Scale Set should provision after VM creation.
        """
        return pulumi.get(self, "extensions_to_provision_after_vm_creations")

    @extensions_to_provision_after_vm_creations.setter
    def extensions_to_provision_after_vm_creations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extensions_to_provision_after_vm_creations", value)

    @property
    @pulumi.getter(name="failureSuppressionEnabled")
    def failure_suppression_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should failures from the extension be suppressed? Possible values are `true` or `false`.

        > **NOTE:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failure_suppression_enabled` value.
        """
        return pulumi.get(self, "failure_suppression_enabled")

    @failure_suppression_enabled.setter
    def failure_suppression_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failure_suppression_enabled", value)

    @property
    @pulumi.getter(name="forceExtensionExecutionOnChange")
    def force_extension_execution_on_change(self) -> Optional[pulumi.Input[str]]:
        """
        A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        """
        return pulumi.get(self, "force_extension_execution_on_change")

    @force_extension_execution_on_change.setter
    def force_extension_execution_on_change(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "force_extension_execution_on_change", value)

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.

        > **NOTE:** Keys within the `protected_settings` block are notoriously case-sensitive, where the casing required (e.g. `TitleCase` vs `snakeCase`) depends on the Extension being used. Please refer to the documentation for the specific Orchestrated Virtual Machine Extension you're looking to use for more information.
        """
        return pulumi.get(self, "protected_settings")

    @protected_settings.setter
    def protected_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protected_settings", value)

    @property
    @pulumi.getter(name="protectedSettingsFromKeyVault")
    def protected_settings_from_key_vault(self) -> Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs']]:
        """
        A `protected_settings_from_key_vault` block as defined below.

        > **Note:** `protected_settings_from_key_vault` cannot be used with `protected_settings`
        """
        return pulumi.get(self, "protected_settings_from_key_vault")

    @protected_settings_from_key_vault.setter
    def protected_settings_from_key_vault(self, value: Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs']]):
        pulumi.set(self, "protected_settings_from_key_vault", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON String which specifies Settings for the Extension.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs:
    def __init__(__self__, *,
                 secret_url: pulumi.Input[str],
                 source_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param pulumi.Input[str] source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> pulumi.Input[str]:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @secret_url.setter
    def secret_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_url", value)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetIdentityArgs:
    def __init__(__self__, *,
                 identity_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Managed Identity IDs to be assigned to this Orchestrated Windows Virtual Machine Scale Set.
        :param pulumi.Input[str] type: The type of Managed Identity that should be configured on this Orchestrated Windows Virtual Machine Scale Set. Only possible value is `UserAssigned`.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of User Managed Identity IDs to be assigned to this Orchestrated Windows Virtual Machine Scale Set.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of Managed Identity that should be configured on this Orchestrated Windows Virtual Machine Scale Set. Only possible value is `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetNetworkInterfaceArgs:
    def __init__(__self__, *,
                 ip_configurations: pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]],
                 name: pulumi.Input[str],
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enable_accelerated_networking: Optional[pulumi.Input[bool]] = None,
                 enable_ip_forwarding: Optional[pulumi.Input[bool]] = None,
                 network_security_group_id: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]] ip_configurations: One or more `ip_configuration` blocks as defined above.
        :param pulumi.Input[str] name: The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        :param pulumi.Input[bool] enable_accelerated_networking: Does this Network Interface support Accelerated Networking? Possible values are `true` and `false`. Defaults to `false`.
        :param pulumi.Input[bool] enable_ip_forwarding: Does this Network Interface support IP Forwarding? Possible values are `true` and `false`. Defaults to `false`.
        :param pulumi.Input[str] network_security_group_id: The ID of a Network Security Group which should be assigned to this Network Interface.
        :param pulumi.Input[bool] primary: Is this the Primary IP Configuration? Possible values are `true` and `false`. Defaults to `false`.
               
               > **NOTE:** If multiple `network_interface` blocks are specified, one must be set to `primary`.
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if enable_accelerated_networking is not None:
            pulumi.set(__self__, "enable_accelerated_networking", enable_accelerated_networking)
        if enable_ip_forwarding is not None:
            pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]]:
        """
        One or more `ip_configuration` blocks as defined above.
        """
        return pulumi.get(self, "ip_configurations")

    @ip_configurations.setter
    def ip_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]]):
        pulumi.set(self, "ip_configurations", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="enableAcceleratedNetworking")
    def enable_accelerated_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Does this Network Interface support Accelerated Networking? Possible values are `true` and `false`. Defaults to `false`.
        """
        return pulumi.get(self, "enable_accelerated_networking")

    @enable_accelerated_networking.setter
    def enable_accelerated_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_accelerated_networking", value)

    @property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[pulumi.Input[bool]]:
        """
        Does this Network Interface support IP Forwarding? Possible values are `true` and `false`. Defaults to `false`.
        """
        return pulumi.get(self, "enable_ip_forwarding")

    @enable_ip_forwarding.setter
    def enable_ip_forwarding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ip_forwarding", value)

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Network Security Group which should be assigned to this Network Interface.
        """
        return pulumi.get(self, "network_security_group_id")

    @network_security_group_id.setter
    def network_security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_security_group_id", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this the Primary IP Configuration? Possible values are `true` and `false`. Defaults to `false`.

        > **NOTE:** If multiple `network_interface` blocks are specified, one must be set to `primary`.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 application_gateway_backend_address_pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 application_security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 load_balancer_backend_address_pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 public_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Name which should be used for this IP Configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] application_gateway_backend_address_pool_ids: A list of Backend Address Pools IDs from a Application Gateway which this Orchestrated Virtual Machine Scale Set should be connected to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] application_security_group_ids: A list of Application Security Group IDs which this Orchestrated Virtual Machine Scale Set should be connected to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_backend_address_pool_ids: A list of Backend Address Pools IDs from a Load Balancer which this Orchestrated Virtual Machine Scale Set should be connected to.
               
               > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a depends_on between this resource and the Load Balancer Rule.
        :param pulumi.Input[bool] primary: Is this the Primary IP Configuration for this Network Interface? Possible values are `true` and `false`. Defaults to `false`.
               
               > **NOTE:** One `ip_configuration` block must be marked as Primary for each Network Interface.
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]] public_ip_addresses: A `public_ip_address` block as defined below.
        :param pulumi.Input[str] subnet_id: The ID of the Subnet which this IP Configuration should be connected to.
               
               > **NOTE:** `subnet_id` is required if version is set to `IPv4`.
        :param pulumi.Input[str] version: The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        pulumi.set(__self__, "name", name)
        if application_gateway_backend_address_pool_ids is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if load_balancer_backend_address_pool_ids is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if public_ip_addresses is not None:
            pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name which should be used for this IP Configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Backend Address Pools IDs from a Application Gateway which this Orchestrated Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @application_gateway_backend_address_pool_ids.setter
    def application_gateway_backend_address_pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "application_gateway_backend_address_pool_ids", value)

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Application Security Group IDs which this Orchestrated Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_security_group_ids")

    @application_security_group_ids.setter
    def application_security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "application_security_group_ids", value)

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Backend Address Pools IDs from a Load Balancer which this Orchestrated Virtual Machine Scale Set should be connected to.

        > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a depends_on between this resource and the Load Balancer Rule.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @load_balancer_backend_address_pool_ids.setter
    def load_balancer_backend_address_pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_backend_address_pool_ids", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this the Primary IP Configuration for this Network Interface? Possible values are `true` and `false`. Defaults to `false`.

        > **NOTE:** One `ip_configuration` block must be marked as Primary for each Network Interface.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]]]:
        """
        A `public_ip_address` block as defined below.
        """
        return pulumi.get(self, "public_ip_addresses")

    @public_ip_addresses.setter
    def public_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]]]):
        pulumi.set(self, "public_ip_addresses", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Subnet which this IP Configuration should be connected to.

        > **NOTE:** `subnet_id` is required if version is set to `IPv4`.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 domain_name_label: Optional[pulumi.Input[str]] = None,
                 idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 ip_tags: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]]] = None,
                 public_ip_prefix_id: Optional[pulumi.Input[str]] = None,
                 sku_name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Name of the Public IP Address Configuration.
        :param pulumi.Input[str] domain_name_label: The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine. Valid values must be between `1` and `26` characters long, start with a lower case letter, end with a lower case letter or number and contains only `a-z`, `0-9` and `hyphens`.
        :param pulumi.Input[int] idle_timeout_in_minutes: The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]] ip_tags: One or more `ip_tag` blocks as defined above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] public_ip_prefix_id: The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sku_name: Specifies what Public IP Address SKU the Public IP Address should be provisioned as. Possible vaules include `Basic_Regional`, `Basic_Global`, `Standard_Regional` or `Standard_Global`. For more information about Public IP Address SKU's and their capabilities, please see the [product documentation](https://docs.microsoft.com/azure/virtual-network/ip-services/public-ip-addresses#sku). Changing this forces a new resource to be created.
        :param pulumi.Input[str] version: The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        if domain_name_label is not None:
            pulumi.set(__self__, "domain_name_label", domain_name_label)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if public_ip_prefix_id is not None:
            pulumi.set(__self__, "public_ip_prefix_id", public_ip_prefix_id)
        if sku_name is not None:
            pulumi.set(__self__, "sku_name", sku_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name of the Public IP Address Configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> Optional[pulumi.Input[str]]:
        """
        The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine. Valid values must be between `1` and `26` characters long, start with a lower case letter, end with a lower case letter or number and contains only `a-z`, `0-9` and `hyphens`.
        """
        return pulumi.get(self, "domain_name_label")

    @domain_name_label.setter
    def domain_name_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name_label", value)

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @idle_timeout_in_minutes.setter
    def idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]]]:
        """
        One or more `ip_tag` blocks as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ip_tags")

    @ip_tags.setter
    def ip_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]]]):
        pulumi.set(self, "ip_tags", value)

    @property
    @pulumi.getter(name="publicIpPrefixId")
    def public_ip_prefix_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "public_ip_prefix_id")

    @public_ip_prefix_id.setter
    def public_ip_prefix_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip_prefix_id", value)

    @property
    @pulumi.getter(name="skuName")
    def sku_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies what Public IP Address SKU the Public IP Address should be provisioned as. Possible vaules include `Basic_Regional`, `Basic_Global`, `Standard_Regional` or `Standard_Global`. For more information about Public IP Address SKU's and their capabilities, please see the [product documentation](https://docs.microsoft.com/azure/virtual-network/ip-services/public-ip-addresses#sku). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku_name")

    @sku_name.setter
    def sku_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku_name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs:
    def __init__(__self__, *,
                 tag: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] tag: The IP Tag associated with the Public IP, such as `SQL` or `Storage`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] type: The Type of IP Tag, such as `FirstPartyUsage`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        """
        The IP Tag associated with the Public IP, such as `SQL` or `Storage`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Type of IP Tag, such as `FirstPartyUsage`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsDiskArgs:
    def __init__(__self__, *,
                 caching: pulumi.Input[str],
                 storage_account_type: pulumi.Input[str],
                 diff_disk_settings: Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs']] = None,
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] caching: The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param pulumi.Input[str] storage_account_type: The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        :param pulumi.Input['OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs'] diff_disk_settings: A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Changing this forces a new resource to be created.
               
               > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        :param pulumi.Input[int] disk_size_gb: The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
        :param pulumi.Input[bool] write_accelerator_enabled: Specifies if Write Accelerator is enabled on the OS Disk. Defaults to `false`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> pulumi.Input[str]:
        """
        The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: pulumi.Input[str]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> pulumi.Input[str]:
        """
        The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_type", value)

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs']]:
        """
        A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "diff_disk_settings")

    @diff_disk_settings.setter
    def diff_disk_settings(self, value: Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs']]):
        pulumi.set(self, "diff_disk_settings", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Changing this forces a new resource to be created.

        > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if Write Accelerator is enabled on the OS Disk. Defaults to `false`.
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs:
    def __init__(__self__, *,
                 option: pulumi.Input[str],
                 placement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> pulumi.Input[str]:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: pulumi.Input[str]):
        pulumi.set(self, "option", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsProfileArgs:
    def __init__(__self__, *,
                 custom_data: Optional[pulumi.Input[str]] = None,
                 linux_configuration: Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationArgs']] = None,
                 windows_configuration: Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] custom_data: The Base64-Encoded Custom Data which should be used for this Orchestrated Virtual Machine Scale Set.
               
               > **NOTE:** When Custom Data has been configured, it's not possible to remove it without tainting the Orchestrated Virtual Machine Scale Set, due to a limitation of the Azure API.
        :param pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationArgs'] linux_configuration: A `linux_configuration` block as documented below.
        :param pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationArgs'] windows_configuration: A `windows_configuration` block as documented below.
        """
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)
        if linux_configuration is not None:
            pulumi.set(__self__, "linux_configuration", linux_configuration)
        if windows_configuration is not None:
            pulumi.set(__self__, "windows_configuration", windows_configuration)

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[pulumi.Input[str]]:
        """
        The Base64-Encoded Custom Data which should be used for this Orchestrated Virtual Machine Scale Set.

        > **NOTE:** When Custom Data has been configured, it's not possible to remove it without tainting the Orchestrated Virtual Machine Scale Set, due to a limitation of the Azure API.
        """
        return pulumi.get(self, "custom_data")

    @custom_data.setter
    def custom_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_data", value)

    @property
    @pulumi.getter(name="linuxConfiguration")
    def linux_configuration(self) -> Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationArgs']]:
        """
        A `linux_configuration` block as documented below.
        """
        return pulumi.get(self, "linux_configuration")

    @linux_configuration.setter
    def linux_configuration(self, value: Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationArgs']]):
        pulumi.set(self, "linux_configuration", value)

    @property
    @pulumi.getter(name="windowsConfiguration")
    def windows_configuration(self) -> Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationArgs']]:
        """
        A `windows_configuration` block as documented below.
        """
        return pulumi.get(self, "windows_configuration")

    @windows_configuration.setter
    def windows_configuration(self, value: Optional[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationArgs']]):
        pulumi.set(self, "windows_configuration", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationArgs:
    def __init__(__self__, *,
                 admin_username: pulumi.Input[str],
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKeyArgs']]]] = None,
                 computer_name_prefix: Optional[pulumi.Input[str]] = None,
                 disable_password_authentication: Optional[pulumi.Input[bool]] = None,
                 patch_assessment_mode: Optional[pulumi.Input[str]] = None,
                 patch_mode: Optional[pulumi.Input[str]] = None,
                 provision_vm_agent: Optional[pulumi.Input[bool]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretArgs']]]] = None):
        """
        :param pulumi.Input[str] admin_username: The username of the local administrator on each Orchestrated Virtual Machine Scale Set instance. Changing this forces a new resource to be created.
        :param pulumi.Input[str] admin_password: The Password which should be used for the local-administrator on this Virtual Machine. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKeyArgs']]] admin_ssh_keys: A `admin_ssh_key` block as documented below.
        :param pulumi.Input[str] computer_name_prefix: The prefix which should be used for the name of the Virtual Machines in this Scale Set. If unspecified this defaults to the value for the name field. If the value of the name field is not a valid `computer_name_prefix`, then you must specify `computer_name_prefix`. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] disable_password_authentication: When an `admin_password` is specified `disable_password_authentication` must be set to `false`. Defaults to `true`.
               
               > **NOTE:** Either `admin_password` or `admin_ssh_key` must be specified.
        :param pulumi.Input[str] patch_assessment_mode: Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.
               
               > **NOTE:** If the `patch_assessment_mode` is set to `AutomaticByPlatform` then the `provision_vm_agent` field must be set to `true`.
        :param pulumi.Input[bool] provision_vm_agent: Should the Azure VM Agent be provisioned on each Virtual Machine in the Scale Set? Defaults to `true`. Changing this value forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretArgs']]] secrets: One or more `secret` blocks as defined below.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_ssh_keys is not None:
            pulumi.set(__self__, "admin_ssh_keys", admin_ssh_keys)
        if computer_name_prefix is not None:
            pulumi.set(__self__, "computer_name_prefix", computer_name_prefix)
        if disable_password_authentication is not None:
            pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if patch_assessment_mode is not None:
            pulumi.set(__self__, "patch_assessment_mode", patch_assessment_mode)
        if patch_mode is not None:
            pulumi.set(__self__, "patch_mode", patch_mode)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        The username of the local administrator on each Orchestrated Virtual Machine Scale Set instance. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        The Password which should be used for the local-administrator on this Virtual Machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminSshKeys")
    def admin_ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKeyArgs']]]]:
        """
        A `admin_ssh_key` block as documented below.
        """
        return pulumi.get(self, "admin_ssh_keys")

    @admin_ssh_keys.setter
    def admin_ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKeyArgs']]]]):
        pulumi.set(self, "admin_ssh_keys", value)

    @property
    @pulumi.getter(name="computerNamePrefix")
    def computer_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix which should be used for the name of the Virtual Machines in this Scale Set. If unspecified this defaults to the value for the name field. If the value of the name field is not a valid `computer_name_prefix`, then you must specify `computer_name_prefix`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "computer_name_prefix")

    @computer_name_prefix.setter
    def computer_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "computer_name_prefix", value)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        When an `admin_password` is specified `disable_password_authentication` must be set to `false`. Defaults to `true`.

        > **NOTE:** Either `admin_password` or `admin_ssh_key` must be specified.
        """
        return pulumi.get(self, "disable_password_authentication")

    @disable_password_authentication.setter
    def disable_password_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_password_authentication", value)

    @property
    @pulumi.getter(name="patchAssessmentMode")
    def patch_assessment_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.

        > **NOTE:** If the `patch_assessment_mode` is set to `AutomaticByPlatform` then the `provision_vm_agent` field must be set to `true`.
        """
        return pulumi.get(self, "patch_assessment_mode")

    @patch_assessment_mode.setter
    def patch_assessment_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patch_assessment_mode", value)

    @property
    @pulumi.getter(name="patchMode")
    def patch_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "patch_mode")

    @patch_mode.setter
    def patch_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patch_mode", value)

    @property
    @pulumi.getter(name="provisionVmAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Azure VM Agent be provisioned on each Virtual Machine in the Scale Set? Defaults to `true`. Changing this value forces a new resource to be created.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretArgs']]]]:
        """
        One or more `secret` blocks as defined below.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretArgs']]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKeyArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key: The Public Key which should be used for authentication, which needs to be at least 2048-bit and in ssh-rsa format.
        :param pulumi.Input[str] username: The Username for which this Public SSH Key should be configured.
               
               > **NOTE:** The Azure VM Agent only allows creating SSH Keys at the path `/home/{username}/.ssh/authorized_keys` - as such this public key will be written to the authorized keys file.
        """
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        The Public Key which should be used for authentication, which needs to be at least 2048-bit and in ssh-rsa format.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The Username for which this Public SSH Key should be configured.

        > **NOTE:** The Azure VM Agent only allows creating SSH Keys at the path `/home/{username}/.ssh/authorized_keys` - as such this public key will be written to the authorized keys file.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretArgs:
    def __init__(__self__, *,
                 certificates: pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificateArgs']]],
                 key_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificateArgs']]] certificates: One or more `certificate` blocks as defined below.
               
               > **NOTE:** The schema of the `certificate` block is slightly different depending on if you are provisioning a `windows_configuration` or a `linux_configuration`.
        :param pulumi.Input[str] key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificateArgs']]]:
        """
        One or more `certificate` blocks as defined below.

        > **NOTE:** The schema of the `certificate` block is slightly different depending on if you are provisioning a `windows_configuration` or a `linux_configuration`.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificateArgs']]]):
        pulumi.set(self, "certificates", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificateArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: The Secret URL of a Key Vault Certificate.
               
               > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Secret URL of a Key Vault Certificate.

        > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 admin_username: pulumi.Input[str],
                 computer_name_prefix: Optional[pulumi.Input[str]] = None,
                 enable_automatic_updates: Optional[pulumi.Input[bool]] = None,
                 hotpatching_enabled: Optional[pulumi.Input[bool]] = None,
                 patch_assessment_mode: Optional[pulumi.Input[str]] = None,
                 patch_mode: Optional[pulumi.Input[str]] = None,
                 provision_vm_agent: Optional[pulumi.Input[bool]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretArgs']]]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 winrm_listeners: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListenerArgs']]]] = None):
        """
        :param pulumi.Input[str] admin_password: The Password which should be used for the local-administrator on this Virtual Machine. Changing this forces a new resource to be created.
        :param pulumi.Input[str] admin_username: The username of the local administrator on each Orchestrated Virtual Machine Scale Set instance. Changing this forces a new resource to be created.
        :param pulumi.Input[str] computer_name_prefix: The prefix which should be used for the name of the Virtual Machines in this Scale Set. If unspecified this defaults to the value for the `name` field. If the value of the `name` field is not a valid `computer_name_prefix`, then you must specify `computer_name_prefix`. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] enable_automatic_updates: Are automatic updates enabled for this Virtual Machine? Defaults to `true`.
        :param pulumi.Input[str] patch_assessment_mode: Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.
               
               > **NOTE:** If the `patch_assessment_mode` is set to `AutomaticByPlatform` then the `provision_vm_agent` field must be set to `true`.
        :param pulumi.Input[str] patch_mode: Specifies the mode of in-guest patching of this Windows Virtual Machine. Possible values are `Manual`, `AutomaticByOS` and `AutomaticByPlatform`. Defaults to `AutomaticByOS`. For more information on patch modes please see the [product documentation](https://docs.microsoft.com/azure/virtual-machines/automatic-vm-guest-patching#patch-orchestration-modes).
               
               > **NOTE:** If `patch_mode` is set to `AutomaticByPlatform` the `provision_vm_agent` must be set to `true` and the `extension` must contain at least one application health extension.
        :param pulumi.Input[bool] provision_vm_agent: Should the Azure VM Agent be provisioned on each Virtual Machine in the Scale Set? Defaults to `true`. Changing this value forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretArgs']]] secrets: One or more `secret` blocks as defined below.
        :param pulumi.Input[str] timezone: Specifies the time zone of the virtual machine, the possible values are defined [here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/).
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListenerArgs']]] winrm_listeners: One or more `winrm_listener` blocks as defined below. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "admin_username", admin_username)
        if computer_name_prefix is not None:
            pulumi.set(__self__, "computer_name_prefix", computer_name_prefix)
        if enable_automatic_updates is not None:
            pulumi.set(__self__, "enable_automatic_updates", enable_automatic_updates)
        if hotpatching_enabled is not None:
            pulumi.set(__self__, "hotpatching_enabled", hotpatching_enabled)
        if patch_assessment_mode is not None:
            pulumi.set(__self__, "patch_assessment_mode", patch_assessment_mode)
        if patch_mode is not None:
            pulumi.set(__self__, "patch_mode", patch_mode)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if winrm_listeners is not None:
            pulumi.set(__self__, "winrm_listeners", winrm_listeners)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        The Password which should be used for the local-administrator on this Virtual Machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        The username of the local administrator on each Orchestrated Virtual Machine Scale Set instance. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="computerNamePrefix")
    def computer_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix which should be used for the name of the Virtual Machines in this Scale Set. If unspecified this defaults to the value for the `name` field. If the value of the `name` field is not a valid `computer_name_prefix`, then you must specify `computer_name_prefix`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "computer_name_prefix")

    @computer_name_prefix.setter
    def computer_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "computer_name_prefix", value)

    @property
    @pulumi.getter(name="enableAutomaticUpdates")
    def enable_automatic_updates(self) -> Optional[pulumi.Input[bool]]:
        """
        Are automatic updates enabled for this Virtual Machine? Defaults to `true`.
        """
        return pulumi.get(self, "enable_automatic_updates")

    @enable_automatic_updates.setter
    def enable_automatic_updates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_updates", value)

    @property
    @pulumi.getter(name="hotpatchingEnabled")
    def hotpatching_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hotpatching_enabled")

    @hotpatching_enabled.setter
    def hotpatching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hotpatching_enabled", value)

    @property
    @pulumi.getter(name="patchAssessmentMode")
    def patch_assessment_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.

        > **NOTE:** If the `patch_assessment_mode` is set to `AutomaticByPlatform` then the `provision_vm_agent` field must be set to `true`.
        """
        return pulumi.get(self, "patch_assessment_mode")

    @patch_assessment_mode.setter
    def patch_assessment_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patch_assessment_mode", value)

    @property
    @pulumi.getter(name="patchMode")
    def patch_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the mode of in-guest patching of this Windows Virtual Machine. Possible values are `Manual`, `AutomaticByOS` and `AutomaticByPlatform`. Defaults to `AutomaticByOS`. For more information on patch modes please see the [product documentation](https://docs.microsoft.com/azure/virtual-machines/automatic-vm-guest-patching#patch-orchestration-modes).

        > **NOTE:** If `patch_mode` is set to `AutomaticByPlatform` the `provision_vm_agent` must be set to `true` and the `extension` must contain at least one application health extension.
        """
        return pulumi.get(self, "patch_mode")

    @patch_mode.setter
    def patch_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patch_mode", value)

    @property
    @pulumi.getter(name="provisionVmAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Azure VM Agent be provisioned on each Virtual Machine in the Scale Set? Defaults to `true`. Changing this value forces a new resource to be created.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretArgs']]]]:
        """
        One or more `secret` blocks as defined below.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the time zone of the virtual machine, the possible values are defined [here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/).
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="winrmListeners")
    def winrm_listeners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListenerArgs']]]]:
        """
        One or more `winrm_listener` blocks as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "winrm_listeners")

    @winrm_listeners.setter
    def winrm_listeners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListenerArgs']]]]):
        pulumi.set(self, "winrm_listeners", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretArgs:
    def __init__(__self__, *,
                 certificates: pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificateArgs']]],
                 key_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificateArgs']]] certificates: One or more `certificate` blocks as defined below.
               
               > **NOTE:** The schema of the `certificate` block is slightly different depending on if you are provisioning a `windows_configuration` or a `linux_configuration`.
        :param pulumi.Input[str] key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificateArgs']]]:
        """
        One or more `certificate` blocks as defined below.

        > **NOTE:** The schema of the `certificate` block is slightly different depending on if you are provisioning a `windows_configuration` or a `linux_configuration`.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: pulumi.Input[Sequence[pulumi.Input['OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificateArgs']]]):
        pulumi.set(self, "certificates", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificateArgs:
    def __init__(__self__, *,
                 store: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] store: The certificate store on the Virtual Machine where the certificate should be added.
        :param pulumi.Input[str] url: The Secret URL of a Key Vault Certificate.
               
               > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        pulumi.set(__self__, "store", store)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def store(self) -> pulumi.Input[str]:
        """
        The certificate store on the Virtual Machine where the certificate should be added.
        """
        return pulumi.get(self, "store")

    @store.setter
    def store(self, value: pulumi.Input[str]):
        pulumi.set(self, "store", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Secret URL of a Key Vault Certificate.

        > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListenerArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 certificate_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: Specifies the protocol of listener. Possible values are `Http` or `Https`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] certificate_url: The Secret URL of a Key Vault Certificate, which must be specified when protocol is set to `Https`. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Specifies the protocol of listener. Possible values are `Http` or `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Secret URL of a Key Vault Certificate, which must be specified when protocol is set to `Https`. Changing this forces a new resource to be created.

        > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_url", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetPlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        :param pulumi.Input[str] product: Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetPriorityMixArgs:
    def __init__(__self__, *,
                 base_regular_count: Optional[pulumi.Input[int]] = None,
                 regular_percentage_above_base: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] base_regular_count: Specifies the base number of VMs of `Regular` priority that will be created before any VMs of priority `Spot` are created. Possible values are integers between `0` and `1000`. Defaults to `0`.
        :param pulumi.Input[int] regular_percentage_above_base: Specifies the desired percentage of VM instances that are of `Regular` priority after the base count has been reached. Possible values are integers between `0` and `100`. Defaults to `0`.
        """
        if base_regular_count is not None:
            pulumi.set(__self__, "base_regular_count", base_regular_count)
        if regular_percentage_above_base is not None:
            pulumi.set(__self__, "regular_percentage_above_base", regular_percentage_above_base)

    @property
    @pulumi.getter(name="baseRegularCount")
    def base_regular_count(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the base number of VMs of `Regular` priority that will be created before any VMs of priority `Spot` are created. Possible values are integers between `0` and `1000`. Defaults to `0`.
        """
        return pulumi.get(self, "base_regular_count")

    @base_regular_count.setter
    def base_regular_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "base_regular_count", value)

    @property
    @pulumi.getter(name="regularPercentageAboveBase")
    def regular_percentage_above_base(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the desired percentage of VM instances that are of `Regular` priority after the base count has been reached. Possible values are integers between `0` and `100`. Defaults to `0`.
        """
        return pulumi.get(self, "regular_percentage_above_base")

    @regular_percentage_above_base.setter
    def regular_percentage_above_base(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "regular_percentage_above_base", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetSourceImageReferenceArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] offer: Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sku: Specifies the SKU of the image used to create the virtual machines.
        :param pulumi.Input[str] version: Specifies the version of the image used to create the virtual machines.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        """
        Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class OrchestratedVirtualMachineScaleSetTerminationNotificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the termination notification be enabled on this Virtual Machine Scale Set? Possible values `true` or `false`
        :param pulumi.Input[str] timeout: Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in `ISO 8601` format. Defaults to `PT5M`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the termination notification be enabled on this Virtual Machine Scale Set? Possible values `true` or `false`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in `ISO 8601` format. Defaults to `PT5M`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class PacketCaptureFilterArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 local_ip_address: Optional[pulumi.Input[str]] = None,
                 local_port: Optional[pulumi.Input[str]] = None,
                 remote_ip_address: Optional[pulumi.Input[str]] = None,
                 remote_port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] local_ip_address: The local IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        :param pulumi.Input[str] local_port: The local port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        :param pulumi.Input[str] remote_ip_address: The remote IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        :param pulumi.Input[str] remote_port: The remote port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "protocol", protocol)
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if remote_ip_address is not None:
            pulumi.set(__self__, "remote_ip_address", remote_ip_address)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The local IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_ip_address")

    @local_ip_address.setter
    def local_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_ip_address", value)

    @property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[str]]:
        """
        The local port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_port", value)

    @property
    @pulumi.getter(name="remoteIpAddress")
    def remote_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The remote IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_ip_address")

    @remote_ip_address.setter
    def remote_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_ip_address", value)

    @property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[pulumi.Input[str]]:
        """
        The remote port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_port")

    @remote_port.setter
    def remote_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_port", value)


@pulumi.input_type
class PacketCaptureStorageLocationArgs:
    def __init__(__self__, *,
                 file_path: Optional[pulumi.Input[str]] = None,
                 storage_account_id: Optional[pulumi.Input[str]] = None,
                 storage_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file_path: A valid local path on the target Virtual Machine. Must include the name of the capture file (*.cap). For Linux Virtual Machines it must start with `/var/captures`.
        :param pulumi.Input[str] storage_account_id: The ID of the storage account where the packet capture sessions should be saved to.
               
               > **NOTE:** At least one of `file_path` or `storage_account_id` must be specified.
        :param pulumi.Input[str] storage_path: The URI of the storage path where the packet capture sessions are saved to.
        """
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_path is not None:
            pulumi.set(__self__, "storage_path", storage_path)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[str]]:
        """
        A valid local path on the target Virtual Machine. Must include the name of the capture file (*.cap). For Linux Virtual Machines it must start with `/var/captures`.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the storage account where the packet capture sessions should be saved to.

        > **NOTE:** At least one of `file_path` or `storage_account_id` must be specified.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="storagePath")
    def storage_path(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the storage path where the packet capture sessions are saved to.
        """
        return pulumi.get(self, "storage_path")

    @storage_path.setter
    def storage_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_path", value)


@pulumi.input_type
class ScaleSetBootDiagnosticsArgs:
    def __init__(__self__, *,
                 storage_uri: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] storage_uri: Blob endpoint for the storage account to hold the virtual machine's diagnostic files. This must be the root of a storage account, and not a storage container.
        :param pulumi.Input[bool] enabled: Whether to enable boot diagnostics for the virtual machine. Defaults to `true`.
        """
        pulumi.set(__self__, "storage_uri", storage_uri)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> pulumi.Input[str]:
        """
        Blob endpoint for the storage account to hold the virtual machine's diagnostic files. This must be the root of a storage account, and not a storage container.
        """
        return pulumi.get(self, "storage_uri")

    @storage_uri.setter
    def storage_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_uri", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable boot diagnostics for the virtual machine. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ScaleSetExtensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 type: pulumi.Input[str],
                 type_handler_version: pulumi.Input[str],
                 auto_upgrade_minor_version: Optional[pulumi.Input[bool]] = None,
                 protected_settings: Optional[pulumi.Input[str]] = None,
                 provision_after_extensions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Specifies the name of the extension.
        :param pulumi.Input[str] publisher: The publisher of the extension, available publishers can be found by using the Azure CLI.
        :param pulumi.Input[str] type: The type of extension, available types for a publisher can be found using the Azure CLI.
        :param pulumi.Input[str] type_handler_version: Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        :param pulumi.Input[bool] auto_upgrade_minor_version: Specifies whether or not to use the latest minor version available.
        :param pulumi.Input[str] protected_settings: The protected_settings passed to the extension, like settings, these are specified as a JSON object in a string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] provision_after_extensions: Specifies a dependency array of extensions required to be executed before, the array stores the name of each extension.
        :param pulumi.Input[str] settings: The settings passed to the extension, these are specified as a JSON object in a string.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version", auto_upgrade_minor_version)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if provision_after_extensions is not None:
            pulumi.set(__self__, "provision_after_extensions", provision_after_extensions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the extension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        The publisher of the extension, available publishers can be found by using the Azure CLI.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of extension, available types for a publisher can be found using the Azure CLI.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        """
        return pulumi.get(self, "type_handler_version")

    @type_handler_version.setter
    def type_handler_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_handler_version", value)

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not to use the latest minor version available.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @auto_upgrade_minor_version.setter
    def auto_upgrade_minor_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_upgrade_minor_version", value)

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[pulumi.Input[str]]:
        """
        The protected_settings passed to the extension, like settings, these are specified as a JSON object in a string.
        """
        return pulumi.get(self, "protected_settings")

    @protected_settings.setter
    def protected_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protected_settings", value)

    @property
    @pulumi.getter(name="provisionAfterExtensions")
    def provision_after_extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a dependency array of extensions required to be executed before, the array stores the name of each extension.
        """
        return pulumi.get(self, "provision_after_extensions")

    @provision_after_extensions.setter
    def provision_after_extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "provision_after_extensions", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[str]]:
        """
        The settings passed to the extension, these are specified as a JSON object in a string.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class ScaleSetIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the identity type to be assigned to the scale set. Allowable values are `SystemAssigned` and `UserAssigned`. For the `SystemAssigned` identity the scale set's Service Principal ID (SPN) can be retrieved after the scale set has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of user managed identity ids to be assigned to the VMSS. Required if `type` is `UserAssigned`.
               
               ```python
               import pulumi
               import pulumi_azure as azure
               
               example = azure.compute.ScaleSet("example",
                   resource_group_name=azurerm_resource_group["example"]["name"],
                   location=azurerm_resource_group["example"]["location"],
                   sku=azure.compute.ScaleSetSkuArgs(
                       name=var["vm_sku"],
                       tier="Standard",
                       capacity=var["instance_count"],
                   ),
                   identity=azure.compute.ScaleSetIdentityArgs(
                       type="SystemAssigned",
                   ),
                   extensions=[azure.compute.ScaleSetExtensionArgs(
                       name="MSILinuxExtension",
                       publisher="Microsoft.ManagedIdentity",
                       type="ManagedIdentityExtensionForLinux",
                       type_handler_version="1.0",
                       settings="{\\"port\\": 50342}",
                   )])
               # ...
               pulumi.export("principalId", example.identity.principal_id)
               ```
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the identity type to be assigned to the scale set. Allowable values are `SystemAssigned` and `UserAssigned`. For the `SystemAssigned` identity the scale set's Service Principal ID (SPN) can be retrieved after the scale set has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of user managed identity ids to be assigned to the VMSS. Required if `type` is `UserAssigned`.

        ```python
        import pulumi
        import pulumi_azure as azure

        example = azure.compute.ScaleSet("example",
            resource_group_name=azurerm_resource_group["example"]["name"],
            location=azurerm_resource_group["example"]["location"],
            sku=azure.compute.ScaleSetSkuArgs(
                name=var["vm_sku"],
                tier="Standard",
                capacity=var["instance_count"],
            ),
            identity=azure.compute.ScaleSetIdentityArgs(
                type="SystemAssigned",
            ),
            extensions=[azure.compute.ScaleSetExtensionArgs(
                name="MSILinuxExtension",
                publisher="Microsoft.ManagedIdentity",
                type="ManagedIdentityExtensionForLinux",
                type_handler_version="1.0",
                settings="{\\"port\\": 50342}",
            )])
        # ...
        pulumi.export("principalId", example.identity.principal_id)
        ```
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)


@pulumi.input_type
class ScaleSetNetworkProfileArgs:
    def __init__(__self__, *,
                 ip_configurations: pulumi.Input[Sequence[pulumi.Input['ScaleSetNetworkProfileIpConfigurationArgs']]],
                 name: pulumi.Input[str],
                 primary: pulumi.Input[bool],
                 accelerated_networking: Optional[pulumi.Input[bool]] = None,
                 dns_settings: Optional[pulumi.Input['ScaleSetNetworkProfileDnsSettingsArgs']] = None,
                 ip_forwarding: Optional[pulumi.Input[bool]] = None,
                 network_security_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScaleSetNetworkProfileIpConfigurationArgs']]] ip_configurations: An ip_configuration block as documented below.
        :param pulumi.Input[str] name: Specifies the name of the network interface configuration.
        :param pulumi.Input[bool] primary: Indicates whether network interfaces created from the network interface configuration will be the primary NIC of the VM.
        :param pulumi.Input[bool] accelerated_networking: Specifies whether to enable accelerated networking or not.
        :param pulumi.Input['ScaleSetNetworkProfileDnsSettingsArgs'] dns_settings: A dns_settings block as documented below.
        :param pulumi.Input[bool] ip_forwarding: Whether IP forwarding is enabled on this NIC. Defaults to `false`.
        :param pulumi.Input[str] network_security_group_id: Specifies the identifier for the network security group.
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if dns_settings is not None:
            pulumi.set(__self__, "dns_settings", dns_settings)
        if ip_forwarding is not None:
            pulumi.set(__self__, "ip_forwarding", ip_forwarding)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['ScaleSetNetworkProfileIpConfigurationArgs']]]:
        """
        An ip_configuration block as documented below.
        """
        return pulumi.get(self, "ip_configurations")

    @ip_configurations.setter
    def ip_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['ScaleSetNetworkProfileIpConfigurationArgs']]]):
        pulumi.set(self, "ip_configurations", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the network interface configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def primary(self) -> pulumi.Input[bool]:
        """
        Indicates whether network interfaces created from the network interface configuration will be the primary NIC of the VM.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to enable accelerated networking or not.
        """
        return pulumi.get(self, "accelerated_networking")

    @accelerated_networking.setter
    def accelerated_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accelerated_networking", value)

    @property
    @pulumi.getter(name="dnsSettings")
    def dns_settings(self) -> Optional[pulumi.Input['ScaleSetNetworkProfileDnsSettingsArgs']]:
        """
        A dns_settings block as documented below.
        """
        return pulumi.get(self, "dns_settings")

    @dns_settings.setter
    def dns_settings(self, value: Optional[pulumi.Input['ScaleSetNetworkProfileDnsSettingsArgs']]):
        pulumi.set(self, "dns_settings", value)

    @property
    @pulumi.getter(name="ipForwarding")
    def ip_forwarding(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether IP forwarding is enabled on this NIC. Defaults to `false`.
        """
        return pulumi.get(self, "ip_forwarding")

    @ip_forwarding.setter
    def ip_forwarding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ip_forwarding", value)

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the identifier for the network security group.
        """
        return pulumi.get(self, "network_security_group_id")

    @network_security_group_id.setter
    def network_security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_security_group_id", value)


@pulumi.input_type
class ScaleSetNetworkProfileDnsSettingsArgs:
    def __init__(__self__, *,
                 dns_servers: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: Specifies an array of DNS servers.
        """
        pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies an array of DNS servers.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dns_servers", value)


@pulumi.input_type
class ScaleSetNetworkProfileIpConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 primary: pulumi.Input[bool],
                 subnet_id: pulumi.Input[str],
                 application_gateway_backend_address_pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 application_security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 load_balancer_backend_address_pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 load_balancer_inbound_nat_rules_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 public_ip_address_configuration: Optional[pulumi.Input['ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] name: Specifies name of the IP configuration.
        :param pulumi.Input[bool] primary: Specifies if this ip_configuration is the primary one.
        :param pulumi.Input[str] subnet_id: Specifies the identifier of the subnet.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] application_gateway_backend_address_pool_ids: Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets can use the same application gateway.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] application_security_group_ids: Specifies up to `20` application security group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_backend_address_pool_ids: Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
               
               > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_inbound_nat_rules_ids: Specifies an array of references to inbound NAT pools for load balancers. A scale set can reference inbound NAT pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
               
               > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        :param pulumi.Input['ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs'] public_ip_address_configuration: Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration. The public_ip_address_configuration is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if application_gateway_backend_address_pool_ids is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if load_balancer_backend_address_pool_ids is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        if load_balancer_inbound_nat_rules_ids is not None:
            pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        if public_ip_address_configuration is not None:
            pulumi.set(__self__, "public_ip_address_configuration", public_ip_address_configuration)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies name of the IP configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def primary(self) -> pulumi.Input[bool]:
        """
        Specifies if this ip_configuration is the primary one.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        Specifies the identifier of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets can use the same application gateway.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @application_gateway_backend_address_pool_ids.setter
    def application_gateway_backend_address_pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "application_gateway_backend_address_pool_ids", value)

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies up to `20` application security group IDs.
        """
        return pulumi.get(self, "application_security_group_ids")

    @application_security_group_ids.setter
    def application_security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "application_security_group_ids", value)

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.

        > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @load_balancer_backend_address_pool_ids.setter
    def load_balancer_backend_address_pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_backend_address_pool_ids", value)

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies an array of references to inbound NAT pools for load balancers. A scale set can reference inbound NAT pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.

        > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @load_balancer_inbound_nat_rules_ids.setter
    def load_balancer_inbound_nat_rules_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_inbound_nat_rules_ids", value)

    @property
    @pulumi.getter(name="publicIpAddressConfiguration")
    def public_ip_address_configuration(self) -> Optional[pulumi.Input['ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs']]:
        """
        Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration. The public_ip_address_configuration is documented below.
        """
        return pulumi.get(self, "public_ip_address_configuration")

    @public_ip_address_configuration.setter
    def public_ip_address_configuration(self, value: Optional[pulumi.Input['ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs']]):
        pulumi.set(self, "public_ip_address_configuration", value)


@pulumi.input_type
class ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs:
    def __init__(__self__, *,
                 domain_name_label: pulumi.Input[str],
                 idle_timeout: pulumi.Input[int],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain_name_label: The domain name label for the DNS settings.
        :param pulumi.Input[int] idle_timeout: The idle timeout in minutes. This value must be between 4 and 30.
        :param pulumi.Input[str] name: The name of the public IP address configuration
        """
        pulumi.set(__self__, "domain_name_label", domain_name_label)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> pulumi.Input[str]:
        """
        The domain name label for the DNS settings.
        """
        return pulumi.get(self, "domain_name_label")

    @domain_name_label.setter
    def domain_name_label(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name_label", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> pulumi.Input[int]:
        """
        The idle timeout in minutes. This value must be between 4 and 30.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: pulumi.Input[int]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the public IP address configuration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ScaleSetOsProfileArgs:
    def __init__(__self__, *,
                 admin_username: pulumi.Input[str],
                 computer_name_prefix: pulumi.Input[str],
                 admin_password: Optional[pulumi.Input[str]] = None,
                 custom_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_username: Specifies the administrator account name to use for all the instances of virtual machines in the scale set.
        :param pulumi.Input[str] computer_name_prefix: Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 9 characters long for windows images and 1 - 58 for Linux. Changing this forces a new resource to be created.
        :param pulumi.Input[str] admin_password: Specifies the administrator password to use for all the instances of virtual machines in a scale set.
        :param pulumi.Input[str] custom_data: Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "computer_name_prefix", computer_name_prefix)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        Specifies the administrator account name to use for all the instances of virtual machines in the scale set.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="computerNamePrefix")
    def computer_name_prefix(self) -> pulumi.Input[str]:
        """
        Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 9 characters long for windows images and 1 - 58 for Linux. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "computer_name_prefix")

    @computer_name_prefix.setter
    def computer_name_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "computer_name_prefix", value)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the administrator password to use for all the instances of virtual machines in a scale set.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes.
        """
        return pulumi.get(self, "custom_data")

    @custom_data.setter
    def custom_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_data", value)


@pulumi.input_type
class ScaleSetOsProfileLinuxConfigArgs:
    def __init__(__self__, *,
                 disable_password_authentication: Optional[pulumi.Input[bool]] = None,
                 ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileLinuxConfigSshKeyArgs']]]] = None):
        """
        :param pulumi.Input[bool] disable_password_authentication: Specifies whether password authentication should be disabled. Defaults to `false`. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileLinuxConfigSshKeyArgs']]] ssh_keys: One or more `ssh_keys` blocks as defined below.
               
               > **Note:** Please note that the only allowed `path` is `/home/<username>/.ssh/authorized_keys` due to a limitation of Azure.
               
               > **NOTE:** At least one `ssh_keys` block is required if `disable_password_authentication` is set to `true`.
        """
        if disable_password_authentication is not None:
            pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether password authentication should be disabled. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "disable_password_authentication")

    @disable_password_authentication.setter
    def disable_password_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_password_authentication", value)

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileLinuxConfigSshKeyArgs']]]]:
        """
        One or more `ssh_keys` blocks as defined below.

        > **Note:** Please note that the only allowed `path` is `/home/<username>/.ssh/authorized_keys` due to a limitation of Azure.

        > **NOTE:** At least one `ssh_keys` block is required if `disable_password_authentication` is set to `true`.
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileLinuxConfigSshKeyArgs']]]]):
        pulumi.set(self, "ssh_keys", value)


@pulumi.input_type
class ScaleSetOsProfileLinuxConfigSshKeyArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 key_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: The path of the destination file on the virtual machine
               
               > **NOTE:** Due to a limitation in the Azure VM Agent the only allowed `path` is `/home/{username}/.ssh/authorized_keys`.
        :param pulumi.Input[str] key_data: The Public SSH Key which should be written to the `path` defined above.
               
               > **Note:** Azure only supports RSA SSH2 key signatures of at least 2048 bits in length
               
               > **NOTE:** Rather than defining this in-line you can source this from a local file using the `file` function - for example `key_data = file("~/.ssh/id_rsa.pub")`.
        """
        pulumi.set(__self__, "path", path)
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path of the destination file on the virtual machine

        > **NOTE:** Due to a limitation in the Azure VM Agent the only allowed `path` is `/home/{username}/.ssh/authorized_keys`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[pulumi.Input[str]]:
        """
        The Public SSH Key which should be written to the `path` defined above.

        > **Note:** Azure only supports RSA SSH2 key signatures of at least 2048 bits in length

        > **NOTE:** Rather than defining this in-line you can source this from a local file using the `file` function - for example `key_data = file("~/.ssh/id_rsa.pub")`.
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_data", value)


@pulumi.input_type
class ScaleSetOsProfileSecretArgs:
    def __init__(__self__, *,
                 source_vault_id: pulumi.Input[str],
                 vault_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileSecretVaultCertificateArgs']]]] = None):
        """
        :param pulumi.Input[str] source_vault_id: Specifies the key vault to use.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileSecretVaultCertificateArgs']]] vault_certificates: (Required, on Windows machines) One or more `vault_certificates` blocks as defined below.
        """
        pulumi.set(__self__, "source_vault_id", source_vault_id)
        if vault_certificates is not None:
            pulumi.set(__self__, "vault_certificates", vault_certificates)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        Specifies the key vault to use.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)

    @property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileSecretVaultCertificateArgs']]]]:
        """
        (Required, on Windows machines) One or more `vault_certificates` blocks as defined below.
        """
        return pulumi.get(self, "vault_certificates")

    @vault_certificates.setter
    def vault_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileSecretVaultCertificateArgs']]]]):
        pulumi.set(self, "vault_certificates", value)


@pulumi.input_type
class ScaleSetOsProfileSecretVaultCertificateArgs:
    def __init__(__self__, *,
                 certificate_url: pulumi.Input[str],
                 certificate_store: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate_url: It is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be `data`, `dataType` and `password`.
        :param pulumi.Input[str] certificate_store: (Required, on windows machines) Specifies the certificate store on the Virtual Machine where the certificate should be added to.
        """
        pulumi.set(__self__, "certificate_url", certificate_url)
        if certificate_store is not None:
            pulumi.set(__self__, "certificate_store", certificate_store)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> pulumi.Input[str]:
        """
        It is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be `data`, `dataType` and `password`.
        """
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_url", value)

    @property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> Optional[pulumi.Input[str]]:
        """
        (Required, on windows machines) Specifies the certificate store on the Virtual Machine where the certificate should be added to.
        """
        return pulumi.get(self, "certificate_store")

    @certificate_store.setter
    def certificate_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_store", value)


@pulumi.input_type
class ScaleSetOsProfileWindowsConfigArgs:
    def __init__(__self__, *,
                 additional_unattend_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs']]]] = None,
                 enable_automatic_upgrades: Optional[pulumi.Input[bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[bool]] = None,
                 winrms: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileWindowsConfigWinrmArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs']]] additional_unattend_configs: An Additional Unattended Config block as documented below.
        :param pulumi.Input[bool] enable_automatic_upgrades: Indicates whether virtual machines in the scale set are enabled for automatic updates.
        :param pulumi.Input[bool] provision_vm_agent: Indicates whether virtual machine agent should be provisioned on the virtual machines in the scale set.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileWindowsConfigWinrmArgs']]] winrms: A collection of WinRM configuration blocks as documented below.
        """
        if additional_unattend_configs is not None:
            pulumi.set(__self__, "additional_unattend_configs", additional_unattend_configs)
        if enable_automatic_upgrades is not None:
            pulumi.set(__self__, "enable_automatic_upgrades", enable_automatic_upgrades)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if winrms is not None:
            pulumi.set(__self__, "winrms", winrms)

    @property
    @pulumi.getter(name="additionalUnattendConfigs")
    def additional_unattend_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs']]]]:
        """
        An Additional Unattended Config block as documented below.
        """
        return pulumi.get(self, "additional_unattend_configs")

    @additional_unattend_configs.setter
    def additional_unattend_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs']]]]):
        pulumi.set(self, "additional_unattend_configs", value)

    @property
    @pulumi.getter(name="enableAutomaticUpgrades")
    def enable_automatic_upgrades(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether virtual machines in the scale set are enabled for automatic updates.
        """
        return pulumi.get(self, "enable_automatic_upgrades")

    @enable_automatic_upgrades.setter
    def enable_automatic_upgrades(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_upgrades", value)

    @property
    @pulumi.getter(name="provisionVmAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether virtual machine agent should be provisioned on the virtual machines in the scale set.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter
    def winrms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileWindowsConfigWinrmArgs']]]]:
        """
        A collection of WinRM configuration blocks as documented below.
        """
        return pulumi.get(self, "winrms")

    @winrms.setter
    def winrms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleSetOsProfileWindowsConfigWinrmArgs']]]]):
        pulumi.set(self, "winrms", value)


@pulumi.input_type
class ScaleSetOsProfileWindowsConfigAdditionalUnattendConfigArgs:
    def __init__(__self__, *,
                 component: pulumi.Input[str],
                 content: pulumi.Input[str],
                 pass_: pulumi.Input[str],
                 setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] component: Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        :param pulumi.Input[str] content: Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        :param pulumi.Input[str] pass_: Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        :param pulumi.Input[str] setting_name: Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "pass_", pass_)
        pulumi.set(__self__, "setting_name", setting_name)

    @property
    @pulumi.getter
    def component(self) -> pulumi.Input[str]:
        """
        Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: pulumi.Input[str]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="pass")
    def pass_(self) -> pulumi.Input[str]:
        """
        Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        """
        return pulumi.get(self, "pass_")

    @pass_.setter
    def pass_(self, value: pulumi.Input[str]):
        pulumi.set(self, "pass_", value)

    @property
    @pulumi.getter(name="settingName")
    def setting_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        return pulumi.get(self, "setting_name")

    @setting_name.setter
    def setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "setting_name", value)


@pulumi.input_type
class ScaleSetOsProfileWindowsConfigWinrmArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 certificate_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: Specifies the protocol of listener
        :param pulumi.Input[str] certificate_url: Specifies URL of the certificate with which new Virtual Machines is provisioned.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Specifies the protocol of listener
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies URL of the certificate with which new Virtual Machines is provisioned.
        """
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_url", value)


@pulumi.input_type
class ScaleSetPacketCaptureFilterArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 local_ip_address: Optional[pulumi.Input[str]] = None,
                 local_port: Optional[pulumi.Input[str]] = None,
                 remote_ip_address: Optional[pulumi.Input[str]] = None,
                 remote_port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] local_ip_address: The local IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        :param pulumi.Input[str] local_port: The local port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        :param pulumi.Input[str] remote_ip_address: The remote IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        :param pulumi.Input[str] remote_port: The remote port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "protocol", protocol)
        if local_ip_address is not None:
            pulumi.set(__self__, "local_ip_address", local_ip_address)
        if local_port is not None:
            pulumi.set(__self__, "local_port", local_port)
        if remote_ip_address is not None:
            pulumi.set(__self__, "remote_ip_address", remote_ip_address)
        if remote_port is not None:
            pulumi.set(__self__, "remote_port", remote_port)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="localIpAddress")
    def local_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The local IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_ip_address")

    @local_ip_address.setter
    def local_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_ip_address", value)

    @property
    @pulumi.getter(name="localPort")
    def local_port(self) -> Optional[pulumi.Input[str]]:
        """
        The local port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "local_port")

    @local_port.setter
    def local_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_port", value)

    @property
    @pulumi.getter(name="remoteIpAddress")
    def remote_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The remote IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_ip_address")

    @remote_ip_address.setter
    def remote_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_ip_address", value)

    @property
    @pulumi.getter(name="remotePort")
    def remote_port(self) -> Optional[pulumi.Input[str]]:
        """
        The remote port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "remote_port")

    @remote_port.setter
    def remote_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_port", value)


@pulumi.input_type
class ScaleSetPacketCaptureMachineScopeArgs:
    def __init__(__self__, *,
                 exclude_instance_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_instance_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_instance_ids: A list of Virtual Machine Scale Set instance IDs which should be excluded from running Packet Capture, e.g. `["0", "2"]`. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_instance_ids: A list of Virtual Machine Scale Set instance IDs which should be included for Packet Capture, e.g. `["1", "3"]`. Changing this forces a new resource to be created.
        """
        if exclude_instance_ids is not None:
            pulumi.set(__self__, "exclude_instance_ids", exclude_instance_ids)
        if include_instance_ids is not None:
            pulumi.set(__self__, "include_instance_ids", include_instance_ids)

    @property
    @pulumi.getter(name="excludeInstanceIds")
    def exclude_instance_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Virtual Machine Scale Set instance IDs which should be excluded from running Packet Capture, e.g. `["0", "2"]`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "exclude_instance_ids")

    @exclude_instance_ids.setter
    def exclude_instance_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_instance_ids", value)

    @property
    @pulumi.getter(name="includeInstanceIds")
    def include_instance_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Virtual Machine Scale Set instance IDs which should be included for Packet Capture, e.g. `["1", "3"]`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "include_instance_ids")

    @include_instance_ids.setter
    def include_instance_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_instance_ids", value)


@pulumi.input_type
class ScaleSetPacketCaptureStorageLocationArgs:
    def __init__(__self__, *,
                 file_path: Optional[pulumi.Input[str]] = None,
                 storage_account_id: Optional[pulumi.Input[str]] = None,
                 storage_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file_path: A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For Linux virtual machine it must start with `/var/captures`.
        :param pulumi.Input[str] storage_account_id: The ID of the storage account to save the packet capture session
               
               > **NOTE:** At least one of `file_path` or `storage_account_id` must be specified.
        :param pulumi.Input[str] storage_path: The URI of the storage path where the packet capture sessions are saved to.
        """
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_path is not None:
            pulumi.set(__self__, "storage_path", storage_path)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[str]]:
        """
        A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For Linux virtual machine it must start with `/var/captures`.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the storage account to save the packet capture session

        > **NOTE:** At least one of `file_path` or `storage_account_id` must be specified.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="storagePath")
    def storage_path(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the storage path where the packet capture sessions are saved to.
        """
        return pulumi.get(self, "storage_path")

    @storage_path.setter
    def storage_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_path", value)


@pulumi.input_type
class ScaleSetPlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Specifies the name of the image from the marketplace.
        :param pulumi.Input[str] product: Specifies the product of the image from the marketplace.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the image from the marketplace.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        Specifies the product of the image from the marketplace.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)


@pulumi.input_type
class ScaleSetRollingUpgradePolicyArgs:
    def __init__(__self__, *,
                 max_batch_instance_percent: Optional[pulumi.Input[int]] = None,
                 max_unhealthy_instance_percent: Optional[pulumi.Input[int]] = None,
                 max_unhealthy_upgraded_instance_percent: Optional[pulumi.Input[int]] = None,
                 pause_time_between_batches: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] max_batch_instance_percent: The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. Defaults to `20`.
        :param pulumi.Input[int] max_unhealthy_instance_percent: The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. Defaults to `20`.
        :param pulumi.Input[int] max_unhealthy_upgraded_instance_percent: The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. Defaults to `20`.
        :param pulumi.Input[str] pause_time_between_batches: The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format for duration (<https://en.wikipedia.org/wiki/ISO_8601#Durations>). Defaults to `0` seconds represented as `PT0S`.
        """
        if max_batch_instance_percent is not None:
            pulumi.set(__self__, "max_batch_instance_percent", max_batch_instance_percent)
        if max_unhealthy_instance_percent is not None:
            pulumi.set(__self__, "max_unhealthy_instance_percent", max_unhealthy_instance_percent)
        if max_unhealthy_upgraded_instance_percent is not None:
            pulumi.set(__self__, "max_unhealthy_upgraded_instance_percent", max_unhealthy_upgraded_instance_percent)
        if pause_time_between_batches is not None:
            pulumi.set(__self__, "pause_time_between_batches", pause_time_between_batches)

    @property
    @pulumi.getter(name="maxBatchInstancePercent")
    def max_batch_instance_percent(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. Defaults to `20`.
        """
        return pulumi.get(self, "max_batch_instance_percent")

    @max_batch_instance_percent.setter
    def max_batch_instance_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_batch_instance_percent", value)

    @property
    @pulumi.getter(name="maxUnhealthyInstancePercent")
    def max_unhealthy_instance_percent(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. Defaults to `20`.
        """
        return pulumi.get(self, "max_unhealthy_instance_percent")

    @max_unhealthy_instance_percent.setter
    def max_unhealthy_instance_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unhealthy_instance_percent", value)

    @property
    @pulumi.getter(name="maxUnhealthyUpgradedInstancePercent")
    def max_unhealthy_upgraded_instance_percent(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. Defaults to `20`.
        """
        return pulumi.get(self, "max_unhealthy_upgraded_instance_percent")

    @max_unhealthy_upgraded_instance_percent.setter
    def max_unhealthy_upgraded_instance_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unhealthy_upgraded_instance_percent", value)

    @property
    @pulumi.getter(name="pauseTimeBetweenBatches")
    def pause_time_between_batches(self) -> Optional[pulumi.Input[str]]:
        """
        The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format for duration (<https://en.wikipedia.org/wiki/ISO_8601#Durations>). Defaults to `0` seconds represented as `PT0S`.
        """
        return pulumi.get(self, "pause_time_between_batches")

    @pause_time_between_batches.setter
    def pause_time_between_batches(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pause_time_between_batches", value)


@pulumi.input_type
class ScaleSetSkuArgs:
    def __init__(__self__, *,
                 capacity: pulumi.Input[int],
                 name: pulumi.Input[str],
                 tier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] capacity: Specifies the number of virtual machines in the scale set.
        :param pulumi.Input[str] name: Specifies the size of virtual machines in a scale set.
        :param pulumi.Input[str] tier: Specifies the tier of virtual machines in a scale set. Possible values, `standard` or `basic`.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> pulumi.Input[int]:
        """
        Specifies the number of virtual machines in the scale set.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the size of virtual machines in a scale set.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the tier of virtual machines in a scale set. Possible values, `standard` or `basic`.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)


@pulumi.input_type
class ScaleSetStorageProfileDataDiskArgs:
    def __init__(__self__, *,
                 create_option: pulumi.Input[str],
                 lun: pulumi.Input[int],
                 caching: Optional[pulumi.Input[str]] = None,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 managed_disk_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create_option: Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
        :param pulumi.Input[int] lun: Specifies the Logical Unit Number of the disk in each virtual machine in the scale set.
        :param pulumi.Input[str] caching: Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        :param pulumi.Input[int] disk_size_gb: Specifies the size of the disk in GB. This element is required when creating an empty disk.
        :param pulumi.Input[str] managed_disk_type: Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
        """
        pulumi.set(__self__, "create_option", create_option)
        pulumi.set(__self__, "lun", lun)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> pulumi.Input[str]:
        """
        Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
        """
        return pulumi.get(self, "create_option")

    @create_option.setter
    def create_option(self, value: pulumi.Input[str]):
        pulumi.set(self, "create_option", value)

    @property
    @pulumi.getter
    def lun(self) -> pulumi.Input[int]:
        """
        Specifies the Logical Unit Number of the disk in each virtual machine in the scale set.
        """
        return pulumi.get(self, "lun")

    @lun.setter
    def lun(self, value: pulumi.Input[int]):
        pulumi.set(self, "lun", value)

    @property
    @pulumi.getter
    def caching(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the size of the disk in GB. This element is required when creating an empty disk.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
        """
        return pulumi.get(self, "managed_disk_type")

    @managed_disk_type.setter
    def managed_disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_disk_type", value)


@pulumi.input_type
class ScaleSetStorageProfileImageReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 offer: Optional[pulumi.Input[str]] = None,
                 publisher: Optional[pulumi.Input[str]] = None,
                 sku: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Specifies the ID of the (custom) image to use to create the virtual machine scale set, as in the example below.
        :param pulumi.Input[str] offer: Specifies the offer of the image used to create the virtual machines.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image used to create the virtual machines.
        :param pulumi.Input[str] sku: Specifies the SKU of the image used to create the virtual machines.
        :param pulumi.Input[str] version: Specifies the version of the image used to create the virtual machines.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if offer is not None:
            pulumi.set(__self__, "offer", offer)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the (custom) image to use to create the virtual machine scale set, as in the example below.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def offer(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the offer of the image used to create the virtual machines.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the publisher of the image used to create the virtual machines.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class ScaleSetStorageProfileOsDiskArgs:
    def __init__(__self__, *,
                 create_option: pulumi.Input[str],
                 caching: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 managed_disk_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 os_type: Optional[pulumi.Input[str]] = None,
                 vhd_containers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] create_option: Specifies how the virtual machine should be created. The only possible option is `FromImage`.
        :param pulumi.Input[str] caching: Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        :param pulumi.Input[str] image: Specifies the blob URI for user image. A virtual machine scale set creates an os disk in the same container as the user image.
               Updating the osDisk image causes the existing disk to be deleted and a new one created with the new image. If the VM scale set is in Manual upgrade mode then the virtual machines are not updated until they have manualUpgrade applied to them.
               When setting this field `os_type` needs to be specified. Cannot be used when `vhd_containers`, `managed_disk_type` or `storage_profile_image_reference` are specified.
        :param pulumi.Input[str] managed_disk_type: Specifies the type of managed disk to create. Value you must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`. Cannot be used when `vhd_containers` or `image` is specified.
        :param pulumi.Input[str] name: Specifies the disk name. Must be specified when using unmanaged disk ('managed_disk_type' property not set).
        :param pulumi.Input[str] os_type: Specifies the operating system Type, valid values are windows, Linux.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vhd_containers: Specifies the VHD URI. Cannot be used when `image` or `managed_disk_type` is specified.
        """
        pulumi.set(__self__, "create_option", create_option)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if vhd_containers is not None:
            pulumi.set(__self__, "vhd_containers", vhd_containers)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> pulumi.Input[str]:
        """
        Specifies how the virtual machine should be created. The only possible option is `FromImage`.
        """
        return pulumi.get(self, "create_option")

    @create_option.setter
    def create_option(self, value: pulumi.Input[str]):
        pulumi.set(self, "create_option", value)

    @property
    @pulumi.getter
    def caching(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the blob URI for user image. A virtual machine scale set creates an os disk in the same container as the user image.
        Updating the osDisk image causes the existing disk to be deleted and a new one created with the new image. If the VM scale set is in Manual upgrade mode then the virtual machines are not updated until they have manualUpgrade applied to them.
        When setting this field `os_type` needs to be specified. Cannot be used when `vhd_containers`, `managed_disk_type` or `storage_profile_image_reference` are specified.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of managed disk to create. Value you must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`. Cannot be used when `vhd_containers` or `image` is specified.
        """
        return pulumi.get(self, "managed_disk_type")

    @managed_disk_type.setter
    def managed_disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_disk_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the disk name. Must be specified when using unmanaged disk ('managed_disk_type' property not set).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the operating system Type, valid values are windows, Linux.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter(name="vhdContainers")
    def vhd_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the VHD URI. Cannot be used when `image` or `managed_disk_type` is specified.
        """
        return pulumi.get(self, "vhd_containers")

    @vhd_containers.setter
    def vhd_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vhd_containers", value)


@pulumi.input_type
class SharedImageGallerySharingArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 community_gallery: Optional[pulumi.Input['SharedImageGallerySharingCommunityGalleryArgs']] = None):
        """
        :param pulumi.Input[str] permission: The permission of the Shared Image Gallery when sharing. The only possible value now is `Community`. Changing this forces a new resource to be created.
               
               > **Note:** This requires that the Preview Feature `Microsoft.Compute/CommunityGalleries` is enabled, see [the documentation](https://learn.microsoft.com/azure/virtual-machines/share-gallery-community?tabs=cli) for more information.
        :param pulumi.Input['SharedImageGallerySharingCommunityGalleryArgs'] community_gallery: A `community_gallery` block as defined below. Changing this forces a new resource to be created.
               
               > **NOTE:** `community_gallery` must be set when `permission` is set to `Community`.
        """
        pulumi.set(__self__, "permission", permission)
        if community_gallery is not None:
            pulumi.set(__self__, "community_gallery", community_gallery)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        The permission of the Shared Image Gallery when sharing. The only possible value now is `Community`. Changing this forces a new resource to be created.

        > **Note:** This requires that the Preview Feature `Microsoft.Compute/CommunityGalleries` is enabled, see [the documentation](https://learn.microsoft.com/azure/virtual-machines/share-gallery-community?tabs=cli) for more information.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="communityGallery")
    def community_gallery(self) -> Optional[pulumi.Input['SharedImageGallerySharingCommunityGalleryArgs']]:
        """
        A `community_gallery` block as defined below. Changing this forces a new resource to be created.

        > **NOTE:** `community_gallery` must be set when `permission` is set to `Community`.
        """
        return pulumi.get(self, "community_gallery")

    @community_gallery.setter
    def community_gallery(self, value: Optional[pulumi.Input['SharedImageGallerySharingCommunityGalleryArgs']]):
        pulumi.set(self, "community_gallery", value)


@pulumi.input_type
class SharedImageGallerySharingCommunityGalleryArgs:
    def __init__(__self__, *,
                 eula: pulumi.Input[str],
                 prefix: pulumi.Input[str],
                 publisher_email: pulumi.Input[str],
                 publisher_uri: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] eula: The End User Licence Agreement for the Shared Image Gallery. Changing this forces a new resource to be created.
        :param pulumi.Input[str] prefix: Prefix of the community public name for the Shared Image Gallery. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher_email: Email of the publisher for the Shared Image Gallery. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher_uri: URI of the publisher for the Shared Image Gallery. Changing this forces a new resource to be created.
        :param pulumi.Input[str] name: Specifies the name of the Shared Image Gallery. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "eula", eula)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "publisher_email", publisher_email)
        pulumi.set(__self__, "publisher_uri", publisher_uri)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def eula(self) -> pulumi.Input[str]:
        """
        The End User Licence Agreement for the Shared Image Gallery. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "eula")

    @eula.setter
    def eula(self, value: pulumi.Input[str]):
        pulumi.set(self, "eula", value)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        """
        Prefix of the community public name for the Shared Image Gallery. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="publisherEmail")
    def publisher_email(self) -> pulumi.Input[str]:
        """
        Email of the publisher for the Shared Image Gallery. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher_email")

    @publisher_email.setter
    def publisher_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher_email", value)

    @property
    @pulumi.getter(name="publisherUri")
    def publisher_uri(self) -> pulumi.Input[str]:
        """
        URI of the publisher for the Shared Image Gallery. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher_uri")

    @publisher_uri.setter
    def publisher_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher_uri", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the name of the Shared Image Gallery. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SharedImageIdentifierArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str]):
        """
        :param pulumi.Input[str] offer: The Offer Name for this Shared Image. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: The Publisher Name for this Gallery Image. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sku: The Name of the SKU for this Gallery Image. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        """
        The Offer Name for this Shared Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        The Publisher Name for this Gallery Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        """
        The Name of the SKU for this Gallery Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)


@pulumi.input_type
class SharedImagePurchasePlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: Optional[pulumi.Input[str]] = None,
                 publisher: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Purchase Plan Name for this Shared Image. Changing this forces a new resource to be created.
        :param pulumi.Input[str] product: The Purchase Plan Product for this Gallery Image. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: The Purchase Plan Publisher for this Gallery Image. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Purchase Plan Name for this Shared Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[str]]:
        """
        The Purchase Plan Product for this Gallery Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> Optional[pulumi.Input[str]]:
        """
        The Purchase Plan Publisher for this Gallery Image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publisher", value)


@pulumi.input_type
class SharedImageVersionTargetRegionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 regional_replica_count: pulumi.Input[int],
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 exclude_from_latest_enabled: Optional[pulumi.Input[bool]] = None,
                 storage_account_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Azure Region in which this Image Version should exist.
        :param pulumi.Input[int] regional_replica_count: The number of replicas of the Image Version to be created per region.
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set to encrypt the Image Version in the target region. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] exclude_from_latest_enabled: Specifies whether this Shared Image Version should be excluded when querying for the `latest` version. Defaults to `false`.
        :param pulumi.Input[str] storage_account_type: The storage account type for the image version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`. You can store all of your image version replicas in Zone Redundant Storage by specifying `Standard_ZRS`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regional_replica_count", regional_replica_count)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if exclude_from_latest_enabled is not None:
            pulumi.set(__self__, "exclude_from_latest_enabled", exclude_from_latest_enabled)
        if storage_account_type is not None:
            pulumi.set(__self__, "storage_account_type", storage_account_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Azure Region in which this Image Version should exist.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="regionalReplicaCount")
    def regional_replica_count(self) -> pulumi.Input[int]:
        """
        The number of replicas of the Image Version to be created per region.
        """
        return pulumi.get(self, "regional_replica_count")

    @regional_replica_count.setter
    def regional_replica_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "regional_replica_count", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set to encrypt the Image Version in the target region. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="excludeFromLatestEnabled")
    def exclude_from_latest_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether this Shared Image Version should be excluded when querying for the `latest` version. Defaults to `false`.
        """
        return pulumi.get(self, "exclude_from_latest_enabled")

    @exclude_from_latest_enabled.setter
    def exclude_from_latest_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_from_latest_enabled", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> Optional[pulumi.Input[str]]:
        """
        The storage account type for the image version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`. You can store all of your image version replicas in Zone Redundant Storage by specifying `Standard_ZRS`.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_type", value)


@pulumi.input_type
class SnapshotEncryptionSettingsArgs:
    def __init__(__self__, *,
                 disk_encryption_key: Optional[pulumi.Input['SnapshotEncryptionSettingsDiskEncryptionKeyArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 key_encryption_key: Optional[pulumi.Input['SnapshotEncryptionSettingsKeyEncryptionKeyArgs']] = None):
        """
        :param pulumi.Input['SnapshotEncryptionSettingsDiskEncryptionKeyArgs'] disk_encryption_key: A `disk_encryption_key` block as defined below.
        :param pulumi.Input['SnapshotEncryptionSettingsKeyEncryptionKeyArgs'] key_encryption_key: A `key_encryption_key` block as defined below.
        """
        if disk_encryption_key is not None:
            pulumi.set(__self__, "disk_encryption_key", disk_encryption_key)
        if enabled is not None:
            warnings.warn("""Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`""", DeprecationWarning)
            pulumi.log.warn("""enabled is deprecated: Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`""")
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_encryption_key is not None:
            pulumi.set(__self__, "key_encryption_key", key_encryption_key)

    @property
    @pulumi.getter(name="diskEncryptionKey")
    def disk_encryption_key(self) -> Optional[pulumi.Input['SnapshotEncryptionSettingsDiskEncryptionKeyArgs']]:
        """
        A `disk_encryption_key` block as defined below.
        """
        return pulumi.get(self, "disk_encryption_key")

    @disk_encryption_key.setter
    def disk_encryption_key(self, value: Optional[pulumi.Input['SnapshotEncryptionSettingsDiskEncryptionKeyArgs']]):
        pulumi.set(self, "disk_encryption_key", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        warnings.warn("""Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`""", DeprecationWarning)
        pulumi.log.warn("""enabled is deprecated: Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`""")

        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keyEncryptionKey")
    def key_encryption_key(self) -> Optional[pulumi.Input['SnapshotEncryptionSettingsKeyEncryptionKeyArgs']]:
        """
        A `key_encryption_key` block as defined below.
        """
        return pulumi.get(self, "key_encryption_key")

    @key_encryption_key.setter
    def key_encryption_key(self, value: Optional[pulumi.Input['SnapshotEncryptionSettingsKeyEncryptionKeyArgs']]):
        pulumi.set(self, "key_encryption_key", value)


@pulumi.input_type
class SnapshotEncryptionSettingsDiskEncryptionKeyArgs:
    def __init__(__self__, *,
                 secret_url: pulumi.Input[str],
                 source_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_url: The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `keyvault.Secret` resource.
        :param pulumi.Input[str] source_vault_id: The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> pulumi.Input[str]:
        """
        The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `keyvault.Secret` resource.
        """
        return pulumi.get(self, "secret_url")

    @secret_url.setter
    def secret_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_url", value)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)


@pulumi.input_type
class SnapshotEncryptionSettingsKeyEncryptionKeyArgs:
    def __init__(__self__, *,
                 key_url: pulumi.Input[str],
                 source_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key_url: The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `keyvault.Key` resource.
        :param pulumi.Input[str] source_vault_id: The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        pulumi.set(__self__, "key_url", key_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="keyUrl")
    def key_url(self) -> pulumi.Input[str]:
        """
        The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `keyvault.Key` resource.
        """
        return pulumi.get(self, "key_url")

    @key_url.setter
    def key_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_url", value)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the source Key Vault. This can be found as `id` on the `keyvault.KeyVault` resource.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)


@pulumi.input_type
class VirtualMachineAdditionalCapabilitiesArgs:
    def __init__(__self__, *,
                 ultra_ssd_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] ultra_ssd_enabled: Should Ultra SSD disk be enabled for this Virtual Machine? Changing this forces a new resource to be created.
               
               > **Note:** Azure Ultra Disk Storage is only available in a region that support availability zones and can only enabled on the following VM series: `ESv3`, `DSv3`, `FSv3`, `LSv2`, `M` and `Mv2`. For more information see the `Azure Ultra Disk Storage` [product documentation](https://docs.microsoft.com/azure/virtual-machines/windows/disks-enable-ultra-ssd).
        """
        pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> pulumi.Input[bool]:
        """
        Should Ultra SSD disk be enabled for this Virtual Machine? Changing this forces a new resource to be created.

        > **Note:** Azure Ultra Disk Storage is only available in a region that support availability zones and can only enabled on the following VM series: `ESv3`, `DSv3`, `FSv3`, `LSv2`, `M` and `Mv2`. For more information see the `Azure Ultra Disk Storage` [product documentation](https://docs.microsoft.com/azure/virtual-machines/windows/disks-enable-ultra-ssd).
        """
        return pulumi.get(self, "ultra_ssd_enabled")

    @ultra_ssd_enabled.setter
    def ultra_ssd_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "ultra_ssd_enabled", value)


@pulumi.input_type
class VirtualMachineBootDiagnosticsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 storage_uri: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Should Boot Diagnostics be enabled for this Virtual Machine?
        :param pulumi.Input[str] storage_uri: The Storage Account's Blob Endpoint which should hold the virtual machine's diagnostic files.
               
               > **NOTE:** This needs to be the root of a Storage Account and not a Storage Container.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "storage_uri", storage_uri)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should Boot Diagnostics be enabled for this Virtual Machine?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> pulumi.Input[str]:
        """
        The Storage Account's Blob Endpoint which should hold the virtual machine's diagnostic files.

        > **NOTE:** This needs to be the root of a Storage Account and not a Storage Container.
        """
        return pulumi.get(self, "storage_uri")

    @storage_uri.setter
    def storage_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_uri", value)


@pulumi.input_type
class VirtualMachineIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
               
               > **NOTE:** Managed Service Identity previously required the installation of a VM Extension, but this information [is now available via the Azure Instance Metadata Service](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview#how-does-it-work).
               
               > **NOTE:** When `type` is set to `SystemAssigned`, identity the Principal ID can be retrieved after the virtual machine has been created. More details are available below. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for additional information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Virtual Machine.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).

        > **NOTE:** Managed Service Identity previously required the installation of a VM Extension, but this information [is now available via the Azure Instance Metadata Service](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview#how-does-it-work).

        > **NOTE:** When `type` is set to `SystemAssigned`, identity the Principal ID can be retrieved after the virtual machine has been created. More details are available below. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for additional information.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Virtual Machine.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)


@pulumi.input_type
class VirtualMachineOsProfileArgs:
    def __init__(__self__, *,
                 admin_username: pulumi.Input[str],
                 computer_name: pulumi.Input[str],
                 admin_password: Optional[pulumi.Input[str]] = None,
                 custom_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_username: Specifies the name of the local administrator account.
        :param pulumi.Input[str] computer_name: Specifies the name of the Virtual Machine. Changing this forces a new resource to be created.
        :param pulumi.Input[str] admin_password: (Optional for Windows, Optional for Linux) The password associated with the local administrator account.
               
               > **NOTE:** If using Linux, it may be preferable to use SSH Key authentication (available in the `os_profile_linux_config` block) instead of password authentication.
        :param pulumi.Input[str] custom_data: Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "computer_name", computer_name)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        Specifies the name of the local administrator account.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Virtual Machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "computer_name")

    @computer_name.setter
    def computer_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "computer_name", value)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional for Windows, Optional for Linux) The password associated with the local administrator account.

        > **NOTE:** If using Linux, it may be preferable to use SSH Key authentication (available in the `os_profile_linux_config` block) instead of password authentication.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "custom_data")

    @custom_data.setter
    def custom_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_data", value)


@pulumi.input_type
class VirtualMachineOsProfileLinuxConfigArgs:
    def __init__(__self__, *,
                 disable_password_authentication: pulumi.Input[bool],
                 ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileLinuxConfigSshKeyArgs']]]] = None):
        """
        :param pulumi.Input[bool] disable_password_authentication: Specifies whether password authentication should be disabled. If set to `false`, an `admin_password` must be specified.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileLinuxConfigSshKeyArgs']]] ssh_keys: One or more `ssh_keys` blocks as defined below. This field is required if `disable_password_authentication` is set to `true`.
        """
        pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> pulumi.Input[bool]:
        """
        Specifies whether password authentication should be disabled. If set to `false`, an `admin_password` must be specified.
        """
        return pulumi.get(self, "disable_password_authentication")

    @disable_password_authentication.setter
    def disable_password_authentication(self, value: pulumi.Input[bool]):
        pulumi.set(self, "disable_password_authentication", value)

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileLinuxConfigSshKeyArgs']]]]:
        """
        One or more `ssh_keys` blocks as defined below. This field is required if `disable_password_authentication` is set to `true`.
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileLinuxConfigSshKeyArgs']]]]):
        pulumi.set(self, "ssh_keys", value)


@pulumi.input_type
class VirtualMachineOsProfileLinuxConfigSshKeyArgs:
    def __init__(__self__, *,
                 key_data: pulumi.Input[str],
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key_data: The Public SSH Key which should be written to the `path` defined above.
               
               > **Note:** Azure only supports RSA SSH2 key signatures of at least 2048 bits in length
        :param pulumi.Input[str] path: The path of the destination file on the virtual machine
               
               > **NOTE:** Due to a limitation in the Azure VM Agent the only allowed `path` is `/home/{username}/.ssh/authorized_keys`.
        """
        pulumi.set(__self__, "key_data", key_data)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> pulumi.Input[str]:
        """
        The Public SSH Key which should be written to the `path` defined above.

        > **Note:** Azure only supports RSA SSH2 key signatures of at least 2048 bits in length
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path of the destination file on the virtual machine

        > **NOTE:** Due to a limitation in the Azure VM Agent the only allowed `path` is `/home/{username}/.ssh/authorized_keys`.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class VirtualMachineOsProfileSecretArgs:
    def __init__(__self__, *,
                 source_vault_id: pulumi.Input[str],
                 vault_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileSecretVaultCertificateArgs']]]] = None):
        """
        :param pulumi.Input[str] source_vault_id: Specifies the ID of the Key Vault to use.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileSecretVaultCertificateArgs']]] vault_certificates: One or more `vault_certificates` blocks as defined below.
        """
        pulumi.set(__self__, "source_vault_id", source_vault_id)
        if vault_certificates is not None:
            pulumi.set(__self__, "vault_certificates", vault_certificates)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        Specifies the ID of the Key Vault to use.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)

    @property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileSecretVaultCertificateArgs']]]]:
        """
        One or more `vault_certificates` blocks as defined below.
        """
        return pulumi.get(self, "vault_certificates")

    @vault_certificates.setter
    def vault_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileSecretVaultCertificateArgs']]]]):
        pulumi.set(self, "vault_certificates", value)


@pulumi.input_type
class VirtualMachineOsProfileSecretVaultCertificateArgs:
    def __init__(__self__, *,
                 certificate_url: pulumi.Input[str],
                 certificate_store: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate_url: The ID of the Key Vault Secret. Stored secret is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be:
               
               
               > **NOTE:** If your certificate is stored in Azure Key Vault - this can be sourced from the `secret_id` property on the `keyvault.Certificate` resource.
        :param pulumi.Input[str] certificate_store: (Required, on windows machines) Specifies the certificate store on the Virtual Machine where the certificate should be added to, such as `My`.
        """
        pulumi.set(__self__, "certificate_url", certificate_url)
        if certificate_store is not None:
            pulumi.set(__self__, "certificate_store", certificate_store)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault Secret. Stored secret is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be:


        > **NOTE:** If your certificate is stored in Azure Key Vault - this can be sourced from the `secret_id` property on the `keyvault.Certificate` resource.
        """
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_url", value)

    @property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> Optional[pulumi.Input[str]]:
        """
        (Required, on windows machines) Specifies the certificate store on the Virtual Machine where the certificate should be added to, such as `My`.
        """
        return pulumi.get(self, "certificate_store")

    @certificate_store.setter
    def certificate_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_store", value)


@pulumi.input_type
class VirtualMachineOsProfileWindowsConfigArgs:
    def __init__(__self__, *,
                 additional_unattend_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs']]]] = None,
                 enable_automatic_upgrades: Optional[pulumi.Input[bool]] = None,
                 provision_vm_agent: Optional[pulumi.Input[bool]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 winrms: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileWindowsConfigWinrmArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs']]] additional_unattend_configs: An `additional_unattend_config` block as defined below.
        :param pulumi.Input[bool] enable_automatic_upgrades: Are automatic updates enabled on this Virtual Machine? Defaults to `false.`
        :param pulumi.Input[bool] provision_vm_agent: Should the Azure Virtual Machine Guest Agent be installed on this Virtual Machine? Defaults to `false`.
               
               > **NOTE:** This is different from the Default value used for this field within Azure.
        :param pulumi.Input[str] timezone: Specifies the time zone of the virtual machine, [the possible values are defined here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/). Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileWindowsConfigWinrmArgs']]] winrms: One or more `winrm` blocks as defined below.
        """
        if additional_unattend_configs is not None:
            pulumi.set(__self__, "additional_unattend_configs", additional_unattend_configs)
        if enable_automatic_upgrades is not None:
            pulumi.set(__self__, "enable_automatic_upgrades", enable_automatic_upgrades)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if winrms is not None:
            pulumi.set(__self__, "winrms", winrms)

    @property
    @pulumi.getter(name="additionalUnattendConfigs")
    def additional_unattend_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs']]]]:
        """
        An `additional_unattend_config` block as defined below.
        """
        return pulumi.get(self, "additional_unattend_configs")

    @additional_unattend_configs.setter
    def additional_unattend_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs']]]]):
        pulumi.set(self, "additional_unattend_configs", value)

    @property
    @pulumi.getter(name="enableAutomaticUpgrades")
    def enable_automatic_upgrades(self) -> Optional[pulumi.Input[bool]]:
        """
        Are automatic updates enabled on this Virtual Machine? Defaults to `false.`
        """
        return pulumi.get(self, "enable_automatic_upgrades")

    @enable_automatic_upgrades.setter
    def enable_automatic_upgrades(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_upgrades", value)

    @property
    @pulumi.getter(name="provisionVmAgent")
    def provision_vm_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Azure Virtual Machine Guest Agent be installed on this Virtual Machine? Defaults to `false`.

        > **NOTE:** This is different from the Default value used for this field within Azure.
        """
        return pulumi.get(self, "provision_vm_agent")

    @provision_vm_agent.setter
    def provision_vm_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_vm_agent", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the time zone of the virtual machine, [the possible values are defined here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def winrms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileWindowsConfigWinrmArgs']]]]:
        """
        One or more `winrm` blocks as defined below.
        """
        return pulumi.get(self, "winrms")

    @winrms.setter
    def winrms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineOsProfileWindowsConfigWinrmArgs']]]]):
        pulumi.set(self, "winrms", value)


@pulumi.input_type
class VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfigArgs:
    def __init__(__self__, *,
                 component: pulumi.Input[str],
                 content: pulumi.Input[str],
                 pass_: pulumi.Input[str],
                 setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] component: Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        :param pulumi.Input[str] content: Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        :param pulumi.Input[str] pass_: Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        :param pulumi.Input[str] setting_name: Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "pass_", pass_)
        pulumi.set(__self__, "setting_name", setting_name)

    @property
    @pulumi.getter
    def component(self) -> pulumi.Input[str]:
        """
        Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: pulumi.Input[str]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="pass")
    def pass_(self) -> pulumi.Input[str]:
        """
        Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        """
        return pulumi.get(self, "pass_")

    @pass_.setter
    def pass_(self, value: pulumi.Input[str]):
        pulumi.set(self, "pass_", value)

    @property
    @pulumi.getter(name="settingName")
    def setting_name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        return pulumi.get(self, "setting_name")

    @setting_name.setter
    def setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "setting_name", value)


@pulumi.input_type
class VirtualMachineOsProfileWindowsConfigWinrmArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 certificate_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: Specifies the protocol of listener. Possible values are `HTTP` or `HTTPS`.
        :param pulumi.Input[str] certificate_url: The ID of the Key Vault Secret which contains the encrypted Certificate which should be installed on the Virtual Machine. This certificate must also be specified in the `vault_certificates` block within the `os_profile_secrets` block.
               
               > **NOTE:** This can be sourced from the `secret_id` field on the `keyvault.Certificate` resource.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Specifies the protocol of listener. Possible values are `HTTP` or `HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Key Vault Secret which contains the encrypted Certificate which should be installed on the Virtual Machine. This certificate must also be specified in the `vault_certificates` block within the `os_profile_secrets` block.

        > **NOTE:** This can be sourced from the `secret_id` field on the `keyvault.Certificate` resource.
        """
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_url", value)


@pulumi.input_type
class VirtualMachinePlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Specifies the name of the image from the marketplace.
        :param pulumi.Input[str] product: Specifies the product of the image from the marketplace.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the image from the marketplace.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        Specifies the product of the image from the marketplace.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)


@pulumi.input_type
class VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs:
    def __init__(__self__, *,
                 secret_url: pulumi.Input[str],
                 source_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param pulumi.Input[str] source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> pulumi.Input[str]:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @secret_url.setter
    def secret_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_url", value)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)


@pulumi.input_type
class VirtualMachineStorageDataDiskArgs:
    def __init__(__self__, *,
                 create_option: pulumi.Input[str],
                 lun: pulumi.Input[int],
                 name: pulumi.Input[str],
                 caching: Optional[pulumi.Input[str]] = None,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 managed_disk_id: Optional[pulumi.Input[str]] = None,
                 managed_disk_type: Optional[pulumi.Input[str]] = None,
                 vhd_uri: Optional[pulumi.Input[str]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] create_option: Specifies how the data disk should be created. Possible values are `Attach`, `FromImage` and `Empty`.
               
               > **NOTE:** If using an image that does not have data to be written to the Data Disk, use `Empty` as the create option in order to create the desired disk without any data.
        :param pulumi.Input[int] lun: Specifies the logical unit number of the data disk. This needs to be unique within all the Data Disks on the Virtual Machine.
        :param pulumi.Input[str] name: The name of the Data Disk.
        :param pulumi.Input[str] caching: Specifies the caching requirements for the Data Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
        :param pulumi.Input[int] disk_size_gb: Specifies the size of the data disk in gigabytes.
        :param pulumi.Input[str] managed_disk_id: Specifies the ID of an Existing Managed Disk which should be attached to this Virtual Machine. When this field is set `create_option` must be set to `Attach`.
               
               The following properties apply when using Unmanaged Disks:
        :param pulumi.Input[str] managed_disk_type: Specifies the type of managed disk to create. Possible values are either `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS` or `UltraSSD_LRS`.
               
               > **Note:** `managed_disk_type` of type `UltraSSD_LRS` is currently in preview and are not available to subscriptions that have not [requested](https://aka.ms/UltraSSDPreviewSignUp) onboarding to `Azure Ultra Disk Storage` preview. `Azure Ultra Disk Storage` is only available in `East US 2`, `North Europe`, and `Southeast Asia` regions. For more information see the `Azure Ultra Disk Storage` [product documentation](https://docs.microsoft.com/azure/virtual-machines/windows/disks-enable-ultra-ssd), [product blog](https://azure.microsoft.com/en-us/blog/announcing-the-general-availability-of-azure-ultra-disk-storage/) and [FAQ](https://docs.microsoft.com/azure/virtual-machines/windows/faq-for-disks#ultra-disks). You must also set `additional_capabilities.ultra_ssd_enabled` to `true`.
        :param pulumi.Input[str] vhd_uri: Specifies the URI of the VHD file backing this Unmanaged Data Disk.
        :param pulumi.Input[bool] write_accelerator_enabled: Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
               
               The following properties apply when using Managed Disks:
        """
        pulumi.set(__self__, "create_option", create_option)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "name", name)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if managed_disk_id is not None:
            pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)
        if vhd_uri is not None:
            pulumi.set(__self__, "vhd_uri", vhd_uri)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> pulumi.Input[str]:
        """
        Specifies how the data disk should be created. Possible values are `Attach`, `FromImage` and `Empty`.

        > **NOTE:** If using an image that does not have data to be written to the Data Disk, use `Empty` as the create option in order to create the desired disk without any data.
        """
        return pulumi.get(self, "create_option")

    @create_option.setter
    def create_option(self, value: pulumi.Input[str]):
        pulumi.set(self, "create_option", value)

    @property
    @pulumi.getter
    def lun(self) -> pulumi.Input[int]:
        """
        Specifies the logical unit number of the data disk. This needs to be unique within all the Data Disks on the Virtual Machine.
        """
        return pulumi.get(self, "lun")

    @lun.setter
    def lun(self, value: pulumi.Input[int]):
        pulumi.set(self, "lun", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Data Disk.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def caching(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the caching requirements for the Data Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the size of the data disk in gigabytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of an Existing Managed Disk which should be attached to this Virtual Machine. When this field is set `create_option` must be set to `Attach`.

        The following properties apply when using Unmanaged Disks:
        """
        return pulumi.get(self, "managed_disk_id")

    @managed_disk_id.setter
    def managed_disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_disk_id", value)

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of managed disk to create. Possible values are either `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS` or `UltraSSD_LRS`.

        > **Note:** `managed_disk_type` of type `UltraSSD_LRS` is currently in preview and are not available to subscriptions that have not [requested](https://aka.ms/UltraSSDPreviewSignUp) onboarding to `Azure Ultra Disk Storage` preview. `Azure Ultra Disk Storage` is only available in `East US 2`, `North Europe`, and `Southeast Asia` regions. For more information see the `Azure Ultra Disk Storage` [product documentation](https://docs.microsoft.com/azure/virtual-machines/windows/disks-enable-ultra-ssd), [product blog](https://azure.microsoft.com/en-us/blog/announcing-the-general-availability-of-azure-ultra-disk-storage/) and [FAQ](https://docs.microsoft.com/azure/virtual-machines/windows/faq-for-disks#ultra-disks). You must also set `additional_capabilities.ultra_ssd_enabled` to `true`.
        """
        return pulumi.get(self, "managed_disk_type")

    @managed_disk_type.setter
    def managed_disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_disk_type", value)

    @property
    @pulumi.getter(name="vhdUri")
    def vhd_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the URI of the VHD file backing this Unmanaged Data Disk.
        """
        return pulumi.get(self, "vhd_uri")

    @vhd_uri.setter
    def vhd_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vhd_uri", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.

        The following properties apply when using Managed Disks:
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class VirtualMachineStorageImageReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 offer: Optional[pulumi.Input[str]] = None,
                 publisher: Optional[pulumi.Input[str]] = None,
                 sku: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Specifies the ID of the Custom Image which the Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param pulumi.Input[str] offer: Specifies the offer of the image used to create the virtual machine. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image used to create the virtual machine. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sku: Specifies the SKU of the image used to create the virtual machine. Changing this forces a new resource to be created.
        :param pulumi.Input[str] version: Specifies the version of the image used to create the virtual machine. Changing this forces a new resource to be created.
               
               To provision a Custom Image, the following fields are applicable:
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if offer is not None:
            pulumi.set(__self__, "offer", offer)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the Custom Image which the Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def offer(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the offer of the image used to create the virtual machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the publisher of the image used to create the virtual machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the SKU of the image used to create the virtual machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the version of the image used to create the virtual machine. Changing this forces a new resource to be created.

        To provision a Custom Image, the following fields are applicable:
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class VirtualMachineStorageOsDiskArgs:
    def __init__(__self__, *,
                 create_option: pulumi.Input[str],
                 name: pulumi.Input[str],
                 caching: Optional[pulumi.Input[str]] = None,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 image_uri: Optional[pulumi.Input[str]] = None,
                 managed_disk_id: Optional[pulumi.Input[str]] = None,
                 managed_disk_type: Optional[pulumi.Input[str]] = None,
                 os_type: Optional[pulumi.Input[str]] = None,
                 vhd_uri: Optional[pulumi.Input[str]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] create_option: Specifies how the OS Disk should be created. Possible values are `Attach` (managed disks only) and `FromImage`.
        :param pulumi.Input[str] name: Specifies the name of the OS Disk.
        :param pulumi.Input[str] caching: Specifies the caching requirements for the OS Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
        :param pulumi.Input[int] disk_size_gb: Specifies the size of the OS Disk in gigabytes.
        :param pulumi.Input[str] image_uri: Specifies the Image URI in the format `publisherName:offer:skus:version`. This field can also specify the [VHD URI](https://docs.microsoft.com/azure/virtual-machines/linux/tutorial-custom-images) of a custom VM image to clone. When cloning a Custom (Unmanaged) Disk Image the `os_type` field must be set.
        :param pulumi.Input[str] managed_disk_id: Specifies the ID of an existing Managed Disk which should be attached as the OS Disk of this Virtual Machine. If this is set then the `create_option` must be set to `Attach`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] managed_disk_type: Specifies the type of Managed Disk which should be created. Possible values are `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
               
               The following properties apply when using Unmanaged Disks:
        :param pulumi.Input[str] os_type: Specifies the Operating System on the OS Disk. Possible values are `Linux` and `Windows`.
        :param pulumi.Input[str] vhd_uri: Specifies the URI of the VHD file backing this Unmanaged OS Disk. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] write_accelerator_enabled: Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
               
               The following properties apply when using Managed Disks:
        """
        pulumi.set(__self__, "create_option", create_option)
        pulumi.set(__self__, "name", name)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if managed_disk_id is not None:
            pulumi.set(__self__, "managed_disk_id", managed_disk_id)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if vhd_uri is not None:
            pulumi.set(__self__, "vhd_uri", vhd_uri)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> pulumi.Input[str]:
        """
        Specifies how the OS Disk should be created. Possible values are `Attach` (managed disks only) and `FromImage`.
        """
        return pulumi.get(self, "create_option")

    @create_option.setter
    def create_option(self, value: pulumi.Input[str]):
        pulumi.set(self, "create_option", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the OS Disk.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def caching(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the caching requirements for the OS Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the size of the OS Disk in gigabytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Image URI in the format `publisherName:offer:skus:version`. This field can also specify the [VHD URI](https://docs.microsoft.com/azure/virtual-machines/linux/tutorial-custom-images) of a custom VM image to clone. When cloning a Custom (Unmanaged) Disk Image the `os_type` field must be set.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter(name="managedDiskId")
    def managed_disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of an existing Managed Disk which should be attached as the OS Disk of this Virtual Machine. If this is set then the `create_option` must be set to `Attach`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "managed_disk_id")

    @managed_disk_id.setter
    def managed_disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_disk_id", value)

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of Managed Disk which should be created. Possible values are `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.

        The following properties apply when using Unmanaged Disks:
        """
        return pulumi.get(self, "managed_disk_type")

    @managed_disk_type.setter
    def managed_disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_disk_type", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Operating System on the OS Disk. Possible values are `Linux` and `Windows`.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter(name="vhdUri")
    def vhd_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the URI of the VHD file backing this Unmanaged OS Disk. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vhd_uri")

    @vhd_uri.setter
    def vhd_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vhd_uri", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.

        The following properties apply when using Managed Disks:
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class WindowsVirtualMachineAdditionalCapabilitiesArgs:
    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
        """
        return pulumi.get(self, "ultra_ssd_enabled")

    @ultra_ssd_enabled.setter
    def ultra_ssd_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ultra_ssd_enabled", value)


@pulumi.input_type
class WindowsVirtualMachineAdditionalUnattendContentArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 setting: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
        :param pulumi.Input[str] setting: The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "setting", setting)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def setting(self) -> pulumi.Input[str]:
        """
        The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "setting")

    @setting.setter
    def setting(self, value: pulumi.Input[str]):
        pulumi.set(self, "setting", value)


@pulumi.input_type
class WindowsVirtualMachineBootDiagnosticsArgs:
    def __init__(__self__, *,
                 storage_account_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_account_uri: The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
               
               > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics.
        """
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.

        > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics.
        """
        return pulumi.get(self, "storage_account_uri")

    @storage_account_uri.setter
    def storage_account_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_uri", value)


@pulumi.input_type
class WindowsVirtualMachineGalleryApplicationArgs:
    def __init__(__self__, *,
                 version_id: pulumi.Input[str],
                 configuration_blob_uri: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] version_id: Specifies the Gallery Application Version resource ID.
        :param pulumi.Input[str] configuration_blob_uri: Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
        :param pulumi.Input[int] order: Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
        :param pulumi.Input[str] tag: Specifies a passthrough value for more generic context. This field can be any valid `string` value.
        """
        pulumi.set(__self__, "version_id", version_id)
        if configuration_blob_uri is not None:
            pulumi.set(__self__, "configuration_blob_uri", configuration_blob_uri)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> pulumi.Input[str]:
        """
        Specifies the Gallery Application Version resource ID.
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "version_id", value)

    @property
    @pulumi.getter(name="configurationBlobUri")
    def configuration_blob_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
        """
        return pulumi.get(self, "configuration_blob_uri")

    @configuration_blob_uri.setter
    def configuration_blob_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration_blob_uri", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a passthrough value for more generic context. This field can be any valid `string` value.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class WindowsVirtualMachineIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class WindowsVirtualMachineOsDiskArgs:
    def __init__(__self__, *,
                 caching: pulumi.Input[str],
                 storage_account_type: pulumi.Input[str],
                 diff_disk_settings: Optional[pulumi.Input['WindowsVirtualMachineOsDiskDiffDiskSettingsArgs']] = None,
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 secure_vm_disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 security_encryption_type: Optional[pulumi.Input[str]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] caching: The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param pulumi.Input[str] storage_account_type: The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        :param pulumi.Input['WindowsVirtualMachineOsDiskDiffDiskSettingsArgs'] diff_disk_settings: A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
               
               > **NOTE:** `diff_disk_settings` can only be set when `caching` is set to `ReadOnly`. More information can be found [here](https://docs.microsoft.com/azure/virtual-machines/ephemeral-os-disks-deploy#vm-template-deployment)
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`.
               
               > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
        :param pulumi.Input[int] disk_size_gb: The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
               
               > **NOTE:** If specified this must be equal to or larger than the size of the Image the Virtual Machine is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
        :param pulumi.Input[str] name: The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
        :param pulumi.Input[str] secure_vm_disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
               
               > **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`.
        :param pulumi.Input[str] security_encryption_type: Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
               
               > **NOTE:** `vtpm_enabled` must be set to `true` when `security_encryption_type` is specified.
               
               > **NOTE:** `encryption_at_host_enabled` cannot be set to `true` when `security_encryption_type` is set to `DiskWithVMGuestState`.
        :param pulumi.Input[bool] write_accelerator_enabled: Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
               
               > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure_vm_disk_encryption_set_id is not None:
            pulumi.set(__self__, "secure_vm_disk_encryption_set_id", secure_vm_disk_encryption_set_id)
        if security_encryption_type is not None:
            pulumi.set(__self__, "security_encryption_type", security_encryption_type)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> pulumi.Input[str]:
        """
        The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: pulumi.Input[str]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> pulumi.Input[str]:
        """
        The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_type", value)

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional[pulumi.Input['WindowsVirtualMachineOsDiskDiffDiskSettingsArgs']]:
        """
        A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.

        > **NOTE:** `diff_disk_settings` can only be set when `caching` is set to `ReadOnly`. More information can be found [here](https://docs.microsoft.com/azure/virtual-machines/ephemeral-os-disks-deploy#vm-template-deployment)
        """
        return pulumi.get(self, "diff_disk_settings")

    @diff_disk_settings.setter
    def diff_disk_settings(self, value: Optional[pulumi.Input['WindowsVirtualMachineOsDiskDiffDiskSettingsArgs']]):
        pulumi.set(self, "diff_disk_settings", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`.

        > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.

        > **NOTE:** If specified this must be equal to or larger than the size of the Image the Virtual Machine is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secureVmDiskEncryptionSetId")
    def secure_vm_disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.

        > **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`.
        """
        return pulumi.get(self, "secure_vm_disk_encryption_set_id")

    @secure_vm_disk_encryption_set_id.setter
    def secure_vm_disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_vm_disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="securityEncryptionType")
    def security_encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.

        > **NOTE:** `vtpm_enabled` must be set to `true` when `security_encryption_type` is specified.

        > **NOTE:** `encryption_at_host_enabled` cannot be set to `true` when `security_encryption_type` is set to `DiskWithVMGuestState`.
        """
        return pulumi.get(self, "security_encryption_type")

    @security_encryption_type.setter
    def security_encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_encryption_type", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.

        > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class WindowsVirtualMachineOsDiskDiffDiskSettingsArgs:
    def __init__(__self__, *,
                 option: pulumi.Input[str],
                 placement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> pulumi.Input[str]:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: pulumi.Input[str]):
        pulumi.set(self, "option", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement", value)


@pulumi.input_type
class WindowsVirtualMachinePlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param pulumi.Input[str] product: Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
               
               > **NOTE:** If you use the `plan` block with one of Microsoft's marketplace images (e.g. `publisher = "MicrosoftWindowsServer"`). This may prevent the purchase of the offer. An example Azure API error: `The Offer: 'WindowsServer' cannot be purchased by subscription: '12345678-12234-5678-9012-123456789012' as it is not to be sold in market: 'US'. Please choose a subscription which is associated with a different market.`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.

        > **NOTE:** If you use the `plan` block with one of Microsoft's marketplace images (e.g. `publisher = "MicrosoftWindowsServer"`). This may prevent the purchase of the offer. An example Azure API error: `The Offer: 'WindowsServer' cannot be purchased by subscription: '12345678-12234-5678-9012-123456789012' as it is not to be sold in market: 'US'. Please choose a subscription which is associated with a different market.`
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetAdditionalCapabilitiesArgs:
    def __init__(__self__, *,
                 ultra_ssd_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] ultra_ssd_enabled: Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ultra_ssd_enabled")

    @ultra_ssd_enabled.setter
    def ultra_ssd_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ultra_ssd_enabled", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetAdditionalUnattendContentArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 setting: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
        :param pulumi.Input[str] setting: The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "setting", setting)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def setting(self) -> pulumi.Input[str]:
        """
        The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "setting")

    @setting.setter
    def setting(self, value: pulumi.Input[str]):
        pulumi.set(self, "setting", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetAutomaticInstanceRepairArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 grace_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
        :param pulumi.Input[str] grace_period: Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format. Defaults to `PT30M`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[str]]:
        """
        Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format. Defaults to `PT30M`.
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grace_period", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicyArgs:
    def __init__(__self__, *,
                 disable_automatic_rollback: pulumi.Input[bool],
                 enable_automatic_os_upgrade: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] disable_automatic_rollback: Should automatic rollbacks be disabled?
        :param pulumi.Input[bool] enable_automatic_os_upgrade: Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
        """
        pulumi.set(__self__, "disable_automatic_rollback", disable_automatic_rollback)
        pulumi.set(__self__, "enable_automatic_os_upgrade", enable_automatic_os_upgrade)

    @property
    @pulumi.getter(name="disableAutomaticRollback")
    def disable_automatic_rollback(self) -> pulumi.Input[bool]:
        """
        Should automatic rollbacks be disabled?
        """
        return pulumi.get(self, "disable_automatic_rollback")

    @disable_automatic_rollback.setter
    def disable_automatic_rollback(self, value: pulumi.Input[bool]):
        pulumi.set(self, "disable_automatic_rollback", value)

    @property
    @pulumi.getter(name="enableAutomaticOsUpgrade")
    def enable_automatic_os_upgrade(self) -> pulumi.Input[bool]:
        """
        Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
        """
        return pulumi.get(self, "enable_automatic_os_upgrade")

    @enable_automatic_os_upgrade.setter
    def enable_automatic_os_upgrade(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_automatic_os_upgrade", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetBootDiagnosticsArgs:
    def __init__(__self__, *,
                 storage_account_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_account_uri: The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
               
               > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics
        """
        if storage_account_uri is not None:
            pulumi.set(__self__, "storage_account_uri", storage_account_uri)

    @property
    @pulumi.getter(name="storageAccountUri")
    def storage_account_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.

        > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics
        """
        return pulumi.get(self, "storage_account_uri")

    @storage_account_uri.setter
    def storage_account_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_uri", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetDataDiskArgs:
    def __init__(__self__, *,
                 caching: pulumi.Input[str],
                 disk_size_gb: pulumi.Input[int],
                 lun: pulumi.Input[int],
                 storage_account_type: pulumi.Input[str],
                 create_option: Optional[pulumi.Input[str]] = None,
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ultra_ssd_disk_iops_read_write: Optional[pulumi.Input[int]] = None,
                 ultra_ssd_disk_mbps_read_write: Optional[pulumi.Input[int]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] caching: The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param pulumi.Input[int] disk_size_gb: The size of the Data Disk which should be created.
        :param pulumi.Input[int] lun: The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        :param pulumi.Input[str] storage_account_type: The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
               
               > **NOTE:** `UltraSSD_LRS` is only supported when `ultra_ssd_enabled` within the `additional_capabilities` block is enabled.
        :param pulumi.Input[str] create_option: The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.
               
               > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
               
               > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        :param pulumi.Input[str] name: The name of the Data Disk.
        :param pulumi.Input[int] ultra_ssd_disk_iops_read_write: Specifies the Read-Write IOPS for this Data Disk. Only settable when `storage_account_type` is `PremiumV2_LRS` or `UltraSSD_LRS`.
        :param pulumi.Input[int] ultra_ssd_disk_mbps_read_write: Specifies the bandwidth in MB per second for this Data Disk. Only settable when `storage_account_type` is `PremiumV2_LRS` or `UltraSSD_LRS`.
        :param pulumi.Input[bool] write_accelerator_enabled: Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
               
               > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if create_option is not None:
            pulumi.set(__self__, "create_option", create_option)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ultra_ssd_disk_iops_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_iops_read_write", ultra_ssd_disk_iops_read_write)
        if ultra_ssd_disk_mbps_read_write is not None:
            pulumi.set(__self__, "ultra_ssd_disk_mbps_read_write", ultra_ssd_disk_mbps_read_write)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> pulumi.Input[str]:
        """
        The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: pulumi.Input[str]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> pulumi.Input[int]:
        """
        The size of the Data Disk which should be created.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter
    def lun(self) -> pulumi.Input[int]:
        """
        The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
        """
        return pulumi.get(self, "lun")

    @lun.setter
    def lun(self, value: pulumi.Input[int]):
        pulumi.set(self, "lun", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> pulumi.Input[str]:
        """
        The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.

        > **NOTE:** `UltraSSD_LRS` is only supported when `ultra_ssd_enabled` within the `additional_capabilities` block is enabled.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_type", value)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> Optional[pulumi.Input[str]]:
        """
        The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
        """
        return pulumi.get(self, "create_option")

    @create_option.setter
    def create_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_option", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.

        > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault

        > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Data Disk.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ultraSsdDiskIopsReadWrite")
    def ultra_ssd_disk_iops_read_write(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the Read-Write IOPS for this Data Disk. Only settable when `storage_account_type` is `PremiumV2_LRS` or `UltraSSD_LRS`.
        """
        return pulumi.get(self, "ultra_ssd_disk_iops_read_write")

    @ultra_ssd_disk_iops_read_write.setter
    def ultra_ssd_disk_iops_read_write(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ultra_ssd_disk_iops_read_write", value)

    @property
    @pulumi.getter(name="ultraSsdDiskMbpsReadWrite")
    def ultra_ssd_disk_mbps_read_write(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the bandwidth in MB per second for this Data Disk. Only settable when `storage_account_type` is `PremiumV2_LRS` or `UltraSSD_LRS`.
        """
        return pulumi.get(self, "ultra_ssd_disk_mbps_read_write")

    @ultra_ssd_disk_mbps_read_write.setter
    def ultra_ssd_disk_mbps_read_write(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ultra_ssd_disk_mbps_read_write", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.

        > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetExtensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 type: pulumi.Input[str],
                 type_handler_version: pulumi.Input[str],
                 auto_upgrade_minor_version: Optional[pulumi.Input[bool]] = None,
                 automatic_upgrade_enabled: Optional[pulumi.Input[bool]] = None,
                 force_update_tag: Optional[pulumi.Input[str]] = None,
                 protected_settings: Optional[pulumi.Input[str]] = None,
                 protected_settings_from_key_vault: Optional[pulumi.Input['WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs']] = None,
                 provision_after_extensions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name for the Virtual Machine Scale Set Extension.
        :param pulumi.Input[str] publisher: Specifies the Publisher of the Extension.
        :param pulumi.Input[str] type: Specifies the Type of the Extension.
        :param pulumi.Input[str] type_handler_version: Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        :param pulumi.Input[bool] auto_upgrade_minor_version: Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        :param pulumi.Input[bool] automatic_upgrade_enabled: Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
        :param pulumi.Input[str] force_update_tag: A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        :param pulumi.Input[str] protected_settings: A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
               
               > **NOTE:** Keys within the `protected_settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] provision_after_extensions: An ordered list of Extension names which this should be provisioned after.
        :param pulumi.Input[str] settings: A JSON String which specifies Settings for the Extension.
               
               > **NOTE:** Keys within the `settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version", auto_upgrade_minor_version)
        if automatic_upgrade_enabled is not None:
            pulumi.set(__self__, "automatic_upgrade_enabled", automatic_upgrade_enabled)
        if force_update_tag is not None:
            pulumi.set(__self__, "force_update_tag", force_update_tag)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if protected_settings_from_key_vault is not None:
            pulumi.set(__self__, "protected_settings_from_key_vault", protected_settings_from_key_vault)
        if provision_after_extensions is not None:
            pulumi.set(__self__, "provision_after_extensions", provision_after_extensions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the Virtual Machine Scale Set Extension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the Publisher of the Extension.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the Type of the Extension.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        """
        return pulumi.get(self, "type_handler_version")

    @type_handler_version.setter
    def type_handler_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_handler_version", value)

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @auto_upgrade_minor_version.setter
    def auto_upgrade_minor_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_upgrade_minor_version", value)

    @property
    @pulumi.getter(name="automaticUpgradeEnabled")
    def automatic_upgrade_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
        """
        return pulumi.get(self, "automatic_upgrade_enabled")

    @automatic_upgrade_enabled.setter
    def automatic_upgrade_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_upgrade_enabled", value)

    @property
    @pulumi.getter(name="forceUpdateTag")
    def force_update_tag(self) -> Optional[pulumi.Input[str]]:
        """
        A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
        """
        return pulumi.get(self, "force_update_tag")

    @force_update_tag.setter
    def force_update_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "force_update_tag", value)

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.

        > **NOTE:** Keys within the `protected_settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        """
        return pulumi.get(self, "protected_settings")

    @protected_settings.setter
    def protected_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protected_settings", value)

    @property
    @pulumi.getter(name="protectedSettingsFromKeyVault")
    def protected_settings_from_key_vault(self) -> Optional[pulumi.Input['WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs']]:
        return pulumi.get(self, "protected_settings_from_key_vault")

    @protected_settings_from_key_vault.setter
    def protected_settings_from_key_vault(self, value: Optional[pulumi.Input['WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs']]):
        pulumi.set(self, "protected_settings_from_key_vault", value)

    @property
    @pulumi.getter(name="provisionAfterExtensions")
    def provision_after_extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An ordered list of Extension names which this should be provisioned after.
        """
        return pulumi.get(self, "provision_after_extensions")

    @provision_after_extensions.setter
    def provision_after_extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "provision_after_extensions", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON String which specifies Settings for the Extension.

        > **NOTE:** Keys within the `settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVaultArgs:
    def __init__(__self__, *,
                 secret_url: pulumi.Input[str],
                 source_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_url: The URL to the Key Vault Secret which stores the protected settings.
        :param pulumi.Input[str] source_vault_id: The ID of the source Key Vault.
        """
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault_id", source_vault_id)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> pulumi.Input[str]:
        """
        The URL to the Key Vault Secret which stores the protected settings.
        """
        return pulumi.get(self, "secret_url")

    @secret_url.setter
    def secret_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_url", value)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the source Key Vault.
        """
        return pulumi.get(self, "source_vault_id")

    @source_vault_id.setter
    def source_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault_id", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetGalleryApplicationArgs:
    def __init__(__self__, *,
                 package_reference_id: pulumi.Input[str],
                 configuration_reference_blob_uri: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] order: Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] tag: Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
        """
        if package_reference_id is not None:
            warnings.warn("""`package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0""", DeprecationWarning)
            pulumi.log.warn("""package_reference_id is deprecated: `package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0""")
        pulumi.set(__self__, "package_reference_id", package_reference_id)
        if configuration_reference_blob_uri is not None:
            warnings.warn("""`configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0""", DeprecationWarning)
            pulumi.log.warn("""configuration_reference_blob_uri is deprecated: `configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0""")
        if configuration_reference_blob_uri is not None:
            pulumi.set(__self__, "configuration_reference_blob_uri", configuration_reference_blob_uri)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="packageReferenceId")
    def package_reference_id(self) -> pulumi.Input[str]:
        warnings.warn("""`package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0""", DeprecationWarning)
        pulumi.log.warn("""package_reference_id is deprecated: `package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0""")

        return pulumi.get(self, "package_reference_id")

    @package_reference_id.setter
    def package_reference_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "package_reference_id", value)

    @property
    @pulumi.getter(name="configurationReferenceBlobUri")
    def configuration_reference_blob_uri(self) -> Optional[pulumi.Input[str]]:
        warnings.warn("""`configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0""", DeprecationWarning)
        pulumi.log.warn("""configuration_reference_blob_uri is deprecated: `configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0""")

        return pulumi.get(self, "configuration_reference_blob_uri")

    @configuration_reference_blob_uri.setter
    def configuration_reference_blob_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration_reference_blob_uri", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine Scale Set.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine Scale Set.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetNetworkInterfaceArgs:
    def __init__(__self__, *,
                 ip_configurations: pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]],
                 name: pulumi.Input[str],
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enable_accelerated_networking: Optional[pulumi.Input[bool]] = None,
                 enable_ip_forwarding: Optional[pulumi.Input[bool]] = None,
                 network_security_group_id: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]] ip_configurations: One or more `ip_configuration` blocks as defined above.
        :param pulumi.Input[str] name: The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        :param pulumi.Input[bool] enable_accelerated_networking: Does this Network Interface support Accelerated Networking? Defaults to `false`.
        :param pulumi.Input[bool] enable_ip_forwarding: Does this Network Interface support IP Forwarding? Defaults to `false`.
        :param pulumi.Input[str] network_security_group_id: The ID of a Network Security Group which should be assigned to this Network Interface.
        :param pulumi.Input[bool] primary: Is this the Primary IP Configuration?
               
               > **NOTE:** If multiple `network_interface` blocks are specified, one must be set to `primary`.
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if enable_accelerated_networking is not None:
            pulumi.set(__self__, "enable_accelerated_networking", enable_accelerated_networking)
        if enable_ip_forwarding is not None:
            pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]]:
        """
        One or more `ip_configuration` blocks as defined above.
        """
        return pulumi.get(self, "ip_configurations")

    @ip_configurations.setter
    def ip_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs']]]):
        pulumi.set(self, "ip_configurations", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="enableAcceleratedNetworking")
    def enable_accelerated_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Does this Network Interface support Accelerated Networking? Defaults to `false`.
        """
        return pulumi.get(self, "enable_accelerated_networking")

    @enable_accelerated_networking.setter
    def enable_accelerated_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_accelerated_networking", value)

    @property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[pulumi.Input[bool]]:
        """
        Does this Network Interface support IP Forwarding? Defaults to `false`.
        """
        return pulumi.get(self, "enable_ip_forwarding")

    @enable_ip_forwarding.setter
    def enable_ip_forwarding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ip_forwarding", value)

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Network Security Group which should be assigned to this Network Interface.
        """
        return pulumi.get(self, "network_security_group_id")

    @network_security_group_id.setter
    def network_security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_security_group_id", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this the Primary IP Configuration?

        > **NOTE:** If multiple `network_interface` blocks are specified, one must be set to `primary`.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 application_gateway_backend_address_pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 application_security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 load_balancer_backend_address_pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 load_balancer_inbound_nat_rules_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 public_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Name which should be used for this IP Configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] application_gateway_backend_address_pool_ids: A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] application_security_group_ids: A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_backend_address_pool_ids: A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
               
               > **NOTE:**  When the Virtual Machine Scale Set is configured to have public IPs per instance are created with a load balancer, the SKU of the Virtual Machine instance IPs is determined by the SKU of the Virtual Machine Scale Sets Load Balancer (e.g. `Basic` or `Standard`). Alternatively, you may use the `public_ip_prefix_id` field to generate instance-level IPs in a virtual machine scale set as well. The zonal properties of the prefix will be passed to the Virtual Machine instance IPs, though they will not be shown in the output. To view the public IP addresses assigned to the Virtual Machine Scale Sets Virtual Machine instances use the **az vmss list-instance-public-ips --resource-group `ResourceGroupName` --name `VirtualMachineScaleSetName`** CLI command.
               
               > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_inbound_nat_rules_ids: A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
               
               > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        :param pulumi.Input[bool] primary: Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
               
               > **NOTE:** One `ip_configuration` block must be marked as Primary for each Network Interface.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]] public_ip_addresses: A `public_ip_address` block as defined below.
        :param pulumi.Input[str] subnet_id: The ID of the Subnet which this IP Configuration should be connected to.
               
               > `subnet_id` is required if `version` is set to `IPv4`.
        :param pulumi.Input[str] version: The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        pulumi.set(__self__, "name", name)
        if application_gateway_backend_address_pool_ids is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if load_balancer_backend_address_pool_ids is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        if load_balancer_inbound_nat_rules_ids is not None:
            pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if public_ip_addresses is not None:
            pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name which should be used for this IP Configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @application_gateway_backend_address_pool_ids.setter
    def application_gateway_backend_address_pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "application_gateway_backend_address_pool_ids", value)

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
        """
        return pulumi.get(self, "application_security_group_ids")

    @application_security_group_ids.setter
    def application_security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "application_security_group_ids", value)

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.

        > **NOTE:**  When the Virtual Machine Scale Set is configured to have public IPs per instance are created with a load balancer, the SKU of the Virtual Machine instance IPs is determined by the SKU of the Virtual Machine Scale Sets Load Balancer (e.g. `Basic` or `Standard`). Alternatively, you may use the `public_ip_prefix_id` field to generate instance-level IPs in a virtual machine scale set as well. The zonal properties of the prefix will be passed to the Virtual Machine instance IPs, though they will not be shown in the output. To view the public IP addresses assigned to the Virtual Machine Scale Sets Virtual Machine instances use the **az vmss list-instance-public-ips --resource-group `ResourceGroupName` --name `VirtualMachineScaleSetName`** CLI command.

        > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @load_balancer_backend_address_pool_ids.setter
    def load_balancer_backend_address_pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_backend_address_pool_ids", value)

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.

        > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `depends_on` between this resource and the Load Balancer Rule.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @load_balancer_inbound_nat_rules_ids.setter
    def load_balancer_inbound_nat_rules_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_inbound_nat_rules_ids", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.

        > **NOTE:** One `ip_configuration` block must be marked as Primary for each Network Interface.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="publicIpAddresses")
    def public_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]]]:
        """
        A `public_ip_address` block as defined below.
        """
        return pulumi.get(self, "public_ip_addresses")

    @public_ip_addresses.setter
    def public_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs']]]]):
        pulumi.set(self, "public_ip_addresses", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Subnet which this IP Configuration should be connected to.

        > `subnet_id` is required if `version` is set to `IPv4`.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 domain_name_label: Optional[pulumi.Input[str]] = None,
                 idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 ip_tags: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]]] = None,
                 public_ip_prefix_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Name of the Public IP Address Configuration.
        :param pulumi.Input[str] domain_name_label: The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
        :param pulumi.Input[int] idle_timeout_in_minutes: The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]] ip_tags: One or more `ip_tag` blocks as defined above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] public_ip_prefix_id: The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
               
               > **NOTE:** This functionality is in Preview and must be opted into via `az feature register --namespace Microsoft.Network --name AllowBringYourOwnPublicIpAddress` and then `az provider register -n Microsoft.Network`.
        :param pulumi.Input[str] version: The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        if domain_name_label is not None:
            pulumi.set(__self__, "domain_name_label", domain_name_label)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if public_ip_prefix_id is not None:
            pulumi.set(__self__, "public_ip_prefix_id", public_ip_prefix_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The Name of the Public IP Address Configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> Optional[pulumi.Input[str]]:
        """
        The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
        """
        return pulumi.get(self, "domain_name_label")

    @domain_name_label.setter
    def domain_name_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name_label", value)

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @idle_timeout_in_minutes.setter
    def idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]]]:
        """
        One or more `ip_tag` blocks as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ip_tags")

    @ip_tags.setter
    def ip_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs']]]]):
        pulumi.set(self, "ip_tags", value)

    @property
    @pulumi.getter(name="publicIpPrefixId")
    def public_ip_prefix_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.

        > **NOTE:** This functionality is in Preview and must be opted into via `az feature register --namespace Microsoft.Network --name AllowBringYourOwnPublicIpAddress` and then `az provider register -n Microsoft.Network`.
        """
        return pulumi.get(self, "public_ip_prefix_id")

    @public_ip_prefix_id.setter
    def public_ip_prefix_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip_prefix_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTagArgs:
    def __init__(__self__, *,
                 tag: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] tag: The IP Tag associated with the Public IP, such as `SQL` or `Storage`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] type: The Type of IP Tag, such as `FirstPartyUsage`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        """
        The IP Tag associated with the Public IP, such as `SQL` or `Storage`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Type of IP Tag, such as `FirstPartyUsage`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetOsDiskArgs:
    def __init__(__self__, *,
                 caching: pulumi.Input[str],
                 storage_account_type: pulumi.Input[str],
                 diff_disk_settings: Optional[pulumi.Input['WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs']] = None,
                 disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 secure_vm_disk_encryption_set_id: Optional[pulumi.Input[str]] = None,
                 security_encryption_type: Optional[pulumi.Input[str]] = None,
                 write_accelerator_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] caching: The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        :param pulumi.Input[str] storage_account_type: The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        :param pulumi.Input['WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs'] diff_disk_settings: A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`. Changing this forces a new resource to be created.
               
               > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
               
               > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        :param pulumi.Input[int] disk_size_gb: The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
               
               > **NOTE:** If specified this must be equal to or larger than the size of the Image the VM Scale Set is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
        :param pulumi.Input[str] secure_vm_disk_encryption_set_id: The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.
               
               > **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`.
        :param pulumi.Input[str] security_encryption_type: Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
               
               > **NOTE:** `vtpm_enabled` must be set to `true` when `security_encryption_type` is specified.
               
               > **NOTE:** `encryption_at_host_enabled` cannot be set to `true` when `security_encryption_type` is set to `DiskWithVMGuestState`.
        :param pulumi.Input[bool] write_accelerator_enabled: Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
               
               > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        pulumi.set(__self__, "caching", caching)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if diff_disk_settings is not None:
            pulumi.set(__self__, "diff_disk_settings", diff_disk_settings)
        if disk_encryption_set_id is not None:
            pulumi.set(__self__, "disk_encryption_set_id", disk_encryption_set_id)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if secure_vm_disk_encryption_set_id is not None:
            pulumi.set(__self__, "secure_vm_disk_encryption_set_id", secure_vm_disk_encryption_set_id)
        if security_encryption_type is not None:
            pulumi.set(__self__, "security_encryption_type", security_encryption_type)
        if write_accelerator_enabled is not None:
            pulumi.set(__self__, "write_accelerator_enabled", write_accelerator_enabled)

    @property
    @pulumi.getter
    def caching(self) -> pulumi.Input[str]:
        """
        The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: pulumi.Input[str]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> pulumi.Input[str]:
        """
        The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_type", value)

    @property
    @pulumi.getter(name="diffDiskSettings")
    def diff_disk_settings(self) -> Optional[pulumi.Input['WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs']]:
        """
        A `diff_disk_settings` block as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "diff_disk_settings")

    @diff_disk_settings.setter
    def diff_disk_settings(self, value: Optional[pulumi.Input['WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs']]):
        pulumi.set(self, "diff_disk_settings", value)

    @property
    @pulumi.getter(name="diskEncryptionSetId")
    def disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secure_vm_disk_encryption_set_id`. Changing this forces a new resource to be created.

        > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault

        > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
        """
        return pulumi.get(self, "disk_encryption_set_id")

    @disk_encryption_set_id.setter
    def disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.

        > **NOTE:** If specified this must be equal to or larger than the size of the Image the VM Scale Set is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="secureVmDiskEncryptionSetId")
    def secure_vm_disk_encryption_set_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `disk_encryption_set_id`. Changing this forces a new resource to be created.

        > **NOTE:** `secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`.
        """
        return pulumi.get(self, "secure_vm_disk_encryption_set_id")

    @secure_vm_disk_encryption_set_id.setter
    def secure_vm_disk_encryption_set_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_vm_disk_encryption_set_id", value)

    @property
    @pulumi.getter(name="securityEncryptionType")
    def security_encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.

        > **NOTE:** `vtpm_enabled` must be set to `true` when `security_encryption_type` is specified.

        > **NOTE:** `encryption_at_host_enabled` cannot be set to `true` when `security_encryption_type` is set to `DiskWithVMGuestState`.
        """
        return pulumi.get(self, "security_encryption_type")

    @security_encryption_type.setter
    def security_encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_encryption_type", value)

    @property
    @pulumi.getter(name="writeAcceleratorEnabled")
    def write_accelerator_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.

        > **NOTE:** This requires that the `storage_account_type` is set to `Premium_LRS` and that `caching` is set to `None`.
        """
        return pulumi.get(self, "write_accelerator_enabled")

    @write_accelerator_enabled.setter
    def write_accelerator_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_accelerator_enabled", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetOsDiskDiffDiskSettingsArgs:
    def __init__(__self__, *,
                 option: pulumi.Input[str],
                 placement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] option: Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] placement: Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "option", option)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def option(self) -> pulumi.Input[str]:
        """
        Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: pulumi.Input[str]):
        pulumi.set(self, "option", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetPlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        :param pulumi.Input[str] product: Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetRollingUpgradePolicyArgs:
    def __init__(__self__, *,
                 max_batch_instance_percent: pulumi.Input[int],
                 max_unhealthy_instance_percent: pulumi.Input[int],
                 max_unhealthy_upgraded_instance_percent: pulumi.Input[int],
                 pause_time_between_batches: pulumi.Input[str],
                 cross_zone_upgrades_enabled: Optional[pulumi.Input[bool]] = None,
                 prioritize_unhealthy_instances_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] max_batch_instance_percent: The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
        :param pulumi.Input[int] max_unhealthy_instance_percent: The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
        :param pulumi.Input[int] max_unhealthy_upgraded_instance_percent: The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
        :param pulumi.Input[str] pause_time_between_batches: The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
        :param pulumi.Input[bool] cross_zone_upgrades_enabled: Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`.
        :param pulumi.Input[bool] prioritize_unhealthy_instances_enabled: Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`.
        """
        pulumi.set(__self__, "max_batch_instance_percent", max_batch_instance_percent)
        pulumi.set(__self__, "max_unhealthy_instance_percent", max_unhealthy_instance_percent)
        pulumi.set(__self__, "max_unhealthy_upgraded_instance_percent", max_unhealthy_upgraded_instance_percent)
        pulumi.set(__self__, "pause_time_between_batches", pause_time_between_batches)
        if cross_zone_upgrades_enabled is not None:
            pulumi.set(__self__, "cross_zone_upgrades_enabled", cross_zone_upgrades_enabled)
        if prioritize_unhealthy_instances_enabled is not None:
            pulumi.set(__self__, "prioritize_unhealthy_instances_enabled", prioritize_unhealthy_instances_enabled)

    @property
    @pulumi.getter(name="maxBatchInstancePercent")
    def max_batch_instance_percent(self) -> pulumi.Input[int]:
        """
        The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
        """
        return pulumi.get(self, "max_batch_instance_percent")

    @max_batch_instance_percent.setter
    def max_batch_instance_percent(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_batch_instance_percent", value)

    @property
    @pulumi.getter(name="maxUnhealthyInstancePercent")
    def max_unhealthy_instance_percent(self) -> pulumi.Input[int]:
        """
        The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
        """
        return pulumi.get(self, "max_unhealthy_instance_percent")

    @max_unhealthy_instance_percent.setter
    def max_unhealthy_instance_percent(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_unhealthy_instance_percent", value)

    @property
    @pulumi.getter(name="maxUnhealthyUpgradedInstancePercent")
    def max_unhealthy_upgraded_instance_percent(self) -> pulumi.Input[int]:
        """
        The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
        """
        return pulumi.get(self, "max_unhealthy_upgraded_instance_percent")

    @max_unhealthy_upgraded_instance_percent.setter
    def max_unhealthy_upgraded_instance_percent(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_unhealthy_upgraded_instance_percent", value)

    @property
    @pulumi.getter(name="pauseTimeBetweenBatches")
    def pause_time_between_batches(self) -> pulumi.Input[str]:
        """
        The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
        """
        return pulumi.get(self, "pause_time_between_batches")

    @pause_time_between_batches.setter
    def pause_time_between_batches(self, value: pulumi.Input[str]):
        pulumi.set(self, "pause_time_between_batches", value)

    @property
    @pulumi.getter(name="crossZoneUpgradesEnabled")
    def cross_zone_upgrades_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`.
        """
        return pulumi.get(self, "cross_zone_upgrades_enabled")

    @cross_zone_upgrades_enabled.setter
    def cross_zone_upgrades_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cross_zone_upgrades_enabled", value)

    @property
    @pulumi.getter(name="prioritizeUnhealthyInstancesEnabled")
    def prioritize_unhealthy_instances_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`.
        """
        return pulumi.get(self, "prioritize_unhealthy_instances_enabled")

    @prioritize_unhealthy_instances_enabled.setter
    def prioritize_unhealthy_instances_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prioritize_unhealthy_instances_enabled", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetScaleInArgs:
    def __init__(__self__, *,
                 force_deletion_enabled: Optional[pulumi.Input[bool]] = None,
                 rule: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] force_deletion_enabled: Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
        :param pulumi.Input[str] rule: The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
        """
        if force_deletion_enabled is not None:
            pulumi.set(__self__, "force_deletion_enabled", force_deletion_enabled)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter(name="forceDeletionEnabled")
    def force_deletion_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
        """
        return pulumi.get(self, "force_deletion_enabled")

    @force_deletion_enabled.setter
    def force_deletion_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_deletion_enabled", value)

    @property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input[str]]:
        """
        The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetSecretArgs:
    def __init__(__self__, *,
                 certificates: pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetSecretCertificateArgs']]],
                 key_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetSecretCertificateArgs']]] certificates: One or more `certificate` blocks as defined above.
        :param pulumi.Input[str] key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetSecretCertificateArgs']]]:
        """
        One or more `certificate` blocks as defined above.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineScaleSetSecretCertificateArgs']]]):
        pulumi.set(self, "certificates", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetSecretCertificateArgs:
    def __init__(__self__, *,
                 store: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] store: The certificate store on the Virtual Machine where the certificate should be added.
        :param pulumi.Input[str] url: The Secret URL of a Key Vault Certificate.
               
               > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        pulumi.set(__self__, "store", store)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def store(self) -> pulumi.Input[str]:
        """
        The certificate store on the Virtual Machine where the certificate should be added.
        """
        return pulumi.get(self, "store")

    @store.setter
    def store(self, value: pulumi.Input[str]):
        pulumi.set(self, "store", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Secret URL of a Key Vault Certificate.

        > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetSourceImageReferenceArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] offer: Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sku: Specifies the SKU of the image used to create the virtual machines.
        :param pulumi.Input[str] version: Specifies the version of the image used to create the virtual machines.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        """
        Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetSpotRestoreArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] timeout: The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetTerminateNotificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the terminate notification be enabled on this Virtual Machine Scale Set?
        :param pulumi.Input[str] timeout: Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
               
               > For more information about the terminate notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the terminate notification be enabled on this Virtual Machine Scale Set?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.

        > For more information about the terminate notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetTerminationNotificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the termination notification be enabled on this Virtual Machine Scale Set?
        :param pulumi.Input[str] timeout: Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
               
               > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the termination notification be enabled on this Virtual Machine Scale Set?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.

        > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class WindowsVirtualMachineScaleSetWinrmListenerArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 certificate_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: The Protocol of the WinRM Listener. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] certificate_url: The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.
               
               > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The Protocol of the WinRM Listener. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.

        > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_url", value)


@pulumi.input_type
class WindowsVirtualMachineSecretArgs:
    def __init__(__self__, *,
                 certificates: pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineSecretCertificateArgs']]],
                 key_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineSecretCertificateArgs']]] certificates: One or more `certificate` blocks as defined above.
        :param pulumi.Input[str] key_vault_id: The ID of the Key Vault from which all Secrets should be sourced.
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter
    def certificates(self) -> pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineSecretCertificateArgs']]]:
        """
        One or more `certificate` blocks as defined above.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: pulumi.Input[Sequence[pulumi.Input['WindowsVirtualMachineSecretCertificateArgs']]]):
        pulumi.set(self, "certificates", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault from which all Secrets should be sourced.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)


@pulumi.input_type
class WindowsVirtualMachineSecretCertificateArgs:
    def __init__(__self__, *,
                 store: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] store: The certificate store on the Virtual Machine where the certificate should be added.
        :param pulumi.Input[str] url: The Secret URL of a Key Vault Certificate.
               
               > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        pulumi.set(__self__, "store", store)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def store(self) -> pulumi.Input[str]:
        """
        The certificate store on the Virtual Machine where the certificate should be added.
        """
        return pulumi.get(self, "store")

    @store.setter
    def store(self, value: pulumi.Input[str]):
        pulumi.set(self, "store", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The Secret URL of a Key Vault Certificate.

        > **NOTE:** This can be sourced from the `secret_id` field within the `keyvault.Certificate` Resource.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WindowsVirtualMachineSourceImageReferenceArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] offer: Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sku: Specifies the SKU of the image used to create the virtual machines. Changing this forces a new resource to be created.
        :param pulumi.Input[str] version: Specifies the version of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        """
        Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        """
        Specifies the SKU of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the image used to create the virtual machines. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class WindowsVirtualMachineTerminationNotificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the termination notification be enabled on this Virtual Machine?
        :param pulumi.Input[str] timeout: Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
               
               > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the termination notification be enabled on this Virtual Machine?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.

        > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class WindowsVirtualMachineWinrmListenerArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 certificate_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: Specifies the protocol of listener. Possible values are `Http` or `Https`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] certificate_url: The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        Specifies the protocol of listener. Possible values are `Http` or `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_url", value)


