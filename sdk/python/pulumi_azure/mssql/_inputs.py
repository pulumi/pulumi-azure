# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'DatabaseImportArgs',
    'DatabaseLongTermRetentionPolicyArgs',
    'DatabaseShortTermRetentionPolicyArgs',
    'DatabaseThreatDetectionPolicyArgs',
    'DatabaseVulnerabilityAssessmentRuleBaselineBaselineResultArgs',
    'ElasticPoolPerDatabaseSettingsArgs',
    'ElasticPoolSkuArgs',
    'FailoverGroupPartnerServerArgs',
    'FailoverGroupReadWriteEndpointFailoverPolicyArgs',
    'ManagedDatabaseLongTermRetentionPolicyArgs',
    'ManagedInstanceFailoverGroupPartnerRegionArgs',
    'ManagedInstanceFailoverGroupReadWriteEndpointFailoverPolicyArgs',
    'ManagedInstanceIdentityArgs',
    'ManagedInstanceVulnerabilityAssessmentRecurringScansArgs',
    'ServerAzureadAdministratorArgs',
    'ServerIdentityArgs',
    'ServerVulnerabilityAssessmentRecurringScansArgs',
    'VirtualMachineAssessmentArgs',
    'VirtualMachineAssessmentScheduleArgs',
    'VirtualMachineAutoBackupArgs',
    'VirtualMachineAutoBackupManualScheduleArgs',
    'VirtualMachineAutoPatchingArgs',
    'VirtualMachineAvailabilityGroupListenerLoadBalancerConfigurationArgs',
    'VirtualMachineAvailabilityGroupListenerMultiSubnetIpConfigurationArgs',
    'VirtualMachineAvailabilityGroupListenerReplicaArgs',
    'VirtualMachineGroupWsfcDomainProfileArgs',
    'VirtualMachineKeyVaultCredentialArgs',
    'VirtualMachineSqlInstanceArgs',
    'VirtualMachineStorageConfigurationArgs',
    'VirtualMachineStorageConfigurationDataSettingsArgs',
    'VirtualMachineStorageConfigurationLogSettingsArgs',
    'VirtualMachineStorageConfigurationTempDbSettingsArgs',
    'VirtualMachineWsfcDomainCredentialArgs',
]

@pulumi.input_type
class DatabaseImportArgs:
    def __init__(__self__, *,
                 administrator_login: pulumi.Input[str],
                 administrator_login_password: pulumi.Input[str],
                 authentication_type: pulumi.Input[str],
                 storage_key: pulumi.Input[str],
                 storage_key_type: pulumi.Input[str],
                 storage_uri: pulumi.Input[str],
                 storage_account_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] administrator_login: Specifies the name of the SQL administrator.
        :param pulumi.Input[str] administrator_login_password: Specifies the password of the SQL administrator.
        :param pulumi.Input[str] authentication_type: Specifies the type of authentication used to access the server. Valid values are `SQL` or `ADPassword`.
        :param pulumi.Input[str] storage_key: Specifies the access key for the storage account.
        :param pulumi.Input[str] storage_key_type: Specifies the type of access key for the storage account. Valid values are `StorageAccessKey` or `SharedAccessKey`.
        :param pulumi.Input[str] storage_uri: Specifies the blob URI of the .bacpac file.
        :param pulumi.Input[str] storage_account_id: The resource id for the storage account used to store BACPAC file. If set, private endpoint connection will be created for the storage account. Must match storage account used for storage_uri parameter.
        """
        pulumi.set(__self__, "administrator_login", administrator_login)
        pulumi.set(__self__, "administrator_login_password", administrator_login_password)
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "storage_key", storage_key)
        pulumi.set(__self__, "storage_key_type", storage_key_type)
        pulumi.set(__self__, "storage_uri", storage_uri)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)

    @property
    @pulumi.getter(name="administratorLogin")
    def administrator_login(self) -> pulumi.Input[str]:
        """
        Specifies the name of the SQL administrator.
        """
        return pulumi.get(self, "administrator_login")

    @administrator_login.setter
    def administrator_login(self, value: pulumi.Input[str]):
        pulumi.set(self, "administrator_login", value)

    @property
    @pulumi.getter(name="administratorLoginPassword")
    def administrator_login_password(self) -> pulumi.Input[str]:
        """
        Specifies the password of the SQL administrator.
        """
        return pulumi.get(self, "administrator_login_password")

    @administrator_login_password.setter
    def administrator_login_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "administrator_login_password", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[str]:
        """
        Specifies the type of authentication used to access the server. Valid values are `SQL` or `ADPassword`.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="storageKey")
    def storage_key(self) -> pulumi.Input[str]:
        """
        Specifies the access key for the storage account.
        """
        return pulumi.get(self, "storage_key")

    @storage_key.setter
    def storage_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_key", value)

    @property
    @pulumi.getter(name="storageKeyType")
    def storage_key_type(self) -> pulumi.Input[str]:
        """
        Specifies the type of access key for the storage account. Valid values are `StorageAccessKey` or `SharedAccessKey`.
        """
        return pulumi.get(self, "storage_key_type")

    @storage_key_type.setter
    def storage_key_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_key_type", value)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> pulumi.Input[str]:
        """
        Specifies the blob URI of the .bacpac file.
        """
        return pulumi.get(self, "storage_uri")

    @storage_uri.setter
    def storage_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_uri", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource id for the storage account used to store BACPAC file. If set, private endpoint connection will be created for the storage account. Must match storage account used for storage_uri parameter.
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_id", value)


@pulumi.input_type
class DatabaseLongTermRetentionPolicyArgs:
    def __init__(__self__, *,
                 monthly_retention: Optional[pulumi.Input[str]] = None,
                 week_of_year: Optional[pulumi.Input[int]] = None,
                 weekly_retention: Optional[pulumi.Input[str]] = None,
                 yearly_retention: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] monthly_retention: The monthly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 120 months. e.g. `P1Y`, `P1M`, `P4W` or `P30D`.
        :param pulumi.Input[int] week_of_year: The week of year to take the yearly backup. Value has to be between `1` and `52`.
        :param pulumi.Input[str] weekly_retention: The weekly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 520 weeks. e.g. `P1Y`, `P1M`, `P1W` or `P7D`.
        :param pulumi.Input[str] yearly_retention: The yearly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 10 years. e.g. `P1Y`, `P12M`, `P52W` or `P365D`.
        """
        if monthly_retention is not None:
            pulumi.set(__self__, "monthly_retention", monthly_retention)
        if week_of_year is not None:
            pulumi.set(__self__, "week_of_year", week_of_year)
        if weekly_retention is not None:
            pulumi.set(__self__, "weekly_retention", weekly_retention)
        if yearly_retention is not None:
            pulumi.set(__self__, "yearly_retention", yearly_retention)

    @property
    @pulumi.getter(name="monthlyRetention")
    def monthly_retention(self) -> Optional[pulumi.Input[str]]:
        """
        The monthly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 120 months. e.g. `P1Y`, `P1M`, `P4W` or `P30D`.
        """
        return pulumi.get(self, "monthly_retention")

    @monthly_retention.setter
    def monthly_retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monthly_retention", value)

    @property
    @pulumi.getter(name="weekOfYear")
    def week_of_year(self) -> Optional[pulumi.Input[int]]:
        """
        The week of year to take the yearly backup. Value has to be between `1` and `52`.
        """
        return pulumi.get(self, "week_of_year")

    @week_of_year.setter
    def week_of_year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "week_of_year", value)

    @property
    @pulumi.getter(name="weeklyRetention")
    def weekly_retention(self) -> Optional[pulumi.Input[str]]:
        """
        The weekly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 520 weeks. e.g. `P1Y`, `P1M`, `P1W` or `P7D`.
        """
        return pulumi.get(self, "weekly_retention")

    @weekly_retention.setter
    def weekly_retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "weekly_retention", value)

    @property
    @pulumi.getter(name="yearlyRetention")
    def yearly_retention(self) -> Optional[pulumi.Input[str]]:
        """
        The yearly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 10 years. e.g. `P1Y`, `P12M`, `P52W` or `P365D`.
        """
        return pulumi.get(self, "yearly_retention")

    @yearly_retention.setter
    def yearly_retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "yearly_retention", value)


@pulumi.input_type
class DatabaseShortTermRetentionPolicyArgs:
    def __init__(__self__, *,
                 retention_days: pulumi.Input[int],
                 backup_interval_in_hours: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] retention_days: Point In Time Restore configuration. Value has to be between `7` and `35`.
        :param pulumi.Input[int] backup_interval_in_hours: The hours between each differential backup. This is only applicable to live databases but not dropped databases. Value has to be `12` or `24`. Defaults to `12` hours.
        """
        pulumi.set(__self__, "retention_days", retention_days)
        if backup_interval_in_hours is not None:
            pulumi.set(__self__, "backup_interval_in_hours", backup_interval_in_hours)

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> pulumi.Input[int]:
        """
        Point In Time Restore configuration. Value has to be between `7` and `35`.
        """
        return pulumi.get(self, "retention_days")

    @retention_days.setter
    def retention_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_days", value)

    @property
    @pulumi.getter(name="backupIntervalInHours")
    def backup_interval_in_hours(self) -> Optional[pulumi.Input[int]]:
        """
        The hours between each differential backup. This is only applicable to live databases but not dropped databases. Value has to be `12` or `24`. Defaults to `12` hours.
        """
        return pulumi.get(self, "backup_interval_in_hours")

    @backup_interval_in_hours.setter
    def backup_interval_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_interval_in_hours", value)


@pulumi.input_type
class DatabaseThreatDetectionPolicyArgs:
    def __init__(__self__, *,
                 disabled_alerts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_account_admins: Optional[pulumi.Input[str]] = None,
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 retention_days: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 storage_account_access_key: Optional[pulumi.Input[str]] = None,
                 storage_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] disabled_alerts: Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
        :param pulumi.Input[str] email_account_admins: Should the account administrators be emailed when this alert is triggered? Possible values are `Disabled` and `Enabled`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_addresses: A list of email addresses which alerts should be sent to.
        :param pulumi.Input[int] retention_days: Specifies the number of days to keep in the Threat Detection audit logs.
        :param pulumi.Input[str] state: The State of the Policy. Possible values are `Enabled`, `Disabled` or `New`.
        :param pulumi.Input[str] storage_account_access_key: Specifies the identifier key of the Threat Detection audit storage account. Required if `state` is `Enabled`.
        :param pulumi.Input[str] storage_endpoint: Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs. Required if `state` is `Enabled`.
        """
        if disabled_alerts is not None:
            pulumi.set(__self__, "disabled_alerts", disabled_alerts)
        if email_account_admins is not None:
            pulumi.set(__self__, "email_account_admins", email_account_admins)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if storage_account_access_key is not None:
            pulumi.set(__self__, "storage_account_access_key", storage_account_access_key)
        if storage_endpoint is not None:
            pulumi.set(__self__, "storage_endpoint", storage_endpoint)

    @property
    @pulumi.getter(name="disabledAlerts")
    def disabled_alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
        """
        return pulumi.get(self, "disabled_alerts")

    @disabled_alerts.setter
    def disabled_alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "disabled_alerts", value)

    @property
    @pulumi.getter(name="emailAccountAdmins")
    def email_account_admins(self) -> Optional[pulumi.Input[str]]:
        """
        Should the account administrators be emailed when this alert is triggered? Possible values are `Disabled` and `Enabled`.
        """
        return pulumi.get(self, "email_account_admins")

    @email_account_admins.setter
    def email_account_admins(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_account_admins", value)

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of email addresses which alerts should be sent to.
        """
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_addresses", value)

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days to keep in the Threat Detection audit logs.
        """
        return pulumi.get(self, "retention_days")

    @retention_days.setter
    def retention_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_days", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The State of the Policy. Possible values are `Enabled`, `Disabled` or `New`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="storageAccountAccessKey")
    def storage_account_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the identifier key of the Threat Detection audit storage account. Required if `state` is `Enabled`.
        """
        return pulumi.get(self, "storage_account_access_key")

    @storage_account_access_key.setter
    def storage_account_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_access_key", value)

    @property
    @pulumi.getter(name="storageEndpoint")
    def storage_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs. Required if `state` is `Enabled`.
        """
        return pulumi.get(self, "storage_endpoint")

    @storage_endpoint.setter
    def storage_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_endpoint", value)


@pulumi.input_type
class DatabaseVulnerabilityAssessmentRuleBaselineBaselineResultArgs:
    def __init__(__self__, *,
                 results: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] results: A list representing a result of the baseline.
        """
        pulumi.set(__self__, "results", results)

    @property
    @pulumi.getter
    def results(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list representing a result of the baseline.
        """
        return pulumi.get(self, "results")

    @results.setter
    def results(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "results", value)


@pulumi.input_type
class ElasticPoolPerDatabaseSettingsArgs:
    def __init__(__self__, *,
                 max_capacity: pulumi.Input[float],
                 min_capacity: pulumi.Input[float]):
        """
        :param pulumi.Input[float] max_capacity: The maximum capacity any one database can consume.
        :param pulumi.Input[float] min_capacity: The minimum capacity all databases are guaranteed.
        """
        pulumi.set(__self__, "max_capacity", max_capacity)
        pulumi.set(__self__, "min_capacity", min_capacity)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> pulumi.Input[float]:
        """
        The maximum capacity any one database can consume.
        """
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: pulumi.Input[float]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> pulumi.Input[float]:
        """
        The minimum capacity all databases are guaranteed.
        """
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: pulumi.Input[float]):
        pulumi.set(self, "min_capacity", value)


@pulumi.input_type
class ElasticPoolSkuArgs:
    def __init__(__self__, *,
                 capacity: pulumi.Input[int],
                 name: pulumi.Input[str],
                 tier: pulumi.Input[str],
                 family: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] capacity: The scale up/out capacity, representing server's compute units. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
        :param pulumi.Input[str] name: Specifies the SKU Name for this Elasticpool. The name of the SKU, will be either `vCore` based `tier` + `family` pattern (e.g. GP_Gen4, BC_Gen5) or the `DTU` based `BasicPool`, `StandardPool`, or `PremiumPool` pattern. Possible values are `BasicPool`, `StandardPool`, `PremiumPool`, `GP_Gen4`, `GP_Gen5`, `GP_Fsv2`, `GP_DC`, `BC_Gen4`, `BC_Gen5`, `BC_DC`, or `HS_Gen5`.
        :param pulumi.Input[str] tier: The tier of the particular SKU. Possible values are `GeneralPurpose`, `BusinessCritical`, `Basic`, `Standard`, `Premium`, or `HyperScale`. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
        :param pulumi.Input[str] family: The `family` of hardware `Gen4`, `Gen5`, `Fsv2` or `DC`.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tier", tier)
        if family is not None:
            pulumi.set(__self__, "family", family)

    @property
    @pulumi.getter
    def capacity(self) -> pulumi.Input[int]:
        """
        The scale up/out capacity, representing server's compute units. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the SKU Name for this Elasticpool. The name of the SKU, will be either `vCore` based `tier` + `family` pattern (e.g. GP_Gen4, BC_Gen5) or the `DTU` based `BasicPool`, `StandardPool`, or `PremiumPool` pattern. Possible values are `BasicPool`, `StandardPool`, `PremiumPool`, `GP_Gen4`, `GP_Gen5`, `GP_Fsv2`, `GP_DC`, `BC_Gen4`, `BC_Gen5`, `BC_DC`, or `HS_Gen5`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tier(self) -> pulumi.Input[str]:
        """
        The tier of the particular SKU. Possible values are `GeneralPurpose`, `BusinessCritical`, `Basic`, `Standard`, `Premium`, or `HyperScale`. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: pulumi.Input[str]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        The `family` of hardware `Gen4`, `Gen5`, `Fsv2` or `DC`.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)


@pulumi.input_type
class FailoverGroupPartnerServerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 location: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of a partner SQL server to include in the failover group.
        :param pulumi.Input[str] location: The location of the partner server.
        :param pulumi.Input[str] role: The replication role of the partner server. Possible values include `Primary` or `Secondary`.
        """
        pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a partner SQL server to include in the failover group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The location of the partner server.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        The replication role of the partner server. Possible values include `Primary` or `Secondary`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


@pulumi.input_type
class FailoverGroupReadWriteEndpointFailoverPolicyArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 grace_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: The failover policy of the read-write endpoint for the failover group. Possible values are `Automatic` or `Manual`.
        :param pulumi.Input[int] grace_minutes: The grace period in minutes, before failover with data loss is attempted for the read-write endpoint. Required when `mode` is `Automatic`.
        """
        pulumi.set(__self__, "mode", mode)
        if grace_minutes is not None:
            pulumi.set(__self__, "grace_minutes", grace_minutes)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        The failover policy of the read-write endpoint for the failover group. Possible values are `Automatic` or `Manual`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="graceMinutes")
    def grace_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period in minutes, before failover with data loss is attempted for the read-write endpoint. Required when `mode` is `Automatic`.
        """
        return pulumi.get(self, "grace_minutes")

    @grace_minutes.setter
    def grace_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_minutes", value)


@pulumi.input_type
class ManagedDatabaseLongTermRetentionPolicyArgs:
    def __init__(__self__, *,
                 monthly_retention: Optional[pulumi.Input[str]] = None,
                 week_of_year: Optional[pulumi.Input[int]] = None,
                 weekly_retention: Optional[pulumi.Input[str]] = None,
                 yearly_retention: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] monthly_retention: The monthly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 120 months. e.g. `P1Y`, `P1M`, `P4W` or `P30D`.
        :param pulumi.Input[int] week_of_year: The week of year to take the yearly backup. Value has to be between `1` and `52`.
        :param pulumi.Input[str] weekly_retention: The weekly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 520 weeks. e.g. `P1Y`, `P1M`, `P1W` or `P7D`.
        :param pulumi.Input[str] yearly_retention: The yearly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 10 years. e.g. `P1Y`, `P12M`, `P52W` or `P365D`.
        """
        if monthly_retention is not None:
            pulumi.set(__self__, "monthly_retention", monthly_retention)
        if week_of_year is not None:
            pulumi.set(__self__, "week_of_year", week_of_year)
        if weekly_retention is not None:
            pulumi.set(__self__, "weekly_retention", weekly_retention)
        if yearly_retention is not None:
            pulumi.set(__self__, "yearly_retention", yearly_retention)

    @property
    @pulumi.getter(name="monthlyRetention")
    def monthly_retention(self) -> Optional[pulumi.Input[str]]:
        """
        The monthly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 120 months. e.g. `P1Y`, `P1M`, `P4W` or `P30D`.
        """
        return pulumi.get(self, "monthly_retention")

    @monthly_retention.setter
    def monthly_retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monthly_retention", value)

    @property
    @pulumi.getter(name="weekOfYear")
    def week_of_year(self) -> Optional[pulumi.Input[int]]:
        """
        The week of year to take the yearly backup. Value has to be between `1` and `52`.
        """
        return pulumi.get(self, "week_of_year")

    @week_of_year.setter
    def week_of_year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "week_of_year", value)

    @property
    @pulumi.getter(name="weeklyRetention")
    def weekly_retention(self) -> Optional[pulumi.Input[str]]:
        """
        The weekly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 520 weeks. e.g. `P1Y`, `P1M`, `P1W` or `P7D`.
        """
        return pulumi.get(self, "weekly_retention")

    @weekly_retention.setter
    def weekly_retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "weekly_retention", value)

    @property
    @pulumi.getter(name="yearlyRetention")
    def yearly_retention(self) -> Optional[pulumi.Input[str]]:
        """
        The yearly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 10 years. e.g. `P1Y`, `P12M`, `P52W` or `P365D`.
        """
        return pulumi.get(self, "yearly_retention")

    @yearly_retention.setter
    def yearly_retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "yearly_retention", value)


@pulumi.input_type
class ManagedInstanceFailoverGroupPartnerRegionArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] location: The Azure Region where the Managed Instance Failover Group should exist. Changing this forces a new resource to be created.
        :param pulumi.Input[str] role: The partner replication role of the Managed Instance Failover Group.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Region where the Managed Instance Failover Group should exist. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        The partner replication role of the Managed Instance Failover Group.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


@pulumi.input_type
class ManagedInstanceFailoverGroupReadWriteEndpointFailoverPolicyArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 grace_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: The failover mode. Possible values are `Automatic` or `Manual`.
        :param pulumi.Input[int] grace_minutes: Applies only if `mode` is `Automatic`. The grace period in minutes before failover with data loss is attempted.
        """
        pulumi.set(__self__, "mode", mode)
        if grace_minutes is not None:
            pulumi.set(__self__, "grace_minutes", grace_minutes)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        The failover mode. Possible values are `Automatic` or `Manual`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="graceMinutes")
    def grace_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Applies only if `mode` is `Automatic`. The grace period in minutes before failover with data loss is attempted.
        """
        return pulumi.get(self, "grace_minutes")

    @grace_minutes.setter
    def grace_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_minutes", value)


@pulumi.input_type
class ManagedInstanceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this SQL Managed Instance. Possible values are `SystemAssigned`, `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this SQL Managed Instance. Required when `type` is set to `UserAssigned`.
               
               > The assigned `principal_id` and `tenant_id` can be retrieved after the identity `type` has been set to `SystemAssigned` and SQL Managed Instance has been created.
        :param pulumi.Input[str] principal_id: The Principal ID for the Service Principal associated with the Identity of this SQL Managed Instance.
        :param pulumi.Input[str] tenant_id: The Tenant ID for the Service Principal associated with the Identity of this SQL Managed Instance.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this SQL Managed Instance. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this SQL Managed Instance. Required when `type` is set to `UserAssigned`.

        > The assigned `principal_id` and `tenant_id` can be retrieved after the identity `type` has been set to `SystemAssigned` and SQL Managed Instance has been created.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID for the Service Principal associated with the Identity of this SQL Managed Instance.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID for the Service Principal associated with the Identity of this SQL Managed Instance.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class ManagedInstanceVulnerabilityAssessmentRecurringScansArgs:
    def __init__(__self__, *,
                 email_subscription_admins: Optional[pulumi.Input[bool]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] email_subscription_admins: Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: Specifies an array of e-mail addresses to which the scan notification is sent.
        :param pulumi.Input[bool] enabled: Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
        """
        if email_subscription_admins is not None:
            pulumi.set(__self__, "email_subscription_admins", email_subscription_admins)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="emailSubscriptionAdmins")
    def email_subscription_admins(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `true`.
        """
        return pulumi.get(self, "email_subscription_admins")

    @email_subscription_admins.setter
    def email_subscription_admins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_subscription_admins", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies an array of e-mail addresses to which the scan notification is sent.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ServerAzureadAdministratorArgs:
    def __init__(__self__, *,
                 login_username: pulumi.Input[str],
                 object_id: pulumi.Input[str],
                 azuread_authentication_only: Optional[pulumi.Input[bool]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] login_username: The login username of the Azure AD Administrator of this SQL Server.
        :param pulumi.Input[str] object_id: The object id of the Azure AD Administrator of this SQL Server.
        :param pulumi.Input[bool] azuread_authentication_only: Specifies whether only AD Users and administrators (e.g. `azuread_administrator.0.login_username`) can be used to login, or also local database users (e.g. `administrator_login`). When `true`, the `administrator_login` and `administrator_login_password` properties can be omitted.
        :param pulumi.Input[str] tenant_id: The tenant id of the Azure AD Administrator of this SQL Server.
        """
        pulumi.set(__self__, "login_username", login_username)
        pulumi.set(__self__, "object_id", object_id)
        if azuread_authentication_only is not None:
            pulumi.set(__self__, "azuread_authentication_only", azuread_authentication_only)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="loginUsername")
    def login_username(self) -> pulumi.Input[str]:
        """
        The login username of the Azure AD Administrator of this SQL Server.
        """
        return pulumi.get(self, "login_username")

    @login_username.setter
    def login_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "login_username", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> pulumi.Input[str]:
        """
        The object id of the Azure AD Administrator of this SQL Server.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="azureadAuthenticationOnly")
    def azuread_authentication_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether only AD Users and administrators (e.g. `azuread_administrator.0.login_username`) can be used to login, or also local database users (e.g. `administrator_login`). When `true`, the `administrator_login` and `administrator_login_password` properties can be omitted.
        """
        return pulumi.get(self, "azuread_authentication_only")

    @azuread_authentication_only.setter
    def azuread_authentication_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "azuread_authentication_only", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant id of the Azure AD Administrator of this SQL Server.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class ServerIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this SQL Server. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this SQL Server.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`
               
               > **NOTE:** When `type` is set to `SystemAssigned`, the assigned `principal_id` and `tenant_id` can be retrieved after the Microsoft SQL Server has been created. More details are available below.
        :param pulumi.Input[str] principal_id: The Principal ID for the Service Principal associated with the Identity of this SQL Server.
        :param pulumi.Input[str] tenant_id: The tenant id of the Azure AD Administrator of this SQL Server.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this SQL Server. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this SQL Server.

        > **NOTE:** This is required when `type` is set to `UserAssigned`

        > **NOTE:** When `type` is set to `SystemAssigned`, the assigned `principal_id` and `tenant_id` can be retrieved after the Microsoft SQL Server has been created. More details are available below.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID for the Service Principal associated with the Identity of this SQL Server.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant id of the Azure AD Administrator of this SQL Server.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class ServerVulnerabilityAssessmentRecurringScansArgs:
    def __init__(__self__, *,
                 email_subscription_admins: Optional[pulumi.Input[bool]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] email_subscription_admins: Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: Specifies an array of email addresses to which the scan notification is sent.
        :param pulumi.Input[bool] enabled: Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
        """
        if email_subscription_admins is not None:
            pulumi.set(__self__, "email_subscription_admins", email_subscription_admins)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="emailSubscriptionAdmins")
    def email_subscription_admins(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `false`.
        """
        return pulumi.get(self, "email_subscription_admins")

    @email_subscription_admins.setter
    def email_subscription_admins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_subscription_admins", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies an array of email addresses to which the scan notification is sent.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class VirtualMachineAssessmentArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 run_immediately: Optional[pulumi.Input[bool]] = None,
                 schedule: Optional[pulumi.Input['VirtualMachineAssessmentScheduleArgs']] = None):
        """
        :param pulumi.Input[bool] enabled: Should Assessment be enabled? Defaults to `true`.
        :param pulumi.Input[bool] run_immediately: Should Assessment be run immediately? Defaults to `false`.
        :param pulumi.Input['VirtualMachineAssessmentScheduleArgs'] schedule: An `schedule` block as defined below.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if run_immediately is not None:
            pulumi.set(__self__, "run_immediately", run_immediately)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Assessment be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="runImmediately")
    def run_immediately(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Assessment be run immediately? Defaults to `false`.
        """
        return pulumi.get(self, "run_immediately")

    @run_immediately.setter
    def run_immediately(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediately", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['VirtualMachineAssessmentScheduleArgs']]:
        """
        An `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['VirtualMachineAssessmentScheduleArgs']]):
        pulumi.set(self, "schedule", value)


@pulumi.input_type
class VirtualMachineAssessmentScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 monthly_occurrence: Optional[pulumi.Input[int]] = None,
                 weekly_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] day_of_week: What day of the week the assessment will be run. Default value is `Monday`. Possible values are `Friday`, `Monday`, `Saturday`, `Sunday`, `Thursday`, `Tuesday` and `Wednesday`.
        :param pulumi.Input[str] start_time: What time the assessment will be run. Must be in the format `HH:mm`.
        :param pulumi.Input[int] monthly_occurrence: How many months between assessment runs. Valid values are between `1` and `5`.
               
               > **NOTE:** Either one of `weekly_interval` or `monthly_occurrence` must be specified.
        :param pulumi.Input[int] weekly_interval: How many weeks between assessment runs. Valid values are between `1` and `6`.
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "start_time", start_time)
        if monthly_occurrence is not None:
            pulumi.set(__self__, "monthly_occurrence", monthly_occurrence)
        if weekly_interval is not None:
            pulumi.set(__self__, "weekly_interval", weekly_interval)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[str]:
        """
        What day of the week the assessment will be run. Default value is `Monday`. Possible values are `Friday`, `Monday`, `Saturday`, `Sunday`, `Thursday`, `Tuesday` and `Wednesday`.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        What time the assessment will be run. Must be in the format `HH:mm`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="monthlyOccurrence")
    def monthly_occurrence(self) -> Optional[pulumi.Input[int]]:
        """
        How many months between assessment runs. Valid values are between `1` and `5`.

        > **NOTE:** Either one of `weekly_interval` or `monthly_occurrence` must be specified.
        """
        return pulumi.get(self, "monthly_occurrence")

    @monthly_occurrence.setter
    def monthly_occurrence(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monthly_occurrence", value)

    @property
    @pulumi.getter(name="weeklyInterval")
    def weekly_interval(self) -> Optional[pulumi.Input[int]]:
        """
        How many weeks between assessment runs. Valid values are between `1` and `6`.
        """
        return pulumi.get(self, "weekly_interval")

    @weekly_interval.setter
    def weekly_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weekly_interval", value)


@pulumi.input_type
class VirtualMachineAutoBackupArgs:
    def __init__(__self__, *,
                 retention_period_in_days: pulumi.Input[int],
                 storage_account_access_key: pulumi.Input[str],
                 storage_blob_endpoint: pulumi.Input[str],
                 encryption_enabled: Optional[pulumi.Input[bool]] = None,
                 encryption_password: Optional[pulumi.Input[str]] = None,
                 manual_schedule: Optional[pulumi.Input['VirtualMachineAutoBackupManualScheduleArgs']] = None,
                 system_databases_backup_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] retention_period_in_days: Retention period of backups, in days. Valid values are from `1` to `30`.
        :param pulumi.Input[str] storage_account_access_key: Access key for the storage account where backups will be kept.
        :param pulumi.Input[str] storage_blob_endpoint: Blob endpoint for the storage account where backups will be kept.
        :param pulumi.Input[bool] encryption_enabled: Enable or disable encryption for backups. Defaults to `false`.
        :param pulumi.Input[str] encryption_password: Encryption password to use. Must be specified when encryption is enabled.
        :param pulumi.Input['VirtualMachineAutoBackupManualScheduleArgs'] manual_schedule: A `manual_schedule` block as documented below. When this block is present, the schedule type is set to `Manual`. Without this block, the schedule type is set to `Automated`.
        :param pulumi.Input[bool] system_databases_backup_enabled: Include or exclude system databases from auto backup.
        """
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        pulumi.set(__self__, "storage_account_access_key", storage_account_access_key)
        pulumi.set(__self__, "storage_blob_endpoint", storage_blob_endpoint)
        if encryption_enabled is not None:
            pulumi.set(__self__, "encryption_enabled", encryption_enabled)
        if encryption_password is not None:
            pulumi.set(__self__, "encryption_password", encryption_password)
        if manual_schedule is not None:
            pulumi.set(__self__, "manual_schedule", manual_schedule)
        if system_databases_backup_enabled is not None:
            pulumi.set(__self__, "system_databases_backup_enabled", system_databases_backup_enabled)

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> pulumi.Input[int]:
        """
        Retention period of backups, in days. Valid values are from `1` to `30`.
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_period_in_days", value)

    @property
    @pulumi.getter(name="storageAccountAccessKey")
    def storage_account_access_key(self) -> pulumi.Input[str]:
        """
        Access key for the storage account where backups will be kept.
        """
        return pulumi.get(self, "storage_account_access_key")

    @storage_account_access_key.setter
    def storage_account_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_access_key", value)

    @property
    @pulumi.getter(name="storageBlobEndpoint")
    def storage_blob_endpoint(self) -> pulumi.Input[str]:
        """
        Blob endpoint for the storage account where backups will be kept.
        """
        return pulumi.get(self, "storage_blob_endpoint")

    @storage_blob_endpoint.setter
    def storage_blob_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_blob_endpoint", value)

    @property
    @pulumi.getter(name="encryptionEnabled")
    def encryption_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable encryption for backups. Defaults to `false`.
        """
        return pulumi.get(self, "encryption_enabled")

    @encryption_enabled.setter
    def encryption_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encryption_enabled", value)

    @property
    @pulumi.getter(name="encryptionPassword")
    def encryption_password(self) -> Optional[pulumi.Input[str]]:
        """
        Encryption password to use. Must be specified when encryption is enabled.
        """
        return pulumi.get(self, "encryption_password")

    @encryption_password.setter
    def encryption_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_password", value)

    @property
    @pulumi.getter(name="manualSchedule")
    def manual_schedule(self) -> Optional[pulumi.Input['VirtualMachineAutoBackupManualScheduleArgs']]:
        """
        A `manual_schedule` block as documented below. When this block is present, the schedule type is set to `Manual`. Without this block, the schedule type is set to `Automated`.
        """
        return pulumi.get(self, "manual_schedule")

    @manual_schedule.setter
    def manual_schedule(self, value: Optional[pulumi.Input['VirtualMachineAutoBackupManualScheduleArgs']]):
        pulumi.set(self, "manual_schedule", value)

    @property
    @pulumi.getter(name="systemDatabasesBackupEnabled")
    def system_databases_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Include or exclude system databases from auto backup.
        """
        return pulumi.get(self, "system_databases_backup_enabled")

    @system_databases_backup_enabled.setter
    def system_databases_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_databases_backup_enabled", value)


@pulumi.input_type
class VirtualMachineAutoBackupManualScheduleArgs:
    def __init__(__self__, *,
                 full_backup_frequency: pulumi.Input[str],
                 full_backup_start_hour: pulumi.Input[int],
                 full_backup_window_in_hours: pulumi.Input[int],
                 log_backup_frequency_in_minutes: pulumi.Input[int],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] full_backup_frequency: Frequency of full backups. Valid values include `Daily` or `Weekly`.
        :param pulumi.Input[int] full_backup_start_hour: Start hour of a given day during which full backups can take place. Valid values are from `0` to `23`.
        :param pulumi.Input[int] full_backup_window_in_hours: Duration of the time window of a given day during which full backups can take place, in hours. Valid values are between `1` and `23`.
        :param pulumi.Input[int] log_backup_frequency_in_minutes: Frequency of log backups, in minutes. Valid values are from `5` to `60`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_of_weeks: A list of days on which backup can take place. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`
               
               > **NOTE:** `days_of_week` can only be specified when `manual_schedule` is set to `Weekly`
        """
        pulumi.set(__self__, "full_backup_frequency", full_backup_frequency)
        pulumi.set(__self__, "full_backup_start_hour", full_backup_start_hour)
        pulumi.set(__self__, "full_backup_window_in_hours", full_backup_window_in_hours)
        pulumi.set(__self__, "log_backup_frequency_in_minutes", log_backup_frequency_in_minutes)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)

    @property
    @pulumi.getter(name="fullBackupFrequency")
    def full_backup_frequency(self) -> pulumi.Input[str]:
        """
        Frequency of full backups. Valid values include `Daily` or `Weekly`.
        """
        return pulumi.get(self, "full_backup_frequency")

    @full_backup_frequency.setter
    def full_backup_frequency(self, value: pulumi.Input[str]):
        pulumi.set(self, "full_backup_frequency", value)

    @property
    @pulumi.getter(name="fullBackupStartHour")
    def full_backup_start_hour(self) -> pulumi.Input[int]:
        """
        Start hour of a given day during which full backups can take place. Valid values are from `0` to `23`.
        """
        return pulumi.get(self, "full_backup_start_hour")

    @full_backup_start_hour.setter
    def full_backup_start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "full_backup_start_hour", value)

    @property
    @pulumi.getter(name="fullBackupWindowInHours")
    def full_backup_window_in_hours(self) -> pulumi.Input[int]:
        """
        Duration of the time window of a given day during which full backups can take place, in hours. Valid values are between `1` and `23`.
        """
        return pulumi.get(self, "full_backup_window_in_hours")

    @full_backup_window_in_hours.setter
    def full_backup_window_in_hours(self, value: pulumi.Input[int]):
        pulumi.set(self, "full_backup_window_in_hours", value)

    @property
    @pulumi.getter(name="logBackupFrequencyInMinutes")
    def log_backup_frequency_in_minutes(self) -> pulumi.Input[int]:
        """
        Frequency of log backups, in minutes. Valid values are from `5` to `60`.
        """
        return pulumi.get(self, "log_backup_frequency_in_minutes")

    @log_backup_frequency_in_minutes.setter
    def log_backup_frequency_in_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "log_backup_frequency_in_minutes", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of days on which backup can take place. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`

        > **NOTE:** `days_of_week` can only be specified when `manual_schedule` is set to `Weekly`
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "days_of_weeks", value)


@pulumi.input_type
class VirtualMachineAutoPatchingArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[str],
                 maintenance_window_duration_in_minutes: pulumi.Input[int],
                 maintenance_window_starting_hour: pulumi.Input[int]):
        """
        :param pulumi.Input[str] day_of_week: The day of week to apply the patch on. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        :param pulumi.Input[int] maintenance_window_duration_in_minutes: The size of the Maintenance Window in minutes.
        :param pulumi.Input[int] maintenance_window_starting_hour: The Hour, in the Virtual Machine Time-Zone when the patching maintenance window should begin.
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "maintenance_window_duration_in_minutes", maintenance_window_duration_in_minutes)
        pulumi.set(__self__, "maintenance_window_starting_hour", maintenance_window_starting_hour)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[str]:
        """
        The day of week to apply the patch on. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="maintenanceWindowDurationInMinutes")
    def maintenance_window_duration_in_minutes(self) -> pulumi.Input[int]:
        """
        The size of the Maintenance Window in minutes.
        """
        return pulumi.get(self, "maintenance_window_duration_in_minutes")

    @maintenance_window_duration_in_minutes.setter
    def maintenance_window_duration_in_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "maintenance_window_duration_in_minutes", value)

    @property
    @pulumi.getter(name="maintenanceWindowStartingHour")
    def maintenance_window_starting_hour(self) -> pulumi.Input[int]:
        """
        The Hour, in the Virtual Machine Time-Zone when the patching maintenance window should begin.
        """
        return pulumi.get(self, "maintenance_window_starting_hour")

    @maintenance_window_starting_hour.setter
    def maintenance_window_starting_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "maintenance_window_starting_hour", value)


@pulumi.input_type
class VirtualMachineAvailabilityGroupListenerLoadBalancerConfigurationArgs:
    def __init__(__self__, *,
                 load_balancer_id: pulumi.Input[str],
                 private_ip_address: pulumi.Input[str],
                 probe_port: pulumi.Input[int],
                 sql_virtual_machine_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] load_balancer_id: The ID of the Load Balancer. Changing this forces a new resource to be created.
        :param pulumi.Input[str] private_ip_address: The private IP Address of the listener. Changing this forces a new resource to be created.
        :param pulumi.Input[int] probe_port: The probe port of the listener. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sql_virtual_machine_ids: Specifies a list of SQL Virtual Machine IDs. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subnet_id: The ID of the Subnet to create the listener. Changing this forces a new resource to be created.
               
               > **NOTE:** `sql_virtual_machine_ids` should match with the SQL Virtual Machines specified in `replica`.
        """
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "probe_port", probe_port)
        pulumi.set(__self__, "sql_virtual_machine_ids", sql_virtual_machine_ids)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> pulumi.Input[str]:
        """
        The ID of the Load Balancer. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> pulumi.Input[str]:
        """
        The private IP Address of the listener. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="probePort")
    def probe_port(self) -> pulumi.Input[int]:
        """
        The probe port of the listener. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "probe_port")

    @probe_port.setter
    def probe_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "probe_port", value)

    @property
    @pulumi.getter(name="sqlVirtualMachineIds")
    def sql_virtual_machine_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of SQL Virtual Machine IDs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sql_virtual_machine_ids")

    @sql_virtual_machine_ids.setter
    def sql_virtual_machine_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sql_virtual_machine_ids", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The ID of the Subnet to create the listener. Changing this forces a new resource to be created.

        > **NOTE:** `sql_virtual_machine_ids` should match with the SQL Virtual Machines specified in `replica`.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class VirtualMachineAvailabilityGroupListenerMultiSubnetIpConfigurationArgs:
    def __init__(__self__, *,
                 private_ip_address: pulumi.Input[str],
                 sql_virtual_machine_id: pulumi.Input[str],
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] private_ip_address: The private IP Address of the listener. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sql_virtual_machine_id: The ID of the Sql Virtual Machine. Changing this forces a new resource to be created.
        :param pulumi.Input[str] subnet_id: The ID of the Subnet to create the listener. Changing this forces a new resource to be created.
               
               > **NOTE:** `sql_virtual_machine_id` should match with the SQL Virtual Machines specified in `replica`.
        """
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "sql_virtual_machine_id", sql_virtual_machine_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> pulumi.Input[str]:
        """
        The private IP Address of the listener. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="sqlVirtualMachineId")
    def sql_virtual_machine_id(self) -> pulumi.Input[str]:
        """
        The ID of the Sql Virtual Machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sql_virtual_machine_id")

    @sql_virtual_machine_id.setter
    def sql_virtual_machine_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "sql_virtual_machine_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The ID of the Subnet to create the listener. Changing this forces a new resource to be created.

        > **NOTE:** `sql_virtual_machine_id` should match with the SQL Virtual Machines specified in `replica`.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class VirtualMachineAvailabilityGroupListenerReplicaArgs:
    def __init__(__self__, *,
                 commit: pulumi.Input[str],
                 failover_mode: pulumi.Input[str],
                 readable_secondary: pulumi.Input[str],
                 role: pulumi.Input[str],
                 sql_virtual_machine_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] commit: The replica commit mode for the availability group. Possible values are `Synchronous_Commit` and `Asynchronous_Commit`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] failover_mode: The replica failover mode for the availability group. Possible values are `Manual` and `Automatic`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] readable_secondary: The replica readable secondary mode for the availability group. Possible values are `No`, `Read_Only` and `All`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] role: The replica role for the availability group. Possible values are `Primary` and `Secondary`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sql_virtual_machine_id: The ID of the SQL Virtual Machine. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "commit", commit)
        pulumi.set(__self__, "failover_mode", failover_mode)
        pulumi.set(__self__, "readable_secondary", readable_secondary)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "sql_virtual_machine_id", sql_virtual_machine_id)

    @property
    @pulumi.getter
    def commit(self) -> pulumi.Input[str]:
        """
        The replica commit mode for the availability group. Possible values are `Synchronous_Commit` and `Asynchronous_Commit`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "commit")

    @commit.setter
    def commit(self, value: pulumi.Input[str]):
        pulumi.set(self, "commit", value)

    @property
    @pulumi.getter(name="failoverMode")
    def failover_mode(self) -> pulumi.Input[str]:
        """
        The replica failover mode for the availability group. Possible values are `Manual` and `Automatic`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "failover_mode")

    @failover_mode.setter
    def failover_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "failover_mode", value)

    @property
    @pulumi.getter(name="readableSecondary")
    def readable_secondary(self) -> pulumi.Input[str]:
        """
        The replica readable secondary mode for the availability group. Possible values are `No`, `Read_Only` and `All`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "readable_secondary")

    @readable_secondary.setter
    def readable_secondary(self, value: pulumi.Input[str]):
        pulumi.set(self, "readable_secondary", value)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        The replica role for the availability group. Possible values are `Primary` and `Secondary`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="sqlVirtualMachineId")
    def sql_virtual_machine_id(self) -> pulumi.Input[str]:
        """
        The ID of the SQL Virtual Machine. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sql_virtual_machine_id")

    @sql_virtual_machine_id.setter
    def sql_virtual_machine_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "sql_virtual_machine_id", value)


@pulumi.input_type
class VirtualMachineGroupWsfcDomainProfileArgs:
    def __init__(__self__, *,
                 cluster_subnet_type: pulumi.Input[str],
                 fqdn: pulumi.Input[str],
                 cluster_bootstrap_account_name: Optional[pulumi.Input[str]] = None,
                 cluster_operator_account_name: Optional[pulumi.Input[str]] = None,
                 organizational_unit_path: Optional[pulumi.Input[str]] = None,
                 sql_service_account_name: Optional[pulumi.Input[str]] = None,
                 storage_account_primary_key: Optional[pulumi.Input[str]] = None,
                 storage_account_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_subnet_type: The subnet type of the SQL Virtual Machine cluster. Possible values are `MultiSubnet` and `SingleSubnet`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] fqdn: The fully qualified name of the domain. Changing this forces a new resource to be created.
        :param pulumi.Input[str] cluster_bootstrap_account_name: The account name used for creating cluster. Changing this forces a new resource to be created.
        :param pulumi.Input[str] cluster_operator_account_name: The account name used for operating cluster. Changing this forces a new resource to be created.
        :param pulumi.Input[str] organizational_unit_path: The organizational Unit path in which the nodes and cluster will be present. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sql_service_account_name: The account name under which SQL service will run on all participating SQL virtual machines in the cluster. Changing this forces a new resource to be created.
        :param pulumi.Input[str] storage_account_primary_key: The primary key of the Storage Account.
        :param pulumi.Input[str] storage_account_url: The SAS URL to the Storage Container of the witness storage account. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "cluster_subnet_type", cluster_subnet_type)
        pulumi.set(__self__, "fqdn", fqdn)
        if cluster_bootstrap_account_name is not None:
            pulumi.set(__self__, "cluster_bootstrap_account_name", cluster_bootstrap_account_name)
        if cluster_operator_account_name is not None:
            pulumi.set(__self__, "cluster_operator_account_name", cluster_operator_account_name)
        if organizational_unit_path is not None:
            pulumi.set(__self__, "organizational_unit_path", organizational_unit_path)
        if sql_service_account_name is not None:
            pulumi.set(__self__, "sql_service_account_name", sql_service_account_name)
        if storage_account_primary_key is not None:
            pulumi.set(__self__, "storage_account_primary_key", storage_account_primary_key)
        if storage_account_url is not None:
            pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter(name="clusterSubnetType")
    def cluster_subnet_type(self) -> pulumi.Input[str]:
        """
        The subnet type of the SQL Virtual Machine cluster. Possible values are `MultiSubnet` and `SingleSubnet`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cluster_subnet_type")

    @cluster_subnet_type.setter
    def cluster_subnet_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_subnet_type", value)

    @property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[str]:
        """
        The fully qualified name of the domain. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[str]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="clusterBootstrapAccountName")
    def cluster_bootstrap_account_name(self) -> Optional[pulumi.Input[str]]:
        """
        The account name used for creating cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cluster_bootstrap_account_name")

    @cluster_bootstrap_account_name.setter
    def cluster_bootstrap_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_bootstrap_account_name", value)

    @property
    @pulumi.getter(name="clusterOperatorAccountName")
    def cluster_operator_account_name(self) -> Optional[pulumi.Input[str]]:
        """
        The account name used for operating cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cluster_operator_account_name")

    @cluster_operator_account_name.setter
    def cluster_operator_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_operator_account_name", value)

    @property
    @pulumi.getter(name="organizationalUnitPath")
    def organizational_unit_path(self) -> Optional[pulumi.Input[str]]:
        """
        The organizational Unit path in which the nodes and cluster will be present. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "organizational_unit_path")

    @organizational_unit_path.setter
    def organizational_unit_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organizational_unit_path", value)

    @property
    @pulumi.getter(name="sqlServiceAccountName")
    def sql_service_account_name(self) -> Optional[pulumi.Input[str]]:
        """
        The account name under which SQL service will run on all participating SQL virtual machines in the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sql_service_account_name")

    @sql_service_account_name.setter
    def sql_service_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_service_account_name", value)

    @property
    @pulumi.getter(name="storageAccountPrimaryKey")
    def storage_account_primary_key(self) -> Optional[pulumi.Input[str]]:
        """
        The primary key of the Storage Account.
        """
        return pulumi.get(self, "storage_account_primary_key")

    @storage_account_primary_key.setter
    def storage_account_primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_primary_key", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> Optional[pulumi.Input[str]]:
        """
        The SAS URL to the Storage Container of the witness storage account. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_url", value)


@pulumi.input_type
class VirtualMachineKeyVaultCredentialArgs:
    def __init__(__self__, *,
                 key_vault_url: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service_principal_name: pulumi.Input[str],
                 service_principal_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key_vault_url: The Azure Key Vault url. Changing this forces a new resource to be created.
        :param pulumi.Input[str] name: The credential name.
        :param pulumi.Input[str] service_principal_name: The service principal name to access key vault. Changing this forces a new resource to be created.
        :param pulumi.Input[str] service_principal_secret: The service principal name secret to access key vault. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "key_vault_url", key_vault_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_principal_name", service_principal_name)
        pulumi.set(__self__, "service_principal_secret", service_principal_secret)

    @property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> pulumi.Input[str]:
        """
        The Azure Key Vault url. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "key_vault_url")

    @key_vault_url.setter
    def key_vault_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_url", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The credential name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> pulumi.Input[str]:
        """
        The service principal name to access key vault. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "service_principal_name")

    @service_principal_name.setter
    def service_principal_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_principal_name", value)

    @property
    @pulumi.getter(name="servicePrincipalSecret")
    def service_principal_secret(self) -> pulumi.Input[str]:
        """
        The service principal name secret to access key vault. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "service_principal_secret")

    @service_principal_secret.setter
    def service_principal_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_principal_secret", value)


@pulumi.input_type
class VirtualMachineSqlInstanceArgs:
    def __init__(__self__, *,
                 adhoc_workloads_optimization_enabled: Optional[pulumi.Input[bool]] = None,
                 collation: Optional[pulumi.Input[str]] = None,
                 instant_file_initialization_enabled: Optional[pulumi.Input[bool]] = None,
                 lock_pages_in_memory_enabled: Optional[pulumi.Input[bool]] = None,
                 max_dop: Optional[pulumi.Input[int]] = None,
                 max_server_memory_mb: Optional[pulumi.Input[int]] = None,
                 min_server_memory_mb: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] adhoc_workloads_optimization_enabled: Specifies if the SQL Server is optimized for adhoc workloads. Possible values are `true` and `false`. Defaults to `false`.
        :param pulumi.Input[str] collation: Collation of the SQL Server. Defaults to `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] instant_file_initialization_enabled: Specifies if Instant File Initialization is enabled for the SQL Server. Possible values are `true` and `false`. Defaults to `false`. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] lock_pages_in_memory_enabled: Specifies if Lock Pages in Memory is enabled for the SQL Server. Possible values are `true` and `false`. Defaults to `false`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] max_dop: Maximum Degree of Parallelism of the SQL Server. Possible values are between `0` and `32767`. Defaults to `0`.
        :param pulumi.Input[int] max_server_memory_mb: Maximum amount memory that SQL Server Memory Manager can allocate to the SQL Server process. Possible values are between `128` and `2147483647` Defaults to `2147483647`.
        :param pulumi.Input[int] min_server_memory_mb: Minimum amount memory that SQL Server Memory Manager can allocate to the SQL Server process. Possible values are between `0` and `2147483647` Defaults to `0`.
               
               > **NOTE:** `max_server_memory_mb` must be greater than or equal to `min_server_memory_mb`
        """
        if adhoc_workloads_optimization_enabled is not None:
            pulumi.set(__self__, "adhoc_workloads_optimization_enabled", adhoc_workloads_optimization_enabled)
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if instant_file_initialization_enabled is not None:
            pulumi.set(__self__, "instant_file_initialization_enabled", instant_file_initialization_enabled)
        if lock_pages_in_memory_enabled is not None:
            pulumi.set(__self__, "lock_pages_in_memory_enabled", lock_pages_in_memory_enabled)
        if max_dop is not None:
            pulumi.set(__self__, "max_dop", max_dop)
        if max_server_memory_mb is not None:
            pulumi.set(__self__, "max_server_memory_mb", max_server_memory_mb)
        if min_server_memory_mb is not None:
            pulumi.set(__self__, "min_server_memory_mb", min_server_memory_mb)

    @property
    @pulumi.getter(name="adhocWorkloadsOptimizationEnabled")
    def adhoc_workloads_optimization_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the SQL Server is optimized for adhoc workloads. Possible values are `true` and `false`. Defaults to `false`.
        """
        return pulumi.get(self, "adhoc_workloads_optimization_enabled")

    @adhoc_workloads_optimization_enabled.setter
    def adhoc_workloads_optimization_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "adhoc_workloads_optimization_enabled", value)

    @property
    @pulumi.getter
    def collation(self) -> Optional[pulumi.Input[str]]:
        """
        Collation of the SQL Server. Defaults to `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "collation")

    @collation.setter
    def collation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collation", value)

    @property
    @pulumi.getter(name="instantFileInitializationEnabled")
    def instant_file_initialization_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if Instant File Initialization is enabled for the SQL Server. Possible values are `true` and `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "instant_file_initialization_enabled")

    @instant_file_initialization_enabled.setter
    def instant_file_initialization_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "instant_file_initialization_enabled", value)

    @property
    @pulumi.getter(name="lockPagesInMemoryEnabled")
    def lock_pages_in_memory_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if Lock Pages in Memory is enabled for the SQL Server. Possible values are `true` and `false`. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "lock_pages_in_memory_enabled")

    @lock_pages_in_memory_enabled.setter
    def lock_pages_in_memory_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lock_pages_in_memory_enabled", value)

    @property
    @pulumi.getter(name="maxDop")
    def max_dop(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum Degree of Parallelism of the SQL Server. Possible values are between `0` and `32767`. Defaults to `0`.
        """
        return pulumi.get(self, "max_dop")

    @max_dop.setter
    def max_dop(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_dop", value)

    @property
    @pulumi.getter(name="maxServerMemoryMb")
    def max_server_memory_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum amount memory that SQL Server Memory Manager can allocate to the SQL Server process. Possible values are between `128` and `2147483647` Defaults to `2147483647`.
        """
        return pulumi.get(self, "max_server_memory_mb")

    @max_server_memory_mb.setter
    def max_server_memory_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_server_memory_mb", value)

    @property
    @pulumi.getter(name="minServerMemoryMb")
    def min_server_memory_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum amount memory that SQL Server Memory Manager can allocate to the SQL Server process. Possible values are between `0` and `2147483647` Defaults to `0`.

        > **NOTE:** `max_server_memory_mb` must be greater than or equal to `min_server_memory_mb`
        """
        return pulumi.get(self, "min_server_memory_mb")

    @min_server_memory_mb.setter
    def min_server_memory_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_server_memory_mb", value)


@pulumi.input_type
class VirtualMachineStorageConfigurationArgs:
    def __init__(__self__, *,
                 disk_type: pulumi.Input[str],
                 storage_workload_type: pulumi.Input[str],
                 data_settings: Optional[pulumi.Input['VirtualMachineStorageConfigurationDataSettingsArgs']] = None,
                 log_settings: Optional[pulumi.Input['VirtualMachineStorageConfigurationLogSettingsArgs']] = None,
                 system_db_on_data_disk_enabled: Optional[pulumi.Input[bool]] = None,
                 temp_db_settings: Optional[pulumi.Input['VirtualMachineStorageConfigurationTempDbSettingsArgs']] = None):
        """
        :param pulumi.Input[str] disk_type: The type of disk configuration to apply to the SQL Server. Valid values include `NEW`, `EXTEND`, or `ADD`.
        :param pulumi.Input[str] storage_workload_type: The type of storage workload. Valid values include `GENERAL`, `OLTP`, or `DW`.
        :param pulumi.Input['VirtualMachineStorageConfigurationDataSettingsArgs'] data_settings: A `storage_settings` block as defined below.
        :param pulumi.Input['VirtualMachineStorageConfigurationLogSettingsArgs'] log_settings: A `storage_settings` block as defined below.
        :param pulumi.Input[bool] system_db_on_data_disk_enabled: Specifies whether to set system databases (except tempDb) location to newly created data storage. Possible values are `true` and `false`. Defaults to `false`.
        :param pulumi.Input['VirtualMachineStorageConfigurationTempDbSettingsArgs'] temp_db_settings: An `temp_db_settings` as defined below.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "storage_workload_type", storage_workload_type)
        if data_settings is not None:
            pulumi.set(__self__, "data_settings", data_settings)
        if log_settings is not None:
            pulumi.set(__self__, "log_settings", log_settings)
        if system_db_on_data_disk_enabled is not None:
            pulumi.set(__self__, "system_db_on_data_disk_enabled", system_db_on_data_disk_enabled)
        if temp_db_settings is not None:
            pulumi.set(__self__, "temp_db_settings", temp_db_settings)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[str]:
        """
        The type of disk configuration to apply to the SQL Server. Valid values include `NEW`, `EXTEND`, or `ADD`.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="storageWorkloadType")
    def storage_workload_type(self) -> pulumi.Input[str]:
        """
        The type of storage workload. Valid values include `GENERAL`, `OLTP`, or `DW`.
        """
        return pulumi.get(self, "storage_workload_type")

    @storage_workload_type.setter
    def storage_workload_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_workload_type", value)

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> Optional[pulumi.Input['VirtualMachineStorageConfigurationDataSettingsArgs']]:
        """
        A `storage_settings` block as defined below.
        """
        return pulumi.get(self, "data_settings")

    @data_settings.setter
    def data_settings(self, value: Optional[pulumi.Input['VirtualMachineStorageConfigurationDataSettingsArgs']]):
        pulumi.set(self, "data_settings", value)

    @property
    @pulumi.getter(name="logSettings")
    def log_settings(self) -> Optional[pulumi.Input['VirtualMachineStorageConfigurationLogSettingsArgs']]:
        """
        A `storage_settings` block as defined below.
        """
        return pulumi.get(self, "log_settings")

    @log_settings.setter
    def log_settings(self, value: Optional[pulumi.Input['VirtualMachineStorageConfigurationLogSettingsArgs']]):
        pulumi.set(self, "log_settings", value)

    @property
    @pulumi.getter(name="systemDbOnDataDiskEnabled")
    def system_db_on_data_disk_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to set system databases (except tempDb) location to newly created data storage. Possible values are `true` and `false`. Defaults to `false`.
        """
        return pulumi.get(self, "system_db_on_data_disk_enabled")

    @system_db_on_data_disk_enabled.setter
    def system_db_on_data_disk_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_db_on_data_disk_enabled", value)

    @property
    @pulumi.getter(name="tempDbSettings")
    def temp_db_settings(self) -> Optional[pulumi.Input['VirtualMachineStorageConfigurationTempDbSettingsArgs']]:
        """
        An `temp_db_settings` as defined below.
        """
        return pulumi.get(self, "temp_db_settings")

    @temp_db_settings.setter
    def temp_db_settings(self, value: Optional[pulumi.Input['VirtualMachineStorageConfigurationTempDbSettingsArgs']]):
        pulumi.set(self, "temp_db_settings", value)


@pulumi.input_type
class VirtualMachineStorageConfigurationDataSettingsArgs:
    def __init__(__self__, *,
                 default_file_path: pulumi.Input[str],
                 luns: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[str] default_file_path: The SQL Server default path
        :param pulumi.Input[Sequence[pulumi.Input[int]]] luns: A list of Logical Unit Numbers for the disks.
        """
        pulumi.set(__self__, "default_file_path", default_file_path)
        pulumi.set(__self__, "luns", luns)

    @property
    @pulumi.getter(name="defaultFilePath")
    def default_file_path(self) -> pulumi.Input[str]:
        """
        The SQL Server default path
        """
        return pulumi.get(self, "default_file_path")

    @default_file_path.setter
    def default_file_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_file_path", value)

    @property
    @pulumi.getter
    def luns(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        A list of Logical Unit Numbers for the disks.
        """
        return pulumi.get(self, "luns")

    @luns.setter
    def luns(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "luns", value)


@pulumi.input_type
class VirtualMachineStorageConfigurationLogSettingsArgs:
    def __init__(__self__, *,
                 default_file_path: pulumi.Input[str],
                 luns: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[str] default_file_path: The SQL Server default path
        :param pulumi.Input[Sequence[pulumi.Input[int]]] luns: A list of Logical Unit Numbers for the disks.
        """
        pulumi.set(__self__, "default_file_path", default_file_path)
        pulumi.set(__self__, "luns", luns)

    @property
    @pulumi.getter(name="defaultFilePath")
    def default_file_path(self) -> pulumi.Input[str]:
        """
        The SQL Server default path
        """
        return pulumi.get(self, "default_file_path")

    @default_file_path.setter
    def default_file_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_file_path", value)

    @property
    @pulumi.getter
    def luns(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        A list of Logical Unit Numbers for the disks.
        """
        return pulumi.get(self, "luns")

    @luns.setter
    def luns(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "luns", value)


@pulumi.input_type
class VirtualMachineStorageConfigurationTempDbSettingsArgs:
    def __init__(__self__, *,
                 default_file_path: pulumi.Input[str],
                 luns: pulumi.Input[Sequence[pulumi.Input[int]]],
                 data_file_count: Optional[pulumi.Input[int]] = None,
                 data_file_growth_in_mb: Optional[pulumi.Input[int]] = None,
                 data_file_size_mb: Optional[pulumi.Input[int]] = None,
                 log_file_growth_mb: Optional[pulumi.Input[int]] = None,
                 log_file_size_mb: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] default_file_path: The SQL Server default path
        :param pulumi.Input[Sequence[pulumi.Input[int]]] luns: A list of Logical Unit Numbers for the disks.
        :param pulumi.Input[int] data_file_count: The SQL Server default file count. This value defaults to `8`
        :param pulumi.Input[int] data_file_growth_in_mb: The SQL Server default file size - This value defaults to `512`
        :param pulumi.Input[int] data_file_size_mb: The SQL Server default file size - This value defaults to `256`
        :param pulumi.Input[int] log_file_growth_mb: The SQL Server default file size - This value defaults to `512`
        :param pulumi.Input[int] log_file_size_mb: The SQL Server default file size - This value defaults to `256`
        """
        pulumi.set(__self__, "default_file_path", default_file_path)
        pulumi.set(__self__, "luns", luns)
        if data_file_count is not None:
            pulumi.set(__self__, "data_file_count", data_file_count)
        if data_file_growth_in_mb is not None:
            pulumi.set(__self__, "data_file_growth_in_mb", data_file_growth_in_mb)
        if data_file_size_mb is not None:
            pulumi.set(__self__, "data_file_size_mb", data_file_size_mb)
        if log_file_growth_mb is not None:
            pulumi.set(__self__, "log_file_growth_mb", log_file_growth_mb)
        if log_file_size_mb is not None:
            pulumi.set(__self__, "log_file_size_mb", log_file_size_mb)

    @property
    @pulumi.getter(name="defaultFilePath")
    def default_file_path(self) -> pulumi.Input[str]:
        """
        The SQL Server default path
        """
        return pulumi.get(self, "default_file_path")

    @default_file_path.setter
    def default_file_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_file_path", value)

    @property
    @pulumi.getter
    def luns(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        A list of Logical Unit Numbers for the disks.
        """
        return pulumi.get(self, "luns")

    @luns.setter
    def luns(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "luns", value)

    @property
    @pulumi.getter(name="dataFileCount")
    def data_file_count(self) -> Optional[pulumi.Input[int]]:
        """
        The SQL Server default file count. This value defaults to `8`
        """
        return pulumi.get(self, "data_file_count")

    @data_file_count.setter
    def data_file_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_file_count", value)

    @property
    @pulumi.getter(name="dataFileGrowthInMb")
    def data_file_growth_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The SQL Server default file size - This value defaults to `512`
        """
        return pulumi.get(self, "data_file_growth_in_mb")

    @data_file_growth_in_mb.setter
    def data_file_growth_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_file_growth_in_mb", value)

    @property
    @pulumi.getter(name="dataFileSizeMb")
    def data_file_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The SQL Server default file size - This value defaults to `256`
        """
        return pulumi.get(self, "data_file_size_mb")

    @data_file_size_mb.setter
    def data_file_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_file_size_mb", value)

    @property
    @pulumi.getter(name="logFileGrowthMb")
    def log_file_growth_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The SQL Server default file size - This value defaults to `512`
        """
        return pulumi.get(self, "log_file_growth_mb")

    @log_file_growth_mb.setter
    def log_file_growth_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_file_growth_mb", value)

    @property
    @pulumi.getter(name="logFileSizeMb")
    def log_file_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The SQL Server default file size - This value defaults to `256`
        """
        return pulumi.get(self, "log_file_size_mb")

    @log_file_size_mb.setter
    def log_file_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_file_size_mb", value)


@pulumi.input_type
class VirtualMachineWsfcDomainCredentialArgs:
    def __init__(__self__, *,
                 cluster_bootstrap_account_password: pulumi.Input[str],
                 cluster_operator_account_password: pulumi.Input[str],
                 sql_service_account_password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cluster_bootstrap_account_password: The account password used for creating cluster.
        :param pulumi.Input[str] cluster_operator_account_password: The account password used for operating cluster.
        :param pulumi.Input[str] sql_service_account_password: The account password under which SQL service will run on all participating SQL virtual machines in the cluster.
        """
        pulumi.set(__self__, "cluster_bootstrap_account_password", cluster_bootstrap_account_password)
        pulumi.set(__self__, "cluster_operator_account_password", cluster_operator_account_password)
        pulumi.set(__self__, "sql_service_account_password", sql_service_account_password)

    @property
    @pulumi.getter(name="clusterBootstrapAccountPassword")
    def cluster_bootstrap_account_password(self) -> pulumi.Input[str]:
        """
        The account password used for creating cluster.
        """
        return pulumi.get(self, "cluster_bootstrap_account_password")

    @cluster_bootstrap_account_password.setter
    def cluster_bootstrap_account_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_bootstrap_account_password", value)

    @property
    @pulumi.getter(name="clusterOperatorAccountPassword")
    def cluster_operator_account_password(self) -> pulumi.Input[str]:
        """
        The account password used for operating cluster.
        """
        return pulumi.get(self, "cluster_operator_account_password")

    @cluster_operator_account_password.setter
    def cluster_operator_account_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_operator_account_password", value)

    @property
    @pulumi.getter(name="sqlServiceAccountPassword")
    def sql_service_account_password(self) -> pulumi.Input[str]:
        """
        The account password under which SQL service will run on all participating SQL virtual machines in the cluster.
        """
        return pulumi.get(self, "sql_service_account_password")

    @sql_service_account_password.setter
    def sql_service_account_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "sql_service_account_password", value)


