# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AccountActiveDirectory',
    'VolumeDataProtectionReplication',
    'VolumeExportPolicyRule',
    'GetVolumeDataProtectionReplicationResult',
]

@pulumi.output_type
class AccountActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"
        elif key == "smbServerName":
            suggest = "smb_server_name"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_servers: Sequence[str],
                 domain: str,
                 password: str,
                 smb_server_name: str,
                 username: str,
                 organizational_unit: Optional[str] = None):
        """
        :param Sequence[str] dns_servers: A list of DNS server IP addresses for the Active Directory domain. Only allows `IPv4` address.
        :param str domain: The name of the Active Directory domain.
        :param str password: The password associated with the `username`.
        :param str smb_server_name: The NetBIOS name which should be used for the NetApp SMB Server, which will be registered as a computer account in the AD and used to mount volumes.
        :param str username: The Username of Active Directory Domain Administrator.
        :param str organizational_unit: The Organizational Unit (OU) within the Active Directory Domain.
        """
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "smb_server_name", smb_server_name)
        pulumi.set(__self__, "username", username)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        A list of DNS server IP addresses for the Active Directory domain. Only allows `IPv4` address.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The name of the Active Directory domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password associated with the `username`.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="smbServerName")
    def smb_server_name(self) -> str:
        """
        The NetBIOS name which should be used for the NetApp SMB Server, which will be registered as a computer account in the AD and used to mount volumes.
        """
        return pulumi.get(self, "smb_server_name")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The Username of Active Directory Domain Administrator.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[str]:
        """
        The Organizational Unit (OU) within the Active Directory Domain.
        """
        return pulumi.get(self, "organizational_unit")


@pulumi.output_type
class VolumeDataProtectionReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteVolumeLocation":
            suggest = "remote_volume_location"
        elif key == "remoteVolumeResourceId":
            suggest = "remote_volume_resource_id"
        elif key == "replicationFrequency":
            suggest = "replication_frequency"
        elif key == "endpointType":
            suggest = "endpoint_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeDataProtectionReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeDataProtectionReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeDataProtectionReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_volume_location: str,
                 remote_volume_resource_id: str,
                 replication_frequency: str,
                 endpoint_type: Optional[str] = None):
        """
        :param str remote_volume_location: Location of the primary volume.
        :param str remote_volume_resource_id: Resource ID of the primary volume.
        :param str replication_frequency: Replication frequency, supported values are '10minutes', 'hourly', 'daily', values are case sensitive.
        :param str endpoint_type: The endpoint type, default value is `dst` for destination.
        """
        pulumi.set(__self__, "remote_volume_location", remote_volume_location)
        pulumi.set(__self__, "remote_volume_resource_id", remote_volume_resource_id)
        pulumi.set(__self__, "replication_frequency", replication_frequency)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)

    @property
    @pulumi.getter(name="remoteVolumeLocation")
    def remote_volume_location(self) -> str:
        """
        Location of the primary volume.
        """
        return pulumi.get(self, "remote_volume_location")

    @property
    @pulumi.getter(name="remoteVolumeResourceId")
    def remote_volume_resource_id(self) -> str:
        """
        Resource ID of the primary volume.
        """
        return pulumi.get(self, "remote_volume_resource_id")

    @property
    @pulumi.getter(name="replicationFrequency")
    def replication_frequency(self) -> str:
        """
        Replication frequency, supported values are '10minutes', 'hourly', 'daily', values are case sensitive.
        """
        return pulumi.get(self, "replication_frequency")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[str]:
        """
        The endpoint type, default value is `dst` for destination.
        """
        return pulumi.get(self, "endpoint_type")


@pulumi.output_type
class VolumeExportPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedClients":
            suggest = "allowed_clients"
        elif key == "ruleIndex":
            suggest = "rule_index"
        elif key == "cifsEnabled":
            suggest = "cifs_enabled"
        elif key == "nfsv3Enabled":
            suggest = "nfsv3_enabled"
        elif key == "nfsv4Enabled":
            suggest = "nfsv4_enabled"
        elif key == "protocolsEnabled":
            suggest = "protocols_enabled"
        elif key == "rootAccessEnabled":
            suggest = "root_access_enabled"
        elif key == "unixReadOnly":
            suggest = "unix_read_only"
        elif key == "unixReadWrite":
            suggest = "unix_read_write"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeExportPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeExportPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeExportPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_clients: Sequence[str],
                 rule_index: int,
                 cifs_enabled: Optional[bool] = None,
                 nfsv3_enabled: Optional[bool] = None,
                 nfsv4_enabled: Optional[bool] = None,
                 protocols_enabled: Optional[str] = None,
                 root_access_enabled: Optional[bool] = None,
                 unix_read_only: Optional[bool] = None,
                 unix_read_write: Optional[bool] = None):
        """
        :param Sequence[str] allowed_clients: A list of allowed clients IPv4 addresses.
        :param int rule_index: The index number of the rule.
        :param str protocols_enabled: A list of allowed protocols. Valid values include `CIFS`, `NFSv3`, or `NFSv4.1`. Only one value is supported at this time. This replaces the previous arguments: `cifs_enabled`, `nfsv3_enabled` and `nfsv4_enabled`.
        :param bool root_access_enabled: Is root access permitted to this volume?
        :param bool unix_read_only: Is the file system on unix read only?
        :param bool unix_read_write: Is the file system on unix read and write?
        """
        pulumi.set(__self__, "allowed_clients", allowed_clients)
        pulumi.set(__self__, "rule_index", rule_index)
        if cifs_enabled is not None:
            pulumi.set(__self__, "cifs_enabled", cifs_enabled)
        if nfsv3_enabled is not None:
            pulumi.set(__self__, "nfsv3_enabled", nfsv3_enabled)
        if nfsv4_enabled is not None:
            pulumi.set(__self__, "nfsv4_enabled", nfsv4_enabled)
        if protocols_enabled is not None:
            pulumi.set(__self__, "protocols_enabled", protocols_enabled)
        if root_access_enabled is not None:
            pulumi.set(__self__, "root_access_enabled", root_access_enabled)
        if unix_read_only is not None:
            pulumi.set(__self__, "unix_read_only", unix_read_only)
        if unix_read_write is not None:
            pulumi.set(__self__, "unix_read_write", unix_read_write)

    @property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Sequence[str]:
        """
        A list of allowed clients IPv4 addresses.
        """
        return pulumi.get(self, "allowed_clients")

    @property
    @pulumi.getter(name="ruleIndex")
    def rule_index(self) -> int:
        """
        The index number of the rule.
        """
        return pulumi.get(self, "rule_index")

    @property
    @pulumi.getter(name="cifsEnabled")
    def cifs_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "cifs_enabled")

    @property
    @pulumi.getter(name="nfsv3Enabled")
    def nfsv3_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "nfsv3_enabled")

    @property
    @pulumi.getter(name="nfsv4Enabled")
    def nfsv4_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "nfsv4_enabled")

    @property
    @pulumi.getter(name="protocolsEnabled")
    def protocols_enabled(self) -> Optional[str]:
        """
        A list of allowed protocols. Valid values include `CIFS`, `NFSv3`, or `NFSv4.1`. Only one value is supported at this time. This replaces the previous arguments: `cifs_enabled`, `nfsv3_enabled` and `nfsv4_enabled`.
        """
        return pulumi.get(self, "protocols_enabled")

    @property
    @pulumi.getter(name="rootAccessEnabled")
    def root_access_enabled(self) -> Optional[bool]:
        """
        Is root access permitted to this volume?
        """
        return pulumi.get(self, "root_access_enabled")

    @property
    @pulumi.getter(name="unixReadOnly")
    def unix_read_only(self) -> Optional[bool]:
        """
        Is the file system on unix read only?
        """
        return pulumi.get(self, "unix_read_only")

    @property
    @pulumi.getter(name="unixReadWrite")
    def unix_read_write(self) -> Optional[bool]:
        """
        Is the file system on unix read and write?
        """
        return pulumi.get(self, "unix_read_write")


@pulumi.output_type
class GetVolumeDataProtectionReplicationResult(dict):
    def __init__(__self__, *,
                 endpoint_type: str,
                 remote_volume_location: str,
                 remote_volume_resource_id: str,
                 replication_frequency: str,
                 replication_schedule: str):
        """
        :param str endpoint_type: The endpoint type.
        :param str remote_volume_location: Location of the primary volume.
        :param str remote_volume_resource_id: Resource ID of the primary volume.
        :param str replication_frequency: Frequency of replication.
        """
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        pulumi.set(__self__, "remote_volume_location", remote_volume_location)
        pulumi.set(__self__, "remote_volume_resource_id", remote_volume_resource_id)
        pulumi.set(__self__, "replication_frequency", replication_frequency)
        pulumi.set(__self__, "replication_schedule", replication_schedule)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> str:
        """
        The endpoint type.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="remoteVolumeLocation")
    def remote_volume_location(self) -> str:
        """
        Location of the primary volume.
        """
        return pulumi.get(self, "remote_volume_location")

    @property
    @pulumi.getter(name="remoteVolumeResourceId")
    def remote_volume_resource_id(self) -> str:
        """
        Resource ID of the primary volume.
        """
        return pulumi.get(self, "remote_volume_resource_id")

    @property
    @pulumi.getter(name="replicationFrequency")
    def replication_frequency(self) -> str:
        """
        Frequency of replication.
        """
        return pulumi.get(self, "replication_frequency")

    @property
    @pulumi.getter(name="replicationSchedule")
    def replication_schedule(self) -> str:
        return pulumi.get(self, "replication_schedule")


