# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'Features',
    'FeaturesApiManagement',
    'FeaturesAppConfiguration',
    'FeaturesApplicationInsights',
    'FeaturesCognitiveAccount',
    'FeaturesKeyVault',
    'FeaturesLogAnalyticsWorkspace',
    'FeaturesMachineLearning',
    'FeaturesManagedDisk',
    'FeaturesPostgresqlFlexibleServer',
    'FeaturesRecoveryService',
    'FeaturesRecoveryServicesVaults',
    'FeaturesResourceGroup',
    'FeaturesSubscription',
    'FeaturesTemplateDeployment',
    'FeaturesVirtualMachine',
    'FeaturesVirtualMachineScaleSet',
]

@pulumi.output_type
class Features(dict):
    def __init__(__self__, *,
                 api_management: Optional['outputs.FeaturesApiManagement'] = None,
                 app_configuration: Optional['outputs.FeaturesAppConfiguration'] = None,
                 application_insights: Optional['outputs.FeaturesApplicationInsights'] = None,
                 cognitive_account: Optional['outputs.FeaturesCognitiveAccount'] = None,
                 key_vault: Optional['outputs.FeaturesKeyVault'] = None,
                 log_analytics_workspace: Optional['outputs.FeaturesLogAnalyticsWorkspace'] = None,
                 machine_learning: Optional['outputs.FeaturesMachineLearning'] = None,
                 managed_disk: Optional['outputs.FeaturesManagedDisk'] = None,
                 postgresql_flexible_server: Optional['outputs.FeaturesPostgresqlFlexibleServer'] = None,
                 recovery_service: Optional['outputs.FeaturesRecoveryService'] = None,
                 recovery_services_vaults: Optional['outputs.FeaturesRecoveryServicesVaults'] = None,
                 resource_group: Optional['outputs.FeaturesResourceGroup'] = None,
                 subscription: Optional['outputs.FeaturesSubscription'] = None,
                 template_deployment: Optional['outputs.FeaturesTemplateDeployment'] = None,
                 virtual_machine: Optional['outputs.FeaturesVirtualMachine'] = None,
                 virtual_machine_scale_set: Optional['outputs.FeaturesVirtualMachineScaleSet'] = None):
        if api_management is not None:
            pulumi.set(__self__, "api_management", api_management)
        if app_configuration is not None:
            pulumi.set(__self__, "app_configuration", app_configuration)
        if application_insights is not None:
            pulumi.set(__self__, "application_insights", application_insights)
        if cognitive_account is not None:
            pulumi.set(__self__, "cognitive_account", cognitive_account)
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if log_analytics_workspace is not None:
            pulumi.set(__self__, "log_analytics_workspace", log_analytics_workspace)
        if machine_learning is not None:
            pulumi.set(__self__, "machine_learning", machine_learning)
        if managed_disk is not None:
            pulumi.set(__self__, "managed_disk", managed_disk)
        if postgresql_flexible_server is not None:
            pulumi.set(__self__, "postgresql_flexible_server", postgresql_flexible_server)
        if recovery_service is not None:
            pulumi.set(__self__, "recovery_service", recovery_service)
        if recovery_services_vaults is not None:
            pulumi.set(__self__, "recovery_services_vaults", recovery_services_vaults)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if template_deployment is not None:
            pulumi.set(__self__, "template_deployment", template_deployment)
        if virtual_machine is not None:
            pulumi.set(__self__, "virtual_machine", virtual_machine)
        if virtual_machine_scale_set is not None:
            pulumi.set(__self__, "virtual_machine_scale_set", virtual_machine_scale_set)

    @property
    @pulumi.getter(name="apiManagement")
    def api_management(self) -> Optional['outputs.FeaturesApiManagement']:
        return pulumi.get(self, "api_management")

    @property
    @pulumi.getter(name="appConfiguration")
    def app_configuration(self) -> Optional['outputs.FeaturesAppConfiguration']:
        return pulumi.get(self, "app_configuration")

    @property
    @pulumi.getter(name="applicationInsights")
    def application_insights(self) -> Optional['outputs.FeaturesApplicationInsights']:
        return pulumi.get(self, "application_insights")

    @property
    @pulumi.getter(name="cognitiveAccount")
    def cognitive_account(self) -> Optional['outputs.FeaturesCognitiveAccount']:
        return pulumi.get(self, "cognitive_account")

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional['outputs.FeaturesKeyVault']:
        return pulumi.get(self, "key_vault")

    @property
    @pulumi.getter(name="logAnalyticsWorkspace")
    def log_analytics_workspace(self) -> Optional['outputs.FeaturesLogAnalyticsWorkspace']:
        return pulumi.get(self, "log_analytics_workspace")

    @property
    @pulumi.getter(name="machineLearning")
    def machine_learning(self) -> Optional['outputs.FeaturesMachineLearning']:
        return pulumi.get(self, "machine_learning")

    @property
    @pulumi.getter(name="managedDisk")
    def managed_disk(self) -> Optional['outputs.FeaturesManagedDisk']:
        return pulumi.get(self, "managed_disk")

    @property
    @pulumi.getter(name="postgresqlFlexibleServer")
    def postgresql_flexible_server(self) -> Optional['outputs.FeaturesPostgresqlFlexibleServer']:
        return pulumi.get(self, "postgresql_flexible_server")

    @property
    @pulumi.getter(name="recoveryService")
    def recovery_service(self) -> Optional['outputs.FeaturesRecoveryService']:
        return pulumi.get(self, "recovery_service")

    @property
    @pulumi.getter(name="recoveryServicesVaults")
    def recovery_services_vaults(self) -> Optional['outputs.FeaturesRecoveryServicesVaults']:
        return pulumi.get(self, "recovery_services_vaults")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional['outputs.FeaturesResourceGroup']:
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.FeaturesSubscription']:
        return pulumi.get(self, "subscription")

    @property
    @pulumi.getter(name="templateDeployment")
    def template_deployment(self) -> Optional['outputs.FeaturesTemplateDeployment']:
        return pulumi.get(self, "template_deployment")

    @property
    @pulumi.getter(name="virtualMachine")
    def virtual_machine(self) -> Optional['outputs.FeaturesVirtualMachine']:
        return pulumi.get(self, "virtual_machine")

    @property
    @pulumi.getter(name="virtualMachineScaleSet")
    def virtual_machine_scale_set(self) -> Optional['outputs.FeaturesVirtualMachineScaleSet']:
        return pulumi.get(self, "virtual_machine_scale_set")


@pulumi.output_type
class FeaturesApiManagement(dict):
    def __init__(__self__, *,
                 purge_soft_delete_on_destroy: Optional[bool] = None,
                 recover_soft_deleted: Optional[bool] = None):
        if purge_soft_delete_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_delete_on_destroy", purge_soft_delete_on_destroy)
        if recover_soft_deleted is not None:
            pulumi.set(__self__, "recover_soft_deleted", recover_soft_deleted)

    @property
    @pulumi.getter(name="purgeSoftDeleteOnDestroy")
    def purge_soft_delete_on_destroy(self) -> Optional[bool]:
        return pulumi.get(self, "purge_soft_delete_on_destroy")

    @property
    @pulumi.getter(name="recoverSoftDeleted")
    def recover_soft_deleted(self) -> Optional[bool]:
        return pulumi.get(self, "recover_soft_deleted")


@pulumi.output_type
class FeaturesAppConfiguration(dict):
    def __init__(__self__, *,
                 purge_soft_delete_on_destroy: Optional[bool] = None,
                 recover_soft_deleted: Optional[bool] = None):
        if purge_soft_delete_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_delete_on_destroy", purge_soft_delete_on_destroy)
        if recover_soft_deleted is not None:
            pulumi.set(__self__, "recover_soft_deleted", recover_soft_deleted)

    @property
    @pulumi.getter(name="purgeSoftDeleteOnDestroy")
    def purge_soft_delete_on_destroy(self) -> Optional[bool]:
        return pulumi.get(self, "purge_soft_delete_on_destroy")

    @property
    @pulumi.getter(name="recoverSoftDeleted")
    def recover_soft_deleted(self) -> Optional[bool]:
        return pulumi.get(self, "recover_soft_deleted")


@pulumi.output_type
class FeaturesApplicationInsights(dict):
    def __init__(__self__, *,
                 disable_generated_rule: Optional[bool] = None):
        if disable_generated_rule is not None:
            pulumi.set(__self__, "disable_generated_rule", disable_generated_rule)

    @property
    @pulumi.getter(name="disableGeneratedRule")
    def disable_generated_rule(self) -> Optional[bool]:
        return pulumi.get(self, "disable_generated_rule")


@pulumi.output_type
class FeaturesCognitiveAccount(dict):
    def __init__(__self__, *,
                 purge_soft_delete_on_destroy: Optional[bool] = None):
        if purge_soft_delete_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_delete_on_destroy", purge_soft_delete_on_destroy)

    @property
    @pulumi.getter(name="purgeSoftDeleteOnDestroy")
    def purge_soft_delete_on_destroy(self) -> Optional[bool]:
        return pulumi.get(self, "purge_soft_delete_on_destroy")


@pulumi.output_type
class FeaturesKeyVault(dict):
    def __init__(__self__, *,
                 purge_soft_delete_on_destroy: Optional[bool] = None,
                 purge_soft_deleted_certificates_on_destroy: Optional[bool] = None,
                 purge_soft_deleted_hardware_security_module_keys_on_destroy: Optional[bool] = None,
                 purge_soft_deleted_hardware_security_modules_on_destroy: Optional[bool] = None,
                 purge_soft_deleted_keys_on_destroy: Optional[bool] = None,
                 purge_soft_deleted_secrets_on_destroy: Optional[bool] = None,
                 recover_soft_deleted_certificates: Optional[bool] = None,
                 recover_soft_deleted_hardware_security_module_keys: Optional[bool] = None,
                 recover_soft_deleted_key_vaults: Optional[bool] = None,
                 recover_soft_deleted_keys: Optional[bool] = None,
                 recover_soft_deleted_secrets: Optional[bool] = None):
        """
        :param bool purge_soft_delete_on_destroy: When enabled soft-deleted `keyvault.KeyVault` resources will be permanently deleted (e.g purged), when destroyed
        :param bool purge_soft_deleted_certificates_on_destroy: When enabled soft-deleted `keyvault.Certificate` resources will be permanently deleted (e.g purged), when destroyed
        :param bool purge_soft_deleted_hardware_security_module_keys_on_destroy: When enabled soft-deleted `keyvault.ManagedHardwareSecurityModuleKey` resources will be permanently deleted (e.g purged), when destroyed
        :param bool purge_soft_deleted_hardware_security_modules_on_destroy: When enabled soft-deleted `keyvault.ManagedHardwareSecurityModule` resources will be permanently deleted (e.g purged), when destroyed
        :param bool purge_soft_deleted_keys_on_destroy: When enabled soft-deleted `keyvault.Key` resources will be permanently deleted (e.g purged), when destroyed
        :param bool purge_soft_deleted_secrets_on_destroy: When enabled soft-deleted `keyvault.Secret` resources will be permanently deleted (e.g purged), when destroyed
        :param bool recover_soft_deleted_certificates: When enabled soft-deleted `keyvault.Certificate` resources will be restored, instead of creating new ones
        :param bool recover_soft_deleted_hardware_security_module_keys: When enabled soft-deleted `keyvault.ManagedHardwareSecurityModuleKey` resources will be restored, instead of creating new ones
        :param bool recover_soft_deleted_key_vaults: When enabled soft-deleted `keyvault.KeyVault` resources will be restored, instead of creating new ones
        :param bool recover_soft_deleted_keys: When enabled soft-deleted `keyvault.Key` resources will be restored, instead of creating new ones
        :param bool recover_soft_deleted_secrets: When enabled soft-deleted `keyvault.Secret` resources will be restored, instead of creating new ones
        """
        if purge_soft_delete_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_delete_on_destroy", purge_soft_delete_on_destroy)
        if purge_soft_deleted_certificates_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_deleted_certificates_on_destroy", purge_soft_deleted_certificates_on_destroy)
        if purge_soft_deleted_hardware_security_module_keys_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_deleted_hardware_security_module_keys_on_destroy", purge_soft_deleted_hardware_security_module_keys_on_destroy)
        if purge_soft_deleted_hardware_security_modules_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_deleted_hardware_security_modules_on_destroy", purge_soft_deleted_hardware_security_modules_on_destroy)
        if purge_soft_deleted_keys_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_deleted_keys_on_destroy", purge_soft_deleted_keys_on_destroy)
        if purge_soft_deleted_secrets_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_deleted_secrets_on_destroy", purge_soft_deleted_secrets_on_destroy)
        if recover_soft_deleted_certificates is not None:
            pulumi.set(__self__, "recover_soft_deleted_certificates", recover_soft_deleted_certificates)
        if recover_soft_deleted_hardware_security_module_keys is not None:
            pulumi.set(__self__, "recover_soft_deleted_hardware_security_module_keys", recover_soft_deleted_hardware_security_module_keys)
        if recover_soft_deleted_key_vaults is not None:
            pulumi.set(__self__, "recover_soft_deleted_key_vaults", recover_soft_deleted_key_vaults)
        if recover_soft_deleted_keys is not None:
            pulumi.set(__self__, "recover_soft_deleted_keys", recover_soft_deleted_keys)
        if recover_soft_deleted_secrets is not None:
            pulumi.set(__self__, "recover_soft_deleted_secrets", recover_soft_deleted_secrets)

    @property
    @pulumi.getter(name="purgeSoftDeleteOnDestroy")
    def purge_soft_delete_on_destroy(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.KeyVault` resources will be permanently deleted (e.g purged), when destroyed
        """
        return pulumi.get(self, "purge_soft_delete_on_destroy")

    @property
    @pulumi.getter(name="purgeSoftDeletedCertificatesOnDestroy")
    def purge_soft_deleted_certificates_on_destroy(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.Certificate` resources will be permanently deleted (e.g purged), when destroyed
        """
        return pulumi.get(self, "purge_soft_deleted_certificates_on_destroy")

    @property
    @pulumi.getter(name="purgeSoftDeletedHardwareSecurityModuleKeysOnDestroy")
    def purge_soft_deleted_hardware_security_module_keys_on_destroy(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.ManagedHardwareSecurityModuleKey` resources will be permanently deleted (e.g purged), when destroyed
        """
        return pulumi.get(self, "purge_soft_deleted_hardware_security_module_keys_on_destroy")

    @property
    @pulumi.getter(name="purgeSoftDeletedHardwareSecurityModulesOnDestroy")
    def purge_soft_deleted_hardware_security_modules_on_destroy(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.ManagedHardwareSecurityModule` resources will be permanently deleted (e.g purged), when destroyed
        """
        return pulumi.get(self, "purge_soft_deleted_hardware_security_modules_on_destroy")

    @property
    @pulumi.getter(name="purgeSoftDeletedKeysOnDestroy")
    def purge_soft_deleted_keys_on_destroy(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.Key` resources will be permanently deleted (e.g purged), when destroyed
        """
        return pulumi.get(self, "purge_soft_deleted_keys_on_destroy")

    @property
    @pulumi.getter(name="purgeSoftDeletedSecretsOnDestroy")
    def purge_soft_deleted_secrets_on_destroy(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.Secret` resources will be permanently deleted (e.g purged), when destroyed
        """
        return pulumi.get(self, "purge_soft_deleted_secrets_on_destroy")

    @property
    @pulumi.getter(name="recoverSoftDeletedCertificates")
    def recover_soft_deleted_certificates(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.Certificate` resources will be restored, instead of creating new ones
        """
        return pulumi.get(self, "recover_soft_deleted_certificates")

    @property
    @pulumi.getter(name="recoverSoftDeletedHardwareSecurityModuleKeys")
    def recover_soft_deleted_hardware_security_module_keys(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.ManagedHardwareSecurityModuleKey` resources will be restored, instead of creating new ones
        """
        return pulumi.get(self, "recover_soft_deleted_hardware_security_module_keys")

    @property
    @pulumi.getter(name="recoverSoftDeletedKeyVaults")
    def recover_soft_deleted_key_vaults(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.KeyVault` resources will be restored, instead of creating new ones
        """
        return pulumi.get(self, "recover_soft_deleted_key_vaults")

    @property
    @pulumi.getter(name="recoverSoftDeletedKeys")
    def recover_soft_deleted_keys(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.Key` resources will be restored, instead of creating new ones
        """
        return pulumi.get(self, "recover_soft_deleted_keys")

    @property
    @pulumi.getter(name="recoverSoftDeletedSecrets")
    def recover_soft_deleted_secrets(self) -> Optional[bool]:
        """
        When enabled soft-deleted `keyvault.Secret` resources will be restored, instead of creating new ones
        """
        return pulumi.get(self, "recover_soft_deleted_secrets")


@pulumi.output_type
class FeaturesLogAnalyticsWorkspace(dict):
    def __init__(__self__, *,
                 permanently_delete_on_destroy: Optional[bool] = None):
        if permanently_delete_on_destroy is not None:
            pulumi.set(__self__, "permanently_delete_on_destroy", permanently_delete_on_destroy)

    @property
    @pulumi.getter(name="permanentlyDeleteOnDestroy")
    def permanently_delete_on_destroy(self) -> Optional[bool]:
        return pulumi.get(self, "permanently_delete_on_destroy")


@pulumi.output_type
class FeaturesMachineLearning(dict):
    def __init__(__self__, *,
                 purge_soft_deleted_workspace_on_destroy: Optional[bool] = None):
        if purge_soft_deleted_workspace_on_destroy is not None:
            pulumi.set(__self__, "purge_soft_deleted_workspace_on_destroy", purge_soft_deleted_workspace_on_destroy)

    @property
    @pulumi.getter(name="purgeSoftDeletedWorkspaceOnDestroy")
    def purge_soft_deleted_workspace_on_destroy(self) -> Optional[bool]:
        return pulumi.get(self, "purge_soft_deleted_workspace_on_destroy")


@pulumi.output_type
class FeaturesManagedDisk(dict):
    def __init__(__self__, *,
                 expand_without_downtime: Optional[bool] = None):
        if expand_without_downtime is not None:
            pulumi.set(__self__, "expand_without_downtime", expand_without_downtime)

    @property
    @pulumi.getter(name="expandWithoutDowntime")
    def expand_without_downtime(self) -> Optional[bool]:
        return pulumi.get(self, "expand_without_downtime")


@pulumi.output_type
class FeaturesPostgresqlFlexibleServer(dict):
    def __init__(__self__, *,
                 restart_server_on_configuration_value_change: Optional[bool] = None):
        if restart_server_on_configuration_value_change is not None:
            pulumi.set(__self__, "restart_server_on_configuration_value_change", restart_server_on_configuration_value_change)

    @property
    @pulumi.getter(name="restartServerOnConfigurationValueChange")
    def restart_server_on_configuration_value_change(self) -> Optional[bool]:
        return pulumi.get(self, "restart_server_on_configuration_value_change")


@pulumi.output_type
class FeaturesRecoveryService(dict):
    def __init__(__self__, *,
                 purge_protected_items_from_vault_on_destroy: Optional[bool] = None,
                 vm_backup_stop_protection_and_retain_data_on_destroy: Optional[bool] = None):
        if purge_protected_items_from_vault_on_destroy is not None:
            pulumi.set(__self__, "purge_protected_items_from_vault_on_destroy", purge_protected_items_from_vault_on_destroy)
        if vm_backup_stop_protection_and_retain_data_on_destroy is not None:
            pulumi.set(__self__, "vm_backup_stop_protection_and_retain_data_on_destroy", vm_backup_stop_protection_and_retain_data_on_destroy)

    @property
    @pulumi.getter(name="purgeProtectedItemsFromVaultOnDestroy")
    def purge_protected_items_from_vault_on_destroy(self) -> Optional[bool]:
        return pulumi.get(self, "purge_protected_items_from_vault_on_destroy")

    @property
    @pulumi.getter(name="vmBackupStopProtectionAndRetainDataOnDestroy")
    def vm_backup_stop_protection_and_retain_data_on_destroy(self) -> Optional[bool]:
        return pulumi.get(self, "vm_backup_stop_protection_and_retain_data_on_destroy")


@pulumi.output_type
class FeaturesRecoveryServicesVaults(dict):
    def __init__(__self__, *,
                 recover_soft_deleted_backup_protected_vm: Optional[bool] = None):
        if recover_soft_deleted_backup_protected_vm is not None:
            pulumi.set(__self__, "recover_soft_deleted_backup_protected_vm", recover_soft_deleted_backup_protected_vm)

    @property
    @pulumi.getter(name="recoverSoftDeletedBackupProtectedVm")
    def recover_soft_deleted_backup_protected_vm(self) -> Optional[bool]:
        return pulumi.get(self, "recover_soft_deleted_backup_protected_vm")


@pulumi.output_type
class FeaturesResourceGroup(dict):
    def __init__(__self__, *,
                 prevent_deletion_if_contains_resources: Optional[bool] = None):
        if prevent_deletion_if_contains_resources is not None:
            pulumi.set(__self__, "prevent_deletion_if_contains_resources", prevent_deletion_if_contains_resources)

    @property
    @pulumi.getter(name="preventDeletionIfContainsResources")
    def prevent_deletion_if_contains_resources(self) -> Optional[bool]:
        return pulumi.get(self, "prevent_deletion_if_contains_resources")


@pulumi.output_type
class FeaturesSubscription(dict):
    def __init__(__self__, *,
                 prevent_cancellation_on_destroy: Optional[bool] = None):
        if prevent_cancellation_on_destroy is not None:
            pulumi.set(__self__, "prevent_cancellation_on_destroy", prevent_cancellation_on_destroy)

    @property
    @pulumi.getter(name="preventCancellationOnDestroy")
    def prevent_cancellation_on_destroy(self) -> Optional[bool]:
        return pulumi.get(self, "prevent_cancellation_on_destroy")


@pulumi.output_type
class FeaturesTemplateDeployment(dict):
    def __init__(__self__, *,
                 delete_nested_items_during_deletion: bool):
        pulumi.set(__self__, "delete_nested_items_during_deletion", delete_nested_items_during_deletion)

    @property
    @pulumi.getter(name="deleteNestedItemsDuringDeletion")
    def delete_nested_items_during_deletion(self) -> bool:
        return pulumi.get(self, "delete_nested_items_during_deletion")


@pulumi.output_type
class FeaturesVirtualMachine(dict):
    def __init__(__self__, *,
                 delete_os_disk_on_deletion: Optional[bool] = None,
                 detach_implicit_data_disk_on_deletion: Optional[bool] = None,
                 graceful_shutdown: Optional[bool] = None,
                 skip_shutdown_and_force_delete: Optional[bool] = None):
        if delete_os_disk_on_deletion is not None:
            pulumi.set(__self__, "delete_os_disk_on_deletion", delete_os_disk_on_deletion)
        if detach_implicit_data_disk_on_deletion is not None:
            pulumi.set(__self__, "detach_implicit_data_disk_on_deletion", detach_implicit_data_disk_on_deletion)
        if graceful_shutdown is not None:
            pulumi.set(__self__, "graceful_shutdown", graceful_shutdown)
        if skip_shutdown_and_force_delete is not None:
            pulumi.set(__self__, "skip_shutdown_and_force_delete", skip_shutdown_and_force_delete)

    @property
    @pulumi.getter(name="deleteOsDiskOnDeletion")
    def delete_os_disk_on_deletion(self) -> Optional[bool]:
        return pulumi.get(self, "delete_os_disk_on_deletion")

    @property
    @pulumi.getter(name="detachImplicitDataDiskOnDeletion")
    def detach_implicit_data_disk_on_deletion(self) -> Optional[bool]:
        return pulumi.get(self, "detach_implicit_data_disk_on_deletion")

    @property
    @pulumi.getter(name="gracefulShutdown")
    def graceful_shutdown(self) -> Optional[bool]:
        return pulumi.get(self, "graceful_shutdown")

    @property
    @pulumi.getter(name="skipShutdownAndForceDelete")
    def skip_shutdown_and_force_delete(self) -> Optional[bool]:
        return pulumi.get(self, "skip_shutdown_and_force_delete")


@pulumi.output_type
class FeaturesVirtualMachineScaleSet(dict):
    def __init__(__self__, *,
                 force_delete: Optional[bool] = None,
                 reimage_on_manual_upgrade: Optional[bool] = None,
                 roll_instances_when_required: Optional[bool] = None,
                 scale_to_zero_before_deletion: Optional[bool] = None):
        if force_delete is not None:
            pulumi.set(__self__, "force_delete", force_delete)
        if reimage_on_manual_upgrade is not None:
            pulumi.set(__self__, "reimage_on_manual_upgrade", reimage_on_manual_upgrade)
        if roll_instances_when_required is not None:
            pulumi.set(__self__, "roll_instances_when_required", roll_instances_when_required)
        if scale_to_zero_before_deletion is not None:
            pulumi.set(__self__, "scale_to_zero_before_deletion", scale_to_zero_before_deletion)

    @property
    @pulumi.getter(name="forceDelete")
    def force_delete(self) -> Optional[bool]:
        return pulumi.get(self, "force_delete")

    @property
    @pulumi.getter(name="reimageOnManualUpgrade")
    def reimage_on_manual_upgrade(self) -> Optional[bool]:
        return pulumi.get(self, "reimage_on_manual_upgrade")

    @property
    @pulumi.getter(name="rollInstancesWhenRequired")
    def roll_instances_when_required(self) -> Optional[bool]:
        return pulumi.get(self, "roll_instances_when_required")

    @property
    @pulumi.getter(name="scaleToZeroBeforeDeletion")
    def scale_to_zero_before_deletion(self) -> Optional[bool]:
        return pulumi.get(self, "scale_to_zero_before_deletion")


