# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ServiceCor',
    'ServiceIdentity',
    'ServiceLiveTrace',
    'ServiceNetworkAclPrivateEndpoint',
    'ServiceNetworkAclPublicNetwork',
    'ServiceSku',
    'ServiceUpstreamEndpoint',
]

@pulumi.output_type
class ServiceCor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceCor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceCor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceCor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[str]):
        """
        :param Sequence[str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        ServiceCor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_origins=allowed_origins,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_origins: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("allowed_origins", allowed_origins)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")


@pulumi.output_type
class ServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str type: Specifies the type of Managed Service Identity that should be configured on this signalR. Possible values are `SystemAssigned`, `UserAssigned`.
        :param Sequence[str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this signalR.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`
        """
        ServiceIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            identity_ids=identity_ids,
            principal_id=principal_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             identity_ids: Optional[Sequence[str]] = None,
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if identity_ids is not None:
            _setter("identity_ids", identity_ids)
        if principal_id is not None:
            _setter("principal_id", principal_id)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of Managed Service Identity that should be configured on this signalR. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this signalR.

        > **NOTE:** This is required when `type` is set to `UserAssigned`
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ServiceLiveTrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectivityLogsEnabled":
            suggest = "connectivity_logs_enabled"
        elif key == "httpRequestLogsEnabled":
            suggest = "http_request_logs_enabled"
        elif key == "messagingLogsEnabled":
            suggest = "messaging_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLiveTrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLiveTrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLiveTrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connectivity_logs_enabled: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 http_request_logs_enabled: Optional[bool] = None,
                 messaging_logs_enabled: Optional[bool] = None):
        """
        :param bool connectivity_logs_enabled: Whether the log category `ConnectivityLogs` is enabled? Defaults to `true`
        :param bool enabled: Whether the live trace is enabled? Defaults to `true`.
        :param bool http_request_logs_enabled: Whether the log category `HttpRequestLogs` is enabled? Defaults to `true`
        :param bool messaging_logs_enabled: Whether the log category `MessagingLogs` is enabled? Defaults to `true`
        """
        ServiceLiveTrace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connectivity_logs_enabled=connectivity_logs_enabled,
            enabled=enabled,
            http_request_logs_enabled=http_request_logs_enabled,
            messaging_logs_enabled=messaging_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connectivity_logs_enabled: Optional[bool] = None,
             enabled: Optional[bool] = None,
             http_request_logs_enabled: Optional[bool] = None,
             messaging_logs_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connectivity_logs_enabled is not None:
            _setter("connectivity_logs_enabled", connectivity_logs_enabled)
        if enabled is not None:
            _setter("enabled", enabled)
        if http_request_logs_enabled is not None:
            _setter("http_request_logs_enabled", http_request_logs_enabled)
        if messaging_logs_enabled is not None:
            _setter("messaging_logs_enabled", messaging_logs_enabled)

    @property
    @pulumi.getter(name="connectivityLogsEnabled")
    def connectivity_logs_enabled(self) -> Optional[bool]:
        """
        Whether the log category `ConnectivityLogs` is enabled? Defaults to `true`
        """
        return pulumi.get(self, "connectivity_logs_enabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the live trace is enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="httpRequestLogsEnabled")
    def http_request_logs_enabled(self) -> Optional[bool]:
        """
        Whether the log category `HttpRequestLogs` is enabled? Defaults to `true`
        """
        return pulumi.get(self, "http_request_logs_enabled")

    @property
    @pulumi.getter(name="messagingLogsEnabled")
    def messaging_logs_enabled(self) -> Optional[bool]:
        """
        Whether the log category `MessagingLogs` is enabled? Defaults to `true`
        """
        return pulumi.get(self, "messaging_logs_enabled")


@pulumi.output_type
class ServiceNetworkAclPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedRequestTypes":
            suggest = "allowed_request_types"
        elif key == "deniedRequestTypes":
            suggest = "denied_request_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNetworkAclPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNetworkAclPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNetworkAclPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 allowed_request_types: Optional[Sequence[str]] = None,
                 denied_request_types: Optional[Sequence[str]] = None):
        """
        :param str id: The ID of the Private Endpoint which is based on the SignalR service.
        :param Sequence[str] allowed_request_types: The allowed request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
               
               > **Note:** When `default_action` is `Allow`, `allowed_request_types`cannot be set.
        :param Sequence[str] denied_request_types: The denied request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
               
               > **Note:** When `default_action` is `Deny`, `denied_request_types`cannot be set.
               
               > **Note:** `allowed_request_types` - (Optional) and `denied_request_types` cannot be set together.
        """
        ServiceNetworkAclPrivateEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            allowed_request_types=allowed_request_types,
            denied_request_types=denied_request_types,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             allowed_request_types: Optional[Sequence[str]] = None,
             denied_request_types: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if allowed_request_types is not None:
            _setter("allowed_request_types", allowed_request_types)
        if denied_request_types is not None:
            _setter("denied_request_types", denied_request_types)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Private Endpoint which is based on the SignalR service.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="allowedRequestTypes")
    def allowed_request_types(self) -> Optional[Sequence[str]]:
        """
        The allowed request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.

        > **Note:** When `default_action` is `Allow`, `allowed_request_types`cannot be set.
        """
        return pulumi.get(self, "allowed_request_types")

    @property
    @pulumi.getter(name="deniedRequestTypes")
    def denied_request_types(self) -> Optional[Sequence[str]]:
        """
        The denied request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.

        > **Note:** When `default_action` is `Deny`, `denied_request_types`cannot be set.

        > **Note:** `allowed_request_types` - (Optional) and `denied_request_types` cannot be set together.
        """
        return pulumi.get(self, "denied_request_types")


@pulumi.output_type
class ServiceNetworkAclPublicNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedRequestTypes":
            suggest = "allowed_request_types"
        elif key == "deniedRequestTypes":
            suggest = "denied_request_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNetworkAclPublicNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNetworkAclPublicNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNetworkAclPublicNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_request_types: Optional[Sequence[str]] = None,
                 denied_request_types: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] allowed_request_types: The allowed request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
               
               > **Note:** When `default_action` is `Allow`, `allowed_request_types`cannot be set.
        :param Sequence[str] denied_request_types: The denied request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
               
               > **Note:** When `default_action` is `Deny`, `denied_request_types`cannot be set.
               
               > **Note:** `allowed_request_types` - (Optional) and `denied_request_types` cannot be set together.
        """
        ServiceNetworkAclPublicNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_request_types=allowed_request_types,
            denied_request_types=denied_request_types,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_request_types: Optional[Sequence[str]] = None,
             denied_request_types: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allowed_request_types is not None:
            _setter("allowed_request_types", allowed_request_types)
        if denied_request_types is not None:
            _setter("denied_request_types", denied_request_types)

    @property
    @pulumi.getter(name="allowedRequestTypes")
    def allowed_request_types(self) -> Optional[Sequence[str]]:
        """
        The allowed request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.

        > **Note:** When `default_action` is `Allow`, `allowed_request_types`cannot be set.
        """
        return pulumi.get(self, "allowed_request_types")

    @property
    @pulumi.getter(name="deniedRequestTypes")
    def denied_request_types(self) -> Optional[Sequence[str]]:
        """
        The denied request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.

        > **Note:** When `default_action` is `Deny`, `denied_request_types`cannot be set.

        > **Note:** `allowed_request_types` - (Optional) and `denied_request_types` cannot be set together.
        """
        return pulumi.get(self, "denied_request_types")


@pulumi.output_type
class ServiceSku(dict):
    def __init__(__self__, *,
                 capacity: int,
                 name: str):
        """
        :param int capacity: Specifies the number of units associated with this SignalR service. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90` and `100`.
        :param str name: Specifies which tier to use. Valid values are `Free_F1`, `Standard_S1` and `Premium_P1`.
        """
        ServiceSku._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity=capacity,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity: int,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("capacity", capacity)
        _setter("name", name)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Specifies the number of units associated with this SignalR service. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90` and `100`.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies which tier to use. Valid values are `Free_F1`, `Standard_S1` and `Premium_P1`.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ServiceUpstreamEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryPatterns":
            suggest = "category_patterns"
        elif key == "eventPatterns":
            suggest = "event_patterns"
        elif key == "hubPatterns":
            suggest = "hub_patterns"
        elif key == "urlTemplate":
            suggest = "url_template"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceUpstreamEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceUpstreamEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceUpstreamEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_patterns: Sequence[str],
                 event_patterns: Sequence[str],
                 hub_patterns: Sequence[str],
                 url_template: str,
                 user_assigned_identity_id: Optional[str] = None):
        """
        :param Sequence[str] category_patterns: The categories to match on, or `*` for all.
        :param Sequence[str] event_patterns: The events to match on, or `*` for all.
        :param Sequence[str] hub_patterns: The hubs to match on, or `*` for all.
        :param str url_template: The upstream URL Template. This can be a url or a template such as `http://host.com/{hub}/api/{category}/{event}`.
        :param str user_assigned_identity_id: Specifies the Managed Identity IDs to be assigned to this signalR upstream setting by using resource uuid as both system assigned and user assigned identity is supported.
        """
        ServiceUpstreamEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category_patterns=category_patterns,
            event_patterns=event_patterns,
            hub_patterns=hub_patterns,
            url_template=url_template,
            user_assigned_identity_id=user_assigned_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category_patterns: Sequence[str],
             event_patterns: Sequence[str],
             hub_patterns: Sequence[str],
             url_template: str,
             user_assigned_identity_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("category_patterns", category_patterns)
        _setter("event_patterns", event_patterns)
        _setter("hub_patterns", hub_patterns)
        _setter("url_template", url_template)
        if user_assigned_identity_id is not None:
            _setter("user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="categoryPatterns")
    def category_patterns(self) -> Sequence[str]:
        """
        The categories to match on, or `*` for all.
        """
        return pulumi.get(self, "category_patterns")

    @property
    @pulumi.getter(name="eventPatterns")
    def event_patterns(self) -> Sequence[str]:
        """
        The events to match on, or `*` for all.
        """
        return pulumi.get(self, "event_patterns")

    @property
    @pulumi.getter(name="hubPatterns")
    def hub_patterns(self) -> Sequence[str]:
        """
        The hubs to match on, or `*` for all.
        """
        return pulumi.get(self, "hub_patterns")

    @property
    @pulumi.getter(name="urlTemplate")
    def url_template(self) -> str:
        """
        The upstream URL Template. This can be a url or a template such as `http://host.com/{hub}/api/{category}/{event}`.
        """
        return pulumi.get(self, "url_template")

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[str]:
        """
        Specifies the Managed Identity IDs to be assigned to this signalR upstream setting by using resource uuid as both system assigned and user assigned identity is supported.
        """
        return pulumi.get(self, "user_assigned_identity_id")


