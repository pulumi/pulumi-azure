# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ServiceCor',
    'ServiceIdentity',
    'ServiceLiveTrace',
    'ServiceNetworkAclPrivateEndpoint',
    'ServiceNetworkAclPublicNetwork',
    'ServiceSku',
    'ServiceUpstreamEndpoint',
]

@pulumi.output_type
class ServiceCor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceCor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceCor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceCor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[_builtins.str]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")


@pulumi.output_type
class ServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 identity_ids: Optional[Sequence[_builtins.str]] = None,
                 principal_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the type of Managed Service Identity that should be configured on this signalR. Possible values are `SystemAssigned`, `UserAssigned`.
        :param Sequence[_builtins.str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this signalR.
               
               > **Note:** This is required when `type` is set to `UserAssigned`
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of Managed Service Identity that should be configured on this signalR. Possible values are `SystemAssigned`, `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this signalR.

        > **Note:** This is required when `type` is set to `UserAssigned`
        """
        return pulumi.get(self, "identity_ids")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ServiceLiveTrace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectivityLogsEnabled":
            suggest = "connectivity_logs_enabled"
        elif key == "httpRequestLogsEnabled":
            suggest = "http_request_logs_enabled"
        elif key == "messagingLogsEnabled":
            suggest = "messaging_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLiveTrace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLiveTrace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLiveTrace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connectivity_logs_enabled: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 http_request_logs_enabled: Optional[_builtins.bool] = None,
                 messaging_logs_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool connectivity_logs_enabled: Whether the log category `ConnectivityLogs` is enabled? Defaults to `true`
        :param _builtins.bool enabled: Whether the live trace is enabled? Defaults to `true`.
        :param _builtins.bool http_request_logs_enabled: Whether the log category `HttpRequestLogs` is enabled? Defaults to `true`
        :param _builtins.bool messaging_logs_enabled: Whether the log category `MessagingLogs` is enabled? Defaults to `true`
        """
        if connectivity_logs_enabled is not None:
            pulumi.set(__self__, "connectivity_logs_enabled", connectivity_logs_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if http_request_logs_enabled is not None:
            pulumi.set(__self__, "http_request_logs_enabled", http_request_logs_enabled)
        if messaging_logs_enabled is not None:
            pulumi.set(__self__, "messaging_logs_enabled", messaging_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="connectivityLogsEnabled")
    def connectivity_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether the log category `ConnectivityLogs` is enabled? Defaults to `true`
        """
        return pulumi.get(self, "connectivity_logs_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether the live trace is enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="httpRequestLogsEnabled")
    def http_request_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether the log category `HttpRequestLogs` is enabled? Defaults to `true`
        """
        return pulumi.get(self, "http_request_logs_enabled")

    @_builtins.property
    @pulumi.getter(name="messagingLogsEnabled")
    def messaging_logs_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether the log category `MessagingLogs` is enabled? Defaults to `true`
        """
        return pulumi.get(self, "messaging_logs_enabled")


@pulumi.output_type
class ServiceNetworkAclPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedRequestTypes":
            suggest = "allowed_request_types"
        elif key == "deniedRequestTypes":
            suggest = "denied_request_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNetworkAclPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNetworkAclPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNetworkAclPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 allowed_request_types: Optional[Sequence[_builtins.str]] = None,
                 denied_request_types: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str id: The ID of the Private Endpoint which is based on the SignalR service.
        :param Sequence[_builtins.str] allowed_request_types: The allowed request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
               
               > **Note:** When `default_action` is `Allow`, `allowed_request_types`cannot be set.
        :param Sequence[_builtins.str] denied_request_types: The denied request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
               
               > **Note:** When `default_action` is `Deny`, `denied_request_types`cannot be set.
               
               > **Note:** `allowed_request_types` - (Optional) and `denied_request_types` cannot be set together.
        """
        pulumi.set(__self__, "id", id)
        if allowed_request_types is not None:
            pulumi.set(__self__, "allowed_request_types", allowed_request_types)
        if denied_request_types is not None:
            pulumi.set(__self__, "denied_request_types", denied_request_types)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Private Endpoint which is based on the SignalR service.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="allowedRequestTypes")
    def allowed_request_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The allowed request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.

        > **Note:** When `default_action` is `Allow`, `allowed_request_types`cannot be set.
        """
        return pulumi.get(self, "allowed_request_types")

    @_builtins.property
    @pulumi.getter(name="deniedRequestTypes")
    def denied_request_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The denied request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.

        > **Note:** When `default_action` is `Deny`, `denied_request_types`cannot be set.

        > **Note:** `allowed_request_types` - (Optional) and `denied_request_types` cannot be set together.
        """
        return pulumi.get(self, "denied_request_types")


@pulumi.output_type
class ServiceNetworkAclPublicNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedRequestTypes":
            suggest = "allowed_request_types"
        elif key == "deniedRequestTypes":
            suggest = "denied_request_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNetworkAclPublicNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNetworkAclPublicNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNetworkAclPublicNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_request_types: Optional[Sequence[_builtins.str]] = None,
                 denied_request_types: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] allowed_request_types: The allowed request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
               
               > **Note:** When `default_action` is `Allow`, `allowed_request_types`cannot be set.
        :param Sequence[_builtins.str] denied_request_types: The denied request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
               
               > **Note:** When `default_action` is `Deny`, `denied_request_types`cannot be set.
               
               > **Note:** `allowed_request_types` - (Optional) and `denied_request_types` cannot be set together.
        """
        if allowed_request_types is not None:
            pulumi.set(__self__, "allowed_request_types", allowed_request_types)
        if denied_request_types is not None:
            pulumi.set(__self__, "denied_request_types", denied_request_types)

    @_builtins.property
    @pulumi.getter(name="allowedRequestTypes")
    def allowed_request_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The allowed request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.

        > **Note:** When `default_action` is `Allow`, `allowed_request_types`cannot be set.
        """
        return pulumi.get(self, "allowed_request_types")

    @_builtins.property
    @pulumi.getter(name="deniedRequestTypes")
    def denied_request_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The denied request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.

        > **Note:** When `default_action` is `Deny`, `denied_request_types`cannot be set.

        > **Note:** `allowed_request_types` - (Optional) and `denied_request_types` cannot be set together.
        """
        return pulumi.get(self, "denied_request_types")


@pulumi.output_type
class ServiceSku(dict):
    def __init__(__self__, *,
                 capacity: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.int capacity: Specifies the number of units associated with this SignalR service. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, `100`, `200`, `300`, `400`, `500`, `600`, `700`, `800`, `900` and `1000`.
               
               > **Note:** The valid capacity range for sku `Free_F1` is `1`, for sku `Premium_P2` is from `100` to `1000`, and from `1` to `100` for sku `Standard_S1` and `Premium_P1`.
        :param _builtins.str name: Specifies which tier to use. Valid values are `Free_F1`, `Standard_S1`, `Premium_P1` and `Premium_P2`.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.int:
        """
        Specifies the number of units associated with this SignalR service. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90`, `100`, `200`, `300`, `400`, `500`, `600`, `700`, `800`, `900` and `1000`.

        > **Note:** The valid capacity range for sku `Free_F1` is `1`, for sku `Premium_P2` is from `100` to `1000`, and from `1` to `100` for sku `Standard_S1` and `Premium_P1`.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies which tier to use. Valid values are `Free_F1`, `Standard_S1`, `Premium_P1` and `Premium_P2`.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ServiceUpstreamEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryPatterns":
            suggest = "category_patterns"
        elif key == "eventPatterns":
            suggest = "event_patterns"
        elif key == "hubPatterns":
            suggest = "hub_patterns"
        elif key == "urlTemplate":
            suggest = "url_template"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceUpstreamEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceUpstreamEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceUpstreamEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_patterns: Sequence[_builtins.str],
                 event_patterns: Sequence[_builtins.str],
                 hub_patterns: Sequence[_builtins.str],
                 url_template: _builtins.str,
                 user_assigned_identity_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] category_patterns: The categories to match on, or `*` for all.
        :param Sequence[_builtins.str] event_patterns: The events to match on, or `*` for all.
        :param Sequence[_builtins.str] hub_patterns: The hubs to match on, or `*` for all.
        :param _builtins.str url_template: The upstream URL Template. This can be a url or a template such as `http://host.com/{hub}/api/{category}/{event}`.
        :param _builtins.str user_assigned_identity_id: Specifies the Managed Identity IDs to be assigned to this signalR upstream setting by using resource uuid as both system assigned and user assigned identity is supported.
        """
        pulumi.set(__self__, "category_patterns", category_patterns)
        pulumi.set(__self__, "event_patterns", event_patterns)
        pulumi.set(__self__, "hub_patterns", hub_patterns)
        pulumi.set(__self__, "url_template", url_template)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="categoryPatterns")
    def category_patterns(self) -> Sequence[_builtins.str]:
        """
        The categories to match on, or `*` for all.
        """
        return pulumi.get(self, "category_patterns")

    @_builtins.property
    @pulumi.getter(name="eventPatterns")
    def event_patterns(self) -> Sequence[_builtins.str]:
        """
        The events to match on, or `*` for all.
        """
        return pulumi.get(self, "event_patterns")

    @_builtins.property
    @pulumi.getter(name="hubPatterns")
    def hub_patterns(self) -> Sequence[_builtins.str]:
        """
        The hubs to match on, or `*` for all.
        """
        return pulumi.get(self, "hub_patterns")

    @_builtins.property
    @pulumi.getter(name="urlTemplate")
    def url_template(self) -> _builtins.str:
        """
        The upstream URL Template. This can be a url or a template such as `http://host.com/{hub}/api/{category}/{event}`.
        """
        return pulumi.get(self, "url_template")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        Specifies the Managed Identity IDs to be assigned to this signalR upstream setting by using resource uuid as both system assigned and user assigned identity is supported.
        """
        return pulumi.get(self, "user_assigned_identity_id")


