# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'CacheAccessPolicyAccessRuleArgs',
    'CacheDefaultAccessPolicyArgs',
    'CacheDefaultAccessPolicyAccessRuleArgs',
    'CacheDirectoryActiveDirectoryArgs',
    'CacheDirectoryFlatFileArgs',
    'CacheDirectoryLdapArgs',
    'CacheDirectoryLdapBindArgs',
    'CacheDnsArgs',
    'CacheIdentityArgs',
    'CacheNfsTargetNamespaceJunctionArgs',
]

@pulumi.input_type
class CacheAccessPolicyAccessRuleArgs:
    def __init__(__self__, *,
                 access: pulumi.Input[str],
                 scope: pulumi.Input[str],
                 anonymous_gid: Optional[pulumi.Input[int]] = None,
                 anonymous_uid: Optional[pulumi.Input[int]] = None,
                 filter: Optional[pulumi.Input[str]] = None,
                 root_squash_enabled: Optional[pulumi.Input[bool]] = None,
                 submount_access_enabled: Optional[pulumi.Input[bool]] = None,
                 suid_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] access: The access level for this rule. Possible values are: `rw`, `ro`, `no`.
        :param pulumi.Input[str] scope: The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
               
               > **NOTE:** Each `access_rule` should set a unique `scope`.
        :param pulumi.Input[int] anonymous_gid: The anonymous GID used when `root_squash_enabled` is `true`.
        :param pulumi.Input[int] anonymous_uid: The anonymous UID used when `root_squash_enabled` is `true`.
        :param pulumi.Input[str] filter: The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
        :param pulumi.Input[bool] root_squash_enabled: Whether to enable [root squash](https://docs.microsoft.com/azure/hpc-cache/access-policies#root-squash)?
        :param pulumi.Input[bool] submount_access_enabled: Whether allow access to subdirectories under the root export?
        :param pulumi.Input[bool] suid_enabled: Whether [SUID](https://docs.microsoft.com/azure/hpc-cache/access-policies#suid) is allowed?
        """
        CacheAccessPolicyAccessRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access=access,
            scope=scope,
            anonymous_gid=anonymous_gid,
            anonymous_uid=anonymous_uid,
            filter=filter,
            root_squash_enabled=root_squash_enabled,
            submount_access_enabled=submount_access_enabled,
            suid_enabled=suid_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access: pulumi.Input[str],
             scope: pulumi.Input[str],
             anonymous_gid: Optional[pulumi.Input[int]] = None,
             anonymous_uid: Optional[pulumi.Input[int]] = None,
             filter: Optional[pulumi.Input[str]] = None,
             root_squash_enabled: Optional[pulumi.Input[bool]] = None,
             submount_access_enabled: Optional[pulumi.Input[bool]] = None,
             suid_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("access", access)
        _setter("scope", scope)
        if anonymous_gid is not None:
            _setter("anonymous_gid", anonymous_gid)
        if anonymous_uid is not None:
            _setter("anonymous_uid", anonymous_uid)
        if filter is not None:
            _setter("filter", filter)
        if root_squash_enabled is not None:
            _setter("root_squash_enabled", root_squash_enabled)
        if submount_access_enabled is not None:
            _setter("submount_access_enabled", submount_access_enabled)
        if suid_enabled is not None:
            _setter("suid_enabled", suid_enabled)

    @property
    @pulumi.getter
    def access(self) -> pulumi.Input[str]:
        """
        The access level for this rule. Possible values are: `rw`, `ro`, `no`.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: pulumi.Input[str]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.

        > **NOTE:** Each `access_rule` should set a unique `scope`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="anonymousGid")
    def anonymous_gid(self) -> Optional[pulumi.Input[int]]:
        """
        The anonymous GID used when `root_squash_enabled` is `true`.
        """
        return pulumi.get(self, "anonymous_gid")

    @anonymous_gid.setter
    def anonymous_gid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "anonymous_gid", value)

    @property
    @pulumi.getter(name="anonymousUid")
    def anonymous_uid(self) -> Optional[pulumi.Input[int]]:
        """
        The anonymous UID used when `root_squash_enabled` is `true`.
        """
        return pulumi.get(self, "anonymous_uid")

    @anonymous_uid.setter
    def anonymous_uid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "anonymous_uid", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="rootSquashEnabled")
    def root_squash_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable [root squash](https://docs.microsoft.com/azure/hpc-cache/access-policies#root-squash)?
        """
        return pulumi.get(self, "root_squash_enabled")

    @root_squash_enabled.setter
    def root_squash_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "root_squash_enabled", value)

    @property
    @pulumi.getter(name="submountAccessEnabled")
    def submount_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether allow access to subdirectories under the root export?
        """
        return pulumi.get(self, "submount_access_enabled")

    @submount_access_enabled.setter
    def submount_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "submount_access_enabled", value)

    @property
    @pulumi.getter(name="suidEnabled")
    def suid_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether [SUID](https://docs.microsoft.com/azure/hpc-cache/access-policies#suid) is allowed?
        """
        return pulumi.get(self, "suid_enabled")

    @suid_enabled.setter
    def suid_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suid_enabled", value)


@pulumi.input_type
class CacheDefaultAccessPolicyArgs:
    def __init__(__self__, *,
                 access_rules: pulumi.Input[Sequence[pulumi.Input['CacheDefaultAccessPolicyAccessRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CacheDefaultAccessPolicyAccessRuleArgs']]] access_rules: One to three `access_rule` blocks as defined above.
        """
        CacheDefaultAccessPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_rules=access_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_rules: pulumi.Input[Sequence[pulumi.Input['CacheDefaultAccessPolicyAccessRuleArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("access_rules", access_rules)

    @property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> pulumi.Input[Sequence[pulumi.Input['CacheDefaultAccessPolicyAccessRuleArgs']]]:
        """
        One to three `access_rule` blocks as defined above.
        """
        return pulumi.get(self, "access_rules")

    @access_rules.setter
    def access_rules(self, value: pulumi.Input[Sequence[pulumi.Input['CacheDefaultAccessPolicyAccessRuleArgs']]]):
        pulumi.set(self, "access_rules", value)


@pulumi.input_type
class CacheDefaultAccessPolicyAccessRuleArgs:
    def __init__(__self__, *,
                 access: pulumi.Input[str],
                 scope: pulumi.Input[str],
                 anonymous_gid: Optional[pulumi.Input[int]] = None,
                 anonymous_uid: Optional[pulumi.Input[int]] = None,
                 filter: Optional[pulumi.Input[str]] = None,
                 root_squash_enabled: Optional[pulumi.Input[bool]] = None,
                 submount_access_enabled: Optional[pulumi.Input[bool]] = None,
                 suid_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] access: The access level for this rule. Possible values are: `rw`, `ro`, `no`.
        :param pulumi.Input[str] scope: The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
               
               > **Note:** Each `access_rule` should set a unique `scope`.
        :param pulumi.Input[int] anonymous_gid: The anonymous GID used when `root_squash_enabled` is `true`.
        :param pulumi.Input[int] anonymous_uid: The anonymous UID used when `root_squash_enabled` is `true`.
        :param pulumi.Input[str] filter: The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
        :param pulumi.Input[bool] root_squash_enabled: Whether to enable [root squash](https://docs.microsoft.com/azure/hpc-cache/access-policies#root-squash)?
        :param pulumi.Input[bool] submount_access_enabled: Whether allow access to subdirectories under the root export?
        :param pulumi.Input[bool] suid_enabled: Whether [SUID](https://docs.microsoft.com/azure/hpc-cache/access-policies#suid) is allowed?
        """
        CacheDefaultAccessPolicyAccessRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access=access,
            scope=scope,
            anonymous_gid=anonymous_gid,
            anonymous_uid=anonymous_uid,
            filter=filter,
            root_squash_enabled=root_squash_enabled,
            submount_access_enabled=submount_access_enabled,
            suid_enabled=suid_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access: pulumi.Input[str],
             scope: pulumi.Input[str],
             anonymous_gid: Optional[pulumi.Input[int]] = None,
             anonymous_uid: Optional[pulumi.Input[int]] = None,
             filter: Optional[pulumi.Input[str]] = None,
             root_squash_enabled: Optional[pulumi.Input[bool]] = None,
             submount_access_enabled: Optional[pulumi.Input[bool]] = None,
             suid_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("access", access)
        _setter("scope", scope)
        if anonymous_gid is not None:
            _setter("anonymous_gid", anonymous_gid)
        if anonymous_uid is not None:
            _setter("anonymous_uid", anonymous_uid)
        if filter is not None:
            _setter("filter", filter)
        if root_squash_enabled is not None:
            _setter("root_squash_enabled", root_squash_enabled)
        if submount_access_enabled is not None:
            _setter("submount_access_enabled", submount_access_enabled)
        if suid_enabled is not None:
            _setter("suid_enabled", suid_enabled)

    @property
    @pulumi.getter
    def access(self) -> pulumi.Input[str]:
        """
        The access level for this rule. Possible values are: `rw`, `ro`, `no`.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: pulumi.Input[str]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.

        > **Note:** Each `access_rule` should set a unique `scope`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="anonymousGid")
    def anonymous_gid(self) -> Optional[pulumi.Input[int]]:
        """
        The anonymous GID used when `root_squash_enabled` is `true`.
        """
        return pulumi.get(self, "anonymous_gid")

    @anonymous_gid.setter
    def anonymous_gid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "anonymous_gid", value)

    @property
    @pulumi.getter(name="anonymousUid")
    def anonymous_uid(self) -> Optional[pulumi.Input[int]]:
        """
        The anonymous UID used when `root_squash_enabled` is `true`.
        """
        return pulumi.get(self, "anonymous_uid")

    @anonymous_uid.setter
    def anonymous_uid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "anonymous_uid", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="rootSquashEnabled")
    def root_squash_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable [root squash](https://docs.microsoft.com/azure/hpc-cache/access-policies#root-squash)?
        """
        return pulumi.get(self, "root_squash_enabled")

    @root_squash_enabled.setter
    def root_squash_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "root_squash_enabled", value)

    @property
    @pulumi.getter(name="submountAccessEnabled")
    def submount_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether allow access to subdirectories under the root export?
        """
        return pulumi.get(self, "submount_access_enabled")

    @submount_access_enabled.setter
    def submount_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "submount_access_enabled", value)

    @property
    @pulumi.getter(name="suidEnabled")
    def suid_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether [SUID](https://docs.microsoft.com/azure/hpc-cache/access-policies#suid) is allowed?
        """
        return pulumi.get(self, "suid_enabled")

    @suid_enabled.setter
    def suid_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suid_enabled", value)


@pulumi.input_type
class CacheDirectoryActiveDirectoryArgs:
    def __init__(__self__, *,
                 cache_netbios_name: pulumi.Input[str],
                 dns_primary_ip: pulumi.Input[str],
                 domain_name: pulumi.Input[str],
                 domain_netbios_name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 dns_secondary_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cache_netbios_name: The NetBIOS name to assign to the HPC Cache when it joins the Active Directory domain as a server.
        :param pulumi.Input[str] dns_primary_ip: The primary DNS IP address used to resolve the Active Directory domain controller's FQDN.
        :param pulumi.Input[str] domain_name: The fully qualified domain name of the Active Directory domain controller.
        :param pulumi.Input[str] domain_netbios_name: The Active Directory domain's NetBIOS name.
        :param pulumi.Input[str] password: The password of the Active Directory domain administrator.
        :param pulumi.Input[str] username: The username of the Active Directory domain administrator.
        :param pulumi.Input[str] dns_secondary_ip: The secondary DNS IP address used to resolve the Active Directory domain controller's FQDN.
        """
        CacheDirectoryActiveDirectoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache_netbios_name=cache_netbios_name,
            dns_primary_ip=dns_primary_ip,
            domain_name=domain_name,
            domain_netbios_name=domain_netbios_name,
            password=password,
            username=username,
            dns_secondary_ip=dns_secondary_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache_netbios_name: pulumi.Input[str],
             dns_primary_ip: pulumi.Input[str],
             domain_name: pulumi.Input[str],
             domain_netbios_name: pulumi.Input[str],
             password: pulumi.Input[str],
             username: pulumi.Input[str],
             dns_secondary_ip: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cache_netbios_name", cache_netbios_name)
        _setter("dns_primary_ip", dns_primary_ip)
        _setter("domain_name", domain_name)
        _setter("domain_netbios_name", domain_netbios_name)
        _setter("password", password)
        _setter("username", username)
        if dns_secondary_ip is not None:
            _setter("dns_secondary_ip", dns_secondary_ip)

    @property
    @pulumi.getter(name="cacheNetbiosName")
    def cache_netbios_name(self) -> pulumi.Input[str]:
        """
        The NetBIOS name to assign to the HPC Cache when it joins the Active Directory domain as a server.
        """
        return pulumi.get(self, "cache_netbios_name")

    @cache_netbios_name.setter
    def cache_netbios_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cache_netbios_name", value)

    @property
    @pulumi.getter(name="dnsPrimaryIp")
    def dns_primary_ip(self) -> pulumi.Input[str]:
        """
        The primary DNS IP address used to resolve the Active Directory domain controller's FQDN.
        """
        return pulumi.get(self, "dns_primary_ip")

    @dns_primary_ip.setter
    def dns_primary_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "dns_primary_ip", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        The fully qualified domain name of the Active Directory domain controller.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="domainNetbiosName")
    def domain_netbios_name(self) -> pulumi.Input[str]:
        """
        The Active Directory domain's NetBIOS name.
        """
        return pulumi.get(self, "domain_netbios_name")

    @domain_netbios_name.setter
    def domain_netbios_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_netbios_name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password of the Active Directory domain administrator.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username of the Active Directory domain administrator.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="dnsSecondaryIp")
    def dns_secondary_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The secondary DNS IP address used to resolve the Active Directory domain controller's FQDN.
        """
        return pulumi.get(self, "dns_secondary_ip")

    @dns_secondary_ip.setter
    def dns_secondary_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_secondary_ip", value)


@pulumi.input_type
class CacheDirectoryFlatFileArgs:
    def __init__(__self__, *,
                 group_file_uri: pulumi.Input[str],
                 password_file_uri: pulumi.Input[str]):
        """
        :param pulumi.Input[str] group_file_uri: The URI of the file containing group information (`/etc/group` file format in Unix-like OS).
        :param pulumi.Input[str] password_file_uri: The URI of the file containing user information (`/etc/passwd` file format in Unix-like OS).
        """
        CacheDirectoryFlatFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_file_uri=group_file_uri,
            password_file_uri=password_file_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_file_uri: pulumi.Input[str],
             password_file_uri: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_file_uri", group_file_uri)
        _setter("password_file_uri", password_file_uri)

    @property
    @pulumi.getter(name="groupFileUri")
    def group_file_uri(self) -> pulumi.Input[str]:
        """
        The URI of the file containing group information (`/etc/group` file format in Unix-like OS).
        """
        return pulumi.get(self, "group_file_uri")

    @group_file_uri.setter
    def group_file_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_file_uri", value)

    @property
    @pulumi.getter(name="passwordFileUri")
    def password_file_uri(self) -> pulumi.Input[str]:
        """
        The URI of the file containing user information (`/etc/passwd` file format in Unix-like OS).
        """
        return pulumi.get(self, "password_file_uri")

    @password_file_uri.setter
    def password_file_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "password_file_uri", value)


@pulumi.input_type
class CacheDirectoryLdapArgs:
    def __init__(__self__, *,
                 base_dn: pulumi.Input[str],
                 server: pulumi.Input[str],
                 bind: Optional[pulumi.Input['CacheDirectoryLdapBindArgs']] = None,
                 certificate_validation_uri: Optional[pulumi.Input[str]] = None,
                 download_certificate_automatically: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] base_dn: The base distinguished name (DN) for the LDAP domain.
        :param pulumi.Input[str] server: The FQDN or IP address of the LDAP server.
        :param pulumi.Input['CacheDirectoryLdapBindArgs'] bind: A `bind` block as defined above.
        :param pulumi.Input[str] certificate_validation_uri: The URI of the CA certificate to validate the LDAP secure connection.
        :param pulumi.Input[bool] download_certificate_automatically: Whether the certificate should be automatically downloaded. This can be set to `true` only when `certificate_validation_uri` is provided.
        :param pulumi.Input[bool] encrypted: Whether the LDAP connection should be encrypted?
        """
        CacheDirectoryLdapArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_dn=base_dn,
            server=server,
            bind=bind,
            certificate_validation_uri=certificate_validation_uri,
            download_certificate_automatically=download_certificate_automatically,
            encrypted=encrypted,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_dn: pulumi.Input[str],
             server: pulumi.Input[str],
             bind: Optional[pulumi.Input['CacheDirectoryLdapBindArgs']] = None,
             certificate_validation_uri: Optional[pulumi.Input[str]] = None,
             download_certificate_automatically: Optional[pulumi.Input[bool]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("base_dn", base_dn)
        _setter("server", server)
        if bind is not None:
            _setter("bind", bind)
        if certificate_validation_uri is not None:
            _setter("certificate_validation_uri", certificate_validation_uri)
        if download_certificate_automatically is not None:
            _setter("download_certificate_automatically", download_certificate_automatically)
        if encrypted is not None:
            _setter("encrypted", encrypted)

    @property
    @pulumi.getter(name="baseDn")
    def base_dn(self) -> pulumi.Input[str]:
        """
        The base distinguished name (DN) for the LDAP domain.
        """
        return pulumi.get(self, "base_dn")

    @base_dn.setter
    def base_dn(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_dn", value)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[str]:
        """
        The FQDN or IP address of the LDAP server.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def bind(self) -> Optional[pulumi.Input['CacheDirectoryLdapBindArgs']]:
        """
        A `bind` block as defined above.
        """
        return pulumi.get(self, "bind")

    @bind.setter
    def bind(self, value: Optional[pulumi.Input['CacheDirectoryLdapBindArgs']]):
        pulumi.set(self, "bind", value)

    @property
    @pulumi.getter(name="certificateValidationUri")
    def certificate_validation_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the CA certificate to validate the LDAP secure connection.
        """
        return pulumi.get(self, "certificate_validation_uri")

    @certificate_validation_uri.setter
    def certificate_validation_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_validation_uri", value)

    @property
    @pulumi.getter(name="downloadCertificateAutomatically")
    def download_certificate_automatically(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the certificate should be automatically downloaded. This can be set to `true` only when `certificate_validation_uri` is provided.
        """
        return pulumi.get(self, "download_certificate_automatically")

    @download_certificate_automatically.setter
    def download_certificate_automatically(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "download_certificate_automatically", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the LDAP connection should be encrypted?
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)


@pulumi.input_type
class CacheDirectoryLdapBindArgs:
    def __init__(__self__, *,
                 dn: pulumi.Input[str],
                 password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dn: The Bind Distinguished Name (DN) identity to be used in the secure LDAP connection.
        :param pulumi.Input[str] password: The Bind password to be used in the secure LDAP connection.
        """
        CacheDirectoryLdapBindArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dn=dn,
            password=password,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dn: pulumi.Input[str],
             password: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dn", dn)
        _setter("password", password)

    @property
    @pulumi.getter
    def dn(self) -> pulumi.Input[str]:
        """
        The Bind Distinguished Name (DN) identity to be used in the secure LDAP connection.
        """
        return pulumi.get(self, "dn")

    @dn.setter
    def dn(self, value: pulumi.Input[str]):
        pulumi.set(self, "dn", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The Bind password to be used in the secure LDAP connection.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class CacheDnsArgs:
    def __init__(__self__, *,
                 servers: pulumi.Input[Sequence[pulumi.Input[str]]],
                 search_domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] servers: A list of DNS servers for the HPC Cache. At most three IP(s) are allowed to set.
        :param pulumi.Input[str] search_domain: The DNS search domain for the HPC Cache.
        """
        CacheDnsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            servers=servers,
            search_domain=search_domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             servers: pulumi.Input[Sequence[pulumi.Input[str]]],
             search_domain: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("servers", servers)
        if search_domain is not None:
            _setter("search_domain", search_domain)

    @property
    @pulumi.getter
    def servers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of DNS servers for the HPC Cache. At most three IP(s) are allowed to set.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter(name="searchDomain")
    def search_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS search domain for the HPC Cache.
        """
        return pulumi.get(self, "search_domain")

    @search_domain.setter
    def search_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_domain", value)


@pulumi.input_type
class CacheIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this HPC Cache. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both). Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this HPC Cache. Changing this forces a new resource to be created.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        CacheIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            identity_ids=identity_ids,
            principal_id=principal_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             principal_id: Optional[pulumi.Input[str]] = None,
             tenant_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if identity_ids is not None:
            _setter("identity_ids", identity_ids)
        if principal_id is not None:
            _setter("principal_id", principal_id)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this HPC Cache. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this HPC Cache. Changing this forces a new resource to be created.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class CacheNfsTargetNamespaceJunctionArgs:
    def __init__(__self__, *,
                 namespace_path: pulumi.Input[str],
                 nfs_export: pulumi.Input[str],
                 access_policy_name: Optional[pulumi.Input[str]] = None,
                 target_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespace_path: The client-facing file path of this NFS target within the HPC Cache NFS Target.
        :param pulumi.Input[str] nfs_export: The NFS export of this NFS target within the HPC Cache NFS Target.
        :param pulumi.Input[str] access_policy_name: The name of the access policy applied to this target. Defaults to `default`.
        :param pulumi.Input[str] target_path: The relative subdirectory path from the `nfs_export` to map to the `namespace_path`. Defaults to `""`, in which case the whole `nfs_export` is exported.
        """
        CacheNfsTargetNamespaceJunctionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            namespace_path=namespace_path,
            nfs_export=nfs_export,
            access_policy_name=access_policy_name,
            target_path=target_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             namespace_path: pulumi.Input[str],
             nfs_export: pulumi.Input[str],
             access_policy_name: Optional[pulumi.Input[str]] = None,
             target_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("namespace_path", namespace_path)
        _setter("nfs_export", nfs_export)
        if access_policy_name is not None:
            _setter("access_policy_name", access_policy_name)
        if target_path is not None:
            _setter("target_path", target_path)

    @property
    @pulumi.getter(name="namespacePath")
    def namespace_path(self) -> pulumi.Input[str]:
        """
        The client-facing file path of this NFS target within the HPC Cache NFS Target.
        """
        return pulumi.get(self, "namespace_path")

    @namespace_path.setter
    def namespace_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace_path", value)

    @property
    @pulumi.getter(name="nfsExport")
    def nfs_export(self) -> pulumi.Input[str]:
        """
        The NFS export of this NFS target within the HPC Cache NFS Target.
        """
        return pulumi.get(self, "nfs_export")

    @nfs_export.setter
    def nfs_export(self, value: pulumi.Input[str]):
        pulumi.set(self, "nfs_export", value)

    @property
    @pulumi.getter(name="accessPolicyName")
    def access_policy_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the access policy applied to this target. Defaults to `default`.
        """
        return pulumi.get(self, "access_policy_name")

    @access_policy_name.setter
    def access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_policy_name", value)

    @property
    @pulumi.getter(name="targetPath")
    def target_path(self) -> Optional[pulumi.Input[str]]:
        """
        The relative subdirectory path from the `nfs_export` to map to the `namespace_path`. Defaults to `""`, in which case the whole `nfs_export` is exported.
        """
        return pulumi.get(self, "target_path")

    @target_path.setter
    def target_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_path", value)


