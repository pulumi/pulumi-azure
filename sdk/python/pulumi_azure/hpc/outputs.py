# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'CacheAccessPolicyAccessRule',
    'CacheDefaultAccessPolicy',
    'CacheDefaultAccessPolicyAccessRule',
    'CacheDns',
    'CacheNfsTargetNamespaceJunction',
]

@pulumi.output_type
class CacheAccessPolicyAccessRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousGid":
            suggest = "anonymous_gid"
        elif key == "anonymousUid":
            suggest = "anonymous_uid"
        elif key == "rootSquashEnabled":
            suggest = "root_squash_enabled"
        elif key == "submountAccessEnabled":
            suggest = "submount_access_enabled"
        elif key == "suidEnabled":
            suggest = "suid_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheAccessPolicyAccessRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheAccessPolicyAccessRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheAccessPolicyAccessRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 scope: str,
                 anonymous_gid: Optional[int] = None,
                 anonymous_uid: Optional[int] = None,
                 filter: Optional[str] = None,
                 root_squash_enabled: Optional[bool] = None,
                 submount_access_enabled: Optional[bool] = None,
                 suid_enabled: Optional[bool] = None):
        """
        :param str access: The access level for this rule. Possible values are: `rw`, `ro`, `no`.
        :param str scope: The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
        :param int anonymous_gid: The anonymous GID used when `root_squash_enabled` is `true`.
        :param int anonymous_uid: The anonymous UID used when `root_squash_enabled` is `true`.
        :param str filter: The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
        :param bool root_squash_enabled: Whether to enable [root squash](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#root-squash)? Defaults to `false`.
        :param bool submount_access_enabled: Whether allow access to subdirectories under the root export? Defaults to `false`.
        :param bool suid_enabled: Whether [SUID](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#suid) is allowed? Defaults to `false`.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "scope", scope)
        if anonymous_gid is not None:
            pulumi.set(__self__, "anonymous_gid", anonymous_gid)
        if anonymous_uid is not None:
            pulumi.set(__self__, "anonymous_uid", anonymous_uid)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if root_squash_enabled is not None:
            pulumi.set(__self__, "root_squash_enabled", root_squash_enabled)
        if submount_access_enabled is not None:
            pulumi.set(__self__, "submount_access_enabled", submount_access_enabled)
        if suid_enabled is not None:
            pulumi.set(__self__, "suid_enabled", suid_enabled)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        The access level for this rule. Possible values are: `rw`, `ro`, `no`.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="anonymousGid")
    def anonymous_gid(self) -> Optional[int]:
        """
        The anonymous GID used when `root_squash_enabled` is `true`.
        """
        return pulumi.get(self, "anonymous_gid")

    @property
    @pulumi.getter(name="anonymousUid")
    def anonymous_uid(self) -> Optional[int]:
        """
        The anonymous UID used when `root_squash_enabled` is `true`.
        """
        return pulumi.get(self, "anonymous_uid")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="rootSquashEnabled")
    def root_squash_enabled(self) -> Optional[bool]:
        """
        Whether to enable [root squash](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#root-squash)? Defaults to `false`.
        """
        return pulumi.get(self, "root_squash_enabled")

    @property
    @pulumi.getter(name="submountAccessEnabled")
    def submount_access_enabled(self) -> Optional[bool]:
        """
        Whether allow access to subdirectories under the root export? Defaults to `false`.
        """
        return pulumi.get(self, "submount_access_enabled")

    @property
    @pulumi.getter(name="suidEnabled")
    def suid_enabled(self) -> Optional[bool]:
        """
        Whether [SUID](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#suid) is allowed? Defaults to `false`.
        """
        return pulumi.get(self, "suid_enabled")


@pulumi.output_type
class CacheDefaultAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessRules":
            suggest = "access_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheDefaultAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheDefaultAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheDefaultAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_rules: Sequence['outputs.CacheDefaultAccessPolicyAccessRule']):
        """
        :param Sequence['CacheDefaultAccessPolicyAccessRuleArgs'] access_rules: One to three `access_rule` blocks as defined above.
        """
        pulumi.set(__self__, "access_rules", access_rules)

    @property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> Sequence['outputs.CacheDefaultAccessPolicyAccessRule']:
        """
        One to three `access_rule` blocks as defined above.
        """
        return pulumi.get(self, "access_rules")


@pulumi.output_type
class CacheDefaultAccessPolicyAccessRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousGid":
            suggest = "anonymous_gid"
        elif key == "anonymousUid":
            suggest = "anonymous_uid"
        elif key == "rootSquashEnabled":
            suggest = "root_squash_enabled"
        elif key == "submountAccessEnabled":
            suggest = "submount_access_enabled"
        elif key == "suidEnabled":
            suggest = "suid_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheDefaultAccessPolicyAccessRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheDefaultAccessPolicyAccessRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheDefaultAccessPolicyAccessRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 scope: str,
                 anonymous_gid: Optional[int] = None,
                 anonymous_uid: Optional[int] = None,
                 filter: Optional[str] = None,
                 root_squash_enabled: Optional[bool] = None,
                 submount_access_enabled: Optional[bool] = None,
                 suid_enabled: Optional[bool] = None):
        """
        :param str access: The access level for this rule. Possible values are: `rw`, `ro`, `no`.
        :param str scope: The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
        :param int anonymous_gid: The anonymous GID used when `root_squash_enabled` is `true`.
        :param int anonymous_uid: The anonymous UID used when `root_squash_enabled` is `true`.
        :param str filter: The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
        :param bool root_squash_enabled: Whether to enable [root squash](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#root-squash)? Defaults to `false`.
        :param bool submount_access_enabled: Whether allow access to subdirectories under the root export? Defaults to `false`.
        :param bool suid_enabled: Whether [SUID](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#suid) is allowed? Defaults to `false`.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "scope", scope)
        if anonymous_gid is not None:
            pulumi.set(__self__, "anonymous_gid", anonymous_gid)
        if anonymous_uid is not None:
            pulumi.set(__self__, "anonymous_uid", anonymous_uid)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if root_squash_enabled is not None:
            pulumi.set(__self__, "root_squash_enabled", root_squash_enabled)
        if submount_access_enabled is not None:
            pulumi.set(__self__, "submount_access_enabled", submount_access_enabled)
        if suid_enabled is not None:
            pulumi.set(__self__, "suid_enabled", suid_enabled)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        The access level for this rule. Possible values are: `rw`, `ro`, `no`.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="anonymousGid")
    def anonymous_gid(self) -> Optional[int]:
        """
        The anonymous GID used when `root_squash_enabled` is `true`.
        """
        return pulumi.get(self, "anonymous_gid")

    @property
    @pulumi.getter(name="anonymousUid")
    def anonymous_uid(self) -> Optional[int]:
        """
        The anonymous UID used when `root_squash_enabled` is `true`.
        """
        return pulumi.get(self, "anonymous_uid")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="rootSquashEnabled")
    def root_squash_enabled(self) -> Optional[bool]:
        """
        Whether to enable [root squash](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#root-squash)? Defaults to `false`.
        """
        return pulumi.get(self, "root_squash_enabled")

    @property
    @pulumi.getter(name="submountAccessEnabled")
    def submount_access_enabled(self) -> Optional[bool]:
        """
        Whether allow access to subdirectories under the root export? Defaults to `false`.
        """
        return pulumi.get(self, "submount_access_enabled")

    @property
    @pulumi.getter(name="suidEnabled")
    def suid_enabled(self) -> Optional[bool]:
        """
        Whether [SUID](https://docs.microsoft.com/en-us/azure/hpc-cache/access-policies#suid) is allowed? Defaults to `false`.
        """
        return pulumi.get(self, "suid_enabled")


@pulumi.output_type
class CacheDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "searchDomain":
            suggest = "search_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 servers: Sequence[str],
                 search_domain: Optional[str] = None):
        """
        :param Sequence[str] servers: A list of DNS servers for the HPC Cache. At most three IP(s) are allowed to set.
        :param str search_domain: The DNS search domain for the HPC Cache.
        """
        pulumi.set(__self__, "servers", servers)
        if search_domain is not None:
            pulumi.set(__self__, "search_domain", search_domain)

    @property
    @pulumi.getter
    def servers(self) -> Sequence[str]:
        """
        A list of DNS servers for the HPC Cache. At most three IP(s) are allowed to set.
        """
        return pulumi.get(self, "servers")

    @property
    @pulumi.getter(name="searchDomain")
    def search_domain(self) -> Optional[str]:
        """
        The DNS search domain for the HPC Cache.
        """
        return pulumi.get(self, "search_domain")


@pulumi.output_type
class CacheNfsTargetNamespaceJunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespacePath":
            suggest = "namespace_path"
        elif key == "nfsExport":
            suggest = "nfs_export"
        elif key == "accessPolicyName":
            suggest = "access_policy_name"
        elif key == "targetPath":
            suggest = "target_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheNfsTargetNamespaceJunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheNfsTargetNamespaceJunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheNfsTargetNamespaceJunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_path: str,
                 nfs_export: str,
                 access_policy_name: Optional[str] = None,
                 target_path: Optional[str] = None):
        """
        :param str namespace_path: The client-facing file path of this NFS target within the HPC Cache NFS Target.
        :param str nfs_export: The NFS export of this NFS target within the HPC Cache NFS Target.
        :param str access_policy_name: The name of the access policy applied to this target. Defaults to `default`.
        :param str target_path: The relative subdirectory path from the `nfs_export` to map to the `namespace_path`. Defaults to `""`, in which case the whole `nfs_export` is exported.
        """
        pulumi.set(__self__, "namespace_path", namespace_path)
        pulumi.set(__self__, "nfs_export", nfs_export)
        if access_policy_name is not None:
            pulumi.set(__self__, "access_policy_name", access_policy_name)
        if target_path is not None:
            pulumi.set(__self__, "target_path", target_path)

    @property
    @pulumi.getter(name="namespacePath")
    def namespace_path(self) -> str:
        """
        The client-facing file path of this NFS target within the HPC Cache NFS Target.
        """
        return pulumi.get(self, "namespace_path")

    @property
    @pulumi.getter(name="nfsExport")
    def nfs_export(self) -> str:
        """
        The NFS export of this NFS target within the HPC Cache NFS Target.
        """
        return pulumi.get(self, "nfs_export")

    @property
    @pulumi.getter(name="accessPolicyName")
    def access_policy_name(self) -> Optional[str]:
        """
        The name of the access policy applied to this target. Defaults to `default`.
        """
        return pulumi.get(self, "access_policy_name")

    @property
    @pulumi.getter(name="targetPath")
    def target_path(self) -> Optional[str]:
        """
        The relative subdirectory path from the `nfs_export` to map to the `namespace_path`. Defaults to `""`, in which case the whole `nfs_export` is exported.
        """
        return pulumi.get(self, "target_path")


