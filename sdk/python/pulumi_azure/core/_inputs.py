# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CustomProviderActionArgs',
    'CustomProviderActionArgsDict',
    'CustomProviderResourceTypeArgs',
    'CustomProviderResourceTypeArgsDict',
    'CustomProviderValidationArgs',
    'CustomProviderValidationArgsDict',
    'ResourceDeploymentScriptAzureCliContainerArgs',
    'ResourceDeploymentScriptAzureCliContainerArgsDict',
    'ResourceDeploymentScriptAzureCliEnvironmentVariableArgs',
    'ResourceDeploymentScriptAzureCliEnvironmentVariableArgsDict',
    'ResourceDeploymentScriptAzureCliIdentityArgs',
    'ResourceDeploymentScriptAzureCliIdentityArgsDict',
    'ResourceDeploymentScriptAzureCliStorageAccountArgs',
    'ResourceDeploymentScriptAzureCliStorageAccountArgsDict',
    'ResourceDeploymentScriptPowerShellContainerArgs',
    'ResourceDeploymentScriptPowerShellContainerArgsDict',
    'ResourceDeploymentScriptPowerShellEnvironmentVariableArgs',
    'ResourceDeploymentScriptPowerShellEnvironmentVariableArgsDict',
    'ResourceDeploymentScriptPowerShellIdentityArgs',
    'ResourceDeploymentScriptPowerShellIdentityArgsDict',
    'ResourceDeploymentScriptPowerShellStorageAccountArgs',
    'ResourceDeploymentScriptPowerShellStorageAccountArgsDict',
    'ResourceGroupCostManagementExportExportDataOptionsArgs',
    'ResourceGroupCostManagementExportExportDataOptionsArgsDict',
    'ResourceGroupCostManagementExportExportDataStorageLocationArgs',
    'ResourceGroupCostManagementExportExportDataStorageLocationArgsDict',
    'ResourceGroupCostManagementViewDatasetArgs',
    'ResourceGroupCostManagementViewDatasetArgsDict',
    'ResourceGroupCostManagementViewDatasetAggregationArgs',
    'ResourceGroupCostManagementViewDatasetAggregationArgsDict',
    'ResourceGroupCostManagementViewDatasetGroupingArgs',
    'ResourceGroupCostManagementViewDatasetGroupingArgsDict',
    'ResourceGroupCostManagementViewDatasetSortingArgs',
    'ResourceGroupCostManagementViewDatasetSortingArgsDict',
    'ResourceGroupCostManagementViewKpiArgs',
    'ResourceGroupCostManagementViewKpiArgsDict',
    'ResourceGroupCostManagementViewPivotArgs',
    'ResourceGroupCostManagementViewPivotArgsDict',
    'ResourceGroupPolicyAssignmentIdentityArgs',
    'ResourceGroupPolicyAssignmentIdentityArgsDict',
    'ResourceGroupPolicyAssignmentNonComplianceMessageArgs',
    'ResourceGroupPolicyAssignmentNonComplianceMessageArgsDict',
    'ResourceGroupPolicyAssignmentOverrideArgs',
    'ResourceGroupPolicyAssignmentOverrideArgsDict',
    'ResourceGroupPolicyAssignmentOverrideSelectorArgs',
    'ResourceGroupPolicyAssignmentOverrideSelectorArgsDict',
    'ResourceGroupPolicyAssignmentResourceSelectorArgs',
    'ResourceGroupPolicyAssignmentResourceSelectorArgsDict',
    'ResourceGroupPolicyAssignmentResourceSelectorSelectorArgs',
    'ResourceGroupPolicyAssignmentResourceSelectorSelectorArgsDict',
    'ResourcePolicyAssignmentIdentityArgs',
    'ResourcePolicyAssignmentIdentityArgsDict',
    'ResourcePolicyAssignmentNonComplianceMessageArgs',
    'ResourcePolicyAssignmentNonComplianceMessageArgsDict',
    'ResourcePolicyAssignmentOverrideArgs',
    'ResourcePolicyAssignmentOverrideArgsDict',
    'ResourcePolicyAssignmentOverrideSelectorArgs',
    'ResourcePolicyAssignmentOverrideSelectorArgsDict',
    'ResourcePolicyAssignmentResourceSelectorArgs',
    'ResourcePolicyAssignmentResourceSelectorArgsDict',
    'ResourcePolicyAssignmentResourceSelectorSelectorArgs',
    'ResourcePolicyAssignmentResourceSelectorSelectorArgsDict',
    'ResourceProviderRegistrationFeatureArgs',
    'ResourceProviderRegistrationFeatureArgsDict',
    'SubscriptionCostManagementExportExportDataOptionsArgs',
    'SubscriptionCostManagementExportExportDataOptionsArgsDict',
    'SubscriptionCostManagementExportExportDataStorageLocationArgs',
    'SubscriptionCostManagementExportExportDataStorageLocationArgsDict',
    'SubscriptionCostManagementViewDatasetArgs',
    'SubscriptionCostManagementViewDatasetArgsDict',
    'SubscriptionCostManagementViewDatasetAggregationArgs',
    'SubscriptionCostManagementViewDatasetAggregationArgsDict',
    'SubscriptionCostManagementViewDatasetGroupingArgs',
    'SubscriptionCostManagementViewDatasetGroupingArgsDict',
    'SubscriptionCostManagementViewDatasetSortingArgs',
    'SubscriptionCostManagementViewDatasetSortingArgsDict',
    'SubscriptionCostManagementViewKpiArgs',
    'SubscriptionCostManagementViewKpiArgsDict',
    'SubscriptionCostManagementViewPivotArgs',
    'SubscriptionCostManagementViewPivotArgsDict',
    'SubscriptionPolicyAssignmentIdentityArgs',
    'SubscriptionPolicyAssignmentIdentityArgsDict',
    'SubscriptionPolicyAssignmentNonComplianceMessageArgs',
    'SubscriptionPolicyAssignmentNonComplianceMessageArgsDict',
    'SubscriptionPolicyAssignmentOverrideArgs',
    'SubscriptionPolicyAssignmentOverrideArgsDict',
    'SubscriptionPolicyAssignmentOverrideSelectorArgs',
    'SubscriptionPolicyAssignmentOverrideSelectorArgsDict',
    'SubscriptionPolicyAssignmentResourceSelectorArgs',
    'SubscriptionPolicyAssignmentResourceSelectorArgsDict',
    'SubscriptionPolicyAssignmentResourceSelectorSelectorArgs',
    'SubscriptionPolicyAssignmentResourceSelectorSelectorArgsDict',
]

MYPY = False

if not MYPY:
    class CustomProviderActionArgsDict(TypedDict):
        endpoint: pulumi.Input[str]
        """
        Specifies the endpoint of the action.
        """
        name: pulumi.Input[str]
        """
        Specifies the name of the action.
        """
elif False:
    CustomProviderActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomProviderActionArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] endpoint: Specifies the endpoint of the action.
        :param pulumi.Input[str] name: Specifies the name of the action.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Specifies the endpoint of the action.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CustomProviderResourceTypeArgsDict(TypedDict):
        endpoint: pulumi.Input[str]
        """
        Specifies the endpoint of the route definition.
        """
        name: pulumi.Input[str]
        """
        Specifies the name of the route definition.
        """
        routing_type: NotRequired[pulumi.Input[str]]
        """
        The routing type that is supported for the resource request. Valid values are `Proxy` and `Proxy,Cache`. Defaults to `Proxy`.
        """
elif False:
    CustomProviderResourceTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomProviderResourceTypeArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 name: pulumi.Input[str],
                 routing_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint: Specifies the endpoint of the route definition.
        :param pulumi.Input[str] name: Specifies the name of the route definition.
        :param pulumi.Input[str] routing_type: The routing type that is supported for the resource request. Valid values are `Proxy` and `Proxy,Cache`. Defaults to `Proxy`.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if routing_type is not None:
            pulumi.set(__self__, "routing_type", routing_type)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Specifies the endpoint of the route definition.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the route definition.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="routingType")
    def routing_type(self) -> Optional[pulumi.Input[str]]:
        """
        The routing type that is supported for the resource request. Valid values are `Proxy` and `Proxy,Cache`. Defaults to `Proxy`.
        """
        return pulumi.get(self, "routing_type")

    @routing_type.setter
    def routing_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_type", value)


if not MYPY:
    class CustomProviderValidationArgsDict(TypedDict):
        specification: pulumi.Input[str]
        """
        The endpoint where the validation specification is located.
        """
elif False:
    CustomProviderValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomProviderValidationArgs:
    def __init__(__self__, *,
                 specification: pulumi.Input[str]):
        """
        :param pulumi.Input[str] specification: The endpoint where the validation specification is located.
        """
        pulumi.set(__self__, "specification", specification)

    @property
    @pulumi.getter
    def specification(self) -> pulumi.Input[str]:
        """
        The endpoint where the validation specification is located.
        """
        return pulumi.get(self, "specification")

    @specification.setter
    def specification(self, value: pulumi.Input[str]):
        pulumi.set(self, "specification", value)


if not MYPY:
    class ResourceDeploymentScriptAzureCliContainerArgsDict(TypedDict):
        container_group_name: NotRequired[pulumi.Input[str]]
        """
        Container group name, if not specified then the name will get auto-generated. For more information, please refer to the [Container Configuration](https://learn.microsoft.com/en-us/rest/api/resources/deployment-scripts/create?tabs=HTTP#containerconfiguration) documentation.
        """
elif False:
    ResourceDeploymentScriptAzureCliContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDeploymentScriptAzureCliContainerArgs:
    def __init__(__self__, *,
                 container_group_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] container_group_name: Container group name, if not specified then the name will get auto-generated. For more information, please refer to the [Container Configuration](https://learn.microsoft.com/en-us/rest/api/resources/deployment-scripts/create?tabs=HTTP#containerconfiguration) documentation.
        """
        if container_group_name is not None:
            pulumi.set(__self__, "container_group_name", container_group_name)

    @property
    @pulumi.getter(name="containerGroupName")
    def container_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        Container group name, if not specified then the name will get auto-generated. For more information, please refer to the [Container Configuration](https://learn.microsoft.com/en-us/rest/api/resources/deployment-scripts/create?tabs=HTTP#containerconfiguration) documentation.
        """
        return pulumi.get(self, "container_group_name")

    @container_group_name.setter
    def container_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_group_name", value)


if not MYPY:
    class ResourceDeploymentScriptAzureCliEnvironmentVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Specifies the name of the environment variable.
        """
        secure_value: NotRequired[pulumi.Input[str]]
        """
        Specifies the value of the secure environment variable.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Specifies the value of the environment variable.
        """
elif False:
    ResourceDeploymentScriptAzureCliEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDeploymentScriptAzureCliEnvironmentVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 secure_value: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Specifies the name of the environment variable.
        :param pulumi.Input[str] secure_value: Specifies the value of the secure environment variable.
        :param pulumi.Input[str] value: Specifies the value of the environment variable.
        """
        pulumi.set(__self__, "name", name)
        if secure_value is not None:
            pulumi.set(__self__, "secure_value", secure_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the environment variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secureValue")
    def secure_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the value of the secure environment variable.
        """
        return pulumi.get(self, "secure_value")

    @secure_value.setter
    def secure_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ResourceDeploymentScriptAzureCliIdentityArgsDict(TypedDict):
        identity_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies the list of user-assigned managed identity IDs associated with the resource. Changing this forces a new resource to be created.
        """
        type: pulumi.Input[str]
        """
        Type of the managed identity. The only possible value is `UserAssigned`. Changing this forces a new resource to be created.
        """
elif False:
    ResourceDeploymentScriptAzureCliIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDeploymentScriptAzureCliIdentityArgs:
    def __init__(__self__, *,
                 identity_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies the list of user-assigned managed identity IDs associated with the resource. Changing this forces a new resource to be created.
        :param pulumi.Input[str] type: Type of the managed identity. The only possible value is `UserAssigned`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies the list of user-assigned managed identity IDs associated with the resource. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the managed identity. The only possible value is `UserAssigned`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceDeploymentScriptAzureCliStorageAccountArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the storage account access key.
        """
        name: pulumi.Input[str]
        """
        Specifies the storage account name.
        """
elif False:
    ResourceDeploymentScriptAzureCliStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDeploymentScriptAzureCliStorageAccountArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Specifies the storage account access key.
        :param pulumi.Input[str] name: Specifies the storage account name.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the storage account access key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the storage account name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ResourceDeploymentScriptPowerShellContainerArgsDict(TypedDict):
        container_group_name: NotRequired[pulumi.Input[str]]
        """
        Container group name, if not specified then the name will get auto-generated. For more information, please refer to the [Container Configuration](https://learn.microsoft.com/en-us/rest/api/resources/deployment-scripts/create?tabs=HTTP#containerconfiguration) documentation.
        """
elif False:
    ResourceDeploymentScriptPowerShellContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDeploymentScriptPowerShellContainerArgs:
    def __init__(__self__, *,
                 container_group_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] container_group_name: Container group name, if not specified then the name will get auto-generated. For more information, please refer to the [Container Configuration](https://learn.microsoft.com/en-us/rest/api/resources/deployment-scripts/create?tabs=HTTP#containerconfiguration) documentation.
        """
        if container_group_name is not None:
            pulumi.set(__self__, "container_group_name", container_group_name)

    @property
    @pulumi.getter(name="containerGroupName")
    def container_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        Container group name, if not specified then the name will get auto-generated. For more information, please refer to the [Container Configuration](https://learn.microsoft.com/en-us/rest/api/resources/deployment-scripts/create?tabs=HTTP#containerconfiguration) documentation.
        """
        return pulumi.get(self, "container_group_name")

    @container_group_name.setter
    def container_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_group_name", value)


if not MYPY:
    class ResourceDeploymentScriptPowerShellEnvironmentVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Specifies the name of the environment variable.
        """
        secure_value: NotRequired[pulumi.Input[str]]
        """
        Specifies the value of the secure environment variable.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Specifies the value of the environment variable.
        """
elif False:
    ResourceDeploymentScriptPowerShellEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDeploymentScriptPowerShellEnvironmentVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 secure_value: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Specifies the name of the environment variable.
        :param pulumi.Input[str] secure_value: Specifies the value of the secure environment variable.
        :param pulumi.Input[str] value: Specifies the value of the environment variable.
        """
        pulumi.set(__self__, "name", name)
        if secure_value is not None:
            pulumi.set(__self__, "secure_value", secure_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the environment variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secureValue")
    def secure_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the value of the secure environment variable.
        """
        return pulumi.get(self, "secure_value")

    @secure_value.setter
    def secure_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ResourceDeploymentScriptPowerShellIdentityArgsDict(TypedDict):
        identity_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies the list of user-assigned managed identity IDs associated with the resource. Changing this forces a new resource to be created.
        """
        type: pulumi.Input[str]
        """
        Type of the managed identity. The only possible value is `UserAssigned`. Changing this forces a new resource to be created.
        """
elif False:
    ResourceDeploymentScriptPowerShellIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDeploymentScriptPowerShellIdentityArgs:
    def __init__(__self__, *,
                 identity_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies the list of user-assigned managed identity IDs associated with the resource. Changing this forces a new resource to be created.
        :param pulumi.Input[str] type: Type of the managed identity. The only possible value is `UserAssigned`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies the list of user-assigned managed identity IDs associated with the resource. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the managed identity. The only possible value is `UserAssigned`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceDeploymentScriptPowerShellStorageAccountArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Specifies the storage account access key.
        """
        name: pulumi.Input[str]
        """
        Specifies the storage account name.
        """
elif False:
    ResourceDeploymentScriptPowerShellStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDeploymentScriptPowerShellStorageAccountArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Specifies the storage account access key.
        :param pulumi.Input[str] name: Specifies the storage account name.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Specifies the storage account access key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the storage account name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ResourceGroupCostManagementExportExportDataOptionsArgsDict(TypedDict):
        time_frame: pulumi.Input[str]
        """
        The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `BillingMonthToDate`, `TheLast7Days`, `TheLastMonth`, `TheLastBillingMonth`, `Custom`.
        """
        type: pulumi.Input[str]
        """
        The type of the query. Possible values are `ActualCost`, `AmortizedCost` and `Usage`.
        """
elif False:
    ResourceGroupCostManagementExportExportDataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupCostManagementExportExportDataOptionsArgs:
    def __init__(__self__, *,
                 time_frame: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] time_frame: The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `BillingMonthToDate`, `TheLast7Days`, `TheLastMonth`, `TheLastBillingMonth`, `Custom`.
        :param pulumi.Input[str] type: The type of the query. Possible values are `ActualCost`, `AmortizedCost` and `Usage`.
        """
        pulumi.set(__self__, "time_frame", time_frame)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="timeFrame")
    def time_frame(self) -> pulumi.Input[str]:
        """
        The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `BillingMonthToDate`, `TheLast7Days`, `TheLastMonth`, `TheLastBillingMonth`, `Custom`.
        """
        return pulumi.get(self, "time_frame")

    @time_frame.setter
    def time_frame(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_frame", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the query. Possible values are `ActualCost`, `AmortizedCost` and `Usage`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceGroupCostManagementExportExportDataStorageLocationArgsDict(TypedDict):
        container_id: pulumi.Input[str]
        """
        The Resource Manager ID of the container where exports will be uploaded. Changing this forces a new resource to be created.
        """
        root_folder_path: pulumi.Input[str]
        """
        The path of the directory where exports will be uploaded. Changing this forces a new resource to be created.

        > **Note:** The Resource Manager ID of a Storage Container is exposed via the `resource_manager_id` attribute of the `storage.Container` resource.
        """
elif False:
    ResourceGroupCostManagementExportExportDataStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupCostManagementExportExportDataStorageLocationArgs:
    def __init__(__self__, *,
                 container_id: pulumi.Input[str],
                 root_folder_path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] container_id: The Resource Manager ID of the container where exports will be uploaded. Changing this forces a new resource to be created.
        :param pulumi.Input[str] root_folder_path: The path of the directory where exports will be uploaded. Changing this forces a new resource to be created.
               
               > **Note:** The Resource Manager ID of a Storage Container is exposed via the `resource_manager_id` attribute of the `storage.Container` resource.
        """
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "root_folder_path", root_folder_path)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> pulumi.Input[str]:
        """
        The Resource Manager ID of the container where exports will be uploaded. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "container_id")

    @container_id.setter
    def container_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_id", value)

    @property
    @pulumi.getter(name="rootFolderPath")
    def root_folder_path(self) -> pulumi.Input[str]:
        """
        The path of the directory where exports will be uploaded. Changing this forces a new resource to be created.

        > **Note:** The Resource Manager ID of a Storage Container is exposed via the `resource_manager_id` attribute of the `storage.Container` resource.
        """
        return pulumi.get(self, "root_folder_path")

    @root_folder_path.setter
    def root_folder_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "root_folder_path", value)


if not MYPY:
    class ResourceGroupCostManagementViewDatasetArgsDict(TypedDict):
        aggregations: pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetAggregationArgsDict']]]
        """
        One or more `aggregation` blocks as defined above.
        """
        granularity: pulumi.Input[str]
        """
        The granularity of rows in the report. Possible values are `Daily` and `Monthly`.
        """
        groupings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetGroupingArgsDict']]]]
        """
        One or more `grouping` blocks as defined below.
        """
        sortings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetSortingArgsDict']]]]
        """
        One or more `sorting` blocks as defined below, containing the order by expression to be used in the report
        """
elif False:
    ResourceGroupCostManagementViewDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupCostManagementViewDatasetArgs:
    def __init__(__self__, *,
                 aggregations: pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetAggregationArgs']]],
                 granularity: pulumi.Input[str],
                 groupings: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetGroupingArgs']]]] = None,
                 sortings: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetSortingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetAggregationArgs']]] aggregations: One or more `aggregation` blocks as defined above.
        :param pulumi.Input[str] granularity: The granularity of rows in the report. Possible values are `Daily` and `Monthly`.
        :param pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetGroupingArgs']]] groupings: One or more `grouping` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetSortingArgs']]] sortings: One or more `sorting` blocks as defined below, containing the order by expression to be used in the report
        """
        pulumi.set(__self__, "aggregations", aggregations)
        pulumi.set(__self__, "granularity", granularity)
        if groupings is not None:
            pulumi.set(__self__, "groupings", groupings)
        if sortings is not None:
            pulumi.set(__self__, "sortings", sortings)

    @property
    @pulumi.getter
    def aggregations(self) -> pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetAggregationArgs']]]:
        """
        One or more `aggregation` blocks as defined above.
        """
        return pulumi.get(self, "aggregations")

    @aggregations.setter
    def aggregations(self, value: pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetAggregationArgs']]]):
        pulumi.set(self, "aggregations", value)

    @property
    @pulumi.getter
    def granularity(self) -> pulumi.Input[str]:
        """
        The granularity of rows in the report. Possible values are `Daily` and `Monthly`.
        """
        return pulumi.get(self, "granularity")

    @granularity.setter
    def granularity(self, value: pulumi.Input[str]):
        pulumi.set(self, "granularity", value)

    @property
    @pulumi.getter
    def groupings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetGroupingArgs']]]]:
        """
        One or more `grouping` blocks as defined below.
        """
        return pulumi.get(self, "groupings")

    @groupings.setter
    def groupings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetGroupingArgs']]]]):
        pulumi.set(self, "groupings", value)

    @property
    @pulumi.getter
    def sortings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetSortingArgs']]]]:
        """
        One or more `sorting` blocks as defined below, containing the order by expression to be used in the report
        """
        return pulumi.get(self, "sortings")

    @sortings.setter
    def sortings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupCostManagementViewDatasetSortingArgs']]]]):
        pulumi.set(self, "sortings", value)


if not MYPY:
    class ResourceGroupCostManagementViewDatasetAggregationArgsDict(TypedDict):
        column_name: pulumi.Input[str]
        """
        The name of the column to aggregate. Changing this forces a new Cost Management View for a Resource Group to be created.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this aggregation. Changing this forces a new Cost Management View for a Resource Group to be created.
        """
elif False:
    ResourceGroupCostManagementViewDatasetAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupCostManagementViewDatasetAggregationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] column_name: The name of the column to aggregate. Changing this forces a new Cost Management View for a Resource Group to be created.
        :param pulumi.Input[str] name: The name which should be used for this aggregation. Changing this forces a new Cost Management View for a Resource Group to be created.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[str]:
        """
        The name of the column to aggregate. Changing this forces a new Cost Management View for a Resource Group to be created.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this aggregation. Changing this forces a new Cost Management View for a Resource Group to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ResourceGroupCostManagementViewDatasetGroupingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column to group.
        """
        type: pulumi.Input[str]
        """
        The type of the column. Possible values are `Dimension` and `TagKey`.
        """
elif False:
    ResourceGroupCostManagementViewDatasetGroupingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupCostManagementViewDatasetGroupingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the column to group.
        :param pulumi.Input[str] type: The type of the column. Possible values are `Dimension` and `TagKey`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the column. Possible values are `Dimension` and `TagKey`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceGroupCostManagementViewDatasetSortingArgsDict(TypedDict):
        direction: pulumi.Input[str]
        """
        Direction of sort. Possible values are `Ascending` and `Descending`.
        """
        name: pulumi.Input[str]
        """
        The name of the column to sort.
        """
elif False:
    ResourceGroupCostManagementViewDatasetSortingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupCostManagementViewDatasetSortingArgs:
    def __init__(__self__, *,
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] direction: Direction of sort. Possible values are `Ascending` and `Descending`.
        :param pulumi.Input[str] name: The name of the column to sort.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        Direction of sort. Possible values are `Ascending` and `Descending`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to sort.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ResourceGroupCostManagementViewKpiArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        KPI type. Possible values are `Budget` and `Forecast`.
        """
elif False:
    ResourceGroupCostManagementViewKpiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupCostManagementViewKpiArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: KPI type. Possible values are `Budget` and `Forecast`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        KPI type. Possible values are `Budget` and `Forecast`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceGroupCostManagementViewPivotArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column which should be used for this sub-view in the Cost Analysis UI.
        """
        type: pulumi.Input[str]
        """
        The data type to show in this sub-view. Possible values are `Dimension` and `TagKey`.
        """
elif False:
    ResourceGroupCostManagementViewPivotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupCostManagementViewPivotArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the column which should be used for this sub-view in the Cost Analysis UI.
        :param pulumi.Input[str] type: The data type to show in this sub-view. Possible values are `Dimension` and `TagKey`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column which should be used for this sub-view in the Cost Analysis UI.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The data type to show in this sub-view. Possible values are `Dimension` and `TagKey`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceGroupPolicyAssignmentIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Managed Identity IDs which should be assigned to the Policy Definition.

        > **NOTE:** This is required when `type` is set to `UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID of the Policy Assignment for this Resource Group.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID of the Policy Assignment for this Resource Group.
        """
elif False:
    ResourceGroupPolicyAssignmentIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupPolicyAssignmentIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` and `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Managed Identity IDs which should be assigned to the Policy Definition.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID of the Policy Assignment for this Resource Group.
        :param pulumi.Input[str] tenant_id: The Tenant ID of the Policy Assignment for this Resource Group.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Managed Identity IDs which should be assigned to the Policy Definition.

        > **NOTE:** This is required when `type` is set to `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID of the Policy Assignment for this Resource Group.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID of the Policy Assignment for this Resource Group.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ResourceGroupPolicyAssignmentNonComplianceMessageArgsDict(TypedDict):
        content: pulumi.Input[str]
        """
        The non-compliance message text. When assigning policy sets (initiatives), unless `policy_definition_reference_id` is specified then this message will be the default for all policies.
        """
        policy_definition_reference_id: NotRequired[pulumi.Input[str]]
        """
        When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
        """
elif False:
    ResourceGroupPolicyAssignmentNonComplianceMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupPolicyAssignmentNonComplianceMessageArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 policy_definition_reference_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: The non-compliance message text. When assigning policy sets (initiatives), unless `policy_definition_reference_id` is specified then this message will be the default for all policies.
        :param pulumi.Input[str] policy_definition_reference_id: When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
        """
        pulumi.set(__self__, "content", content)
        if policy_definition_reference_id is not None:
            pulumi.set(__self__, "policy_definition_reference_id", policy_definition_reference_id)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The non-compliance message text. When assigning policy sets (initiatives), unless `policy_definition_reference_id` is specified then this message will be the default for all policies.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="policyDefinitionReferenceId")
    def policy_definition_reference_id(self) -> Optional[pulumi.Input[str]]:
        """
        When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
        """
        return pulumi.get(self, "policy_definition_reference_id")

    @policy_definition_reference_id.setter
    def policy_definition_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_definition_reference_id", value)


if not MYPY:
    class ResourceGroupPolicyAssignmentOverrideArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentOverrideSelectorArgsDict']]]]
        """
        One or more `override_selector` block as defined below.
        """
elif False:
    ResourceGroupPolicyAssignmentOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupPolicyAssignmentOverrideArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentOverrideSelectorArgs']]]] = None):
        """
        :param pulumi.Input[str] value: Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
        :param pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentOverrideSelectorArgs']]] selectors: One or more `override_selector` block as defined below.
        """
        pulumi.set(__self__, "value", value)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentOverrideSelectorArgs']]]]:
        """
        One or more `override_selector` block as defined below.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentOverrideSelectorArgs']]]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class ResourceGroupPolicyAssignmentOverrideSelectorArgsDict(TypedDict):
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        kind: NotRequired[pulumi.Input[str]]
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ResourceGroupPolicyAssignmentOverrideSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupPolicyAssignmentOverrideSelectorArgs:
    def __init__(__self__, *,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class ResourceGroupPolicyAssignmentResourceSelectorArgsDict(TypedDict):
        selectors: pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentResourceSelectorSelectorArgsDict']]]
        """
        One or more `resource_selector` block as defined below.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Specifies a name for the resource selector.
        """
elif False:
    ResourceGroupPolicyAssignmentResourceSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupPolicyAssignmentResourceSelectorArgs:
    def __init__(__self__, *,
                 selectors: pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentResourceSelectorSelectorArgs']]],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentResourceSelectorSelectorArgs']]] selectors: One or more `resource_selector` block as defined below.
        :param pulumi.Input[str] name: Specifies a name for the resource selector.
        """
        pulumi.set(__self__, "selectors", selectors)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentResourceSelectorSelectorArgs']]]:
        """
        One or more `resource_selector` block as defined below.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['ResourceGroupPolicyAssignmentResourceSelectorSelectorArgs']]]):
        pulumi.set(self, "selectors", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a name for the resource selector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ResourceGroupPolicyAssignmentResourceSelectorSelectorArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ResourceGroupPolicyAssignmentResourceSelectorSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupPolicyAssignmentResourceSelectorSelectorArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        pulumi.set(__self__, "kind", kind)
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class ResourcePolicyAssignmentIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Managed Identity IDs which should be assigned to the Policy Definition.

        > **NOTE:** This is required when `type` is set to `UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID of the Policy Assignment for this Resource.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID of the Policy Assignment for this Resource.
        """
elif False:
    ResourcePolicyAssignmentIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePolicyAssignmentIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` and `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Managed Identity IDs which should be assigned to the Policy Definition.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID of the Policy Assignment for this Resource.
        :param pulumi.Input[str] tenant_id: The Tenant ID of the Policy Assignment for this Resource.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` and `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Managed Identity IDs which should be assigned to the Policy Definition.

        > **NOTE:** This is required when `type` is set to `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID of the Policy Assignment for this Resource.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID of the Policy Assignment for this Resource.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ResourcePolicyAssignmentNonComplianceMessageArgsDict(TypedDict):
        content: pulumi.Input[str]
        """
        The non-compliance message text. When assigning policy sets (initiatives), unless `policy_definition_reference_id` is specified then this message will be the default for all policies.
        """
        policy_definition_reference_id: NotRequired[pulumi.Input[str]]
        """
        When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
        """
elif False:
    ResourcePolicyAssignmentNonComplianceMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePolicyAssignmentNonComplianceMessageArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 policy_definition_reference_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: The non-compliance message text. When assigning policy sets (initiatives), unless `policy_definition_reference_id` is specified then this message will be the default for all policies.
        :param pulumi.Input[str] policy_definition_reference_id: When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
        """
        pulumi.set(__self__, "content", content)
        if policy_definition_reference_id is not None:
            pulumi.set(__self__, "policy_definition_reference_id", policy_definition_reference_id)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The non-compliance message text. When assigning policy sets (initiatives), unless `policy_definition_reference_id` is specified then this message will be the default for all policies.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="policyDefinitionReferenceId")
    def policy_definition_reference_id(self) -> Optional[pulumi.Input[str]]:
        """
        When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
        """
        return pulumi.get(self, "policy_definition_reference_id")

    @policy_definition_reference_id.setter
    def policy_definition_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_definition_reference_id", value)


if not MYPY:
    class ResourcePolicyAssignmentOverrideArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentOverrideSelectorArgsDict']]]]
        """
        One or more `override_selector` block as defined below.
        """
elif False:
    ResourcePolicyAssignmentOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePolicyAssignmentOverrideArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentOverrideSelectorArgs']]]] = None):
        """
        :param pulumi.Input[str] value: Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
        :param pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentOverrideSelectorArgs']]] selectors: One or more `override_selector` block as defined below.
        """
        pulumi.set(__self__, "value", value)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentOverrideSelectorArgs']]]]:
        """
        One or more `override_selector` block as defined below.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentOverrideSelectorArgs']]]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class ResourcePolicyAssignmentOverrideSelectorArgsDict(TypedDict):
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        kind: NotRequired[pulumi.Input[str]]
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ResourcePolicyAssignmentOverrideSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePolicyAssignmentOverrideSelectorArgs:
    def __init__(__self__, *,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class ResourcePolicyAssignmentResourceSelectorArgsDict(TypedDict):
        selectors: pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentResourceSelectorSelectorArgsDict']]]
        """
        One or more `resource_selector` block as defined below.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Specifies a name for the resource selector.
        """
elif False:
    ResourcePolicyAssignmentResourceSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePolicyAssignmentResourceSelectorArgs:
    def __init__(__self__, *,
                 selectors: pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentResourceSelectorSelectorArgs']]],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentResourceSelectorSelectorArgs']]] selectors: One or more `resource_selector` block as defined below.
        :param pulumi.Input[str] name: Specifies a name for the resource selector.
        """
        pulumi.set(__self__, "selectors", selectors)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentResourceSelectorSelectorArgs']]]:
        """
        One or more `resource_selector` block as defined below.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['ResourcePolicyAssignmentResourceSelectorSelectorArgs']]]):
        pulumi.set(self, "selectors", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a name for the resource selector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ResourcePolicyAssignmentResourceSelectorSelectorArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ResourcePolicyAssignmentResourceSelectorSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePolicyAssignmentResourceSelectorSelectorArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        pulumi.set(__self__, "kind", kind)
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class ResourceProviderRegistrationFeatureArgsDict(TypedDict):
        name: pulumi.Input[str]
        registered: pulumi.Input[bool]
        """
        Should this feature be Registered or Unregistered?
        """
elif False:
    ResourceProviderRegistrationFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceProviderRegistrationFeatureArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 registered: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] registered: Should this feature be Registered or Unregistered?
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "registered", registered)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def registered(self) -> pulumi.Input[bool]:
        """
        Should this feature be Registered or Unregistered?
        """
        return pulumi.get(self, "registered")

    @registered.setter
    def registered(self, value: pulumi.Input[bool]):
        pulumi.set(self, "registered", value)


if not MYPY:
    class SubscriptionCostManagementExportExportDataOptionsArgsDict(TypedDict):
        time_frame: pulumi.Input[str]
        """
        The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `BillingMonthToDate`, `TheLast7Days`, `TheLastMonth`, `TheLastBillingMonth`, `Custom`.
        """
        type: pulumi.Input[str]
        """
        The type of the query. Possible values are `ActualCost`, `AmortizedCost` and `Usage`.
        """
elif False:
    SubscriptionCostManagementExportExportDataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCostManagementExportExportDataOptionsArgs:
    def __init__(__self__, *,
                 time_frame: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] time_frame: The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `BillingMonthToDate`, `TheLast7Days`, `TheLastMonth`, `TheLastBillingMonth`, `Custom`.
        :param pulumi.Input[str] type: The type of the query. Possible values are `ActualCost`, `AmortizedCost` and `Usage`.
        """
        pulumi.set(__self__, "time_frame", time_frame)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="timeFrame")
    def time_frame(self) -> pulumi.Input[str]:
        """
        The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `BillingMonthToDate`, `TheLast7Days`, `TheLastMonth`, `TheLastBillingMonth`, `Custom`.
        """
        return pulumi.get(self, "time_frame")

    @time_frame.setter
    def time_frame(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_frame", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the query. Possible values are `ActualCost`, `AmortizedCost` and `Usage`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SubscriptionCostManagementExportExportDataStorageLocationArgsDict(TypedDict):
        container_id: pulumi.Input[str]
        """
        The Resource Manager ID of the container where exports will be uploaded. Changing this forces a new resource to be created.
        """
        root_folder_path: pulumi.Input[str]
        """
        The path of the directory where exports will be uploaded. Changing this forces a new resource to be created.

        > **Note:** The Resource Manager ID of a Storage Container is exposed via the `resource_manager_id` attribute of the `storage.Container` resource.
        """
elif False:
    SubscriptionCostManagementExportExportDataStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCostManagementExportExportDataStorageLocationArgs:
    def __init__(__self__, *,
                 container_id: pulumi.Input[str],
                 root_folder_path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] container_id: The Resource Manager ID of the container where exports will be uploaded. Changing this forces a new resource to be created.
        :param pulumi.Input[str] root_folder_path: The path of the directory where exports will be uploaded. Changing this forces a new resource to be created.
               
               > **Note:** The Resource Manager ID of a Storage Container is exposed via the `resource_manager_id` attribute of the `storage.Container` resource.
        """
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "root_folder_path", root_folder_path)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> pulumi.Input[str]:
        """
        The Resource Manager ID of the container where exports will be uploaded. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "container_id")

    @container_id.setter
    def container_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_id", value)

    @property
    @pulumi.getter(name="rootFolderPath")
    def root_folder_path(self) -> pulumi.Input[str]:
        """
        The path of the directory where exports will be uploaded. Changing this forces a new resource to be created.

        > **Note:** The Resource Manager ID of a Storage Container is exposed via the `resource_manager_id` attribute of the `storage.Container` resource.
        """
        return pulumi.get(self, "root_folder_path")

    @root_folder_path.setter
    def root_folder_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "root_folder_path", value)


if not MYPY:
    class SubscriptionCostManagementViewDatasetArgsDict(TypedDict):
        aggregations: pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetAggregationArgsDict']]]
        """
        One or more `aggregation` blocks as defined above.
        """
        granularity: pulumi.Input[str]
        """
        The granularity of rows in the report. Possible values are `Daily` and `Monthly`.
        """
        groupings: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetGroupingArgsDict']]]]
        """
        One or more `grouping` blocks as defined below.
        """
        sortings: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetSortingArgsDict']]]]
        """
        One or more `sorting` blocks as defined below, containing the order by expression to be used in the report
        """
elif False:
    SubscriptionCostManagementViewDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCostManagementViewDatasetArgs:
    def __init__(__self__, *,
                 aggregations: pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetAggregationArgs']]],
                 granularity: pulumi.Input[str],
                 groupings: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetGroupingArgs']]]] = None,
                 sortings: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetSortingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetAggregationArgs']]] aggregations: One or more `aggregation` blocks as defined above.
        :param pulumi.Input[str] granularity: The granularity of rows in the report. Possible values are `Daily` and `Monthly`.
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetGroupingArgs']]] groupings: One or more `grouping` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetSortingArgs']]] sortings: One or more `sorting` blocks as defined below, containing the order by expression to be used in the report
        """
        pulumi.set(__self__, "aggregations", aggregations)
        pulumi.set(__self__, "granularity", granularity)
        if groupings is not None:
            pulumi.set(__self__, "groupings", groupings)
        if sortings is not None:
            pulumi.set(__self__, "sortings", sortings)

    @property
    @pulumi.getter
    def aggregations(self) -> pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetAggregationArgs']]]:
        """
        One or more `aggregation` blocks as defined above.
        """
        return pulumi.get(self, "aggregations")

    @aggregations.setter
    def aggregations(self, value: pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetAggregationArgs']]]):
        pulumi.set(self, "aggregations", value)

    @property
    @pulumi.getter
    def granularity(self) -> pulumi.Input[str]:
        """
        The granularity of rows in the report. Possible values are `Daily` and `Monthly`.
        """
        return pulumi.get(self, "granularity")

    @granularity.setter
    def granularity(self, value: pulumi.Input[str]):
        pulumi.set(self, "granularity", value)

    @property
    @pulumi.getter
    def groupings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetGroupingArgs']]]]:
        """
        One or more `grouping` blocks as defined below.
        """
        return pulumi.get(self, "groupings")

    @groupings.setter
    def groupings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetGroupingArgs']]]]):
        pulumi.set(self, "groupings", value)

    @property
    @pulumi.getter
    def sortings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetSortingArgs']]]]:
        """
        One or more `sorting` blocks as defined below, containing the order by expression to be used in the report
        """
        return pulumi.get(self, "sortings")

    @sortings.setter
    def sortings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionCostManagementViewDatasetSortingArgs']]]]):
        pulumi.set(self, "sortings", value)


if not MYPY:
    class SubscriptionCostManagementViewDatasetAggregationArgsDict(TypedDict):
        column_name: pulumi.Input[str]
        """
        The name of the column to aggregate. Changing this forces a new Cost Management View for a Subscription to be created.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this aggregation. Changing this forces a new Cost Management View for a Subscription to be created.
        """
elif False:
    SubscriptionCostManagementViewDatasetAggregationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCostManagementViewDatasetAggregationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] column_name: The name of the column to aggregate. Changing this forces a new Cost Management View for a Subscription to be created.
        :param pulumi.Input[str] name: The name which should be used for this aggregation. Changing this forces a new Cost Management View for a Subscription to be created.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[str]:
        """
        The name of the column to aggregate. Changing this forces a new Cost Management View for a Subscription to be created.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this aggregation. Changing this forces a new Cost Management View for a Subscription to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SubscriptionCostManagementViewDatasetGroupingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column to group.
        """
        type: pulumi.Input[str]
        """
        The type of the column. Possible values are `Dimension` and `TagKey`.
        """
elif False:
    SubscriptionCostManagementViewDatasetGroupingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCostManagementViewDatasetGroupingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the column to group.
        :param pulumi.Input[str] type: The type of the column. Possible values are `Dimension` and `TagKey`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the column. Possible values are `Dimension` and `TagKey`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SubscriptionCostManagementViewDatasetSortingArgsDict(TypedDict):
        direction: pulumi.Input[str]
        """
        Direction of sort. Possible values are `Ascending` and `Descending`.
        """
        name: pulumi.Input[str]
        """
        The name of the column to sort.
        """
elif False:
    SubscriptionCostManagementViewDatasetSortingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCostManagementViewDatasetSortingArgs:
    def __init__(__self__, *,
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] direction: Direction of sort. Possible values are `Ascending` and `Descending`.
        :param pulumi.Input[str] name: The name of the column to sort.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        Direction of sort. Possible values are `Ascending` and `Descending`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column to sort.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SubscriptionCostManagementViewKpiArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        KPI type. Possible values are `Budget` and `Forecast`.
        """
elif False:
    SubscriptionCostManagementViewKpiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCostManagementViewKpiArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: KPI type. Possible values are `Budget` and `Forecast`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        KPI type. Possible values are `Budget` and `Forecast`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SubscriptionCostManagementViewPivotArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the column which should be used for this sub-view in the Cost Analysis UI.
        """
        type: pulumi.Input[str]
        """
        The data type to show in this sub-view. Possible values are `Dimension` and `TagKey`.
        """
elif False:
    SubscriptionCostManagementViewPivotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCostManagementViewPivotArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the column which should be used for this sub-view in the Cost Analysis UI.
        :param pulumi.Input[str] type: The data type to show in this sub-view. Possible values are `Dimension` and `TagKey`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the column which should be used for this sub-view in the Cost Analysis UI.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The data type to show in this sub-view. Possible values are `Dimension` and `TagKey`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SubscriptionPolicyAssignmentIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` or `UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Managed Identity IDs which should be assigned to the Policy Definition.

        > **NOTE:** This is required when `type` is set to `UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID of the Policy Assignment for this Subscription.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID of the Policy Assignment for this Subscription.
        """
elif False:
    SubscriptionPolicyAssignmentIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionPolicyAssignmentIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` or `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Managed Identity IDs which should be assigned to the Policy Definition.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID of the Policy Assignment for this Subscription.
        :param pulumi.Input[str] tenant_id: The Tenant ID of the Policy Assignment for this Subscription.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` or `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Managed Identity IDs which should be assigned to the Policy Definition.

        > **NOTE:** This is required when `type` is set to `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID of the Policy Assignment for this Subscription.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID of the Policy Assignment for this Subscription.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class SubscriptionPolicyAssignmentNonComplianceMessageArgsDict(TypedDict):
        content: pulumi.Input[str]
        """
        The non-compliance message text. When assigning policy sets (initiatives), unless `policy_definition_reference_id` is specified then this message will be the default for all policies.
        """
        policy_definition_reference_id: NotRequired[pulumi.Input[str]]
        """
        When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
        """
elif False:
    SubscriptionPolicyAssignmentNonComplianceMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionPolicyAssignmentNonComplianceMessageArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 policy_definition_reference_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: The non-compliance message text. When assigning policy sets (initiatives), unless `policy_definition_reference_id` is specified then this message will be the default for all policies.
        :param pulumi.Input[str] policy_definition_reference_id: When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
        """
        pulumi.set(__self__, "content", content)
        if policy_definition_reference_id is not None:
            pulumi.set(__self__, "policy_definition_reference_id", policy_definition_reference_id)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The non-compliance message text. When assigning policy sets (initiatives), unless `policy_definition_reference_id` is specified then this message will be the default for all policies.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="policyDefinitionReferenceId")
    def policy_definition_reference_id(self) -> Optional[pulumi.Input[str]]:
        """
        When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
        """
        return pulumi.get(self, "policy_definition_reference_id")

    @policy_definition_reference_id.setter
    def policy_definition_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_definition_reference_id", value)


if not MYPY:
    class SubscriptionPolicyAssignmentOverrideArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentOverrideSelectorArgsDict']]]]
        """
        One or more `override_selector` block as defined below.
        """
elif False:
    SubscriptionPolicyAssignmentOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionPolicyAssignmentOverrideArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentOverrideSelectorArgs']]]] = None):
        """
        :param pulumi.Input[str] value: Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentOverrideSelectorArgs']]] selectors: One or more `override_selector` block as defined below.
        """
        pulumi.set(__self__, "value", value)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentOverrideSelectorArgs']]]]:
        """
        One or more `override_selector` block as defined below.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentOverrideSelectorArgs']]]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class SubscriptionPolicyAssignmentOverrideSelectorArgsDict(TypedDict):
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        kind: NotRequired[pulumi.Input[str]]
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SubscriptionPolicyAssignmentOverrideSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionPolicyAssignmentOverrideSelectorArgs:
    def __init__(__self__, *,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class SubscriptionPolicyAssignmentResourceSelectorArgsDict(TypedDict):
        selectors: pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentResourceSelectorSelectorArgsDict']]]
        """
        One or more `resource_selector` block as defined below.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Specifies a name for the resource selector.
        """
elif False:
    SubscriptionPolicyAssignmentResourceSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionPolicyAssignmentResourceSelectorArgs:
    def __init__(__self__, *,
                 selectors: pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentResourceSelectorSelectorArgs']]],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentResourceSelectorSelectorArgs']]] selectors: One or more `resource_selector` block as defined below.
        :param pulumi.Input[str] name: Specifies a name for the resource selector.
        """
        pulumi.set(__self__, "selectors", selectors)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentResourceSelectorSelectorArgs']]]:
        """
        One or more `resource_selector` block as defined below.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['SubscriptionPolicyAssignmentResourceSelectorSelectorArgs']]]):
        pulumi.set(self, "selectors", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a name for the resource selector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SubscriptionPolicyAssignmentResourceSelectorSelectorArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SubscriptionPolicyAssignmentResourceSelectorSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionPolicyAssignmentResourceSelectorSelectorArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        pulumi.set(__self__, "kind", kind)
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`, `resourceType` and `resourceWithoutLocation`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


