# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ConnectedRegistryNotificationArgs',
    'FluxConfigurationBlobStorageArgs',
    'FluxConfigurationBlobStorageManagedIdentityArgs',
    'FluxConfigurationBlobStorageServicePrincipalArgs',
    'FluxConfigurationBucketArgs',
    'FluxConfigurationGitRepositoryArgs',
    'FluxConfigurationKustomizationArgs',
    'GroupContainerArgs',
    'GroupContainerGpuArgs',
    'GroupContainerGpuLimitArgs',
    'GroupContainerLivenessProbeArgs',
    'GroupContainerLivenessProbeHttpGetArgs',
    'GroupContainerPortArgs',
    'GroupContainerReadinessProbeArgs',
    'GroupContainerReadinessProbeHttpGetArgs',
    'GroupContainerSecurityArgs',
    'GroupContainerVolumeArgs',
    'GroupContainerVolumeGitRepoArgs',
    'GroupDiagnosticsArgs',
    'GroupDiagnosticsLogAnalyticsArgs',
    'GroupDnsConfigArgs',
    'GroupExposedPortArgs',
    'GroupIdentityArgs',
    'GroupImageRegistryCredentialArgs',
    'GroupInitContainerArgs',
    'GroupInitContainerSecurityArgs',
    'GroupInitContainerVolumeArgs',
    'GroupInitContainerVolumeGitRepoArgs',
    'KubernetesClusterAciConnectorLinuxArgs',
    'KubernetesClusterAciConnectorLinuxConnectorIdentityArgs',
    'KubernetesClusterApiServerAccessProfileArgs',
    'KubernetesClusterAutoScalerProfileArgs',
    'KubernetesClusterAzureActiveDirectoryRoleBasedAccessControlArgs',
    'KubernetesClusterConfidentialComputingArgs',
    'KubernetesClusterDefaultNodePoolArgs',
    'KubernetesClusterDefaultNodePoolKubeletConfigArgs',
    'KubernetesClusterDefaultNodePoolLinuxOsConfigArgs',
    'KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfigArgs',
    'KubernetesClusterDefaultNodePoolNodeNetworkProfileArgs',
    'KubernetesClusterDefaultNodePoolUpgradeSettingsArgs',
    'KubernetesClusterExtensionAksAssignedIdentityArgs',
    'KubernetesClusterExtensionPlanArgs',
    'KubernetesClusterHttpProxyConfigArgs',
    'KubernetesClusterIdentityArgs',
    'KubernetesClusterIngressApplicationGatewayArgs',
    'KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityArgs',
    'KubernetesClusterKeyManagementServiceArgs',
    'KubernetesClusterKeyVaultSecretsProviderArgs',
    'KubernetesClusterKeyVaultSecretsProviderSecretIdentityArgs',
    'KubernetesClusterKubeAdminConfigArgs',
    'KubernetesClusterKubeConfigArgs',
    'KubernetesClusterKubeletIdentityArgs',
    'KubernetesClusterLinuxProfileArgs',
    'KubernetesClusterLinuxProfileSshKeyArgs',
    'KubernetesClusterMaintenanceWindowArgs',
    'KubernetesClusterMaintenanceWindowAllowedArgs',
    'KubernetesClusterMaintenanceWindowAutoUpgradeArgs',
    'KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowedArgs',
    'KubernetesClusterMaintenanceWindowNodeOsArgs',
    'KubernetesClusterMaintenanceWindowNodeOsNotAllowedArgs',
    'KubernetesClusterMaintenanceWindowNotAllowedArgs',
    'KubernetesClusterMicrosoftDefenderArgs',
    'KubernetesClusterMonitorMetricsArgs',
    'KubernetesClusterNetworkProfileArgs',
    'KubernetesClusterNetworkProfileLoadBalancerProfileArgs',
    'KubernetesClusterNetworkProfileNatGatewayProfileArgs',
    'KubernetesClusterNodePoolKubeletConfigArgs',
    'KubernetesClusterNodePoolLinuxOsConfigArgs',
    'KubernetesClusterNodePoolLinuxOsConfigSysctlConfigArgs',
    'KubernetesClusterNodePoolNodeNetworkProfileArgs',
    'KubernetesClusterNodePoolUpgradeSettingsArgs',
    'KubernetesClusterNodePoolWindowsProfileArgs',
    'KubernetesClusterOmsAgentArgs',
    'KubernetesClusterOmsAgentOmsAgentIdentityArgs',
    'KubernetesClusterServiceMeshProfileArgs',
    'KubernetesClusterServicePrincipalArgs',
    'KubernetesClusterStorageProfileArgs',
    'KubernetesClusterWebAppRoutingArgs',
    'KubernetesClusterWebAppRoutingWebAppRoutingIdentityArgs',
    'KubernetesClusterWindowsProfileArgs',
    'KubernetesClusterWindowsProfileGmsaArgs',
    'KubernetesClusterWorkloadAutoscalerProfileArgs',
    'KubernetesFleetManagerHubProfileArgs',
    'RegistryEncryptionArgs',
    'RegistryGeoreplicationArgs',
    'RegistryIdentityArgs',
    'RegistryNetworkRuleSetArgs',
    'RegistryNetworkRuleSetIpRuleArgs',
    'RegistryNetworkRuleSetVirtualNetworkArgs',
    'RegistryRetentionPolicyArgs',
    'RegistryTaskAgentSettingArgs',
    'RegistryTaskBaseImageTriggerArgs',
    'RegistryTaskDockerStepArgs',
    'RegistryTaskEncodedStepArgs',
    'RegistryTaskFileStepArgs',
    'RegistryTaskIdentityArgs',
    'RegistryTaskPlatformArgs',
    'RegistryTaskRegistryCredentialArgs',
    'RegistryTaskRegistryCredentialCustomArgs',
    'RegistryTaskRegistryCredentialSourceArgs',
    'RegistryTaskSourceTriggerArgs',
    'RegistryTaskSourceTriggerAuthenticationArgs',
    'RegistryTaskTimerTriggerArgs',
    'RegistryTrustPolicyArgs',
    'TokenPasswordPassword1Args',
    'TokenPasswordPassword2Args',
]

@pulumi.input_type
class ConnectedRegistryNotificationArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 digest: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action of the artifact that wants to be subscribed for the Connected Registry. Possible values are `push`, `delete` and `*` (i.e. any).
        :param pulumi.Input[str] name: The name of the artifact that wants to be subscribed for the Connected Registry.
        :param pulumi.Input[str] digest: The digest of the artifact that wants to be subscribed for the Connected Registry.
               
               > **NOTE:** One of either `tag` or `digest` can be specified.
        :param pulumi.Input[str] tag: The tag of the artifact that wants to be subscribed for the Connected Registry.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action of the artifact that wants to be subscribed for the Connected Registry. Possible values are `push`, `delete` and `*` (i.e. any).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the artifact that wants to be subscribed for the Connected Registry.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[str]]:
        """
        The digest of the artifact that wants to be subscribed for the Connected Registry.

        > **NOTE:** One of either `tag` or `digest` can be specified.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "digest", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        The tag of the artifact that wants to be subscribed for the Connected Registry.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class FluxConfigurationBlobStorageArgs:
    def __init__(__self__, *,
                 container_id: pulumi.Input[str],
                 account_key: Optional[pulumi.Input[str]] = None,
                 local_auth_reference: Optional[pulumi.Input[str]] = None,
                 managed_identity: Optional[pulumi.Input['FluxConfigurationBlobStorageManagedIdentityArgs']] = None,
                 sas_token: Optional[pulumi.Input[str]] = None,
                 service_principal: Optional[pulumi.Input['FluxConfigurationBlobStorageServicePrincipalArgs']] = None,
                 sync_interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] container_id: Specifies the Azure Blob container ID.
        :param pulumi.Input[str] account_key: Specifies the account key (shared key) to access the storage account.
        :param pulumi.Input[str] local_auth_reference: Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param pulumi.Input['FluxConfigurationBlobStorageManagedIdentityArgs'] managed_identity: A `managed_identity` block as defined below.
        :param pulumi.Input[str] sas_token: Specifies the shared access token to access the storage container.
        :param pulumi.Input['FluxConfigurationBlobStorageServicePrincipalArgs'] service_principal: A `service_principal` block as defined below.
        :param pulumi.Input[int] sync_interval_in_seconds: Specifies the interval at which to re-reconcile the cluster Azure Blob source with the remote.
        :param pulumi.Input[int] timeout_in_seconds: Specifies the maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
        """
        pulumi.set(__self__, "container_id", container_id)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if local_auth_reference is not None:
            pulumi.set(__self__, "local_auth_reference", local_auth_reference)
        if managed_identity is not None:
            pulumi.set(__self__, "managed_identity", managed_identity)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if service_principal is not None:
            pulumi.set(__self__, "service_principal", service_principal)
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> pulumi.Input[str]:
        """
        Specifies the Azure Blob container ID.
        """
        return pulumi.get(self, "container_id")

    @container_id.setter
    def container_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_id", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the account key (shared key) to access the storage account.
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="localAuthReference")
    def local_auth_reference(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_reference")

    @local_auth_reference.setter
    def local_auth_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_auth_reference", value)

    @property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> Optional[pulumi.Input['FluxConfigurationBlobStorageManagedIdentityArgs']]:
        """
        A `managed_identity` block as defined below.
        """
        return pulumi.get(self, "managed_identity")

    @managed_identity.setter
    def managed_identity(self, value: Optional[pulumi.Input['FluxConfigurationBlobStorageManagedIdentityArgs']]):
        pulumi.set(self, "managed_identity", value)

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the shared access token to access the storage container.
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sas_token", value)

    @property
    @pulumi.getter(name="servicePrincipal")
    def service_principal(self) -> Optional[pulumi.Input['FluxConfigurationBlobStorageServicePrincipalArgs']]:
        """
        A `service_principal` block as defined below.
        """
        return pulumi.get(self, "service_principal")

    @service_principal.setter
    def service_principal(self, value: Optional[pulumi.Input['FluxConfigurationBlobStorageServicePrincipalArgs']]):
        pulumi.set(self, "service_principal", value)

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the interval at which to re-reconcile the cluster Azure Blob source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @sync_interval_in_seconds.setter
    def sync_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sync_interval_in_seconds", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_seconds", value)


@pulumi.input_type
class FluxConfigurationBlobStorageManagedIdentityArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: Specifies the client ID for authenticating a Managed Identity.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Specifies the client ID for authenticating a Managed Identity.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


@pulumi.input_type
class FluxConfigurationBlobStorageServicePrincipalArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 client_certificate_base64: Optional[pulumi.Input[str]] = None,
                 client_certificate_password: Optional[pulumi.Input[str]] = None,
                 client_certificate_send_chain: Optional[pulumi.Input[bool]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: Specifies the client ID for authenticating a Service Principal.
        :param pulumi.Input[str] tenant_id: Specifies the tenant ID for authenticating a Service Principal.
        :param pulumi.Input[str] client_certificate_base64: Base64-encoded certificate used to authenticate a Service Principal .
        :param pulumi.Input[str] client_certificate_password: Specifies the password for the certificate used to authenticate a Service Principal .
        :param pulumi.Input[bool] client_certificate_send_chain: Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the client certificate.
        :param pulumi.Input[str] client_secret: Specifies the client secret for authenticating a Service Principal.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if client_certificate_base64 is not None:
            pulumi.set(__self__, "client_certificate_base64", client_certificate_base64)
        if client_certificate_password is not None:
            pulumi.set(__self__, "client_certificate_password", client_certificate_password)
        if client_certificate_send_chain is not None:
            pulumi.set(__self__, "client_certificate_send_chain", client_certificate_send_chain)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Specifies the client ID for authenticating a Service Principal.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Specifies the tenant ID for authenticating a Service Principal.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="clientCertificateBase64")
    def client_certificate_base64(self) -> Optional[pulumi.Input[str]]:
        """
        Base64-encoded certificate used to authenticate a Service Principal .
        """
        return pulumi.get(self, "client_certificate_base64")

    @client_certificate_base64.setter
    def client_certificate_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate_base64", value)

    @property
    @pulumi.getter(name="clientCertificatePassword")
    def client_certificate_password(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the password for the certificate used to authenticate a Service Principal .
        """
        return pulumi.get(self, "client_certificate_password")

    @client_certificate_password.setter
    def client_certificate_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate_password", value)

    @property
    @pulumi.getter(name="clientCertificateSendChain")
    def client_certificate_send_chain(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the client certificate.
        """
        return pulumi.get(self, "client_certificate_send_chain")

    @client_certificate_send_chain.setter
    def client_certificate_send_chain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_certificate_send_chain", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the client secret for authenticating a Service Principal.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class FluxConfigurationBucketArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 local_auth_reference: Optional[pulumi.Input[str]] = None,
                 secret_key_base64: Optional[pulumi.Input[str]] = None,
                 sync_interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[int]] = None,
                 tls_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bucket_name: Specifies the bucket name to sync from the url endpoint for the flux configuration.
        :param pulumi.Input[str] url: Specifies the URL to sync for the flux configuration S3 bucket. It must start with `http://` or `https://`.
        :param pulumi.Input[str] access_key: Specifies the plaintext access key used to securely access the S3 bucket.
        :param pulumi.Input[str] local_auth_reference: Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
        :param pulumi.Input[str] secret_key_base64: Specifies the Base64-encoded secret key used to authenticate with the bucket source.
        :param pulumi.Input[int] sync_interval_in_seconds: Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
        :param pulumi.Input[int] timeout_in_seconds: Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
        :param pulumi.Input[bool] tls_enabled: Specify whether to communicate with a bucket using TLS is enabled. Defaults to `true`.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "url", url)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if local_auth_reference is not None:
            pulumi.set(__self__, "local_auth_reference", local_auth_reference)
        if secret_key_base64 is not None:
            pulumi.set(__self__, "secret_key_base64", secret_key_base64)
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if tls_enabled is not None:
            pulumi.set(__self__, "tls_enabled", tls_enabled)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        Specifies the bucket name to sync from the url endpoint for the flux configuration.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL to sync for the flux configuration S3 bucket. It must start with `http://` or `https://`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the plaintext access key used to securely access the S3 bucket.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="localAuthReference")
    def local_auth_reference(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
        """
        return pulumi.get(self, "local_auth_reference")

    @local_auth_reference.setter
    def local_auth_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_auth_reference", value)

    @property
    @pulumi.getter(name="secretKeyBase64")
    def secret_key_base64(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Base64-encoded secret key used to authenticate with the bucket source.
        """
        return pulumi.get(self, "secret_key_base64")

    @secret_key_base64.setter
    def secret_key_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key_base64", value)

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @sync_interval_in_seconds.setter
    def sync_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sync_interval_in_seconds", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_seconds", value)

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether to communicate with a bucket using TLS is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "tls_enabled")

    @tls_enabled.setter
    def tls_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_enabled", value)


@pulumi.input_type
class FluxConfigurationGitRepositoryArgs:
    def __init__(__self__, *,
                 reference_type: pulumi.Input[str],
                 reference_value: pulumi.Input[str],
                 url: pulumi.Input[str],
                 https_ca_cert_base64: Optional[pulumi.Input[str]] = None,
                 https_key_base64: Optional[pulumi.Input[str]] = None,
                 https_user: Optional[pulumi.Input[str]] = None,
                 local_auth_reference: Optional[pulumi.Input[str]] = None,
                 ssh_known_hosts_base64: Optional[pulumi.Input[str]] = None,
                 ssh_private_key_base64: Optional[pulumi.Input[str]] = None,
                 sync_interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] reference_type: Specifies the source reference type for the GitRepository object. Possible values are `branch`, `commit`, `semver` and `tag`.
        :param pulumi.Input[str] reference_value: Specifies the source reference value for the GitRepository object.
        :param pulumi.Input[str] url: Specifies the URL to sync for the flux configuration git repository. It must start with `http://`, `https://`, `git@` or `ssh://`.
        :param pulumi.Input[str] https_ca_cert_base64: Specifies the Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS.
        :param pulumi.Input[str] https_key_base64: Specifies the Base64-encoded HTTPS personal access token or password that will be used to access the repository.
        :param pulumi.Input[str] https_user: Specifies the plaintext HTTPS username used to access private git repositories over HTTPS.
        :param pulumi.Input[str] local_auth_reference: Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
        :param pulumi.Input[str] ssh_known_hosts_base64: Specifies the Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH.
        :param pulumi.Input[str] ssh_private_key_base64: Specifies the Base64-encoded SSH private key in PEM format.
        :param pulumi.Input[int] sync_interval_in_seconds: Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
        :param pulumi.Input[int] timeout_in_seconds: Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        pulumi.set(__self__, "reference_type", reference_type)
        pulumi.set(__self__, "reference_value", reference_value)
        pulumi.set(__self__, "url", url)
        if https_ca_cert_base64 is not None:
            pulumi.set(__self__, "https_ca_cert_base64", https_ca_cert_base64)
        if https_key_base64 is not None:
            pulumi.set(__self__, "https_key_base64", https_key_base64)
        if https_user is not None:
            pulumi.set(__self__, "https_user", https_user)
        if local_auth_reference is not None:
            pulumi.set(__self__, "local_auth_reference", local_auth_reference)
        if ssh_known_hosts_base64 is not None:
            pulumi.set(__self__, "ssh_known_hosts_base64", ssh_known_hosts_base64)
        if ssh_private_key_base64 is not None:
            pulumi.set(__self__, "ssh_private_key_base64", ssh_private_key_base64)
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> pulumi.Input[str]:
        """
        Specifies the source reference type for the GitRepository object. Possible values are `branch`, `commit`, `semver` and `tag`.
        """
        return pulumi.get(self, "reference_type")

    @reference_type.setter
    def reference_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_type", value)

    @property
    @pulumi.getter(name="referenceValue")
    def reference_value(self) -> pulumi.Input[str]:
        """
        Specifies the source reference value for the GitRepository object.
        """
        return pulumi.get(self, "reference_value")

    @reference_value.setter
    def reference_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_value", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL to sync for the flux configuration git repository. It must start with `http://`, `https://`, `git@` or `ssh://`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpsCaCertBase64")
    def https_ca_cert_base64(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS.
        """
        return pulumi.get(self, "https_ca_cert_base64")

    @https_ca_cert_base64.setter
    def https_ca_cert_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_ca_cert_base64", value)

    @property
    @pulumi.getter(name="httpsKeyBase64")
    def https_key_base64(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Base64-encoded HTTPS personal access token or password that will be used to access the repository.
        """
        return pulumi.get(self, "https_key_base64")

    @https_key_base64.setter
    def https_key_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_key_base64", value)

    @property
    @pulumi.getter(name="httpsUser")
    def https_user(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the plaintext HTTPS username used to access private git repositories over HTTPS.
        """
        return pulumi.get(self, "https_user")

    @https_user.setter
    def https_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_user", value)

    @property
    @pulumi.getter(name="localAuthReference")
    def local_auth_reference(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
        """
        return pulumi.get(self, "local_auth_reference")

    @local_auth_reference.setter
    def local_auth_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_auth_reference", value)

    @property
    @pulumi.getter(name="sshKnownHostsBase64")
    def ssh_known_hosts_base64(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH.
        """
        return pulumi.get(self, "ssh_known_hosts_base64")

    @ssh_known_hosts_base64.setter
    def ssh_known_hosts_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_known_hosts_base64", value)

    @property
    @pulumi.getter(name="sshPrivateKeyBase64")
    def ssh_private_key_base64(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Base64-encoded SSH private key in PEM format.
        """
        return pulumi.get(self, "ssh_private_key_base64")

    @ssh_private_key_base64.setter
    def ssh_private_key_base64(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_private_key_base64", value)

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @sync_interval_in_seconds.setter
    def sync_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sync_interval_in_seconds", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_seconds", value)


@pulumi.input_type
class FluxConfigurationKustomizationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 depends_ons: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 garbage_collection_enabled: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 recreating_enabled: Optional[pulumi.Input[bool]] = None,
                 retry_interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 sync_interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Specifies the name of the kustomization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] depends_ons: Specifies other kustomizations that this kustomization depends on. This kustomization will not reconcile until all dependencies have completed their reconciliation.
        :param pulumi.Input[bool] garbage_collection_enabled: Whether garbage collections of Kubernetes objects created by this kustomization is enabled. Defaults to `false`.
        :param pulumi.Input[str] path: Specifies the path in the source reference to reconcile on the cluster.
        :param pulumi.Input[bool] recreating_enabled: Whether re-creating Kubernetes resources on the cluster is enabled when patching fails due to an immutable field change. Defaults to `false`.
        :param pulumi.Input[int] retry_interval_in_seconds: The interval at which to re-reconcile the kustomization on the cluster in the event of failure on reconciliation. Defaults to `600`.
        :param pulumi.Input[int] sync_interval_in_seconds: The interval at which to re-reconcile the kustomization on the cluster. Defaults to `600`.
        :param pulumi.Input[int] timeout_in_seconds: The maximum time to attempt to reconcile the kustomization on the cluster. Defaults to `600`.
        """
        pulumi.set(__self__, "name", name)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if garbage_collection_enabled is not None:
            pulumi.set(__self__, "garbage_collection_enabled", garbage_collection_enabled)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if recreating_enabled is not None:
            pulumi.set(__self__, "recreating_enabled", recreating_enabled)
        if retry_interval_in_seconds is not None:
            pulumi.set(__self__, "retry_interval_in_seconds", retry_interval_in_seconds)
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the kustomization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies other kustomizations that this kustomization depends on. This kustomization will not reconcile until all dependencies have completed their reconciliation.
        """
        return pulumi.get(self, "depends_ons")

    @depends_ons.setter
    def depends_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "depends_ons", value)

    @property
    @pulumi.getter(name="garbageCollectionEnabled")
    def garbage_collection_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether garbage collections of Kubernetes objects created by this kustomization is enabled. Defaults to `false`.
        """
        return pulumi.get(self, "garbage_collection_enabled")

    @garbage_collection_enabled.setter
    def garbage_collection_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "garbage_collection_enabled", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the path in the source reference to reconcile on the cluster.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="recreatingEnabled")
    def recreating_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether re-creating Kubernetes resources on the cluster is enabled when patching fails due to an immutable field change. Defaults to `false`.
        """
        return pulumi.get(self, "recreating_enabled")

    @recreating_enabled.setter
    def recreating_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "recreating_enabled", value)

    @property
    @pulumi.getter(name="retryIntervalInSeconds")
    def retry_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The interval at which to re-reconcile the kustomization on the cluster in the event of failure on reconciliation. Defaults to `600`.
        """
        return pulumi.get(self, "retry_interval_in_seconds")

    @retry_interval_in_seconds.setter
    def retry_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry_interval_in_seconds", value)

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The interval at which to re-reconcile the kustomization on the cluster. Defaults to `600`.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @sync_interval_in_seconds.setter
    def sync_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sync_interval_in_seconds", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum time to attempt to reconcile the kustomization on the cluster. Defaults to `600`.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_seconds", value)


@pulumi.input_type
class GroupContainerArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[float],
                 image: pulumi.Input[str],
                 memory: pulumi.Input[float],
                 name: pulumi.Input[str],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_limit: Optional[pulumi.Input[float]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 gpu: Optional[pulumi.Input['GroupContainerGpuArgs']] = None,
                 gpu_limit: Optional[pulumi.Input['GroupContainerGpuLimitArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['GroupContainerLivenessProbeArgs']] = None,
                 memory_limit: Optional[pulumi.Input[float]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerPortArgs']]]] = None,
                 readiness_probe: Optional[pulumi.Input['GroupContainerReadinessProbeArgs']] = None,
                 secure_environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 securities: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerSecurityArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerVolumeArgs']]]] = None):
        """
        :param pulumi.Input[float] cpu: The required number of CPU cores of the containers. Changing this forces a new resource to be created.
        :param pulumi.Input[str] image: The container image name. Changing this forces a new resource to be created.
        :param pulumi.Input[float] memory: The required memory of the containers in GB. Changing this forces a new resource to be created.
        :param pulumi.Input[str] name: Specifies the name of the Container. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: A list of commands which should be run on the container. Changing this forces a new resource to be created.
        :param pulumi.Input[float] cpu_limit: The upper limit of the number of CPU cores of the containers.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment_variables: A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param pulumi.Input['GroupContainerGpuArgs'] gpu: A `gpu` block as defined below. Changing this forces a new resource to be created.
               
               > **Note:** Gpu resources are currently only supported in Linux containers.
        :param pulumi.Input['GroupContainerGpuLimitArgs'] gpu_limit: A `gpu_limit` block as defined below.
        :param pulumi.Input['GroupContainerLivenessProbeArgs'] liveness_probe: The definition of a readiness probe for this container as documented in the `liveness_probe` block below. Changing this forces a new resource to be created.
        :param pulumi.Input[float] memory_limit: The the upper limit of the memory of the containers in GB.
        :param pulumi.Input[Sequence[pulumi.Input['GroupContainerPortArgs']]] ports: A set of public ports for the container. Changing this forces a new resource to be created. Set as documented in the `ports` block below.
        :param pulumi.Input['GroupContainerReadinessProbeArgs'] readiness_probe: The definition of a readiness probe for this container as documented in the `readiness_probe` block below. Changing this forces a new resource to be created.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secure_environment_variables: A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['GroupContainerSecurityArgs']]] securities: The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['GroupContainerVolumeArgs']]] volumes: The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if gpu_limit is not None:
            pulumi.set(__self__, "gpu_limit", gpu_limit)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if secure_environment_variables is not None:
            pulumi.set(__self__, "secure_environment_variables", secure_environment_variables)
        if securities is not None:
            pulumi.set(__self__, "securities", securities)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[float]:
        """
        The required number of CPU cores of the containers. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[float]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        The container image name. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[str]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[float]:
        """
        The required memory of the containers in GB. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of commands which should be run on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[pulumi.Input[float]]:
        """
        The upper limit of the number of CPU cores of the containers.
        """
        return pulumi.get(self, "cpu_limit")

    @cpu_limit.setter
    def cpu_limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_limit", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter
    def gpu(self) -> Optional[pulumi.Input['GroupContainerGpuArgs']]:
        """
        A `gpu` block as defined below. Changing this forces a new resource to be created.

        > **Note:** Gpu resources are currently only supported in Linux containers.
        """
        return pulumi.get(self, "gpu")

    @gpu.setter
    def gpu(self, value: Optional[pulumi.Input['GroupContainerGpuArgs']]):
        pulumi.set(self, "gpu", value)

    @property
    @pulumi.getter(name="gpuLimit")
    def gpu_limit(self) -> Optional[pulumi.Input['GroupContainerGpuLimitArgs']]:
        """
        A `gpu_limit` block as defined below.
        """
        return pulumi.get(self, "gpu_limit")

    @gpu_limit.setter
    def gpu_limit(self, value: Optional[pulumi.Input['GroupContainerGpuLimitArgs']]):
        pulumi.set(self, "gpu_limit", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['GroupContainerLivenessProbeArgs']]:
        """
        The definition of a readiness probe for this container as documented in the `liveness_probe` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['GroupContainerLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[pulumi.Input[float]]:
        """
        The the upper limit of the memory of the containers in GB.
        """
        return pulumi.get(self, "memory_limit")

    @memory_limit.setter
    def memory_limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_limit", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerPortArgs']]]]:
        """
        A set of public ports for the container. Changing this forces a new resource to be created. Set as documented in the `ports` block below.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerPortArgs']]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['GroupContainerReadinessProbeArgs']]:
        """
        The definition of a readiness probe for this container as documented in the `readiness_probe` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['GroupContainerReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter(name="secureEnvironmentVariables")
    def secure_environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secure_environment_variables")

    @secure_environment_variables.setter
    def secure_environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_environment_variables", value)

    @property
    @pulumi.getter
    def securities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerSecurityArgs']]]]:
        """
        The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "securities")

    @securities.setter
    def securities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerSecurityArgs']]]]):
        pulumi.set(self, "securities", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerVolumeArgs']]]]:
        """
        The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerVolumeArgs']]]]):
        pulumi.set(self, "volumes", value)


@pulumi.input_type
class GroupContainerGpuArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 sku: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of GPUs which should be assigned to this container. Allowed values are `1`, `2`, or `4`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] sku: The SKU which should be used for the GPU. Possible values are `K80`, `P100`, or `V100`. Changing this forces a new resource to be created.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of GPUs which should be assigned to this container. Allowed values are `1`, `2`, or `4`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def sku(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU which should be used for the GPU. Possible values are `K80`, `P100`, or `V100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku", value)


@pulumi.input_type
class GroupContainerGpuLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 sku: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The upper limit of the number of GPUs which should be assigned to this container.
        :param pulumi.Input[str] sku: The allowed SKU which should be used for the GPU. Possible values are `K80`, `P100`, or `V100`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit of the number of GPUs which should be assigned to this container.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def sku(self) -> Optional[pulumi.Input[str]]:
        """
        The allowed SKU which should be used for the GPU. Possible values are `K80`, `P100`, or `V100`.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku", value)


@pulumi.input_type
class GroupContainerLivenessProbeArgs:
    def __init__(__self__, *,
                 execs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerLivenessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] execs: Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        :param pulumi.Input[int] failure_threshold: How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['GroupContainerLivenessProbeHttpGetArgs']]] http_gets: The definition of the http_get for this container as documented in the `http_get` block below. Changing this forces a new resource to be created.
        :param pulumi.Input[int] initial_delay_seconds: Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] timeout_seconds: Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        if execs is not None:
            pulumi.set(__self__, "execs", execs)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def execs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "execs")

    @execs.setter
    def execs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "execs", value)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerLivenessProbeHttpGetArgs']]]]:
        """
        The definition of the http_get for this container as documented in the `http_get` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerLivenessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class GroupContainerLivenessProbeHttpGetArgs:
    def __init__(__self__, *,
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
        :param pulumi.Input[str] path: Path to access on the HTTP server. Changing this forces a new resource to be created.
        :param pulumi.Input[int] port: Number of the port to access on the container. Changing this forces a new resource to be created.
        :param pulumi.Input[str] scheme: Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to access on the HTTP server. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Number of the port to access on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class GroupContainerPortArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] port: The port number the container will expose. Changing this forces a new resource to be created.
        :param pulumi.Input[str] protocol: The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.
               
               > **Note:** Omitting these blocks will default the exposed ports on the group to all ports on all containers defined in the `container` blocks of this group.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number the container will expose. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.

        > **Note:** Omitting these blocks will default the exposed ports on the group to all ports on all containers defined in the `container` blocks of this group.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class GroupContainerReadinessProbeArgs:
    def __init__(__self__, *,
                 execs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerReadinessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] execs: Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        :param pulumi.Input[int] failure_threshold: How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['GroupContainerReadinessProbeHttpGetArgs']]] http_gets: The definition of the http_get for this container as documented in the `http_get` block below. Changing this forces a new resource to be created.
        :param pulumi.Input[int] initial_delay_seconds: Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] timeout_seconds: Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        if execs is not None:
            pulumi.set(__self__, "execs", execs)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def execs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "execs")

    @execs.setter
    def execs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "execs", value)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerReadinessProbeHttpGetArgs']]]]:
        """
        The definition of the http_get for this container as documented in the `http_get` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupContainerReadinessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class GroupContainerReadinessProbeHttpGetArgs:
    def __init__(__self__, *,
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
        :param pulumi.Input[str] path: Path to access on the HTTP server. Changing this forces a new resource to be created.
        :param pulumi.Input[int] port: Number of the port to access on the container. Changing this forces a new resource to be created.
        :param pulumi.Input[str] scheme: Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to access on the HTTP server. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Number of the port to access on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class GroupContainerSecurityArgs:
    def __init__(__self__, *,
                 privilege_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] privilege_enabled: Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.
               
               > **NOTE:** Currently, this only applies when the `os_type` is `Linux` and the `sku` is `Confidential`.
        """
        pulumi.set(__self__, "privilege_enabled", privilege_enabled)

    @property
    @pulumi.getter(name="privilegeEnabled")
    def privilege_enabled(self) -> pulumi.Input[bool]:
        """
        Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.

        > **NOTE:** Currently, this only applies when the `os_type` is `Linux` and the `sku` is `Confidential`.
        """
        return pulumi.get(self, "privilege_enabled")

    @privilege_enabled.setter
    def privilege_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "privilege_enabled", value)


@pulumi.input_type
class GroupContainerVolumeArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[str],
                 name: pulumi.Input[str],
                 empty_dir: Optional[pulumi.Input[bool]] = None,
                 git_repo: Optional[pulumi.Input['GroupContainerVolumeGitRepoArgs']] = None,
                 read_only: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 share_name: Optional[pulumi.Input[str]] = None,
                 storage_account_key: Optional[pulumi.Input[str]] = None,
                 storage_account_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_path: The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        :param pulumi.Input[str] name: The name of the volume mount. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] empty_dir: Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        :param pulumi.Input['GroupContainerVolumeGitRepoArgs'] git_repo: A `git_repo` block as defined below. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] read_only: Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secret: A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.
               
               > **Note:** Exactly one of `empty_dir` volume, `git_repo` volume, `secret` volume or storage account volume (`share_name`, `storage_account_name`, and `storage_account_key`) must be specified.
               
               > **Note** when using a storage account volume, all of `share_name`, `storage_account_name`, and `storage_account_key` must be specified.
               
               > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
        :param pulumi.Input[str] share_name: The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] storage_account_key: The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] storage_account_name: The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if empty_dir is not None:
            pulumi.set(__self__, "empty_dir", empty_dir)
        if git_repo is not None:
            pulumi.set(__self__, "git_repo", git_repo)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if storage_account_key is not None:
            pulumi.set(__self__, "storage_account_key", storage_account_key)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[str]:
        """
        The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the volume mount. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="emptyDir")
    def empty_dir(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "empty_dir")

    @empty_dir.setter
    def empty_dir(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "empty_dir", value)

    @property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> Optional[pulumi.Input['GroupContainerVolumeGitRepoArgs']]:
        """
        A `git_repo` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "git_repo")

    @git_repo.setter
    def git_repo(self, value: Optional[pulumi.Input['GroupContainerVolumeGitRepoArgs']]):
        pulumi.set(self, "git_repo", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.

        > **Note:** Exactly one of `empty_dir` volume, `git_repo` volume, `secret` volume or storage account volume (`share_name`, `storage_account_name`, and `storage_account_key`) must be specified.

        > **Note** when using a storage account volume, all of `share_name`, `storage_account_name`, and `storage_account_key` must be specified.

        > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> Optional[pulumi.Input[str]]:
        """
        The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @storage_account_key.setter
    def storage_account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_key", value)

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_name", value)


@pulumi.input_type
class GroupContainerVolumeGitRepoArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 directory: Optional[pulumi.Input[str]] = None,
                 revision: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        :param pulumi.Input[str] directory: Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        :param pulumi.Input[str] revision: Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "url", url)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "revision", value)


@pulumi.input_type
class GroupDiagnosticsArgs:
    def __init__(__self__, *,
                 log_analytics: pulumi.Input['GroupDiagnosticsLogAnalyticsArgs']):
        """
        :param pulumi.Input['GroupDiagnosticsLogAnalyticsArgs'] log_analytics: A `log_analytics` block as defined below. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "log_analytics", log_analytics)

    @property
    @pulumi.getter(name="logAnalytics")
    def log_analytics(self) -> pulumi.Input['GroupDiagnosticsLogAnalyticsArgs']:
        """
        A `log_analytics` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "log_analytics")

    @log_analytics.setter
    def log_analytics(self, value: pulumi.Input['GroupDiagnosticsLogAnalyticsArgs']):
        pulumi.set(self, "log_analytics", value)


@pulumi.input_type
class GroupDiagnosticsLogAnalyticsArgs:
    def __init__(__self__, *,
                 workspace_id: pulumi.Input[str],
                 workspace_key: pulumi.Input[str],
                 log_type: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] workspace_id: The Workspace ID of the Log Analytics Workspace. Changing this forces a new resource to be created.
        :param pulumi.Input[str] workspace_key: The Workspace Key of the Log Analytics Workspace. Changing this forces a new resource to be created.
        :param pulumi.Input[str] log_type: The log type which should be used. Possible values are `ContainerInsights` and `ContainerInstanceLogs`. Changing this forces a new resource to be created.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Any metadata required for Log Analytics. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)
        pulumi.set(__self__, "workspace_key", workspace_key)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> pulumi.Input[str]:
        """
        The Workspace ID of the Log Analytics Workspace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_id", value)

    @property
    @pulumi.getter(name="workspaceKey")
    def workspace_key(self) -> pulumi.Input[str]:
        """
        The Workspace Key of the Log Analytics Workspace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "workspace_key")

    @workspace_key.setter
    def workspace_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_key", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input[str]]:
        """
        The log type which should be used. Possible values are `ContainerInsights` and `ContainerInstanceLogs`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_type", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Any metadata required for Log Analytics. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class GroupDnsConfigArgs:
    def __init__(__self__, *,
                 nameservers: pulumi.Input[Sequence[pulumi.Input[str]]],
                 options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nameservers: A list of nameservers the containers will search out to resolve requests. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] options: A list of [resolver configuration options](https://man7.org/linux/man-pages/man5/resolv.conf.5.html). Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] search_domains: A list of search domains that DNS requests will search along. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "nameservers", nameservers)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if search_domains is not None:
            pulumi.set(__self__, "search_domains", search_domains)

    @property
    @pulumi.getter
    def nameservers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of nameservers the containers will search out to resolve requests. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "nameservers", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of [resolver configuration options](https://man7.org/linux/man-pages/man5/resolv.conf.5.html). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter(name="searchDomains")
    def search_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of search domains that DNS requests will search along. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "search_domains")

    @search_domains.setter
    def search_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_domains", value)


@pulumi.input_type
class GroupExposedPortArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] port: The port number the container will expose. Changing this forces a new resource to be created.
        :param pulumi.Input[str] protocol: The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.
               
               > **Note:** Removing all `exposed_port` blocks requires setting `exposed_port = []`.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number the container will expose. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.

        > **Note:** Removing all `exposed_port` blocks requires setting `exposed_port = []`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class GroupIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Container Group. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
               
               > **NOTE:** When `type` is set to `SystemAssigned`, the identity of the Principal ID can be retrieved after the container group has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Group.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
               
               > **NOTE:** Currently you can't use a managed identity in a container group deployed to a virtual network.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Container Group. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).

        > **NOTE:** When `type` is set to `SystemAssigned`, the identity of the Principal ID can be retrieved after the container group has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Group.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.

        > **NOTE:** Currently you can't use a managed identity in a container group deployed to a virtual network.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class GroupImageRegistryCredentialArgs:
    def __init__(__self__, *,
                 server: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 user_assigned_identity_id: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] server: The address to use to connect to the registry without protocol ("https"/"http"). For example: "myacr.acr.io". Changing this forces a new resource to be created.
        :param pulumi.Input[str] password: The password with which to connect to the registry. Changing this forces a new resource to be created.
        :param pulumi.Input[str] user_assigned_identity_id: The identity ID for the private registry. Changing this forces a new resource to be created.
        :param pulumi.Input[str] username: The username with which to connect to the registry. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "server", server)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[str]:
        """
        The address to use to connect to the registry without protocol ("https"/"http"). For example: "myacr.acr.io". Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password with which to connect to the registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identity ID for the private registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "user_assigned_identity_id")

    @user_assigned_identity_id.setter
    def user_assigned_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity_id", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username with which to connect to the registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class GroupInitContainerArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[str],
                 name: pulumi.Input[str],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 securities: Optional[pulumi.Input[Sequence[pulumi.Input['GroupInitContainerSecurityArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['GroupInitContainerVolumeArgs']]]] = None):
        """
        :param pulumi.Input[str] image: The container image name. Changing this forces a new resource to be created.
        :param pulumi.Input[str] name: Specifies the name of the Container. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: A list of commands which should be run on the container. Changing this forces a new resource to be created.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment_variables: A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secure_environment_variables: A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['GroupInitContainerSecurityArgs']]] securities: The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input['GroupInitContainerVolumeArgs']]] volumes: The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "name", name)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if secure_environment_variables is not None:
            pulumi.set(__self__, "secure_environment_variables", secure_environment_variables)
        if securities is not None:
            pulumi.set(__self__, "securities", securities)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        The container image name. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[str]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the Container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of commands which should be run on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter(name="secureEnvironmentVariables")
    def secure_environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secure_environment_variables")

    @secure_environment_variables.setter
    def secure_environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_environment_variables", value)

    @property
    @pulumi.getter
    def securities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupInitContainerSecurityArgs']]]]:
        """
        The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "securities")

    @securities.setter
    def securities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupInitContainerSecurityArgs']]]]):
        pulumi.set(self, "securities", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupInitContainerVolumeArgs']]]]:
        """
        The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupInitContainerVolumeArgs']]]]):
        pulumi.set(self, "volumes", value)


@pulumi.input_type
class GroupInitContainerSecurityArgs:
    def __init__(__self__, *,
                 privilege_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] privilege_enabled: Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.
               
               > **NOTE:** Currently, this only applies when the `os_type` is `Linux` and the `sku` is `Confidential`.
        """
        pulumi.set(__self__, "privilege_enabled", privilege_enabled)

    @property
    @pulumi.getter(name="privilegeEnabled")
    def privilege_enabled(self) -> pulumi.Input[bool]:
        """
        Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.

        > **NOTE:** Currently, this only applies when the `os_type` is `Linux` and the `sku` is `Confidential`.
        """
        return pulumi.get(self, "privilege_enabled")

    @privilege_enabled.setter
    def privilege_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "privilege_enabled", value)


@pulumi.input_type
class GroupInitContainerVolumeArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[str],
                 name: pulumi.Input[str],
                 empty_dir: Optional[pulumi.Input[bool]] = None,
                 git_repo: Optional[pulumi.Input['GroupInitContainerVolumeGitRepoArgs']] = None,
                 read_only: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 share_name: Optional[pulumi.Input[str]] = None,
                 storage_account_key: Optional[pulumi.Input[str]] = None,
                 storage_account_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_path: The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        :param pulumi.Input[str] name: The name of the volume mount. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] empty_dir: Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        :param pulumi.Input['GroupInitContainerVolumeGitRepoArgs'] git_repo: A `git_repo` block as defined below. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] read_only: Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secret: A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.
               
               > **Note:** Exactly one of `empty_dir` volume, `git_repo` volume, `secret` volume or storage account volume (`share_name`, `storage_account_name`, and `storage_account_key`) must be specified.
               
               > **Note** when using a storage account volume, all of `share_name`, `storage_account_name`, and `storage_account_key` must be specified.
               
               > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
        :param pulumi.Input[str] share_name: The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] storage_account_key: The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        :param pulumi.Input[str] storage_account_name: The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if empty_dir is not None:
            pulumi.set(__self__, "empty_dir", empty_dir)
        if git_repo is not None:
            pulumi.set(__self__, "git_repo", git_repo)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if storage_account_key is not None:
            pulumi.set(__self__, "storage_account_key", storage_account_key)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[str]:
        """
        The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the volume mount. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="emptyDir")
    def empty_dir(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "empty_dir")

    @empty_dir.setter
    def empty_dir(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "empty_dir", value)

    @property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> Optional[pulumi.Input['GroupInitContainerVolumeGitRepoArgs']]:
        """
        A `git_repo` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "git_repo")

    @git_repo.setter
    def git_repo(self, value: Optional[pulumi.Input['GroupInitContainerVolumeGitRepoArgs']]):
        pulumi.set(self, "git_repo", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.

        > **Note:** Exactly one of `empty_dir` volume, `git_repo` volume, `secret` volume or storage account volume (`share_name`, `storage_account_name`, and `storage_account_key`) must be specified.

        > **Note** when using a storage account volume, all of `share_name`, `storage_account_name`, and `storage_account_key` must be specified.

        > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> Optional[pulumi.Input[str]]:
        """
        The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @storage_account_key.setter
    def storage_account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_key", value)

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_name", value)


@pulumi.input_type
class GroupInitContainerVolumeGitRepoArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 directory: Optional[pulumi.Input[str]] = None,
                 revision: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        :param pulumi.Input[str] directory: Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        :param pulumi.Input[str] revision: Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "url", url)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "revision", value)


@pulumi.input_type
class KubernetesClusterAciConnectorLinuxArgs:
    def __init__(__self__, *,
                 subnet_name: pulumi.Input[str],
                 connector_identities: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterAciConnectorLinuxConnectorIdentityArgs']]]] = None):
        """
        :param pulumi.Input[str] subnet_name: The subnet name for the virtual nodes to run.
               
               > **Note:** At this time ACI Connectors are not supported in Azure China.
               
               > **Note:** AKS will add a delegation to the subnet named here. To prevent further runs from failing you should make sure that the subnet you create for virtual nodes has a delegation, like so.
               
               ```python
               import pulumi
               import pulumi_azure as azure
               
               virtual = azure.network.Subnet("virtual", delegations=[azure.network.SubnetDelegationArgs(
                   name="aciDelegation",
                   service_delegation=azure.network.SubnetDelegationServiceDelegationArgs(
                       actions=["Microsoft.Network/virtualNetworks/subnets/action"],
                       name="Microsoft.ContainerInstance/containerGroups",
                   ),
               )])
               ```
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterAciConnectorLinuxConnectorIdentityArgs']]] connector_identities: A `connector_identity` block is exported. The exported attributes are defined below.
        """
        pulumi.set(__self__, "subnet_name", subnet_name)
        if connector_identities is not None:
            pulumi.set(__self__, "connector_identities", connector_identities)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> pulumi.Input[str]:
        """
        The subnet name for the virtual nodes to run.

        > **Note:** At this time ACI Connectors are not supported in Azure China.

        > **Note:** AKS will add a delegation to the subnet named here. To prevent further runs from failing you should make sure that the subnet you create for virtual nodes has a delegation, like so.

        ```python
        import pulumi
        import pulumi_azure as azure

        virtual = azure.network.Subnet("virtual", delegations=[azure.network.SubnetDelegationArgs(
            name="aciDelegation",
            service_delegation=azure.network.SubnetDelegationServiceDelegationArgs(
                actions=["Microsoft.Network/virtualNetworks/subnets/action"],
                name="Microsoft.ContainerInstance/containerGroups",
            ),
        )])
        ```
        """
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_name", value)

    @property
    @pulumi.getter(name="connectorIdentities")
    def connector_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterAciConnectorLinuxConnectorIdentityArgs']]]]:
        """
        A `connector_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "connector_identities")

    @connector_identities.setter
    def connector_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterAciConnectorLinuxConnectorIdentityArgs']]]]):
        pulumi.set(self, "connector_identities", value)


@pulumi.input_type
class KubernetesClusterAciConnectorLinuxConnectorIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 user_assigned_identity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
               
               > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.

        > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        return pulumi.get(self, "user_assigned_identity_id")

    @user_assigned_identity_id.setter
    def user_assigned_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity_id", value)


@pulumi.input_type
class KubernetesClusterApiServerAccessProfileArgs:
    def __init__(__self__, *,
                 authorized_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vnet_integration_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_ip_ranges: Set of authorized IP ranges to allow access to API server, e.g. ["198.51.100.0/24"].
        :param pulumi.Input[str] subnet_id: The ID of the Subnet where the API server endpoint is delegated to.
        :param pulumi.Input[bool] vnet_integration_enabled: Should API Server VNet Integration be enabled? For more details please visit [Use API Server VNet Integration](https://learn.microsoft.com/en-us/azure/aks/api-server-vnet-integration).
               
               > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/EnableAPIServerVnetIntegrationPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/api-server-vnet-integration#register-the-enableapiservervnetintegrationpreview-preview-feature) for more information.
        """
        if authorized_ip_ranges is not None:
            pulumi.set(__self__, "authorized_ip_ranges", authorized_ip_ranges)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vnet_integration_enabled is not None:
            pulumi.set(__self__, "vnet_integration_enabled", vnet_integration_enabled)

    @property
    @pulumi.getter(name="authorizedIpRanges")
    def authorized_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of authorized IP ranges to allow access to API server, e.g. ["198.51.100.0/24"].
        """
        return pulumi.get(self, "authorized_ip_ranges")

    @authorized_ip_ranges.setter
    def authorized_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "authorized_ip_ranges", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Subnet where the API server endpoint is delegated to.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vnetIntegrationEnabled")
    def vnet_integration_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should API Server VNet Integration be enabled? For more details please visit [Use API Server VNet Integration](https://learn.microsoft.com/en-us/azure/aks/api-server-vnet-integration).

        > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/EnableAPIServerVnetIntegrationPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/api-server-vnet-integration#register-the-enableapiservervnetintegrationpreview-preview-feature) for more information.
        """
        return pulumi.get(self, "vnet_integration_enabled")

    @vnet_integration_enabled.setter
    def vnet_integration_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_integration_enabled", value)


@pulumi.input_type
class KubernetesClusterAutoScalerProfileArgs:
    def __init__(__self__, *,
                 balance_similar_node_groups: Optional[pulumi.Input[bool]] = None,
                 empty_bulk_delete_max: Optional[pulumi.Input[str]] = None,
                 expander: Optional[pulumi.Input[str]] = None,
                 max_graceful_termination_sec: Optional[pulumi.Input[str]] = None,
                 max_node_provisioning_time: Optional[pulumi.Input[str]] = None,
                 max_unready_nodes: Optional[pulumi.Input[int]] = None,
                 max_unready_percentage: Optional[pulumi.Input[float]] = None,
                 new_pod_scale_up_delay: Optional[pulumi.Input[str]] = None,
                 scale_down_delay_after_add: Optional[pulumi.Input[str]] = None,
                 scale_down_delay_after_delete: Optional[pulumi.Input[str]] = None,
                 scale_down_delay_after_failure: Optional[pulumi.Input[str]] = None,
                 scale_down_unneeded: Optional[pulumi.Input[str]] = None,
                 scale_down_unready: Optional[pulumi.Input[str]] = None,
                 scale_down_utilization_threshold: Optional[pulumi.Input[str]] = None,
                 scan_interval: Optional[pulumi.Input[str]] = None,
                 skip_nodes_with_local_storage: Optional[pulumi.Input[bool]] = None,
                 skip_nodes_with_system_pods: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] balance_similar_node_groups: Detect similar node groups and balance the number of nodes between them. Defaults to `false`.
        :param pulumi.Input[str] empty_bulk_delete_max: Maximum number of empty nodes that can be deleted at the same time. Defaults to `10`.
        :param pulumi.Input[str] expander: Expander to use. Possible values are `least-waste`, `priority`, `most-pods` and `random`. Defaults to `random`.
        :param pulumi.Input[str] max_graceful_termination_sec: Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. Defaults to `600`.
        :param pulumi.Input[str] max_node_provisioning_time: Maximum time the autoscaler waits for a node to be provisioned. Defaults to `15m`.
        :param pulumi.Input[int] max_unready_nodes: Maximum Number of allowed unready nodes. Defaults to `3`.
        :param pulumi.Input[float] max_unready_percentage: Maximum percentage of unready nodes the cluster autoscaler will stop if the percentage is exceeded. Defaults to `45`.
        :param pulumi.Input[str] new_pod_scale_up_delay: For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. Defaults to `10s`.
        :param pulumi.Input[str] scale_down_delay_after_add: How long after the scale up of AKS nodes the scale down evaluation resumes. Defaults to `10m`.
        :param pulumi.Input[str] scale_down_delay_after_delete: How long after node deletion that scale down evaluation resumes. Defaults to the value used for `scan_interval`.
        :param pulumi.Input[str] scale_down_delay_after_failure: How long after scale down failure that scale down evaluation resumes. Defaults to `3m`.
        :param pulumi.Input[str] scale_down_unneeded: How long a node should be unneeded before it is eligible for scale down. Defaults to `10m`.
        :param pulumi.Input[str] scale_down_unready: How long an unready node should be unneeded before it is eligible for scale down. Defaults to `20m`.
        :param pulumi.Input[str] scale_down_utilization_threshold: Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. Defaults to `0.5`.
        :param pulumi.Input[str] scan_interval: How often the AKS Cluster should be re-evaluated for scale up/down. Defaults to `10s`.
        :param pulumi.Input[bool] skip_nodes_with_local_storage: If `true` cluster autoscaler will never delete nodes with pods with local storage, for example, EmptyDir or HostPath. Defaults to `true`.
        :param pulumi.Input[bool] skip_nodes_with_system_pods: If `true` cluster autoscaler will never delete nodes with pods from kube-system (except for DaemonSet or mirror pods). Defaults to `true`.
        """
        if balance_similar_node_groups is not None:
            pulumi.set(__self__, "balance_similar_node_groups", balance_similar_node_groups)
        if empty_bulk_delete_max is not None:
            pulumi.set(__self__, "empty_bulk_delete_max", empty_bulk_delete_max)
        if expander is not None:
            pulumi.set(__self__, "expander", expander)
        if max_graceful_termination_sec is not None:
            pulumi.set(__self__, "max_graceful_termination_sec", max_graceful_termination_sec)
        if max_node_provisioning_time is not None:
            pulumi.set(__self__, "max_node_provisioning_time", max_node_provisioning_time)
        if max_unready_nodes is not None:
            pulumi.set(__self__, "max_unready_nodes", max_unready_nodes)
        if max_unready_percentage is not None:
            pulumi.set(__self__, "max_unready_percentage", max_unready_percentage)
        if new_pod_scale_up_delay is not None:
            pulumi.set(__self__, "new_pod_scale_up_delay", new_pod_scale_up_delay)
        if scale_down_delay_after_add is not None:
            pulumi.set(__self__, "scale_down_delay_after_add", scale_down_delay_after_add)
        if scale_down_delay_after_delete is not None:
            pulumi.set(__self__, "scale_down_delay_after_delete", scale_down_delay_after_delete)
        if scale_down_delay_after_failure is not None:
            pulumi.set(__self__, "scale_down_delay_after_failure", scale_down_delay_after_failure)
        if scale_down_unneeded is not None:
            pulumi.set(__self__, "scale_down_unneeded", scale_down_unneeded)
        if scale_down_unready is not None:
            pulumi.set(__self__, "scale_down_unready", scale_down_unready)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)
        if scan_interval is not None:
            pulumi.set(__self__, "scan_interval", scan_interval)
        if skip_nodes_with_local_storage is not None:
            pulumi.set(__self__, "skip_nodes_with_local_storage", skip_nodes_with_local_storage)
        if skip_nodes_with_system_pods is not None:
            pulumi.set(__self__, "skip_nodes_with_system_pods", skip_nodes_with_system_pods)

    @property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        Detect similar node groups and balance the number of nodes between them. Defaults to `false`.
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @balance_similar_node_groups.setter
    def balance_similar_node_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "balance_similar_node_groups", value)

    @property
    @pulumi.getter(name="emptyBulkDeleteMax")
    def empty_bulk_delete_max(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum number of empty nodes that can be deleted at the same time. Defaults to `10`.
        """
        return pulumi.get(self, "empty_bulk_delete_max")

    @empty_bulk_delete_max.setter
    def empty_bulk_delete_max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "empty_bulk_delete_max", value)

    @property
    @pulumi.getter
    def expander(self) -> Optional[pulumi.Input[str]]:
        """
        Expander to use. Possible values are `least-waste`, `priority`, `most-pods` and `random`. Defaults to `random`.
        """
        return pulumi.get(self, "expander")

    @expander.setter
    def expander(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expander", value)

    @property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. Defaults to `600`.
        """
        return pulumi.get(self, "max_graceful_termination_sec")

    @max_graceful_termination_sec.setter
    def max_graceful_termination_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_graceful_termination_sec", value)

    @property
    @pulumi.getter(name="maxNodeProvisioningTime")
    def max_node_provisioning_time(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum time the autoscaler waits for a node to be provisioned. Defaults to `15m`.
        """
        return pulumi.get(self, "max_node_provisioning_time")

    @max_node_provisioning_time.setter
    def max_node_provisioning_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_node_provisioning_time", value)

    @property
    @pulumi.getter(name="maxUnreadyNodes")
    def max_unready_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum Number of allowed unready nodes. Defaults to `3`.
        """
        return pulumi.get(self, "max_unready_nodes")

    @max_unready_nodes.setter
    def max_unready_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unready_nodes", value)

    @property
    @pulumi.getter(name="maxUnreadyPercentage")
    def max_unready_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum percentage of unready nodes the cluster autoscaler will stop if the percentage is exceeded. Defaults to `45`.
        """
        return pulumi.get(self, "max_unready_percentage")

    @max_unready_percentage.setter
    def max_unready_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_unready_percentage", value)

    @property
    @pulumi.getter(name="newPodScaleUpDelay")
    def new_pod_scale_up_delay(self) -> Optional[pulumi.Input[str]]:
        """
        For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. Defaults to `10s`.
        """
        return pulumi.get(self, "new_pod_scale_up_delay")

    @new_pod_scale_up_delay.setter
    def new_pod_scale_up_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "new_pod_scale_up_delay", value)

    @property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> Optional[pulumi.Input[str]]:
        """
        How long after the scale up of AKS nodes the scale down evaluation resumes. Defaults to `10m`.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @scale_down_delay_after_add.setter
    def scale_down_delay_after_add(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_down_delay_after_add", value)

    @property
    @pulumi.getter(name="scaleDownDelayAfterDelete")
    def scale_down_delay_after_delete(self) -> Optional[pulumi.Input[str]]:
        """
        How long after node deletion that scale down evaluation resumes. Defaults to the value used for `scan_interval`.
        """
        return pulumi.get(self, "scale_down_delay_after_delete")

    @scale_down_delay_after_delete.setter
    def scale_down_delay_after_delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_down_delay_after_delete", value)

    @property
    @pulumi.getter(name="scaleDownDelayAfterFailure")
    def scale_down_delay_after_failure(self) -> Optional[pulumi.Input[str]]:
        """
        How long after scale down failure that scale down evaluation resumes. Defaults to `3m`.
        """
        return pulumi.get(self, "scale_down_delay_after_failure")

    @scale_down_delay_after_failure.setter
    def scale_down_delay_after_failure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_down_delay_after_failure", value)

    @property
    @pulumi.getter(name="scaleDownUnneeded")
    def scale_down_unneeded(self) -> Optional[pulumi.Input[str]]:
        """
        How long a node should be unneeded before it is eligible for scale down. Defaults to `10m`.
        """
        return pulumi.get(self, "scale_down_unneeded")

    @scale_down_unneeded.setter
    def scale_down_unneeded(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_down_unneeded", value)

    @property
    @pulumi.getter(name="scaleDownUnready")
    def scale_down_unready(self) -> Optional[pulumi.Input[str]]:
        """
        How long an unready node should be unneeded before it is eligible for scale down. Defaults to `20m`.
        """
        return pulumi.get(self, "scale_down_unready")

    @scale_down_unready.setter
    def scale_down_unready(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_down_unready", value)

    @property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[pulumi.Input[str]]:
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. Defaults to `0.5`.
        """
        return pulumi.get(self, "scale_down_utilization_threshold")

    @scale_down_utilization_threshold.setter
    def scale_down_utilization_threshold(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_down_utilization_threshold", value)

    @property
    @pulumi.getter(name="scanInterval")
    def scan_interval(self) -> Optional[pulumi.Input[str]]:
        """
        How often the AKS Cluster should be re-evaluated for scale up/down. Defaults to `10s`.
        """
        return pulumi.get(self, "scan_interval")

    @scan_interval.setter
    def scan_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_interval", value)

    @property
    @pulumi.getter(name="skipNodesWithLocalStorage")
    def skip_nodes_with_local_storage(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` cluster autoscaler will never delete nodes with pods with local storage, for example, EmptyDir or HostPath. Defaults to `true`.
        """
        return pulumi.get(self, "skip_nodes_with_local_storage")

    @skip_nodes_with_local_storage.setter
    def skip_nodes_with_local_storage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_nodes_with_local_storage", value)

    @property
    @pulumi.getter(name="skipNodesWithSystemPods")
    def skip_nodes_with_system_pods(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true` cluster autoscaler will never delete nodes with pods from kube-system (except for DaemonSet or mirror pods). Defaults to `true`.
        """
        return pulumi.get(self, "skip_nodes_with_system_pods")

    @skip_nodes_with_system_pods.setter
    def skip_nodes_with_system_pods(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_nodes_with_system_pods", value)


@pulumi.input_type
class KubernetesClusterAzureActiveDirectoryRoleBasedAccessControlArgs:
    def __init__(__self__, *,
                 admin_group_object_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 azure_rbac_enabled: Optional[pulumi.Input[bool]] = None,
                 client_app_id: Optional[pulumi.Input[str]] = None,
                 managed: Optional[pulumi.Input[bool]] = None,
                 server_app_id: Optional[pulumi.Input[str]] = None,
                 server_app_secret: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] admin_group_object_ids: A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
        :param pulumi.Input[bool] azure_rbac_enabled: Is Role Based Access Control based on Azure AD enabled?
        :param pulumi.Input[str] client_app_id: The Client ID of an Azure Active Directory Application.
        :param pulumi.Input[bool] managed: Is the Azure Active Directory integration Managed, meaning that Azure will create/manage the Service Principal used for integration.
        :param pulumi.Input[str] server_app_id: The Server ID of an Azure Active Directory Application.
        :param pulumi.Input[str] server_app_secret: The Server Secret of an Azure Active Directory Application.
        :param pulumi.Input[str] tenant_id: The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        """
        if admin_group_object_ids is not None:
            pulumi.set(__self__, "admin_group_object_ids", admin_group_object_ids)
        if azure_rbac_enabled is not None:
            pulumi.set(__self__, "azure_rbac_enabled", azure_rbac_enabled)
        if client_app_id is not None:
            pulumi.set(__self__, "client_app_id", client_app_id)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if server_app_id is not None:
            pulumi.set(__self__, "server_app_id", server_app_id)
        if server_app_secret is not None:
            pulumi.set(__self__, "server_app_secret", server_app_secret)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="adminGroupObjectIds")
    def admin_group_object_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
        """
        return pulumi.get(self, "admin_group_object_ids")

    @admin_group_object_ids.setter
    def admin_group_object_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "admin_group_object_ids", value)

    @property
    @pulumi.getter(name="azureRbacEnabled")
    def azure_rbac_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Role Based Access Control based on Azure AD enabled?
        """
        return pulumi.get(self, "azure_rbac_enabled")

    @azure_rbac_enabled.setter
    def azure_rbac_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "azure_rbac_enabled", value)

    @property
    @pulumi.getter(name="clientAppId")
    def client_app_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of an Azure Active Directory Application.
        """
        return pulumi.get(self, "client_app_id")

    @client_app_id.setter
    def client_app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_app_id", value)

    @property
    @pulumi.getter
    def managed(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the Azure Active Directory integration Managed, meaning that Azure will create/manage the Service Principal used for integration.
        """
        return pulumi.get(self, "managed")

    @managed.setter
    def managed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "managed", value)

    @property
    @pulumi.getter(name="serverAppId")
    def server_app_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Server ID of an Azure Active Directory Application.
        """
        return pulumi.get(self, "server_app_id")

    @server_app_id.setter
    def server_app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_app_id", value)

    @property
    @pulumi.getter(name="serverAppSecret")
    def server_app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Server Secret of an Azure Active Directory Application.
        """
        return pulumi.get(self, "server_app_secret")

    @server_app_secret.setter
    def server_app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_app_secret", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class KubernetesClusterConfidentialComputingArgs:
    def __init__(__self__, *,
                 sgx_quote_helper_enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] sgx_quote_helper_enabled: Should the SGX quote helper be enabled?
        """
        pulumi.set(__self__, "sgx_quote_helper_enabled", sgx_quote_helper_enabled)

    @property
    @pulumi.getter(name="sgxQuoteHelperEnabled")
    def sgx_quote_helper_enabled(self) -> pulumi.Input[bool]:
        """
        Should the SGX quote helper be enabled?
        """
        return pulumi.get(self, "sgx_quote_helper_enabled")

    @sgx_quote_helper_enabled.setter
    def sgx_quote_helper_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sgx_quote_helper_enabled", value)


@pulumi.input_type
class KubernetesClusterDefaultNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 vm_size: pulumi.Input[str],
                 capacity_reservation_group_id: Optional[pulumi.Input[str]] = None,
                 custom_ca_trust_enabled: Optional[pulumi.Input[bool]] = None,
                 enable_auto_scaling: Optional[pulumi.Input[bool]] = None,
                 enable_host_encryption: Optional[pulumi.Input[bool]] = None,
                 enable_node_public_ip: Optional[pulumi.Input[bool]] = None,
                 fips_enabled: Optional[pulumi.Input[bool]] = None,
                 host_group_id: Optional[pulumi.Input[str]] = None,
                 kubelet_config: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolKubeletConfigArgs']] = None,
                 kubelet_disk_type: Optional[pulumi.Input[str]] = None,
                 linux_os_config: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolLinuxOsConfigArgs']] = None,
                 max_count: Optional[pulumi.Input[int]] = None,
                 max_pods: Optional[pulumi.Input[int]] = None,
                 message_of_the_day: Optional[pulumi.Input[str]] = None,
                 min_count: Optional[pulumi.Input[int]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 node_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_network_profile: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolNodeNetworkProfileArgs']] = None,
                 node_public_ip_prefix_id: Optional[pulumi.Input[str]] = None,
                 node_taints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 only_critical_addons_enabled: Optional[pulumi.Input[bool]] = None,
                 orchestrator_version: Optional[pulumi.Input[str]] = None,
                 os_disk_size_gb: Optional[pulumi.Input[int]] = None,
                 os_disk_type: Optional[pulumi.Input[str]] = None,
                 os_sku: Optional[pulumi.Input[str]] = None,
                 pod_subnet_id: Optional[pulumi.Input[str]] = None,
                 proximity_placement_group_id: Optional[pulumi.Input[str]] = None,
                 scale_down_mode: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 temporary_name_for_rotation: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 ultra_ssd_enabled: Optional[pulumi.Input[bool]] = None,
                 upgrade_settings: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolUpgradeSettingsArgs']] = None,
                 vnet_subnet_id: Optional[pulumi.Input[str]] = None,
                 workload_runtime: Optional[pulumi.Input[str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for the default Kubernetes Node Pool. Changing this forces a new resource to be created.
        :param pulumi.Input[str] vm_size: The size of the Virtual Machine, such as `Standard_DS2_v2`. `temporary_name_for_rotation` must be specified when attempting a resize.
        :param pulumi.Input[str] capacity_reservation_group_id: Specifies the ID of the Capacity Reservation Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] custom_ca_trust_enabled: Specifies whether to trust a Custom CA.
        :param pulumi.Input[bool] enable_auto_scaling: Should [the Kubernetes Auto Scaler](https://docs.microsoft.com/azure/aks/cluster-autoscaler) be enabled for this Node Pool?
               
               > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets`.
               
               > **Note:** If you're using AutoScaling, you may wish to use [`ignoreChanges` functionality](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) to ignore changes to the `node_count` field.
        :param pulumi.Input[bool] enable_host_encryption: Should the nodes in the Default Node Pool have host encryption enabled? `temporary_name_for_rotation` must be specified when changing this property.
               
               > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/EnableEncryptionAtHostPreview` is enabled and the Resource Provider is re-registered.
        :param pulumi.Input[bool] enable_node_public_ip: Should nodes in this Node Pool have a Public IP Address? `temporary_name_for_rotation` must be specified when changing this property.
        :param pulumi.Input[bool] fips_enabled: Should the nodes in this Node Pool have Federal Information Processing Standard enabled? Changing this forces a new resource to be created.
        :param pulumi.Input[str] host_group_id: Specifies the ID of the Host Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
        :param pulumi.Input['KubernetesClusterDefaultNodePoolKubeletConfigArgs'] kubelet_config: A `kubelet_config` block as defined below. `temporary_name_for_rotation` must be specified when changing this block.
        :param pulumi.Input[str] kubelet_disk_type: The type of disk used by kubelet. Possible values are `OS` and `Temporary`.
        :param pulumi.Input['KubernetesClusterDefaultNodePoolLinuxOsConfigArgs'] linux_os_config: A `linux_os_config` block as defined below. `temporary_name_for_rotation` must be specified when changing this block.
        :param pulumi.Input[int] max_count: The maximum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
        :param pulumi.Input[int] max_pods: The maximum number of pods that can run on each agent. Changing this forces a new resource to be created. `temporary_name_for_rotation` must be specified when changing this property.
        :param pulumi.Input[str] message_of_the_day: A base64-encoded string which will be written to /etc/motd after decoding. This allows customization of the message of the day for Linux nodes. It cannot be specified for Windows nodes and must be a static string (i.e. will be printed raw and not executed as a script). Changing this forces a new resource to be created.
        :param pulumi.Input[int] min_count: The minimum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
        :param pulumi.Input[int] node_count: The number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
               
               > **Note:** If `enable_auto_scaling` is set to `false` both `min_count` and `max_count` fields need to be set to `null` or omitted from the configuration.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_labels: A map of Kubernetes labels which should be applied to nodes in the Default Node Pool.
        :param pulumi.Input['KubernetesClusterDefaultNodePoolNodeNetworkProfileArgs'] node_network_profile: A `node_network_profile` block as documented below.
        :param pulumi.Input[str] node_public_ip_prefix_id: Resource ID for the Public IP Addresses Prefix for the nodes in this Node Pool. `enable_node_public_ip` should be `true`. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] node_taints: A list of the taints added to new nodes during node pool create and scale. `temporary_name_for_rotation` must be specified when changing this property.
        :param pulumi.Input[bool] only_critical_addons_enabled: Enabling this option will taint default node pool with `CriticalAddonsOnly=true:NoSchedule` taint. `temporary_name_for_rotation` must be specified when changing this property.
        :param pulumi.Input[str] orchestrator_version: Version of Kubernetes used for the Agents. If not specified, the default node pool will be created with the version specified by `kubernetes_version`. If both are unspecified, the latest recommended version will be used at provisioning time (but won't auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version's latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
               
               > **Note:** This version must be supported by the Kubernetes Cluster - as such the version of Kubernetes used on the Cluster/Control Plane may need to be upgraded first.
        :param pulumi.Input[int] os_disk_size_gb: The size of the OS Disk which should be used for each agent in the Node Pool. `temporary_name_for_rotation` must be specified when attempting a change.
        :param pulumi.Input[str] os_disk_type: The type of disk which should be used for the Operating System. Possible values are `Ephemeral` and `Managed`. Defaults to `Managed`.  `temporary_name_for_rotation` must be specified when attempting a change.
        :param pulumi.Input[str] os_sku: Specifies the OS SKU used by the agent pool. Possible values include: `AzureLinux`, `Ubuntu`, `Windows2019`, `Windows2022`. If not specified, the default is `Ubuntu` if OSType=Linux or `Windows2019` if OSType=Windows. And the default Windows OSSKU will be changed to `Windows2022` after Windows2019 is deprecated. `temporary_name_for_rotation` must be specified when attempting a change.
        :param pulumi.Input[str] pod_subnet_id: The ID of the Subnet where the pods in the default Node Pool should exist. Changing this forces a new resource to be created.
        :param pulumi.Input[str] proximity_placement_group_id: The ID of the Proximity Placement Group. Changing this forces a new resource to be created.
        :param pulumi.Input[str] scale_down_mode: Specifies the autoscaling behaviour of the Kubernetes Cluster. Allowed values are `Delete` and `Deallocate`. Defaults to `Delete`.
        :param pulumi.Input[str] snapshot_id: The ID of the Snapshot which should be used to create this default Node Pool. `temporary_name_for_rotation` must be specified when changing this property.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A mapping of tags to assign to the Node Pool.
               
               > At this time there's a bug in the AKS API where Tags for a Node Pool are not stored in the correct case - you may wish to use `ignore_changes` functionality to ignore changes to the casing until this is fixed in the AKS API.
        :param pulumi.Input[str] temporary_name_for_rotation: Specifies the name of the temporary node pool used to cycle the default node pool for VM resizing.
        :param pulumi.Input[str] type: The type of Node Pool which should be created. Possible values are `AvailabilitySet` and `VirtualMachineScaleSets`. Defaults to `VirtualMachineScaleSets`. Changing this forces a new resource to be created.
               
               > **Note:** When creating a cluster that supports multiple node pools, the cluster must use `VirtualMachineScaleSets`. For more information on the limitations of clusters using multiple node pools see [the documentation](https://learn.microsoft.com/en-us/azure/aks/use-multiple-node-pools#limitations).
        :param pulumi.Input[bool] ultra_ssd_enabled: Used to specify whether the UltraSSD is enabled in the Default Node Pool. Defaults to `false`. See [the documentation](https://docs.microsoft.com/azure/aks/use-ultra-disks) for more information. `temporary_name_for_rotation` must be specified when attempting a change.
        :param pulumi.Input['KubernetesClusterDefaultNodePoolUpgradeSettingsArgs'] upgrade_settings: A `upgrade_settings` block as documented below.
        :param pulumi.Input[str] vnet_subnet_id: The ID of a Subnet where the Kubernetes Node Pool should exist. Changing this forces a new resource to be created.
               
               > **Note:** A Route Table must be configured on this Subnet.
        :param pulumi.Input[str] workload_runtime: Specifies the workload runtime used by the node pool. Possible values are `OCIContainer` and `KataMshvVmIsolation`.
               
               > **Note:** Pod Sandboxing / KataVM Isolation node pools are in Public Preview - more information and details on how to opt into the preview can be found in [this article](https://learn.microsoft.com/azure/aks/use-pod-sandboxing)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] zones: Specifies a list of Availability Zones in which this Kubernetes Cluster should be located. `temporary_name_for_rotation` must be specified when changing this property.
               
               > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets` and that `load_balancer_sku` is set to `standard`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vm_size", vm_size)
        if capacity_reservation_group_id is not None:
            pulumi.set(__self__, "capacity_reservation_group_id", capacity_reservation_group_id)
        if custom_ca_trust_enabled is not None:
            pulumi.set(__self__, "custom_ca_trust_enabled", custom_ca_trust_enabled)
        if enable_auto_scaling is not None:
            pulumi.set(__self__, "enable_auto_scaling", enable_auto_scaling)
        if enable_host_encryption is not None:
            pulumi.set(__self__, "enable_host_encryption", enable_host_encryption)
        if enable_node_public_ip is not None:
            pulumi.set(__self__, "enable_node_public_ip", enable_node_public_ip)
        if fips_enabled is not None:
            pulumi.set(__self__, "fips_enabled", fips_enabled)
        if host_group_id is not None:
            pulumi.set(__self__, "host_group_id", host_group_id)
        if kubelet_config is not None:
            pulumi.set(__self__, "kubelet_config", kubelet_config)
        if kubelet_disk_type is not None:
            pulumi.set(__self__, "kubelet_disk_type", kubelet_disk_type)
        if linux_os_config is not None:
            pulumi.set(__self__, "linux_os_config", linux_os_config)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if message_of_the_day is not None:
            pulumi.set(__self__, "message_of_the_day", message_of_the_day)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if node_labels is not None:
            pulumi.set(__self__, "node_labels", node_labels)
        if node_network_profile is not None:
            pulumi.set(__self__, "node_network_profile", node_network_profile)
        if node_public_ip_prefix_id is not None:
            pulumi.set(__self__, "node_public_ip_prefix_id", node_public_ip_prefix_id)
        if node_taints is not None:
            pulumi.set(__self__, "node_taints", node_taints)
        if only_critical_addons_enabled is not None:
            pulumi.set(__self__, "only_critical_addons_enabled", only_critical_addons_enabled)
        if orchestrator_version is not None:
            pulumi.set(__self__, "orchestrator_version", orchestrator_version)
        if os_disk_size_gb is not None:
            pulumi.set(__self__, "os_disk_size_gb", os_disk_size_gb)
        if os_disk_type is not None:
            pulumi.set(__self__, "os_disk_type", os_disk_type)
        if os_sku is not None:
            pulumi.set(__self__, "os_sku", os_sku)
        if pod_subnet_id is not None:
            pulumi.set(__self__, "pod_subnet_id", pod_subnet_id)
        if proximity_placement_group_id is not None:
            pulumi.set(__self__, "proximity_placement_group_id", proximity_placement_group_id)
        if scale_down_mode is not None:
            pulumi.set(__self__, "scale_down_mode", scale_down_mode)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if temporary_name_for_rotation is not None:
            pulumi.set(__self__, "temporary_name_for_rotation", temporary_name_for_rotation)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)
        if upgrade_settings is not None:
            pulumi.set(__self__, "upgrade_settings", upgrade_settings)
        if vnet_subnet_id is not None:
            pulumi.set(__self__, "vnet_subnet_id", vnet_subnet_id)
        if workload_runtime is not None:
            pulumi.set(__self__, "workload_runtime", workload_runtime)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for the default Kubernetes Node Pool. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> pulumi.Input[str]:
        """
        The size of the Virtual Machine, such as `Standard_DS2_v2`. `temporary_name_for_rotation` must be specified when attempting a resize.
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_size", value)

    @property
    @pulumi.getter(name="capacityReservationGroupId")
    def capacity_reservation_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the Capacity Reservation Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "capacity_reservation_group_id")

    @capacity_reservation_group_id.setter
    def capacity_reservation_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_group_id", value)

    @property
    @pulumi.getter(name="customCaTrustEnabled")
    def custom_ca_trust_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to trust a Custom CA.
        """
        return pulumi.get(self, "custom_ca_trust_enabled")

    @custom_ca_trust_enabled.setter
    def custom_ca_trust_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom_ca_trust_enabled", value)

    @property
    @pulumi.getter(name="enableAutoScaling")
    def enable_auto_scaling(self) -> Optional[pulumi.Input[bool]]:
        """
        Should [the Kubernetes Auto Scaler](https://docs.microsoft.com/azure/aks/cluster-autoscaler) be enabled for this Node Pool?

        > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets`.

        > **Note:** If you're using AutoScaling, you may wish to use [`ignoreChanges` functionality](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) to ignore changes to the `node_count` field.
        """
        return pulumi.get(self, "enable_auto_scaling")

    @enable_auto_scaling.setter
    def enable_auto_scaling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_auto_scaling", value)

    @property
    @pulumi.getter(name="enableHostEncryption")
    def enable_host_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nodes in the Default Node Pool have host encryption enabled? `temporary_name_for_rotation` must be specified when changing this property.

        > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/EnableEncryptionAtHostPreview` is enabled and the Resource Provider is re-registered.
        """
        return pulumi.get(self, "enable_host_encryption")

    @enable_host_encryption.setter
    def enable_host_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_host_encryption", value)

    @property
    @pulumi.getter(name="enableNodePublicIp")
    def enable_node_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Should nodes in this Node Pool have a Public IP Address? `temporary_name_for_rotation` must be specified when changing this property.
        """
        return pulumi.get(self, "enable_node_public_ip")

    @enable_node_public_ip.setter
    def enable_node_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_node_public_ip", value)

    @property
    @pulumi.getter(name="fipsEnabled")
    def fips_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nodes in this Node Pool have Federal Information Processing Standard enabled? Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fips_enabled")

    @fips_enabled.setter
    def fips_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fips_enabled", value)

    @property
    @pulumi.getter(name="hostGroupId")
    def host_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the ID of the Host Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "host_group_id")

    @host_group_id.setter
    def host_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_group_id", value)

    @property
    @pulumi.getter(name="kubeletConfig")
    def kubelet_config(self) -> Optional[pulumi.Input['KubernetesClusterDefaultNodePoolKubeletConfigArgs']]:
        """
        A `kubelet_config` block as defined below. `temporary_name_for_rotation` must be specified when changing this block.
        """
        return pulumi.get(self, "kubelet_config")

    @kubelet_config.setter
    def kubelet_config(self, value: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolKubeletConfigArgs']]):
        pulumi.set(self, "kubelet_config", value)

    @property
    @pulumi.getter(name="kubeletDiskType")
    def kubelet_disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of disk used by kubelet. Possible values are `OS` and `Temporary`.
        """
        return pulumi.get(self, "kubelet_disk_type")

    @kubelet_disk_type.setter
    def kubelet_disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubelet_disk_type", value)

    @property
    @pulumi.getter(name="linuxOsConfig")
    def linux_os_config(self) -> Optional[pulumi.Input['KubernetesClusterDefaultNodePoolLinuxOsConfigArgs']]:
        """
        A `linux_os_config` block as defined below. `temporary_name_for_rotation` must be specified when changing this block.
        """
        return pulumi.get(self, "linux_os_config")

    @linux_os_config.setter
    def linux_os_config(self, value: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolLinuxOsConfigArgs']]):
        pulumi.set(self, "linux_os_config", value)

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
        """
        return pulumi.get(self, "max_count")

    @max_count.setter
    def max_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_count", value)

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of pods that can run on each agent. Changing this forces a new resource to be created. `temporary_name_for_rotation` must be specified when changing this property.
        """
        return pulumi.get(self, "max_pods")

    @max_pods.setter
    def max_pods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pods", value)

    @property
    @pulumi.getter(name="messageOfTheDay")
    def message_of_the_day(self) -> Optional[pulumi.Input[str]]:
        """
        A base64-encoded string which will be written to /etc/motd after decoding. This allows customization of the message of the day for Linux nodes. It cannot be specified for Windows nodes and must be a static string (i.e. will be printed raw and not executed as a script). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "message_of_the_day")

    @message_of_the_day.setter
    def message_of_the_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_of_the_day", value)

    @property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
        """
        return pulumi.get(self, "min_count")

    @min_count.setter
    def min_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_count", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.

        > **Note:** If `enable_auto_scaling` is set to `false` both `min_count` and `max_count` fields need to be set to `null` or omitted from the configuration.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of Kubernetes labels which should be applied to nodes in the Default Node Pool.
        """
        return pulumi.get(self, "node_labels")

    @node_labels.setter
    def node_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_labels", value)

    @property
    @pulumi.getter(name="nodeNetworkProfile")
    def node_network_profile(self) -> Optional[pulumi.Input['KubernetesClusterDefaultNodePoolNodeNetworkProfileArgs']]:
        """
        A `node_network_profile` block as documented below.
        """
        return pulumi.get(self, "node_network_profile")

    @node_network_profile.setter
    def node_network_profile(self, value: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolNodeNetworkProfileArgs']]):
        pulumi.set(self, "node_network_profile", value)

    @property
    @pulumi.getter(name="nodePublicIpPrefixId")
    def node_public_ip_prefix_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID for the Public IP Addresses Prefix for the nodes in this Node Pool. `enable_node_public_ip` should be `true`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "node_public_ip_prefix_id")

    @node_public_ip_prefix_id.setter
    def node_public_ip_prefix_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_public_ip_prefix_id", value)

    @property
    @pulumi.getter(name="nodeTaints")
    def node_taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the taints added to new nodes during node pool create and scale. `temporary_name_for_rotation` must be specified when changing this property.
        """
        return pulumi.get(self, "node_taints")

    @node_taints.setter
    def node_taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "node_taints", value)

    @property
    @pulumi.getter(name="onlyCriticalAddonsEnabled")
    def only_critical_addons_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabling this option will taint default node pool with `CriticalAddonsOnly=true:NoSchedule` taint. `temporary_name_for_rotation` must be specified when changing this property.
        """
        return pulumi.get(self, "only_critical_addons_enabled")

    @only_critical_addons_enabled.setter
    def only_critical_addons_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "only_critical_addons_enabled", value)

    @property
    @pulumi.getter(name="orchestratorVersion")
    def orchestrator_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of Kubernetes used for the Agents. If not specified, the default node pool will be created with the version specified by `kubernetes_version`. If both are unspecified, the latest recommended version will be used at provisioning time (but won't auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version's latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).

        > **Note:** This version must be supported by the Kubernetes Cluster - as such the version of Kubernetes used on the Cluster/Control Plane may need to be upgraded first.
        """
        return pulumi.get(self, "orchestrator_version")

    @orchestrator_version.setter
    def orchestrator_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "orchestrator_version", value)

    @property
    @pulumi.getter(name="osDiskSizeGb")
    def os_disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the OS Disk which should be used for each agent in the Node Pool. `temporary_name_for_rotation` must be specified when attempting a change.
        """
        return pulumi.get(self, "os_disk_size_gb")

    @os_disk_size_gb.setter
    def os_disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "os_disk_size_gb", value)

    @property
    @pulumi.getter(name="osDiskType")
    def os_disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of disk which should be used for the Operating System. Possible values are `Ephemeral` and `Managed`. Defaults to `Managed`.  `temporary_name_for_rotation` must be specified when attempting a change.
        """
        return pulumi.get(self, "os_disk_type")

    @os_disk_type.setter
    def os_disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_disk_type", value)

    @property
    @pulumi.getter(name="osSku")
    def os_sku(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the OS SKU used by the agent pool. Possible values include: `AzureLinux`, `Ubuntu`, `Windows2019`, `Windows2022`. If not specified, the default is `Ubuntu` if OSType=Linux or `Windows2019` if OSType=Windows. And the default Windows OSSKU will be changed to `Windows2022` after Windows2019 is deprecated. `temporary_name_for_rotation` must be specified when attempting a change.
        """
        return pulumi.get(self, "os_sku")

    @os_sku.setter
    def os_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_sku", value)

    @property
    @pulumi.getter(name="podSubnetId")
    def pod_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Subnet where the pods in the default Node Pool should exist. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "pod_subnet_id")

    @pod_subnet_id.setter
    def pod_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_subnet_id", value)

    @property
    @pulumi.getter(name="proximityPlacementGroupId")
    def proximity_placement_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Proximity Placement Group. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "proximity_placement_group_id")

    @proximity_placement_group_id.setter
    def proximity_placement_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proximity_placement_group_id", value)

    @property
    @pulumi.getter(name="scaleDownMode")
    def scale_down_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the autoscaling behaviour of the Kubernetes Cluster. Allowed values are `Delete` and `Deallocate`. Defaults to `Delete`.
        """
        return pulumi.get(self, "scale_down_mode")

    @scale_down_mode.setter
    def scale_down_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_down_mode", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Snapshot which should be used to create this default Node Pool. `temporary_name_for_rotation` must be specified when changing this property.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping of tags to assign to the Node Pool.

        > At this time there's a bug in the AKS API where Tags for a Node Pool are not stored in the correct case - you may wish to use `ignore_changes` functionality to ignore changes to the casing until this is fixed in the AKS API.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="temporaryNameForRotation")
    def temporary_name_for_rotation(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the name of the temporary node pool used to cycle the default node pool for VM resizing.
        """
        return pulumi.get(self, "temporary_name_for_rotation")

    @temporary_name_for_rotation.setter
    def temporary_name_for_rotation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "temporary_name_for_rotation", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of Node Pool which should be created. Possible values are `AvailabilitySet` and `VirtualMachineScaleSets`. Defaults to `VirtualMachineScaleSets`. Changing this forces a new resource to be created.

        > **Note:** When creating a cluster that supports multiple node pools, the cluster must use `VirtualMachineScaleSets`. For more information on the limitations of clusters using multiple node pools see [the documentation](https://learn.microsoft.com/en-us/azure/aks/use-multiple-node-pools#limitations).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Used to specify whether the UltraSSD is enabled in the Default Node Pool. Defaults to `false`. See [the documentation](https://docs.microsoft.com/azure/aks/use-ultra-disks) for more information. `temporary_name_for_rotation` must be specified when attempting a change.
        """
        return pulumi.get(self, "ultra_ssd_enabled")

    @ultra_ssd_enabled.setter
    def ultra_ssd_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ultra_ssd_enabled", value)

    @property
    @pulumi.getter(name="upgradeSettings")
    def upgrade_settings(self) -> Optional[pulumi.Input['KubernetesClusterDefaultNodePoolUpgradeSettingsArgs']]:
        """
        A `upgrade_settings` block as documented below.
        """
        return pulumi.get(self, "upgrade_settings")

    @upgrade_settings.setter
    def upgrade_settings(self, value: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolUpgradeSettingsArgs']]):
        pulumi.set(self, "upgrade_settings", value)

    @property
    @pulumi.getter(name="vnetSubnetId")
    def vnet_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Subnet where the Kubernetes Node Pool should exist. Changing this forces a new resource to be created.

        > **Note:** A Route Table must be configured on this Subnet.
        """
        return pulumi.get(self, "vnet_subnet_id")

    @vnet_subnet_id.setter
    def vnet_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_subnet_id", value)

    @property
    @pulumi.getter(name="workloadRuntime")
    def workload_runtime(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the workload runtime used by the node pool. Possible values are `OCIContainer` and `KataMshvVmIsolation`.

        > **Note:** Pod Sandboxing / KataVM Isolation node pools are in Public Preview - more information and details on how to opt into the preview can be found in [this article](https://learn.microsoft.com/azure/aks/use-pod-sandboxing)
        """
        return pulumi.get(self, "workload_runtime")

    @workload_runtime.setter
    def workload_runtime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_runtime", value)

    @property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Availability Zones in which this Kubernetes Cluster should be located. `temporary_name_for_rotation` must be specified when changing this property.

        > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets` and that `load_balancer_sku` is set to `standard`.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "zones", value)


@pulumi.input_type
class KubernetesClusterDefaultNodePoolKubeletConfigArgs:
    def __init__(__self__, *,
                 allowed_unsafe_sysctls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 container_log_max_line: Optional[pulumi.Input[int]] = None,
                 container_log_max_size_mb: Optional[pulumi.Input[int]] = None,
                 cpu_cfs_quota_enabled: Optional[pulumi.Input[bool]] = None,
                 cpu_cfs_quota_period: Optional[pulumi.Input[str]] = None,
                 cpu_manager_policy: Optional[pulumi.Input[str]] = None,
                 image_gc_high_threshold: Optional[pulumi.Input[int]] = None,
                 image_gc_low_threshold: Optional[pulumi.Input[int]] = None,
                 pod_max_pid: Optional[pulumi.Input[int]] = None,
                 topology_manager_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_unsafe_sysctls: Specifies the allow list of unsafe sysctls command or patterns (ending in `*`). Changing this forces a new resource to be created.
        :param pulumi.Input[int] container_log_max_line: Specifies the maximum number of container log files that can be present for a container. must be at least 2. Changing this forces a new resource to be created.
        :param pulumi.Input[int] container_log_max_size_mb: Specifies the maximum size (e.g. 10MB) of container log file before it is rotated. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] cpu_cfs_quota_enabled: Is CPU CFS quota enforcement for containers enabled? Changing this forces a new resource to be created.
        :param pulumi.Input[str] cpu_cfs_quota_period: Specifies the CPU CFS quota period value. Changing this forces a new resource to be created.
        :param pulumi.Input[str] cpu_manager_policy: Specifies the CPU Manager policy to use. Possible values are `none` and `static`, Changing this forces a new resource to be created.
        :param pulumi.Input[int] image_gc_high_threshold: Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] image_gc_low_threshold: Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] pod_max_pid: Specifies the maximum number of processes per pod. Changing this forces a new resource to be created.
        :param pulumi.Input[str] topology_manager_policy: Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`. Changing this forces a new resource to be created.
        """
        if allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        if container_log_max_line is not None:
            pulumi.set(__self__, "container_log_max_line", container_log_max_line)
        if container_log_max_size_mb is not None:
            pulumi.set(__self__, "container_log_max_size_mb", container_log_max_size_mb)
        if cpu_cfs_quota_enabled is not None:
            pulumi.set(__self__, "cpu_cfs_quota_enabled", cpu_cfs_quota_enabled)
        if cpu_cfs_quota_period is not None:
            pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if image_gc_high_threshold is not None:
            pulumi.set(__self__, "image_gc_high_threshold", image_gc_high_threshold)
        if image_gc_low_threshold is not None:
            pulumi.set(__self__, "image_gc_low_threshold", image_gc_low_threshold)
        if pod_max_pid is not None:
            pulumi.set(__self__, "pod_max_pid", pod_max_pid)
        if topology_manager_policy is not None:
            pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)

    @property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the allow list of unsafe sysctls command or patterns (ending in `*`). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @allowed_unsafe_sysctls.setter
    def allowed_unsafe_sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_unsafe_sysctls", value)

    @property
    @pulumi.getter(name="containerLogMaxLine")
    def container_log_max_line(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum number of container log files that can be present for a container. must be at least 2. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "container_log_max_line")

    @container_log_max_line.setter
    def container_log_max_line(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_log_max_line", value)

    @property
    @pulumi.getter(name="containerLogMaxSizeMb")
    def container_log_max_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum size (e.g. 10MB) of container log file before it is rotated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "container_log_max_size_mb")

    @container_log_max_size_mb.setter
    def container_log_max_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_log_max_size_mb", value)

    @property
    @pulumi.getter(name="cpuCfsQuotaEnabled")
    def cpu_cfs_quota_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is CPU CFS quota enforcement for containers enabled? Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cpu_cfs_quota_enabled")

    @cpu_cfs_quota_enabled.setter
    def cpu_cfs_quota_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cpu_cfs_quota_enabled", value)

    @property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the CPU CFS quota period value. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cpu_cfs_quota_period")

    @cpu_cfs_quota_period.setter
    def cpu_cfs_quota_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_cfs_quota_period", value)

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the CPU Manager policy to use. Possible values are `none` and `static`, Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cpu_manager_policy")

    @cpu_manager_policy.setter
    def cpu_manager_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_manager_policy", value)

    @property
    @pulumi.getter(name="imageGcHighThreshold")
    def image_gc_high_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_gc_high_threshold")

    @image_gc_high_threshold.setter
    def image_gc_high_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "image_gc_high_threshold", value)

    @property
    @pulumi.getter(name="imageGcLowThreshold")
    def image_gc_low_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_gc_low_threshold")

    @image_gc_low_threshold.setter
    def image_gc_low_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "image_gc_low_threshold", value)

    @property
    @pulumi.getter(name="podMaxPid")
    def pod_max_pid(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum number of processes per pod. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "pod_max_pid")

    @pod_max_pid.setter
    def pod_max_pid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pod_max_pid", value)

    @property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "topology_manager_policy")

    @topology_manager_policy.setter
    def topology_manager_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_manager_policy", value)


@pulumi.input_type
class KubernetesClusterDefaultNodePoolLinuxOsConfigArgs:
    def __init__(__self__, *,
                 swap_file_size_mb: Optional[pulumi.Input[int]] = None,
                 sysctl_config: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfigArgs']] = None,
                 transparent_huge_page_defrag: Optional[pulumi.Input[str]] = None,
                 transparent_huge_page_enabled: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] swap_file_size_mb: Specifies the size of the swap file on each node in MB. Changing this forces a new resource to be created.
        :param pulumi.Input['KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfigArgs'] sysctl_config: A `sysctl_config` block as defined below. Changing this forces a new resource to be created.
        :param pulumi.Input[str] transparent_huge_page_defrag: specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] transparent_huge_page_enabled: Specifies the Transparent Huge Page enabled configuration. Possible values are `always`, `madvise` and `never`. Changing this forces a new resource to be created.
        """
        if swap_file_size_mb is not None:
            pulumi.set(__self__, "swap_file_size_mb", swap_file_size_mb)
        if sysctl_config is not None:
            pulumi.set(__self__, "sysctl_config", sysctl_config)
        if transparent_huge_page_defrag is not None:
            pulumi.set(__self__, "transparent_huge_page_defrag", transparent_huge_page_defrag)
        if transparent_huge_page_enabled is not None:
            pulumi.set(__self__, "transparent_huge_page_enabled", transparent_huge_page_enabled)

    @property
    @pulumi.getter(name="swapFileSizeMb")
    def swap_file_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the size of the swap file on each node in MB. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "swap_file_size_mb")

    @swap_file_size_mb.setter
    def swap_file_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "swap_file_size_mb", value)

    @property
    @pulumi.getter(name="sysctlConfig")
    def sysctl_config(self) -> Optional[pulumi.Input['KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfigArgs']]:
        """
        A `sysctl_config` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sysctl_config")

    @sysctl_config.setter
    def sysctl_config(self, value: Optional[pulumi.Input['KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfigArgs']]):
        pulumi.set(self, "sysctl_config", value)

    @property
    @pulumi.getter(name="transparentHugePageDefrag")
    def transparent_huge_page_defrag(self) -> Optional[pulumi.Input[str]]:
        """
        specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "transparent_huge_page_defrag")

    @transparent_huge_page_defrag.setter
    def transparent_huge_page_defrag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transparent_huge_page_defrag", value)

    @property
    @pulumi.getter(name="transparentHugePageEnabled")
    def transparent_huge_page_enabled(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Transparent Huge Page enabled configuration. Possible values are `always`, `madvise` and `never`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "transparent_huge_page_enabled")

    @transparent_huge_page_enabled.setter
    def transparent_huge_page_enabled(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transparent_huge_page_enabled", value)


@pulumi.input_type
class KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfigArgs:
    def __init__(__self__, *,
                 fs_aio_max_nr: Optional[pulumi.Input[int]] = None,
                 fs_file_max: Optional[pulumi.Input[int]] = None,
                 fs_inotify_max_user_watches: Optional[pulumi.Input[int]] = None,
                 fs_nr_open: Optional[pulumi.Input[int]] = None,
                 kernel_threads_max: Optional[pulumi.Input[int]] = None,
                 net_core_netdev_max_backlog: Optional[pulumi.Input[int]] = None,
                 net_core_optmem_max: Optional[pulumi.Input[int]] = None,
                 net_core_rmem_default: Optional[pulumi.Input[int]] = None,
                 net_core_rmem_max: Optional[pulumi.Input[int]] = None,
                 net_core_somaxconn: Optional[pulumi.Input[int]] = None,
                 net_core_wmem_default: Optional[pulumi.Input[int]] = None,
                 net_core_wmem_max: Optional[pulumi.Input[int]] = None,
                 net_ipv4_ip_local_port_range_max: Optional[pulumi.Input[int]] = None,
                 net_ipv4_ip_local_port_range_min: Optional[pulumi.Input[int]] = None,
                 net_ipv4_neigh_default_gc_thresh1: Optional[pulumi.Input[int]] = None,
                 net_ipv4_neigh_default_gc_thresh2: Optional[pulumi.Input[int]] = None,
                 net_ipv4_neigh_default_gc_thresh3: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_fin_timeout: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_keepalive_intvl: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_keepalive_probes: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_keepalive_time: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_max_syn_backlog: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_max_tw_buckets: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_tw_reuse: Optional[pulumi.Input[bool]] = None,
                 net_netfilter_nf_conntrack_buckets: Optional[pulumi.Input[int]] = None,
                 net_netfilter_nf_conntrack_max: Optional[pulumi.Input[int]] = None,
                 vm_max_map_count: Optional[pulumi.Input[int]] = None,
                 vm_swappiness: Optional[pulumi.Input[int]] = None,
                 vm_vfs_cache_pressure: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] fs_aio_max_nr: The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] fs_file_max: The sysctl setting fs.file-max. Must be between `8192` and `12000500`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] fs_inotify_max_user_watches: The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] fs_nr_open: The sysctl setting fs.nr_open. Must be between `8192` and `20000500`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] kernel_threads_max: The sysctl setting kernel.threads-max. Must be between `20` and `513785`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_netdev_max_backlog: The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_optmem_max: The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_rmem_default: The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_rmem_max: The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_somaxconn: The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_wmem_default: The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_wmem_max: The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_ip_local_port_range_max: The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_ip_local_port_range_min: The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_neigh_default_gc_thresh1: The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_neigh_default_gc_thresh2: The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_neigh_default_gc_thresh3: The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_fin_timeout: The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_keepalive_intvl: The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_keepalive_probes: The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_keepalive_time: The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_max_syn_backlog: The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_max_tw_buckets: The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] net_ipv4_tcp_tw_reuse: The sysctl setting net.ipv4.tcp_tw_reuse. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_netfilter_nf_conntrack_buckets: The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_netfilter_nf_conntrack_max: The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] vm_max_map_count: The sysctl setting vm.max_map_count. Must be between `65530` and `262144`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] vm_swappiness: The sysctl setting vm.swappiness. Must be between `0` and `100`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] vm_vfs_cache_pressure: The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        if fs_aio_max_nr is not None:
            pulumi.set(__self__, "fs_aio_max_nr", fs_aio_max_nr)
        if fs_file_max is not None:
            pulumi.set(__self__, "fs_file_max", fs_file_max)
        if fs_inotify_max_user_watches is not None:
            pulumi.set(__self__, "fs_inotify_max_user_watches", fs_inotify_max_user_watches)
        if fs_nr_open is not None:
            pulumi.set(__self__, "fs_nr_open", fs_nr_open)
        if kernel_threads_max is not None:
            pulumi.set(__self__, "kernel_threads_max", kernel_threads_max)
        if net_core_netdev_max_backlog is not None:
            pulumi.set(__self__, "net_core_netdev_max_backlog", net_core_netdev_max_backlog)
        if net_core_optmem_max is not None:
            pulumi.set(__self__, "net_core_optmem_max", net_core_optmem_max)
        if net_core_rmem_default is not None:
            pulumi.set(__self__, "net_core_rmem_default", net_core_rmem_default)
        if net_core_rmem_max is not None:
            pulumi.set(__self__, "net_core_rmem_max", net_core_rmem_max)
        if net_core_somaxconn is not None:
            pulumi.set(__self__, "net_core_somaxconn", net_core_somaxconn)
        if net_core_wmem_default is not None:
            pulumi.set(__self__, "net_core_wmem_default", net_core_wmem_default)
        if net_core_wmem_max is not None:
            pulumi.set(__self__, "net_core_wmem_max", net_core_wmem_max)
        if net_ipv4_ip_local_port_range_max is not None:
            pulumi.set(__self__, "net_ipv4_ip_local_port_range_max", net_ipv4_ip_local_port_range_max)
        if net_ipv4_ip_local_port_range_min is not None:
            pulumi.set(__self__, "net_ipv4_ip_local_port_range_min", net_ipv4_ip_local_port_range_min)
        if net_ipv4_neigh_default_gc_thresh1 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh1", net_ipv4_neigh_default_gc_thresh1)
        if net_ipv4_neigh_default_gc_thresh2 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh2", net_ipv4_neigh_default_gc_thresh2)
        if net_ipv4_neigh_default_gc_thresh3 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh3", net_ipv4_neigh_default_gc_thresh3)
        if net_ipv4_tcp_fin_timeout is not None:
            pulumi.set(__self__, "net_ipv4_tcp_fin_timeout", net_ipv4_tcp_fin_timeout)
        if net_ipv4_tcp_keepalive_intvl is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_intvl", net_ipv4_tcp_keepalive_intvl)
        if net_ipv4_tcp_keepalive_probes is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_probes", net_ipv4_tcp_keepalive_probes)
        if net_ipv4_tcp_keepalive_time is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_time", net_ipv4_tcp_keepalive_time)
        if net_ipv4_tcp_max_syn_backlog is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_syn_backlog", net_ipv4_tcp_max_syn_backlog)
        if net_ipv4_tcp_max_tw_buckets is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_tw_buckets", net_ipv4_tcp_max_tw_buckets)
        if net_ipv4_tcp_tw_reuse is not None:
            pulumi.set(__self__, "net_ipv4_tcp_tw_reuse", net_ipv4_tcp_tw_reuse)
        if net_netfilter_nf_conntrack_buckets is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_buckets", net_netfilter_nf_conntrack_buckets)
        if net_netfilter_nf_conntrack_max is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_max", net_netfilter_nf_conntrack_max)
        if vm_max_map_count is not None:
            pulumi.set(__self__, "vm_max_map_count", vm_max_map_count)
        if vm_swappiness is not None:
            pulumi.set(__self__, "vm_swappiness", vm_swappiness)
        if vm_vfs_cache_pressure is not None:
            pulumi.set(__self__, "vm_vfs_cache_pressure", vm_vfs_cache_pressure)

    @property
    @pulumi.getter(name="fsAioMaxNr")
    def fs_aio_max_nr(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fs_aio_max_nr")

    @fs_aio_max_nr.setter
    def fs_aio_max_nr(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_aio_max_nr", value)

    @property
    @pulumi.getter(name="fsFileMax")
    def fs_file_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting fs.file-max. Must be between `8192` and `12000500`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fs_file_max")

    @fs_file_max.setter
    def fs_file_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_file_max", value)

    @property
    @pulumi.getter(name="fsInotifyMaxUserWatches")
    def fs_inotify_max_user_watches(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fs_inotify_max_user_watches")

    @fs_inotify_max_user_watches.setter
    def fs_inotify_max_user_watches(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_inotify_max_user_watches", value)

    @property
    @pulumi.getter(name="fsNrOpen")
    def fs_nr_open(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting fs.nr_open. Must be between `8192` and `20000500`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fs_nr_open")

    @fs_nr_open.setter
    def fs_nr_open(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_nr_open", value)

    @property
    @pulumi.getter(name="kernelThreadsMax")
    def kernel_threads_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting kernel.threads-max. Must be between `20` and `513785`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "kernel_threads_max")

    @kernel_threads_max.setter
    def kernel_threads_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "kernel_threads_max", value)

    @property
    @pulumi.getter(name="netCoreNetdevMaxBacklog")
    def net_core_netdev_max_backlog(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_netdev_max_backlog")

    @net_core_netdev_max_backlog.setter
    def net_core_netdev_max_backlog(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_netdev_max_backlog", value)

    @property
    @pulumi.getter(name="netCoreOptmemMax")
    def net_core_optmem_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_optmem_max")

    @net_core_optmem_max.setter
    def net_core_optmem_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_optmem_max", value)

    @property
    @pulumi.getter(name="netCoreRmemDefault")
    def net_core_rmem_default(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_rmem_default")

    @net_core_rmem_default.setter
    def net_core_rmem_default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_rmem_default", value)

    @property
    @pulumi.getter(name="netCoreRmemMax")
    def net_core_rmem_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_rmem_max")

    @net_core_rmem_max.setter
    def net_core_rmem_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_rmem_max", value)

    @property
    @pulumi.getter(name="netCoreSomaxconn")
    def net_core_somaxconn(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_somaxconn")

    @net_core_somaxconn.setter
    def net_core_somaxconn(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_somaxconn", value)

    @property
    @pulumi.getter(name="netCoreWmemDefault")
    def net_core_wmem_default(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_wmem_default")

    @net_core_wmem_default.setter
    def net_core_wmem_default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_wmem_default", value)

    @property
    @pulumi.getter(name="netCoreWmemMax")
    def net_core_wmem_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_wmem_max")

    @net_core_wmem_max.setter
    def net_core_wmem_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_wmem_max", value)

    @property
    @pulumi.getter(name="netIpv4IpLocalPortRangeMax")
    def net_ipv4_ip_local_port_range_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_ip_local_port_range_max")

    @net_ipv4_ip_local_port_range_max.setter
    def net_ipv4_ip_local_port_range_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_ip_local_port_range_max", value)

    @property
    @pulumi.getter(name="netIpv4IpLocalPortRangeMin")
    def net_ipv4_ip_local_port_range_min(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_ip_local_port_range_min")

    @net_ipv4_ip_local_port_range_min.setter
    def net_ipv4_ip_local_port_range_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_ip_local_port_range_min", value)

    @property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh1")
    def net_ipv4_neigh_default_gc_thresh1(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh1")

    @net_ipv4_neigh_default_gc_thresh1.setter
    def net_ipv4_neigh_default_gc_thresh1(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_neigh_default_gc_thresh1", value)

    @property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh2")
    def net_ipv4_neigh_default_gc_thresh2(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh2")

    @net_ipv4_neigh_default_gc_thresh2.setter
    def net_ipv4_neigh_default_gc_thresh2(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_neigh_default_gc_thresh2", value)

    @property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh3")
    def net_ipv4_neigh_default_gc_thresh3(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh3")

    @net_ipv4_neigh_default_gc_thresh3.setter
    def net_ipv4_neigh_default_gc_thresh3(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_neigh_default_gc_thresh3", value)

    @property
    @pulumi.getter(name="netIpv4TcpFinTimeout")
    def net_ipv4_tcp_fin_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_fin_timeout")

    @net_ipv4_tcp_fin_timeout.setter
    def net_ipv4_tcp_fin_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_fin_timeout", value)

    @property
    @pulumi.getter(name="netIpv4TcpKeepaliveIntvl")
    def net_ipv4_tcp_keepalive_intvl(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_intvl")

    @net_ipv4_tcp_keepalive_intvl.setter
    def net_ipv4_tcp_keepalive_intvl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_keepalive_intvl", value)

    @property
    @pulumi.getter(name="netIpv4TcpKeepaliveProbes")
    def net_ipv4_tcp_keepalive_probes(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_probes")

    @net_ipv4_tcp_keepalive_probes.setter
    def net_ipv4_tcp_keepalive_probes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_keepalive_probes", value)

    @property
    @pulumi.getter(name="netIpv4TcpKeepaliveTime")
    def net_ipv4_tcp_keepalive_time(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_time")

    @net_ipv4_tcp_keepalive_time.setter
    def net_ipv4_tcp_keepalive_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_keepalive_time", value)

    @property
    @pulumi.getter(name="netIpv4TcpMaxSynBacklog")
    def net_ipv4_tcp_max_syn_backlog(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_syn_backlog")

    @net_ipv4_tcp_max_syn_backlog.setter
    def net_ipv4_tcp_max_syn_backlog(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_max_syn_backlog", value)

    @property
    @pulumi.getter(name="netIpv4TcpMaxTwBuckets")
    def net_ipv4_tcp_max_tw_buckets(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_tw_buckets")

    @net_ipv4_tcp_max_tw_buckets.setter
    def net_ipv4_tcp_max_tw_buckets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_max_tw_buckets", value)

    @property
    @pulumi.getter(name="netIpv4TcpTwReuse")
    def net_ipv4_tcp_tw_reuse(self) -> Optional[pulumi.Input[bool]]:
        """
        The sysctl setting net.ipv4.tcp_tw_reuse. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_tw_reuse")

    @net_ipv4_tcp_tw_reuse.setter
    def net_ipv4_tcp_tw_reuse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "net_ipv4_tcp_tw_reuse", value)

    @property
    @pulumi.getter(name="netNetfilterNfConntrackBuckets")
    def net_netfilter_nf_conntrack_buckets(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_buckets")

    @net_netfilter_nf_conntrack_buckets.setter
    def net_netfilter_nf_conntrack_buckets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_netfilter_nf_conntrack_buckets", value)

    @property
    @pulumi.getter(name="netNetfilterNfConntrackMax")
    def net_netfilter_nf_conntrack_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_max")

    @net_netfilter_nf_conntrack_max.setter
    def net_netfilter_nf_conntrack_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_netfilter_nf_conntrack_max", value)

    @property
    @pulumi.getter(name="vmMaxMapCount")
    def vm_max_map_count(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting vm.max_map_count. Must be between `65530` and `262144`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_max_map_count")

    @vm_max_map_count.setter
    def vm_max_map_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vm_max_map_count", value)

    @property
    @pulumi.getter(name="vmSwappiness")
    def vm_swappiness(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting vm.swappiness. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_swappiness")

    @vm_swappiness.setter
    def vm_swappiness(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vm_swappiness", value)

    @property
    @pulumi.getter(name="vmVfsCachePressure")
    def vm_vfs_cache_pressure(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_vfs_cache_pressure")

    @vm_vfs_cache_pressure.setter
    def vm_vfs_cache_pressure(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vm_vfs_cache_pressure", value)


@pulumi.input_type
class KubernetesClusterDefaultNodePoolNodeNetworkProfileArgs:
    def __init__(__self__, *,
                 node_public_ip_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_public_ip_tags: Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.
               
               > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/NodePublicIPTagsPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/use-node-public-ips#use-public-ip-tags-on-node-public-ips-preview) for more information.
        """
        if node_public_ip_tags is not None:
            pulumi.set(__self__, "node_public_ip_tags", node_public_ip_tags)

    @property
    @pulumi.getter(name="nodePublicIpTags")
    def node_public_ip_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.

        > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/NodePublicIPTagsPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/use-node-public-ips#use-public-ip-tags-on-node-public-ips-preview) for more information.
        """
        return pulumi.get(self, "node_public_ip_tags")

    @node_public_ip_tags.setter
    def node_public_ip_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_public_ip_tags", value)


@pulumi.input_type
class KubernetesClusterDefaultNodePoolUpgradeSettingsArgs:
    def __init__(__self__, *,
                 max_surge: pulumi.Input[str]):
        """
        :param pulumi.Input[str] max_surge: The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
               
               > **Note:** If a percentage is provided, the number of surge nodes is calculated from the `node_count` value on the current cluster. Node surge can allow a cluster to have more nodes than `max_count` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
        """
        pulumi.set(__self__, "max_surge", max_surge)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> pulumi.Input[str]:
        """
        The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.

        > **Note:** If a percentage is provided, the number of surge nodes is calculated from the `node_count` value on the current cluster. Node surge can allow a cluster to have more nodes than `max_count` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: pulumi.Input[str]):
        pulumi.set(self, "max_surge", value)


@pulumi.input_type
class KubernetesClusterExtensionAksAssignedIdentityArgs:
    def __init__(__self__, *,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] principal_id: The principal ID of resource identity.
        :param pulumi.Input[str] tenant_id: The tenant ID of resource.
        :param pulumi.Input[str] type: The identity type.
        """
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KubernetesClusterExtensionPlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 promotion_code: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Specifies the name of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
        :param pulumi.Input[str] product: Specifies the product of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
        :param pulumi.Input[str] publisher: Specifies the publisher of the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
        :param pulumi.Input[str] promotion_code: Specifies the promotion code to use with the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
        :param pulumi.Input[str] version: Specifies the version of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
               
               > **NOTE:** When `plan` is specified, legal terms must be accepted for this item on this subscription before creating the Kubernetes Cluster Extension. The `marketplace.Agreement` resource or AZ CLI tool can be used to do this.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        Specifies the product of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Specifies the publisher of the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the promotion code to use with the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
        """
        return pulumi.get(self, "promotion_code")

    @promotion_code.setter
    def promotion_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "promotion_code", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the version of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.

        > **NOTE:** When `plan` is specified, legal terms must be accepted for this item on this subscription before creating the Kubernetes Cluster Extension. The `marketplace.Agreement` resource or AZ CLI tool can be used to do this.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KubernetesClusterHttpProxyConfigArgs:
    def __init__(__self__, *,
                 http_proxy: Optional[pulumi.Input[str]] = None,
                 https_proxy: Optional[pulumi.Input[str]] = None,
                 no_proxies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 trusted_ca: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_proxy: The proxy address to be used when communicating over HTTP. Changing this forces a new resource to be created.
        :param pulumi.Input[str] https_proxy: The proxy address to be used when communicating over HTTPS. Changing this forces a new resource to be created.
        :param pulumi.Input[str] trusted_ca: The base64 encoded alternative CA certificate content in PEM format.
        """
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if no_proxies is not None:
            pulumi.set(__self__, "no_proxies", no_proxies)
        if trusted_ca is not None:
            pulumi.set(__self__, "trusted_ca", trusted_ca)

    @property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        The proxy address to be used when communicating over HTTP. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_proxy")

    @http_proxy.setter
    def http_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_proxy", value)

    @property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        The proxy address to be used when communicating over HTTPS. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "https_proxy")

    @https_proxy.setter
    def https_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "https_proxy", value)

    @property
    @pulumi.getter(name="noProxies")
    def no_proxies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "no_proxies")

    @no_proxies.setter
    def no_proxies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "no_proxies", value)

    @property
    @pulumi.getter(name="trustedCa")
    def trusted_ca(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded alternative CA certificate content in PEM format.
        """
        return pulumi.get(self, "trusted_ca")

    @trusted_ca.setter
    def trusted_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca", value)


@pulumi.input_type
class KubernetesClusterIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Kubernetes Cluster. Possible values are `SystemAssigned` or `UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Kubernetes Cluster.
               
               > **Note:** This is required when `type` is set to `UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Kubernetes Cluster. Possible values are `SystemAssigned` or `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Kubernetes Cluster.

        > **Note:** This is required when `type` is set to `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class KubernetesClusterIngressApplicationGatewayArgs:
    def __init__(__self__, *,
                 effective_gateway_id: Optional[pulumi.Input[str]] = None,
                 gateway_id: Optional[pulumi.Input[str]] = None,
                 gateway_name: Optional[pulumi.Input[str]] = None,
                 ingress_application_gateway_identities: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityArgs']]]] = None,
                 subnet_cidr: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective_gateway_id: The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
        :param pulumi.Input[str] gateway_id: The ID of the Application Gateway to integrate with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-existing) page for further details.
        :param pulumi.Input[str] gateway_name: The name of the Application Gateway to be used or created in the Nodepool Resource Group, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityArgs']]] ingress_application_gateway_identities: An `ingress_application_gateway_identity` block is exported. The exported attributes are defined below.
        :param pulumi.Input[str] subnet_cidr: The subnet CIDR to be used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
        :param pulumi.Input[str] subnet_id: The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
               
               > **Note:** Exactly one of `gateway_id`, `subnet_id` or `subnet_cidr` must be specified.
               
               > **Note:** If specifying `ingress_application_gateway` in conjunction with `only_critical_addons_enabled`, the AGIC pod will fail to start. A separate `containerservice.KubernetesClusterNodePool` is required to run the AGIC pod successfully. This is because AGIC is classed as a "non-critical addon".
        """
        if effective_gateway_id is not None:
            pulumi.set(__self__, "effective_gateway_id", effective_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if gateway_name is not None:
            pulumi.set(__self__, "gateway_name", gateway_name)
        if ingress_application_gateway_identities is not None:
            pulumi.set(__self__, "ingress_application_gateway_identities", ingress_application_gateway_identities)
        if subnet_cidr is not None:
            pulumi.set(__self__, "subnet_cidr", subnet_cidr)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="effectiveGatewayId")
    def effective_gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
        """
        return pulumi.get(self, "effective_gateway_id")

    @effective_gateway_id.setter
    def effective_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_gateway_id", value)

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Application Gateway to integrate with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-existing) page for further details.
        """
        return pulumi.get(self, "gateway_id")

    @gateway_id.setter
    def gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_id", value)

    @property
    @pulumi.getter(name="gatewayName")
    def gateway_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Application Gateway to be used or created in the Nodepool Resource Group, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
        """
        return pulumi.get(self, "gateway_name")

    @gateway_name.setter
    def gateway_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_name", value)

    @property
    @pulumi.getter(name="ingressApplicationGatewayIdentities")
    def ingress_application_gateway_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityArgs']]]]:
        """
        An `ingress_application_gateway_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "ingress_application_gateway_identities")

    @ingress_application_gateway_identities.setter
    def ingress_application_gateway_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityArgs']]]]):
        pulumi.set(self, "ingress_application_gateway_identities", value)

    @property
    @pulumi.getter(name="subnetCidr")
    def subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet CIDR to be used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
        """
        return pulumi.get(self, "subnet_cidr")

    @subnet_cidr.setter
    def subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_cidr", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.

        > **Note:** Exactly one of `gateway_id`, `subnet_id` or `subnet_cidr` must be specified.

        > **Note:** If specifying `ingress_application_gateway` in conjunction with `only_critical_addons_enabled`, the AGIC pod will fail to start. A separate `containerservice.KubernetesClusterNodePool` is required to run the AGIC pod successfully. This is because AGIC is classed as a "non-critical addon".
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 user_assigned_identity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
               
               > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.

        > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        return pulumi.get(self, "user_assigned_identity_id")

    @user_assigned_identity_id.setter
    def user_assigned_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity_id", value)


@pulumi.input_type
class KubernetesClusterKeyManagementServiceArgs:
    def __init__(__self__, *,
                 key_vault_key_id: pulumi.Input[str],
                 key_vault_network_access: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_vault_key_id: Identifier of Azure Key Vault key. See [key identifier format](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When `enabled` is `false`, leave the field empty.
        :param pulumi.Input[str] key_vault_network_access: Network access of the key vault Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.
        """
        pulumi.set(__self__, "key_vault_key_id", key_vault_key_id)
        if key_vault_network_access is not None:
            pulumi.set(__self__, "key_vault_network_access", key_vault_network_access)

    @property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> pulumi.Input[str]:
        """
        Identifier of Azure Key Vault key. See [key identifier format](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When `enabled` is `false`, leave the field empty.
        """
        return pulumi.get(self, "key_vault_key_id")

    @key_vault_key_id.setter
    def key_vault_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_key_id", value)

    @property
    @pulumi.getter(name="keyVaultNetworkAccess")
    def key_vault_network_access(self) -> Optional[pulumi.Input[str]]:
        """
        Network access of the key vault Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.
        """
        return pulumi.get(self, "key_vault_network_access")

    @key_vault_network_access.setter
    def key_vault_network_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_network_access", value)


@pulumi.input_type
class KubernetesClusterKeyVaultSecretsProviderArgs:
    def __init__(__self__, *,
                 secret_identities: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterKeyVaultSecretsProviderSecretIdentityArgs']]]] = None,
                 secret_rotation_enabled: Optional[pulumi.Input[bool]] = None,
                 secret_rotation_interval: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterKeyVaultSecretsProviderSecretIdentityArgs']]] secret_identities: An `secret_identity` block is exported. The exported attributes are defined below.
        :param pulumi.Input[bool] secret_rotation_enabled: Should the secret store CSI driver on the AKS cluster be enabled?
        :param pulumi.Input[str] secret_rotation_interval: The interval to poll for secret rotation. This attribute is only set when `secret_rotation` is true and defaults to `2m`.
               
               > **Note:** To enable`key_vault_secrets_provider` either `secret_rotation_enabled` or `secret_rotation_interval` must be specified.
        """
        if secret_identities is not None:
            pulumi.set(__self__, "secret_identities", secret_identities)
        if secret_rotation_enabled is not None:
            pulumi.set(__self__, "secret_rotation_enabled", secret_rotation_enabled)
        if secret_rotation_interval is not None:
            pulumi.set(__self__, "secret_rotation_interval", secret_rotation_interval)

    @property
    @pulumi.getter(name="secretIdentities")
    def secret_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterKeyVaultSecretsProviderSecretIdentityArgs']]]]:
        """
        An `secret_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "secret_identities")

    @secret_identities.setter
    def secret_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterKeyVaultSecretsProviderSecretIdentityArgs']]]]):
        pulumi.set(self, "secret_identities", value)

    @property
    @pulumi.getter(name="secretRotationEnabled")
    def secret_rotation_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the secret store CSI driver on the AKS cluster be enabled?
        """
        return pulumi.get(self, "secret_rotation_enabled")

    @secret_rotation_enabled.setter
    def secret_rotation_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secret_rotation_enabled", value)

    @property
    @pulumi.getter(name="secretRotationInterval")
    def secret_rotation_interval(self) -> Optional[pulumi.Input[str]]:
        """
        The interval to poll for secret rotation. This attribute is only set when `secret_rotation` is true and defaults to `2m`.

        > **Note:** To enable`key_vault_secrets_provider` either `secret_rotation_enabled` or `secret_rotation_interval` must be specified.
        """
        return pulumi.get(self, "secret_rotation_interval")

    @secret_rotation_interval.setter
    def secret_rotation_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_rotation_interval", value)


@pulumi.input_type
class KubernetesClusterKeyVaultSecretsProviderSecretIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 user_assigned_identity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
               
               > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.

        > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        return pulumi.get(self, "user_assigned_identity_id")

    @user_assigned_identity_id.setter
    def user_assigned_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity_id", value)


@pulumi.input_type
class KubernetesClusterKubeAdminConfigArgs:
    def __init__(__self__, *,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 cluster_ca_certificate: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param pulumi.Input[str] client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param pulumi.Input[str] cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param pulumi.Input[str] host: The Kubernetes cluster server host.
        :param pulumi.Input[str] password: A password or token used to authenticate to the Kubernetes cluster.
        :param pulumi.Input[str] username: A username used to authenticate to the Kubernetes cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class KubernetesClusterKubeConfigArgs:
    def __init__(__self__, *,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 cluster_ca_certificate: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param pulumi.Input[str] client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param pulumi.Input[str] cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param pulumi.Input[str] host: The Kubernetes cluster server host.
        :param pulumi.Input[str] password: A password or token used to authenticate to the Kubernetes cluster.
        :param pulumi.Input[str] username: A username used to authenticate to the Kubernetes cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class KubernetesClusterKubeletIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 user_assigned_identity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
               
               > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.

        > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        return pulumi.get(self, "user_assigned_identity_id")

    @user_assigned_identity_id.setter
    def user_assigned_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity_id", value)


@pulumi.input_type
class KubernetesClusterLinuxProfileArgs:
    def __init__(__self__, *,
                 admin_username: pulumi.Input[str],
                 ssh_key: pulumi.Input['KubernetesClusterLinuxProfileSshKeyArgs']):
        """
        :param pulumi.Input[str] admin_username: The Admin Username for the Cluster. Changing this forces a new resource to be created.
        :param pulumi.Input['KubernetesClusterLinuxProfileSshKeyArgs'] ssh_key: An `ssh_key` block. Only one is currently allowed. Changing this will update the key on all node pools. More information can be found in [the documentation](https://learn.microsoft.com/en-us/azure/aks/node-access#update-ssh-key-on-an-existing-aks-cluster-preview).
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "ssh_key", ssh_key)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        The Admin Username for the Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input['KubernetesClusterLinuxProfileSshKeyArgs']:
        """
        An `ssh_key` block. Only one is currently allowed. Changing this will update the key on all node pools. More information can be found in [the documentation](https://learn.microsoft.com/en-us/azure/aks/node-access#update-ssh-key-on-an-existing-aks-cluster-preview).
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input['KubernetesClusterLinuxProfileSshKeyArgs']):
        pulumi.set(self, "ssh_key", value)


@pulumi.input_type
class KubernetesClusterLinuxProfileSshKeyArgs:
    def __init__(__self__, *,
                 key_data: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key_data: The Public SSH Key used to access the cluster.
        """
        pulumi.set(__self__, "key_data", key_data)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> pulumi.Input[str]:
        """
        The Public SSH Key used to access the cluster.
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_data", value)


@pulumi.input_type
class KubernetesClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 alloweds: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowAllowedArgs']]]] = None,
                 not_alloweds: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowNotAllowedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowAllowedArgs']]] alloweds: One or more `allowed` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowNotAllowedArgs']]] not_alloweds: One or more `not_allowed` block as defined below.
        """
        if alloweds is not None:
            pulumi.set(__self__, "alloweds", alloweds)
        if not_alloweds is not None:
            pulumi.set(__self__, "not_alloweds", not_alloweds)

    @property
    @pulumi.getter
    def alloweds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowAllowedArgs']]]]:
        """
        One or more `allowed` blocks as defined below.
        """
        return pulumi.get(self, "alloweds")

    @alloweds.setter
    def alloweds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowAllowedArgs']]]]):
        pulumi.set(self, "alloweds", value)

    @property
    @pulumi.getter(name="notAlloweds")
    def not_alloweds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowNotAllowedArgs']]]]:
        """
        One or more `not_allowed` block as defined below.
        """
        return pulumi.get(self, "not_alloweds")

    @not_alloweds.setter
    def not_alloweds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowNotAllowedArgs']]]]):
        pulumi.set(self, "not_alloweds", value)


@pulumi.input_type
class KubernetesClusterMaintenanceWindowAllowedArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[str],
                 hours: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[str] day: A day in a week. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours: An array of hour slots in a day. For example, specifying `1` will allow maintenance from 1:00am to 2:00am. Specifying `1`, `2` will allow maintenance from 1:00am to 3:00m. Possible values are between `0` and `23`.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hours", hours)

    @property
    @pulumi.getter
    def day(self) -> pulumi.Input[str]:
        """
        A day in a week. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[str]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        An array of hour slots in a day. For example, specifying `1` will allow maintenance from 1:00am to 2:00am. Specifying `1`, `2` will allow maintenance from 1:00am to 3:00m. Possible values are between `0` and `23`.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "hours", value)


@pulumi.input_type
class KubernetesClusterMaintenanceWindowAutoUpgradeArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[int],
                 frequency: pulumi.Input[str],
                 interval: pulumi.Input[int],
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 not_alloweds: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowedArgs']]]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 utc_offset: Optional[pulumi.Input[str]] = None,
                 week_index: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] duration: The duration of the window for maintenance to run in hours.
        :param pulumi.Input[str] frequency: Frequency of maintenance. Possible options are `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
        :param pulumi.Input[int] interval: The interval for maintenance runs. Depending on the frequency this interval is week or month based.
        :param pulumi.Input[str] day_of_week: The day of the week for the maintenance run. Options are `Monday`, `Tuesday`, `Wednesday`, `Thurday`, `Friday`, `Saturday` and `Sunday`. Required in combination with weekly frequency.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowedArgs']]] not_alloweds: One or more `not_allowed` block as defined below.
        :param pulumi.Input[str] start_date: The date on which the maintenance window begins to take effect.
        :param pulumi.Input[str] start_time: The time for maintenance to begin, based on the timezone determined by `utc_offset`. Format is `HH:mm`.
        :param pulumi.Input[str] utc_offset: Used to determine the timezone for cluster maintenance.
        :param pulumi.Input[str] week_index: The week in the month used for the maintenance run. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
               Required in combination with relative monthly frequency.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if not_alloweds is not None:
            pulumi.set(__self__, "not_alloweds", not_alloweds)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if utc_offset is not None:
            pulumi.set(__self__, "utc_offset", utc_offset)
        if week_index is not None:
            pulumi.set(__self__, "week_index", week_index)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[int]:
        """
        The duration of the window for maintenance to run in hours.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[int]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[str]:
        """
        Frequency of maintenance. Possible options are `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[int]:
        """
        The interval for maintenance runs. Depending on the frequency this interval is week or month based.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        The day of the week for the maintenance run. Options are `Monday`, `Tuesday`, `Wednesday`, `Thurday`, `Friday`, `Saturday` and `Sunday`. Required in combination with weekly frequency.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="notAlloweds")
    def not_alloweds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowedArgs']]]]:
        """
        One or more `not_allowed` block as defined below.
        """
        return pulumi.get(self, "not_alloweds")

    @not_alloweds.setter
    def not_alloweds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowedArgs']]]]):
        pulumi.set(self, "not_alloweds", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date on which the maintenance window begins to take effect.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time for maintenance to begin, based on the timezone determined by `utc_offset`. Format is `HH:mm`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="utcOffset")
    def utc_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Used to determine the timezone for cluster maintenance.
        """
        return pulumi.get(self, "utc_offset")

    @utc_offset.setter
    def utc_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "utc_offset", value)

    @property
    @pulumi.getter(name="weekIndex")
    def week_index(self) -> Optional[pulumi.Input[str]]:
        """
        The week in the month used for the maintenance run. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
        Required in combination with relative monthly frequency.
        """
        return pulumi.get(self, "week_index")

    @week_index.setter
    def week_index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "week_index", value)


@pulumi.input_type
class KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowedArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end: The end of a time span, formatted as an RFC3339 string.
        :param pulumi.Input[str] start: The start of a time span, formatted as an RFC3339 string.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        The end of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The start of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class KubernetesClusterMaintenanceWindowNodeOsArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[int],
                 frequency: pulumi.Input[str],
                 interval: pulumi.Input[int],
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 not_alloweds: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowNodeOsNotAllowedArgs']]]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 utc_offset: Optional[pulumi.Input[str]] = None,
                 week_index: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] duration: The duration of the window for maintenance to run in hours.
        :param pulumi.Input[str] frequency: Frequency of maintenance. Possible options are `Daily`, `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
        :param pulumi.Input[int] interval: The interval for maintenance runs. Depending on the frequency this interval is week or month based.
        :param pulumi.Input[str] day_of_week: The day of the week for the maintenance run. Options are `Monday`, `Tuesday`, `Wednesday`, `Thurday`, `Friday`, `Saturday` and `Sunday`. Required in combination with weekly frequency.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowNodeOsNotAllowedArgs']]] not_alloweds: One or more `not_allowed` block as defined below.
        :param pulumi.Input[str] start_date: The date on which the maintenance window begins to take effect.
        :param pulumi.Input[str] start_time: The time for maintenance to begin, based on the timezone determined by `utc_offset`. Format is `HH:mm`.
        :param pulumi.Input[str] utc_offset: Used to determine the timezone for cluster maintenance.
        :param pulumi.Input[str] week_index: The week in the month used for the maintenance run. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if not_alloweds is not None:
            pulumi.set(__self__, "not_alloweds", not_alloweds)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if utc_offset is not None:
            pulumi.set(__self__, "utc_offset", utc_offset)
        if week_index is not None:
            pulumi.set(__self__, "week_index", week_index)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[int]:
        """
        The duration of the window for maintenance to run in hours.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[int]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[str]:
        """
        Frequency of maintenance. Possible options are `Daily`, `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[int]:
        """
        The interval for maintenance runs. Depending on the frequency this interval is week or month based.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        The day of the week for the maintenance run. Options are `Monday`, `Tuesday`, `Wednesday`, `Thurday`, `Friday`, `Saturday` and `Sunday`. Required in combination with weekly frequency.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="notAlloweds")
    def not_alloweds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowNodeOsNotAllowedArgs']]]]:
        """
        One or more `not_allowed` block as defined below.
        """
        return pulumi.get(self, "not_alloweds")

    @not_alloweds.setter
    def not_alloweds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterMaintenanceWindowNodeOsNotAllowedArgs']]]]):
        pulumi.set(self, "not_alloweds", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date on which the maintenance window begins to take effect.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time for maintenance to begin, based on the timezone determined by `utc_offset`. Format is `HH:mm`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="utcOffset")
    def utc_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Used to determine the timezone for cluster maintenance.
        """
        return pulumi.get(self, "utc_offset")

    @utc_offset.setter
    def utc_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "utc_offset", value)

    @property
    @pulumi.getter(name="weekIndex")
    def week_index(self) -> Optional[pulumi.Input[str]]:
        """
        The week in the month used for the maintenance run. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
        """
        return pulumi.get(self, "week_index")

    @week_index.setter
    def week_index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "week_index", value)


@pulumi.input_type
class KubernetesClusterMaintenanceWindowNodeOsNotAllowedArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end: The end of a time span, formatted as an RFC3339 string.
        :param pulumi.Input[str] start: The start of a time span, formatted as an RFC3339 string.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        The end of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The start of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class KubernetesClusterMaintenanceWindowNotAllowedArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end: The end of a time span, formatted as an RFC3339 string.
        :param pulumi.Input[str] start: The start of a time span, formatted as an RFC3339 string.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        The end of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The start of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class KubernetesClusterMicrosoftDefenderArgs:
    def __init__(__self__, *,
                 log_analytics_workspace_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] log_analytics_workspace_id: Specifies the ID of the Log Analytics Workspace where the audit logs collected by Microsoft Defender should be sent to.
        """
        pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> pulumi.Input[str]:
        """
        Specifies the ID of the Log Analytics Workspace where the audit logs collected by Microsoft Defender should be sent to.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_analytics_workspace_id", value)


@pulumi.input_type
class KubernetesClusterMonitorMetricsArgs:
    def __init__(__self__, *,
                 annotations_allowed: Optional[pulumi.Input[str]] = None,
                 labels_allowed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] annotations_allowed: Specifies a comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric.
        :param pulumi.Input[str] labels_allowed: Specifies a Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.
        """
        if annotations_allowed is not None:
            pulumi.set(__self__, "annotations_allowed", annotations_allowed)
        if labels_allowed is not None:
            pulumi.set(__self__, "labels_allowed", labels_allowed)

    @property
    @pulumi.getter(name="annotationsAllowed")
    def annotations_allowed(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric.
        """
        return pulumi.get(self, "annotations_allowed")

    @annotations_allowed.setter
    def annotations_allowed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotations_allowed", value)

    @property
    @pulumi.getter(name="labelsAllowed")
    def labels_allowed(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.
        """
        return pulumi.get(self, "labels_allowed")

    @labels_allowed.setter
    def labels_allowed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "labels_allowed", value)


@pulumi.input_type
class KubernetesClusterNetworkProfileArgs:
    def __init__(__self__, *,
                 network_plugin: pulumi.Input[str],
                 dns_service_ip: Optional[pulumi.Input[str]] = None,
                 docker_bridge_cidr: Optional[pulumi.Input[str]] = None,
                 ebpf_data_plane: Optional[pulumi.Input[str]] = None,
                 ip_versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 load_balancer_profile: Optional[pulumi.Input['KubernetesClusterNetworkProfileLoadBalancerProfileArgs']] = None,
                 load_balancer_sku: Optional[pulumi.Input[str]] = None,
                 nat_gateway_profile: Optional[pulumi.Input['KubernetesClusterNetworkProfileNatGatewayProfileArgs']] = None,
                 network_mode: Optional[pulumi.Input[str]] = None,
                 network_plugin_mode: Optional[pulumi.Input[str]] = None,
                 network_policy: Optional[pulumi.Input[str]] = None,
                 outbound_type: Optional[pulumi.Input[str]] = None,
                 pod_cidr: Optional[pulumi.Input[str]] = None,
                 pod_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_cidr: Optional[pulumi.Input[str]] = None,
                 service_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] network_plugin: Network plugin to use for networking. Currently supported values are `azure`, `kubenet` and `none`. Changing this forces a new resource to be created.
               
               > **Note:** When `network_plugin` is set to `azure` - the `pod_cidr` field must not be set.
        :param pulumi.Input[str] dns_service_ip: IP address within the Kubernetes service address range that will be used by cluster service discovery (kube-dns). Changing this forces a new resource to be created.
        :param pulumi.Input[str] docker_bridge_cidr: IP address (in CIDR notation) used as the Docker bridge IP address on nodes. Changing this forces a new resource to be created.
               
               > **Note:** `docker_bridge_cidr` has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
        :param pulumi.Input[str] ebpf_data_plane: Specifies the eBPF data plane used for building the Kubernetes network. Possible value is `cilium`. Disabling this forces a new resource to be created.
               
               > **Note:** When `ebpf_data_plane` is set to `cilium`, the `network_plugin` field can only be set to `azure`.
               
               > **Note:** When `ebpf_data_plane` is set to `cilium`, one of either `network_plugin_mode = "overlay"` or `pod_subnet_id` must be specified.
               
               > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/CiliumDataplanePreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/azure-cni-powered-by-cilium) for more information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_versions: Specifies a list of IP versions the Kubernetes Cluster will use to assign IP addresses to its nodes and pods. Possible values are `IPv4` and/or `IPv6`. `IPv4` must always be specified. Changing this forces a new resource to be created.
               
               ->**Note:** To configure dual-stack networking `ip_versions` should be set to `["IPv4", "IPv6"]`.
               
               ->**Note:** Dual-stack networking requires that the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` is enabled and the Resource Provider is re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
        :param pulumi.Input['KubernetesClusterNetworkProfileLoadBalancerProfileArgs'] load_balancer_profile: A `load_balancer_profile` block as defined below. This can only be specified when `load_balancer_sku` is set to `standard`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] load_balancer_sku: Specifies the SKU of the Load Balancer used for this Kubernetes Cluster. Possible values are `basic` and `standard`. Defaults to `standard`. Changing this forces a new resource to be created.
        :param pulumi.Input['KubernetesClusterNetworkProfileNatGatewayProfileArgs'] nat_gateway_profile: A `nat_gateway_profile` block as defined below. This can only be specified when `load_balancer_sku` is set to `standard` and `outbound_type` is set to `managedNATGateway` or `userAssignedNATGateway`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] network_mode: Network mode to be used with Azure CNI. Possible values are `bridge` and `transparent`. Changing this forces a new resource to be created.
               
               > **Note:** `network_mode` can only be set to `bridge` for existing Kubernetes Clusters and cannot be used to provision new Clusters - this will be removed by Azure in the future.
               
               > **Note:** This property can only be set when `network_plugin` is set to `azure`.
        :param pulumi.Input[str] network_plugin_mode: Specifies the network plugin mode used for building the Kubernetes network. Possible value is `overlay`.
               
               > **Note:** When `network_plugin_mode` is set to `overlay`, the `network_plugin` field can only be set to `azure`. When upgrading from Azure CNI without overlay, `pod_subnet_id` must be specified.
        :param pulumi.Input[str] network_policy: Sets up network policy to be used with Azure CNI. [Network policy allows us to control the traffic flow between pods](https://docs.microsoft.com/azure/aks/use-network-policies). Currently supported values are `calico`, `azure` and `cilium`. Changing this forces a new resource to be created.
               
               > **Note:** When `network_policy` is set to `azure`, the `network_plugin` field can only be set to `azure`.
               
               > **Note:** When `network_policy` is set to `cilium`, the `ebpf_data_plane` field must be set to `cilium`.
        :param pulumi.Input[str] outbound_type: The outbound (egress) routing method which should be used for this Kubernetes Cluster. Possible values are `loadBalancer`, `userDefinedRouting`, `managedNATGateway` and `userAssignedNATGateway`. Defaults to `loadBalancer`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] pod_cidr: The CIDR to use for pod IP addresses. This field can only be set when `network_plugin` is set to `kubenet`. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pod_cidrs: A list of CIDRs to use for pod IP addresses. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.
        :param pulumi.Input[str] service_cidr: The Network Range used by the Kubernetes service. Changing this forces a new resource to be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_cidrs: A list of CIDRs to use for Kubernetes services. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.
               
               > **Note:** This range should not be used by any network element on or connected to this VNet. Service address CIDR must be smaller than /12. `docker_bridge_cidr`, `dns_service_ip` and `service_cidr` should all be empty or all should be set.
        """
        pulumi.set(__self__, "network_plugin", network_plugin)
        if dns_service_ip is not None:
            pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        if docker_bridge_cidr is not None:
            warnings.warn("""`docker_bridge_cidr` has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""", DeprecationWarning)
            pulumi.log.warn("""docker_bridge_cidr is deprecated: `docker_bridge_cidr` has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""")
        if docker_bridge_cidr is not None:
            pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        if ebpf_data_plane is not None:
            pulumi.set(__self__, "ebpf_data_plane", ebpf_data_plane)
        if ip_versions is not None:
            pulumi.set(__self__, "ip_versions", ip_versions)
        if load_balancer_profile is not None:
            pulumi.set(__self__, "load_balancer_profile", load_balancer_profile)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if nat_gateway_profile is not None:
            pulumi.set(__self__, "nat_gateway_profile", nat_gateway_profile)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if network_plugin_mode is not None:
            pulumi.set(__self__, "network_plugin_mode", network_plugin_mode)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_cidrs is not None:
            pulumi.set(__self__, "pod_cidrs", pod_cidrs)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if service_cidrs is not None:
            pulumi.set(__self__, "service_cidrs", service_cidrs)

    @property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> pulumi.Input[str]:
        """
        Network plugin to use for networking. Currently supported values are `azure`, `kubenet` and `none`. Changing this forces a new resource to be created.

        > **Note:** When `network_plugin` is set to `azure` - the `pod_cidr` field must not be set.
        """
        return pulumi.get(self, "network_plugin")

    @network_plugin.setter
    def network_plugin(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_plugin", value)

    @property
    @pulumi.getter(name="dnsServiceIp")
    def dns_service_ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP address within the Kubernetes service address range that will be used by cluster service discovery (kube-dns). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "dns_service_ip")

    @dns_service_ip.setter
    def dns_service_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_service_ip", value)

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        IP address (in CIDR notation) used as the Docker bridge IP address on nodes. Changing this forces a new resource to be created.

        > **Note:** `docker_bridge_cidr` has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
        """
        warnings.warn("""`docker_bridge_cidr` has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""", DeprecationWarning)
        pulumi.log.warn("""docker_bridge_cidr is deprecated: `docker_bridge_cidr` has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.""")

        return pulumi.get(self, "docker_bridge_cidr")

    @docker_bridge_cidr.setter
    def docker_bridge_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_bridge_cidr", value)

    @property
    @pulumi.getter(name="ebpfDataPlane")
    def ebpf_data_plane(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the eBPF data plane used for building the Kubernetes network. Possible value is `cilium`. Disabling this forces a new resource to be created.

        > **Note:** When `ebpf_data_plane` is set to `cilium`, the `network_plugin` field can only be set to `azure`.

        > **Note:** When `ebpf_data_plane` is set to `cilium`, one of either `network_plugin_mode = "overlay"` or `pod_subnet_id` must be specified.

        > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/CiliumDataplanePreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/azure-cni-powered-by-cilium) for more information.
        """
        return pulumi.get(self, "ebpf_data_plane")

    @ebpf_data_plane.setter
    def ebpf_data_plane(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebpf_data_plane", value)

    @property
    @pulumi.getter(name="ipVersions")
    def ip_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of IP versions the Kubernetes Cluster will use to assign IP addresses to its nodes and pods. Possible values are `IPv4` and/or `IPv6`. `IPv4` must always be specified. Changing this forces a new resource to be created.

        ->**Note:** To configure dual-stack networking `ip_versions` should be set to `["IPv4", "IPv6"]`.

        ->**Note:** Dual-stack networking requires that the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` is enabled and the Resource Provider is re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
        """
        return pulumi.get(self, "ip_versions")

    @ip_versions.setter
    def ip_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_versions", value)

    @property
    @pulumi.getter(name="loadBalancerProfile")
    def load_balancer_profile(self) -> Optional[pulumi.Input['KubernetesClusterNetworkProfileLoadBalancerProfileArgs']]:
        """
        A `load_balancer_profile` block as defined below. This can only be specified when `load_balancer_sku` is set to `standard`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "load_balancer_profile")

    @load_balancer_profile.setter
    def load_balancer_profile(self, value: Optional[pulumi.Input['KubernetesClusterNetworkProfileLoadBalancerProfileArgs']]):
        pulumi.set(self, "load_balancer_profile", value)

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the SKU of the Load Balancer used for this Kubernetes Cluster. Possible values are `basic` and `standard`. Defaults to `standard`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "load_balancer_sku")

    @load_balancer_sku.setter
    def load_balancer_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_sku", value)

    @property
    @pulumi.getter(name="natGatewayProfile")
    def nat_gateway_profile(self) -> Optional[pulumi.Input['KubernetesClusterNetworkProfileNatGatewayProfileArgs']]:
        """
        A `nat_gateway_profile` block as defined below. This can only be specified when `load_balancer_sku` is set to `standard` and `outbound_type` is set to `managedNATGateway` or `userAssignedNATGateway`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "nat_gateway_profile")

    @nat_gateway_profile.setter
    def nat_gateway_profile(self, value: Optional[pulumi.Input['KubernetesClusterNetworkProfileNatGatewayProfileArgs']]):
        pulumi.set(self, "nat_gateway_profile", value)

    @property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Network mode to be used with Azure CNI. Possible values are `bridge` and `transparent`. Changing this forces a new resource to be created.

        > **Note:** `network_mode` can only be set to `bridge` for existing Kubernetes Clusters and cannot be used to provision new Clusters - this will be removed by Azure in the future.

        > **Note:** This property can only be set when `network_plugin` is set to `azure`.
        """
        return pulumi.get(self, "network_mode")

    @network_mode.setter
    def network_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_mode", value)

    @property
    @pulumi.getter(name="networkPluginMode")
    def network_plugin_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the network plugin mode used for building the Kubernetes network. Possible value is `overlay`.

        > **Note:** When `network_plugin_mode` is set to `overlay`, the `network_plugin` field can only be set to `azure`. When upgrading from Azure CNI without overlay, `pod_subnet_id` must be specified.
        """
        return pulumi.get(self, "network_plugin_mode")

    @network_plugin_mode.setter
    def network_plugin_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_plugin_mode", value)

    @property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Sets up network policy to be used with Azure CNI. [Network policy allows us to control the traffic flow between pods](https://docs.microsoft.com/azure/aks/use-network-policies). Currently supported values are `calico`, `azure` and `cilium`. Changing this forces a new resource to be created.

        > **Note:** When `network_policy` is set to `azure`, the `network_plugin` field can only be set to `azure`.

        > **Note:** When `network_policy` is set to `cilium`, the `ebpf_data_plane` field must be set to `cilium`.
        """
        return pulumi.get(self, "network_policy")

    @network_policy.setter
    def network_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_policy", value)

    @property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[pulumi.Input[str]]:
        """
        The outbound (egress) routing method which should be used for this Kubernetes Cluster. Possible values are `loadBalancer`, `userDefinedRouting`, `managedNATGateway` and `userAssignedNATGateway`. Defaults to `loadBalancer`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "outbound_type")

    @outbound_type.setter
    def outbound_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outbound_type", value)

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR to use for pod IP addresses. This field can only be set when `network_plugin` is set to `kubenet`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "pod_cidr")

    @pod_cidr.setter
    def pod_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_cidr", value)

    @property
    @pulumi.getter(name="podCidrs")
    def pod_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDRs to use for pod IP addresses. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "pod_cidrs")

    @pod_cidrs.setter
    def pod_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pod_cidrs", value)

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        The Network Range used by the Kubernetes service. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "service_cidr")

    @service_cidr.setter
    def service_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cidr", value)

    @property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDRs to use for Kubernetes services. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.

        > **Note:** This range should not be used by any network element on or connected to this VNet. Service address CIDR must be smaller than /12. `docker_bridge_cidr`, `dns_service_ip` and `service_cidr` should all be empty or all should be set.
        """
        return pulumi.get(self, "service_cidrs")

    @service_cidrs.setter
    def service_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_cidrs", value)


@pulumi.input_type
class KubernetesClusterNetworkProfileLoadBalancerProfileArgs:
    def __init__(__self__, *,
                 effective_outbound_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 managed_outbound_ip_count: Optional[pulumi.Input[int]] = None,
                 managed_outbound_ipv6_count: Optional[pulumi.Input[int]] = None,
                 outbound_ip_address_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 outbound_ip_prefix_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 outbound_ports_allocated: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] effective_outbound_ips: The outcome (resource IDs) of the specified arguments.
        :param pulumi.Input[int] idle_timeout_in_minutes: Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `120` inclusive. Defaults to `30`.
        :param pulumi.Input[int] managed_outbound_ip_count: Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
        :param pulumi.Input[int] managed_outbound_ipv6_count: The desired number of IPv6 outbound IPs created and managed by Azure for the cluster load balancer. Must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.
               
               > **Note:** `managed_outbound_ipv6_count` requires dual-stack networking. To enable dual-stack networking the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` needs to be enabled and the Resource Provider re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] outbound_ip_address_ids: The ID of the Public IP Addresses which should be used for outbound communication for the cluster load balancer.
               
               > **Note:** Set `outbound_ip_address_ids` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outbound_ip_address_ids` will revert the load balancing for the cluster back to a managed one.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] outbound_ip_prefix_ids: The ID of the outbound Public IP Address Prefixes which should be used for the cluster load balancer.
               
               > **Note:** Set `outbound_ip_prefix_ids` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outbound_ip_prefix_ids` will revert the load balancing for the cluster back to a managed one.
        :param pulumi.Input[int] outbound_ports_allocated: Number of desired SNAT port for each VM in the clusters load balancer. Must be between `0` and `64000` inclusive. Defaults to `0`.
        """
        if effective_outbound_ips is not None:
            pulumi.set(__self__, "effective_outbound_ips", effective_outbound_ips)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if managed_outbound_ip_count is not None:
            pulumi.set(__self__, "managed_outbound_ip_count", managed_outbound_ip_count)
        if managed_outbound_ipv6_count is not None:
            pulumi.set(__self__, "managed_outbound_ipv6_count", managed_outbound_ipv6_count)
        if outbound_ip_address_ids is not None:
            pulumi.set(__self__, "outbound_ip_address_ids", outbound_ip_address_ids)
        if outbound_ip_prefix_ids is not None:
            pulumi.set(__self__, "outbound_ip_prefix_ids", outbound_ip_prefix_ids)
        if outbound_ports_allocated is not None:
            pulumi.set(__self__, "outbound_ports_allocated", outbound_ports_allocated)

    @property
    @pulumi.getter(name="effectiveOutboundIps")
    def effective_outbound_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The outcome (resource IDs) of the specified arguments.
        """
        return pulumi.get(self, "effective_outbound_ips")

    @effective_outbound_ips.setter
    def effective_outbound_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "effective_outbound_ips", value)

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `120` inclusive. Defaults to `30`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @idle_timeout_in_minutes.setter
    def idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="managedOutboundIpCount")
    def managed_outbound_ip_count(self) -> Optional[pulumi.Input[int]]:
        """
        Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
        """
        return pulumi.get(self, "managed_outbound_ip_count")

    @managed_outbound_ip_count.setter
    def managed_outbound_ip_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "managed_outbound_ip_count", value)

    @property
    @pulumi.getter(name="managedOutboundIpv6Count")
    def managed_outbound_ipv6_count(self) -> Optional[pulumi.Input[int]]:
        """
        The desired number of IPv6 outbound IPs created and managed by Azure for the cluster load balancer. Must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.

        > **Note:** `managed_outbound_ipv6_count` requires dual-stack networking. To enable dual-stack networking the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` needs to be enabled and the Resource Provider re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
        """
        return pulumi.get(self, "managed_outbound_ipv6_count")

    @managed_outbound_ipv6_count.setter
    def managed_outbound_ipv6_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "managed_outbound_ipv6_count", value)

    @property
    @pulumi.getter(name="outboundIpAddressIds")
    def outbound_ip_address_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the Public IP Addresses which should be used for outbound communication for the cluster load balancer.

        > **Note:** Set `outbound_ip_address_ids` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outbound_ip_address_ids` will revert the load balancing for the cluster back to a managed one.
        """
        return pulumi.get(self, "outbound_ip_address_ids")

    @outbound_ip_address_ids.setter
    def outbound_ip_address_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "outbound_ip_address_ids", value)

    @property
    @pulumi.getter(name="outboundIpPrefixIds")
    def outbound_ip_prefix_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ID of the outbound Public IP Address Prefixes which should be used for the cluster load balancer.

        > **Note:** Set `outbound_ip_prefix_ids` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outbound_ip_prefix_ids` will revert the load balancing for the cluster back to a managed one.
        """
        return pulumi.get(self, "outbound_ip_prefix_ids")

    @outbound_ip_prefix_ids.setter
    def outbound_ip_prefix_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "outbound_ip_prefix_ids", value)

    @property
    @pulumi.getter(name="outboundPortsAllocated")
    def outbound_ports_allocated(self) -> Optional[pulumi.Input[int]]:
        """
        Number of desired SNAT port for each VM in the clusters load balancer. Must be between `0` and `64000` inclusive. Defaults to `0`.
        """
        return pulumi.get(self, "outbound_ports_allocated")

    @outbound_ports_allocated.setter
    def outbound_ports_allocated(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "outbound_ports_allocated", value)


@pulumi.input_type
class KubernetesClusterNetworkProfileNatGatewayProfileArgs:
    def __init__(__self__, *,
                 effective_outbound_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 managed_outbound_ip_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] effective_outbound_ips: The outcome (resource IDs) of the specified arguments.
        :param pulumi.Input[int] idle_timeout_in_minutes: Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `120` inclusive. Defaults to `4`.
        :param pulumi.Input[int] managed_outbound_ip_count: Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
        """
        if effective_outbound_ips is not None:
            pulumi.set(__self__, "effective_outbound_ips", effective_outbound_ips)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if managed_outbound_ip_count is not None:
            pulumi.set(__self__, "managed_outbound_ip_count", managed_outbound_ip_count)

    @property
    @pulumi.getter(name="effectiveOutboundIps")
    def effective_outbound_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The outcome (resource IDs) of the specified arguments.
        """
        return pulumi.get(self, "effective_outbound_ips")

    @effective_outbound_ips.setter
    def effective_outbound_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "effective_outbound_ips", value)

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `120` inclusive. Defaults to `4`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @idle_timeout_in_minutes.setter
    def idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="managedOutboundIpCount")
    def managed_outbound_ip_count(self) -> Optional[pulumi.Input[int]]:
        """
        Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
        """
        return pulumi.get(self, "managed_outbound_ip_count")

    @managed_outbound_ip_count.setter
    def managed_outbound_ip_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "managed_outbound_ip_count", value)


@pulumi.input_type
class KubernetesClusterNodePoolKubeletConfigArgs:
    def __init__(__self__, *,
                 allowed_unsafe_sysctls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 container_log_max_line: Optional[pulumi.Input[int]] = None,
                 container_log_max_size_mb: Optional[pulumi.Input[int]] = None,
                 cpu_cfs_quota_enabled: Optional[pulumi.Input[bool]] = None,
                 cpu_cfs_quota_period: Optional[pulumi.Input[str]] = None,
                 cpu_manager_policy: Optional[pulumi.Input[str]] = None,
                 image_gc_high_threshold: Optional[pulumi.Input[int]] = None,
                 image_gc_low_threshold: Optional[pulumi.Input[int]] = None,
                 pod_max_pid: Optional[pulumi.Input[int]] = None,
                 topology_manager_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_unsafe_sysctls: Specifies the allow list of unsafe sysctls command or patterns (ending in `*`). Changing this forces a new resource to be created.
        :param pulumi.Input[int] container_log_max_line: Specifies the maximum number of container log files that can be present for a container. must be at least 2. Changing this forces a new resource to be created.
        :param pulumi.Input[int] container_log_max_size_mb: Specifies the maximum size (e.g. 10MB) of container log file before it is rotated. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] cpu_cfs_quota_enabled: Is CPU CFS quota enforcement for containers enabled? Changing this forces a new resource to be created.
        :param pulumi.Input[str] cpu_cfs_quota_period: Specifies the CPU CFS quota period value. Changing this forces a new resource to be created.
        :param pulumi.Input[str] cpu_manager_policy: Specifies the CPU Manager policy to use. Possible values are `none` and `static`, Changing this forces a new resource to be created.
        :param pulumi.Input[int] image_gc_high_threshold: Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] image_gc_low_threshold: Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] pod_max_pid: Specifies the maximum number of processes per pod. Changing this forces a new resource to be created.
        :param pulumi.Input[str] topology_manager_policy: Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`. Changing this forces a new resource to be created.
        """
        if allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        if container_log_max_line is not None:
            pulumi.set(__self__, "container_log_max_line", container_log_max_line)
        if container_log_max_size_mb is not None:
            pulumi.set(__self__, "container_log_max_size_mb", container_log_max_size_mb)
        if cpu_cfs_quota_enabled is not None:
            pulumi.set(__self__, "cpu_cfs_quota_enabled", cpu_cfs_quota_enabled)
        if cpu_cfs_quota_period is not None:
            pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if image_gc_high_threshold is not None:
            pulumi.set(__self__, "image_gc_high_threshold", image_gc_high_threshold)
        if image_gc_low_threshold is not None:
            pulumi.set(__self__, "image_gc_low_threshold", image_gc_low_threshold)
        if pod_max_pid is not None:
            pulumi.set(__self__, "pod_max_pid", pod_max_pid)
        if topology_manager_policy is not None:
            pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)

    @property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the allow list of unsafe sysctls command or patterns (ending in `*`). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @allowed_unsafe_sysctls.setter
    def allowed_unsafe_sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_unsafe_sysctls", value)

    @property
    @pulumi.getter(name="containerLogMaxLine")
    def container_log_max_line(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum number of container log files that can be present for a container. must be at least 2. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "container_log_max_line")

    @container_log_max_line.setter
    def container_log_max_line(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_log_max_line", value)

    @property
    @pulumi.getter(name="containerLogMaxSizeMb")
    def container_log_max_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum size (e.g. 10MB) of container log file before it is rotated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "container_log_max_size_mb")

    @container_log_max_size_mb.setter
    def container_log_max_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_log_max_size_mb", value)

    @property
    @pulumi.getter(name="cpuCfsQuotaEnabled")
    def cpu_cfs_quota_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is CPU CFS quota enforcement for containers enabled? Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cpu_cfs_quota_enabled")

    @cpu_cfs_quota_enabled.setter
    def cpu_cfs_quota_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cpu_cfs_quota_enabled", value)

    @property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the CPU CFS quota period value. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cpu_cfs_quota_period")

    @cpu_cfs_quota_period.setter
    def cpu_cfs_quota_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_cfs_quota_period", value)

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the CPU Manager policy to use. Possible values are `none` and `static`, Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cpu_manager_policy")

    @cpu_manager_policy.setter
    def cpu_manager_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_manager_policy", value)

    @property
    @pulumi.getter(name="imageGcHighThreshold")
    def image_gc_high_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_gc_high_threshold")

    @image_gc_high_threshold.setter
    def image_gc_high_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "image_gc_high_threshold", value)

    @property
    @pulumi.getter(name="imageGcLowThreshold")
    def image_gc_low_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_gc_low_threshold")

    @image_gc_low_threshold.setter
    def image_gc_low_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "image_gc_low_threshold", value)

    @property
    @pulumi.getter(name="podMaxPid")
    def pod_max_pid(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum number of processes per pod. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "pod_max_pid")

    @pod_max_pid.setter
    def pod_max_pid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pod_max_pid", value)

    @property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "topology_manager_policy")

    @topology_manager_policy.setter
    def topology_manager_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_manager_policy", value)


@pulumi.input_type
class KubernetesClusterNodePoolLinuxOsConfigArgs:
    def __init__(__self__, *,
                 swap_file_size_mb: Optional[pulumi.Input[int]] = None,
                 sysctl_config: Optional[pulumi.Input['KubernetesClusterNodePoolLinuxOsConfigSysctlConfigArgs']] = None,
                 transparent_huge_page_defrag: Optional[pulumi.Input[str]] = None,
                 transparent_huge_page_enabled: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] swap_file_size_mb: Specifies the size of swap file on each node in MB. Changing this forces a new resource to be created.
        :param pulumi.Input['KubernetesClusterNodePoolLinuxOsConfigSysctlConfigArgs'] sysctl_config: A `sysctl_config` block as defined below. Changing this forces a new resource to be created.
        :param pulumi.Input[str] transparent_huge_page_defrag: specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] transparent_huge_page_enabled: Specifies the Transparent Huge Page enabled configuration. Possible values are `always`, `madvise` and `never`. Changing this forces a new resource to be created.
        """
        if swap_file_size_mb is not None:
            pulumi.set(__self__, "swap_file_size_mb", swap_file_size_mb)
        if sysctl_config is not None:
            pulumi.set(__self__, "sysctl_config", sysctl_config)
        if transparent_huge_page_defrag is not None:
            pulumi.set(__self__, "transparent_huge_page_defrag", transparent_huge_page_defrag)
        if transparent_huge_page_enabled is not None:
            pulumi.set(__self__, "transparent_huge_page_enabled", transparent_huge_page_enabled)

    @property
    @pulumi.getter(name="swapFileSizeMb")
    def swap_file_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the size of swap file on each node in MB. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "swap_file_size_mb")

    @swap_file_size_mb.setter
    def swap_file_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "swap_file_size_mb", value)

    @property
    @pulumi.getter(name="sysctlConfig")
    def sysctl_config(self) -> Optional[pulumi.Input['KubernetesClusterNodePoolLinuxOsConfigSysctlConfigArgs']]:
        """
        A `sysctl_config` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sysctl_config")

    @sysctl_config.setter
    def sysctl_config(self, value: Optional[pulumi.Input['KubernetesClusterNodePoolLinuxOsConfigSysctlConfigArgs']]):
        pulumi.set(self, "sysctl_config", value)

    @property
    @pulumi.getter(name="transparentHugePageDefrag")
    def transparent_huge_page_defrag(self) -> Optional[pulumi.Input[str]]:
        """
        specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "transparent_huge_page_defrag")

    @transparent_huge_page_defrag.setter
    def transparent_huge_page_defrag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transparent_huge_page_defrag", value)

    @property
    @pulumi.getter(name="transparentHugePageEnabled")
    def transparent_huge_page_enabled(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Transparent Huge Page enabled configuration. Possible values are `always`, `madvise` and `never`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "transparent_huge_page_enabled")

    @transparent_huge_page_enabled.setter
    def transparent_huge_page_enabled(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transparent_huge_page_enabled", value)


@pulumi.input_type
class KubernetesClusterNodePoolLinuxOsConfigSysctlConfigArgs:
    def __init__(__self__, *,
                 fs_aio_max_nr: Optional[pulumi.Input[int]] = None,
                 fs_file_max: Optional[pulumi.Input[int]] = None,
                 fs_inotify_max_user_watches: Optional[pulumi.Input[int]] = None,
                 fs_nr_open: Optional[pulumi.Input[int]] = None,
                 kernel_threads_max: Optional[pulumi.Input[int]] = None,
                 net_core_netdev_max_backlog: Optional[pulumi.Input[int]] = None,
                 net_core_optmem_max: Optional[pulumi.Input[int]] = None,
                 net_core_rmem_default: Optional[pulumi.Input[int]] = None,
                 net_core_rmem_max: Optional[pulumi.Input[int]] = None,
                 net_core_somaxconn: Optional[pulumi.Input[int]] = None,
                 net_core_wmem_default: Optional[pulumi.Input[int]] = None,
                 net_core_wmem_max: Optional[pulumi.Input[int]] = None,
                 net_ipv4_ip_local_port_range_max: Optional[pulumi.Input[int]] = None,
                 net_ipv4_ip_local_port_range_min: Optional[pulumi.Input[int]] = None,
                 net_ipv4_neigh_default_gc_thresh1: Optional[pulumi.Input[int]] = None,
                 net_ipv4_neigh_default_gc_thresh2: Optional[pulumi.Input[int]] = None,
                 net_ipv4_neigh_default_gc_thresh3: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_fin_timeout: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_keepalive_intvl: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_keepalive_probes: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_keepalive_time: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_max_syn_backlog: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_max_tw_buckets: Optional[pulumi.Input[int]] = None,
                 net_ipv4_tcp_tw_reuse: Optional[pulumi.Input[bool]] = None,
                 net_netfilter_nf_conntrack_buckets: Optional[pulumi.Input[int]] = None,
                 net_netfilter_nf_conntrack_max: Optional[pulumi.Input[int]] = None,
                 vm_max_map_count: Optional[pulumi.Input[int]] = None,
                 vm_swappiness: Optional[pulumi.Input[int]] = None,
                 vm_vfs_cache_pressure: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] fs_aio_max_nr: The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] fs_file_max: The sysctl setting fs.file-max. Must be between `8192` and `12000500`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] fs_inotify_max_user_watches: The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] fs_nr_open: The sysctl setting fs.nr_open. Must be between `8192` and `20000500`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] kernel_threads_max: The sysctl setting kernel.threads-max. Must be between `20` and `513785`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_netdev_max_backlog: The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_optmem_max: The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_rmem_default: The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_rmem_max: The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_somaxconn: The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_wmem_default: The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_core_wmem_max: The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_ip_local_port_range_max: The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_ip_local_port_range_min: The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_neigh_default_gc_thresh1: The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_neigh_default_gc_thresh2: The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_neigh_default_gc_thresh3: The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_fin_timeout: The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_keepalive_intvl: The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_keepalive_probes: The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_keepalive_time: The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_max_syn_backlog: The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_ipv4_tcp_max_tw_buckets: The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] net_ipv4_tcp_tw_reuse: Is sysctl setting net.ipv4.tcp_tw_reuse enabled? Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_netfilter_nf_conntrack_buckets: The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] net_netfilter_nf_conntrack_max: The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] vm_max_map_count: The sysctl setting vm.max_map_count. Must be between `65530` and `262144`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] vm_swappiness: The sysctl setting vm.swappiness. Must be between `0` and `100`. Changing this forces a new resource to be created.
        :param pulumi.Input[int] vm_vfs_cache_pressure: The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        if fs_aio_max_nr is not None:
            pulumi.set(__self__, "fs_aio_max_nr", fs_aio_max_nr)
        if fs_file_max is not None:
            pulumi.set(__self__, "fs_file_max", fs_file_max)
        if fs_inotify_max_user_watches is not None:
            pulumi.set(__self__, "fs_inotify_max_user_watches", fs_inotify_max_user_watches)
        if fs_nr_open is not None:
            pulumi.set(__self__, "fs_nr_open", fs_nr_open)
        if kernel_threads_max is not None:
            pulumi.set(__self__, "kernel_threads_max", kernel_threads_max)
        if net_core_netdev_max_backlog is not None:
            pulumi.set(__self__, "net_core_netdev_max_backlog", net_core_netdev_max_backlog)
        if net_core_optmem_max is not None:
            pulumi.set(__self__, "net_core_optmem_max", net_core_optmem_max)
        if net_core_rmem_default is not None:
            pulumi.set(__self__, "net_core_rmem_default", net_core_rmem_default)
        if net_core_rmem_max is not None:
            pulumi.set(__self__, "net_core_rmem_max", net_core_rmem_max)
        if net_core_somaxconn is not None:
            pulumi.set(__self__, "net_core_somaxconn", net_core_somaxconn)
        if net_core_wmem_default is not None:
            pulumi.set(__self__, "net_core_wmem_default", net_core_wmem_default)
        if net_core_wmem_max is not None:
            pulumi.set(__self__, "net_core_wmem_max", net_core_wmem_max)
        if net_ipv4_ip_local_port_range_max is not None:
            pulumi.set(__self__, "net_ipv4_ip_local_port_range_max", net_ipv4_ip_local_port_range_max)
        if net_ipv4_ip_local_port_range_min is not None:
            pulumi.set(__self__, "net_ipv4_ip_local_port_range_min", net_ipv4_ip_local_port_range_min)
        if net_ipv4_neigh_default_gc_thresh1 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh1", net_ipv4_neigh_default_gc_thresh1)
        if net_ipv4_neigh_default_gc_thresh2 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh2", net_ipv4_neigh_default_gc_thresh2)
        if net_ipv4_neigh_default_gc_thresh3 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh3", net_ipv4_neigh_default_gc_thresh3)
        if net_ipv4_tcp_fin_timeout is not None:
            pulumi.set(__self__, "net_ipv4_tcp_fin_timeout", net_ipv4_tcp_fin_timeout)
        if net_ipv4_tcp_keepalive_intvl is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_intvl", net_ipv4_tcp_keepalive_intvl)
        if net_ipv4_tcp_keepalive_probes is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_probes", net_ipv4_tcp_keepalive_probes)
        if net_ipv4_tcp_keepalive_time is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_time", net_ipv4_tcp_keepalive_time)
        if net_ipv4_tcp_max_syn_backlog is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_syn_backlog", net_ipv4_tcp_max_syn_backlog)
        if net_ipv4_tcp_max_tw_buckets is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_tw_buckets", net_ipv4_tcp_max_tw_buckets)
        if net_ipv4_tcp_tw_reuse is not None:
            pulumi.set(__self__, "net_ipv4_tcp_tw_reuse", net_ipv4_tcp_tw_reuse)
        if net_netfilter_nf_conntrack_buckets is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_buckets", net_netfilter_nf_conntrack_buckets)
        if net_netfilter_nf_conntrack_max is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_max", net_netfilter_nf_conntrack_max)
        if vm_max_map_count is not None:
            pulumi.set(__self__, "vm_max_map_count", vm_max_map_count)
        if vm_swappiness is not None:
            pulumi.set(__self__, "vm_swappiness", vm_swappiness)
        if vm_vfs_cache_pressure is not None:
            pulumi.set(__self__, "vm_vfs_cache_pressure", vm_vfs_cache_pressure)

    @property
    @pulumi.getter(name="fsAioMaxNr")
    def fs_aio_max_nr(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fs_aio_max_nr")

    @fs_aio_max_nr.setter
    def fs_aio_max_nr(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_aio_max_nr", value)

    @property
    @pulumi.getter(name="fsFileMax")
    def fs_file_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting fs.file-max. Must be between `8192` and `12000500`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fs_file_max")

    @fs_file_max.setter
    def fs_file_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_file_max", value)

    @property
    @pulumi.getter(name="fsInotifyMaxUserWatches")
    def fs_inotify_max_user_watches(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fs_inotify_max_user_watches")

    @fs_inotify_max_user_watches.setter
    def fs_inotify_max_user_watches(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_inotify_max_user_watches", value)

    @property
    @pulumi.getter(name="fsNrOpen")
    def fs_nr_open(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting fs.nr_open. Must be between `8192` and `20000500`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "fs_nr_open")

    @fs_nr_open.setter
    def fs_nr_open(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_nr_open", value)

    @property
    @pulumi.getter(name="kernelThreadsMax")
    def kernel_threads_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting kernel.threads-max. Must be between `20` and `513785`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "kernel_threads_max")

    @kernel_threads_max.setter
    def kernel_threads_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "kernel_threads_max", value)

    @property
    @pulumi.getter(name="netCoreNetdevMaxBacklog")
    def net_core_netdev_max_backlog(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_netdev_max_backlog")

    @net_core_netdev_max_backlog.setter
    def net_core_netdev_max_backlog(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_netdev_max_backlog", value)

    @property
    @pulumi.getter(name="netCoreOptmemMax")
    def net_core_optmem_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_optmem_max")

    @net_core_optmem_max.setter
    def net_core_optmem_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_optmem_max", value)

    @property
    @pulumi.getter(name="netCoreRmemDefault")
    def net_core_rmem_default(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_rmem_default")

    @net_core_rmem_default.setter
    def net_core_rmem_default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_rmem_default", value)

    @property
    @pulumi.getter(name="netCoreRmemMax")
    def net_core_rmem_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_rmem_max")

    @net_core_rmem_max.setter
    def net_core_rmem_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_rmem_max", value)

    @property
    @pulumi.getter(name="netCoreSomaxconn")
    def net_core_somaxconn(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_somaxconn")

    @net_core_somaxconn.setter
    def net_core_somaxconn(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_somaxconn", value)

    @property
    @pulumi.getter(name="netCoreWmemDefault")
    def net_core_wmem_default(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_wmem_default")

    @net_core_wmem_default.setter
    def net_core_wmem_default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_wmem_default", value)

    @property
    @pulumi.getter(name="netCoreWmemMax")
    def net_core_wmem_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_core_wmem_max")

    @net_core_wmem_max.setter
    def net_core_wmem_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_core_wmem_max", value)

    @property
    @pulumi.getter(name="netIpv4IpLocalPortRangeMax")
    def net_ipv4_ip_local_port_range_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_ip_local_port_range_max")

    @net_ipv4_ip_local_port_range_max.setter
    def net_ipv4_ip_local_port_range_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_ip_local_port_range_max", value)

    @property
    @pulumi.getter(name="netIpv4IpLocalPortRangeMin")
    def net_ipv4_ip_local_port_range_min(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_ip_local_port_range_min")

    @net_ipv4_ip_local_port_range_min.setter
    def net_ipv4_ip_local_port_range_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_ip_local_port_range_min", value)

    @property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh1")
    def net_ipv4_neigh_default_gc_thresh1(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh1")

    @net_ipv4_neigh_default_gc_thresh1.setter
    def net_ipv4_neigh_default_gc_thresh1(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_neigh_default_gc_thresh1", value)

    @property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh2")
    def net_ipv4_neigh_default_gc_thresh2(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh2")

    @net_ipv4_neigh_default_gc_thresh2.setter
    def net_ipv4_neigh_default_gc_thresh2(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_neigh_default_gc_thresh2", value)

    @property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh3")
    def net_ipv4_neigh_default_gc_thresh3(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh3")

    @net_ipv4_neigh_default_gc_thresh3.setter
    def net_ipv4_neigh_default_gc_thresh3(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_neigh_default_gc_thresh3", value)

    @property
    @pulumi.getter(name="netIpv4TcpFinTimeout")
    def net_ipv4_tcp_fin_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_fin_timeout")

    @net_ipv4_tcp_fin_timeout.setter
    def net_ipv4_tcp_fin_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_fin_timeout", value)

    @property
    @pulumi.getter(name="netIpv4TcpKeepaliveIntvl")
    def net_ipv4_tcp_keepalive_intvl(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_intvl")

    @net_ipv4_tcp_keepalive_intvl.setter
    def net_ipv4_tcp_keepalive_intvl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_keepalive_intvl", value)

    @property
    @pulumi.getter(name="netIpv4TcpKeepaliveProbes")
    def net_ipv4_tcp_keepalive_probes(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_probes")

    @net_ipv4_tcp_keepalive_probes.setter
    def net_ipv4_tcp_keepalive_probes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_keepalive_probes", value)

    @property
    @pulumi.getter(name="netIpv4TcpKeepaliveTime")
    def net_ipv4_tcp_keepalive_time(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_time")

    @net_ipv4_tcp_keepalive_time.setter
    def net_ipv4_tcp_keepalive_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_keepalive_time", value)

    @property
    @pulumi.getter(name="netIpv4TcpMaxSynBacklog")
    def net_ipv4_tcp_max_syn_backlog(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_syn_backlog")

    @net_ipv4_tcp_max_syn_backlog.setter
    def net_ipv4_tcp_max_syn_backlog(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_max_syn_backlog", value)

    @property
    @pulumi.getter(name="netIpv4TcpMaxTwBuckets")
    def net_ipv4_tcp_max_tw_buckets(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_tw_buckets")

    @net_ipv4_tcp_max_tw_buckets.setter
    def net_ipv4_tcp_max_tw_buckets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_ipv4_tcp_max_tw_buckets", value)

    @property
    @pulumi.getter(name="netIpv4TcpTwReuse")
    def net_ipv4_tcp_tw_reuse(self) -> Optional[pulumi.Input[bool]]:
        """
        Is sysctl setting net.ipv4.tcp_tw_reuse enabled? Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_ipv4_tcp_tw_reuse")

    @net_ipv4_tcp_tw_reuse.setter
    def net_ipv4_tcp_tw_reuse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "net_ipv4_tcp_tw_reuse", value)

    @property
    @pulumi.getter(name="netNetfilterNfConntrackBuckets")
    def net_netfilter_nf_conntrack_buckets(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_buckets")

    @net_netfilter_nf_conntrack_buckets.setter
    def net_netfilter_nf_conntrack_buckets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_netfilter_nf_conntrack_buckets", value)

    @property
    @pulumi.getter(name="netNetfilterNfConntrackMax")
    def net_netfilter_nf_conntrack_max(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_max")

    @net_netfilter_nf_conntrack_max.setter
    def net_netfilter_nf_conntrack_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_netfilter_nf_conntrack_max", value)

    @property
    @pulumi.getter(name="vmMaxMapCount")
    def vm_max_map_count(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting vm.max_map_count. Must be between `65530` and `262144`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_max_map_count")

    @vm_max_map_count.setter
    def vm_max_map_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vm_max_map_count", value)

    @property
    @pulumi.getter(name="vmSwappiness")
    def vm_swappiness(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting vm.swappiness. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_swappiness")

    @vm_swappiness.setter
    def vm_swappiness(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vm_swappiness", value)

    @property
    @pulumi.getter(name="vmVfsCachePressure")
    def vm_vfs_cache_pressure(self) -> Optional[pulumi.Input[int]]:
        """
        The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vm_vfs_cache_pressure")

    @vm_vfs_cache_pressure.setter
    def vm_vfs_cache_pressure(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vm_vfs_cache_pressure", value)


@pulumi.input_type
class KubernetesClusterNodePoolNodeNetworkProfileArgs:
    def __init__(__self__, *,
                 node_public_ip_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_public_ip_tags: Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.
               
               > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/NodePublicIPTagsPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/azure/aks/use-node-public-ips#use-public-ip-tags-on-node-public-ips-preview) for more information.
        """
        if node_public_ip_tags is not None:
            pulumi.set(__self__, "node_public_ip_tags", node_public_ip_tags)

    @property
    @pulumi.getter(name="nodePublicIpTags")
    def node_public_ip_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.

        > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/NodePublicIPTagsPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/azure/aks/use-node-public-ips#use-public-ip-tags-on-node-public-ips-preview) for more information.
        """
        return pulumi.get(self, "node_public_ip_tags")

    @node_public_ip_tags.setter
    def node_public_ip_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_public_ip_tags", value)


@pulumi.input_type
class KubernetesClusterNodePoolUpgradeSettingsArgs:
    def __init__(__self__, *,
                 max_surge: pulumi.Input[str]):
        """
        :param pulumi.Input[str] max_surge: The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        pulumi.set(__self__, "max_surge", max_surge)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> pulumi.Input[str]:
        """
        The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: pulumi.Input[str]):
        pulumi.set(self, "max_surge", value)


@pulumi.input_type
class KubernetesClusterNodePoolWindowsProfileArgs:
    def __init__(__self__, *,
                 outbound_nat_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] outbound_nat_enabled: Should the Windows nodes in this Node Pool have outbound NAT enabled? Defaults to `true`. Changing this forces a new resource to be created.
               
               > **Note:** If a percentage is provided, the number of surge nodes is calculated from the current node count on the cluster. Node surge can allow a cluster to have more nodes than `max_count` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
        """
        if outbound_nat_enabled is not None:
            pulumi.set(__self__, "outbound_nat_enabled", outbound_nat_enabled)

    @property
    @pulumi.getter(name="outboundNatEnabled")
    def outbound_nat_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows nodes in this Node Pool have outbound NAT enabled? Defaults to `true`. Changing this forces a new resource to be created.

        > **Note:** If a percentage is provided, the number of surge nodes is calculated from the current node count on the cluster. Node surge can allow a cluster to have more nodes than `max_count` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
        """
        return pulumi.get(self, "outbound_nat_enabled")

    @outbound_nat_enabled.setter
    def outbound_nat_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "outbound_nat_enabled", value)


@pulumi.input_type
class KubernetesClusterOmsAgentArgs:
    def __init__(__self__, *,
                 log_analytics_workspace_id: pulumi.Input[str],
                 msi_auth_for_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 oms_agent_identities: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterOmsAgentOmsAgentIdentityArgs']]]] = None):
        """
        :param pulumi.Input[str] log_analytics_workspace_id: The ID of the Log Analytics Workspace which the OMS Agent should send data to.
        :param pulumi.Input[bool] msi_auth_for_monitoring_enabled: Is managed identity authentication for monitoring enabled?
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterOmsAgentOmsAgentIdentityArgs']]] oms_agent_identities: An `oms_agent_identity` block is exported. The exported attributes are defined below.
        """
        pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)
        if msi_auth_for_monitoring_enabled is not None:
            pulumi.set(__self__, "msi_auth_for_monitoring_enabled", msi_auth_for_monitoring_enabled)
        if oms_agent_identities is not None:
            pulumi.set(__self__, "oms_agent_identities", oms_agent_identities)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> pulumi.Input[str]:
        """
        The ID of the Log Analytics Workspace which the OMS Agent should send data to.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_analytics_workspace_id", value)

    @property
    @pulumi.getter(name="msiAuthForMonitoringEnabled")
    def msi_auth_for_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is managed identity authentication for monitoring enabled?
        """
        return pulumi.get(self, "msi_auth_for_monitoring_enabled")

    @msi_auth_for_monitoring_enabled.setter
    def msi_auth_for_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "msi_auth_for_monitoring_enabled", value)

    @property
    @pulumi.getter(name="omsAgentIdentities")
    def oms_agent_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterOmsAgentOmsAgentIdentityArgs']]]]:
        """
        An `oms_agent_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "oms_agent_identities")

    @oms_agent_identities.setter
    def oms_agent_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterOmsAgentOmsAgentIdentityArgs']]]]):
        pulumi.set(self, "oms_agent_identities", value)


@pulumi.input_type
class KubernetesClusterOmsAgentOmsAgentIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 user_assigned_identity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
               
               > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.

        > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        return pulumi.get(self, "user_assigned_identity_id")

    @user_assigned_identity_id.setter
    def user_assigned_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity_id", value)


@pulumi.input_type
class KubernetesClusterServiceMeshProfileArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 external_ingress_gateway_enabled: Optional[pulumi.Input[bool]] = None,
                 internal_ingress_gateway_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] mode: The mode of the service mesh. Possible value is `Istio`.
        :param pulumi.Input[bool] external_ingress_gateway_enabled: Is Istio External Ingress Gateway enabled?
               
               > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/AzureServiceMeshPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/istio-deploy-addon#register-the-azureservicemeshpreview-feature-flag) for more information.
               
               > **NOTE:** Currently only one Internal Ingress Gateway and one External Ingress Gateway are allowed per cluster
        :param pulumi.Input[bool] internal_ingress_gateway_enabled: Is Istio Internal Ingress Gateway enabled?
        """
        pulumi.set(__self__, "mode", mode)
        if external_ingress_gateway_enabled is not None:
            pulumi.set(__self__, "external_ingress_gateway_enabled", external_ingress_gateway_enabled)
        if internal_ingress_gateway_enabled is not None:
            pulumi.set(__self__, "internal_ingress_gateway_enabled", internal_ingress_gateway_enabled)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        The mode of the service mesh. Possible value is `Istio`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="externalIngressGatewayEnabled")
    def external_ingress_gateway_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Istio External Ingress Gateway enabled?

        > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/AzureServiceMeshPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/istio-deploy-addon#register-the-azureservicemeshpreview-feature-flag) for more information.

        > **NOTE:** Currently only one Internal Ingress Gateway and one External Ingress Gateway are allowed per cluster
        """
        return pulumi.get(self, "external_ingress_gateway_enabled")

    @external_ingress_gateway_enabled.setter
    def external_ingress_gateway_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "external_ingress_gateway_enabled", value)

    @property
    @pulumi.getter(name="internalIngressGatewayEnabled")
    def internal_ingress_gateway_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Istio Internal Ingress Gateway enabled?
        """
        return pulumi.get(self, "internal_ingress_gateway_enabled")

    @internal_ingress_gateway_enabled.setter
    def internal_ingress_gateway_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "internal_ingress_gateway_enabled", value)


@pulumi.input_type
class KubernetesClusterServicePrincipalArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID for the Service Principal.
        :param pulumi.Input[str] client_secret: The Client Secret for the Service Principal.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID for the Service Principal.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret for the Service Principal.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class KubernetesClusterStorageProfileArgs:
    def __init__(__self__, *,
                 blob_driver_enabled: Optional[pulumi.Input[bool]] = None,
                 disk_driver_enabled: Optional[pulumi.Input[bool]] = None,
                 disk_driver_version: Optional[pulumi.Input[str]] = None,
                 file_driver_enabled: Optional[pulumi.Input[bool]] = None,
                 snapshot_controller_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] blob_driver_enabled: Is the Blob CSI driver enabled? Defaults to `false`.
        :param pulumi.Input[bool] disk_driver_enabled: Is the Disk CSI driver enabled? Defaults to `true`.
        :param pulumi.Input[str] disk_driver_version: Disk CSI Driver version to be used. Possible values are `v1` and `v2`. Defaults to `v1`.
               
               > **Note:** `Azure Disk CSI driver v2` is currently in [Public Preview](https://azure.microsoft.com/en-us/updates/public-preview-azure-disk-csi-driver-v2-in-aks/) on an opt-in basis. To use it, the feature `EnableAzureDiskCSIDriverV2` for namespace `Microsoft.ContainerService` must be requested.
        :param pulumi.Input[bool] file_driver_enabled: Is the File CSI driver enabled? Defaults to `true`.
        :param pulumi.Input[bool] snapshot_controller_enabled: Is the Snapshot Controller enabled? Defaults to `true`.
        """
        if blob_driver_enabled is not None:
            pulumi.set(__self__, "blob_driver_enabled", blob_driver_enabled)
        if disk_driver_enabled is not None:
            pulumi.set(__self__, "disk_driver_enabled", disk_driver_enabled)
        if disk_driver_version is not None:
            pulumi.set(__self__, "disk_driver_version", disk_driver_version)
        if file_driver_enabled is not None:
            pulumi.set(__self__, "file_driver_enabled", file_driver_enabled)
        if snapshot_controller_enabled is not None:
            pulumi.set(__self__, "snapshot_controller_enabled", snapshot_controller_enabled)

    @property
    @pulumi.getter(name="blobDriverEnabled")
    def blob_driver_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the Blob CSI driver enabled? Defaults to `false`.
        """
        return pulumi.get(self, "blob_driver_enabled")

    @blob_driver_enabled.setter
    def blob_driver_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "blob_driver_enabled", value)

    @property
    @pulumi.getter(name="diskDriverEnabled")
    def disk_driver_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the Disk CSI driver enabled? Defaults to `true`.
        """
        return pulumi.get(self, "disk_driver_enabled")

    @disk_driver_enabled.setter
    def disk_driver_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disk_driver_enabled", value)

    @property
    @pulumi.getter(name="diskDriverVersion")
    def disk_driver_version(self) -> Optional[pulumi.Input[str]]:
        """
        Disk CSI Driver version to be used. Possible values are `v1` and `v2`. Defaults to `v1`.

        > **Note:** `Azure Disk CSI driver v2` is currently in [Public Preview](https://azure.microsoft.com/en-us/updates/public-preview-azure-disk-csi-driver-v2-in-aks/) on an opt-in basis. To use it, the feature `EnableAzureDiskCSIDriverV2` for namespace `Microsoft.ContainerService` must be requested.
        """
        return pulumi.get(self, "disk_driver_version")

    @disk_driver_version.setter
    def disk_driver_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_driver_version", value)

    @property
    @pulumi.getter(name="fileDriverEnabled")
    def file_driver_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the File CSI driver enabled? Defaults to `true`.
        """
        return pulumi.get(self, "file_driver_enabled")

    @file_driver_enabled.setter
    def file_driver_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "file_driver_enabled", value)

    @property
    @pulumi.getter(name="snapshotControllerEnabled")
    def snapshot_controller_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the Snapshot Controller enabled? Defaults to `true`.
        """
        return pulumi.get(self, "snapshot_controller_enabled")

    @snapshot_controller_enabled.setter
    def snapshot_controller_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "snapshot_controller_enabled", value)


@pulumi.input_type
class KubernetesClusterWebAppRoutingArgs:
    def __init__(__self__, *,
                 dns_zone_id: pulumi.Input[str],
                 web_app_routing_identities: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterWebAppRoutingWebAppRoutingIdentityArgs']]]] = None):
        """
        :param pulumi.Input[str] dns_zone_id: Specifies the ID of the DNS Zone in which DNS entries are created for applications deployed to the cluster when Web App Routing is enabled. For Bring-Your-Own DNS zones this property should be set to an empty string `""`.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterWebAppRoutingWebAppRoutingIdentityArgs']]] web_app_routing_identities: A `web_app_routing_identity` block is exported. The exported attributes are defined below.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if web_app_routing_identities is not None:
            pulumi.set(__self__, "web_app_routing_identities", web_app_routing_identities)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> pulumi.Input[str]:
        """
        Specifies the ID of the DNS Zone in which DNS entries are created for applications deployed to the cluster when Web App Routing is enabled. For Bring-Your-Own DNS zones this property should be set to an empty string `""`.
        """
        return pulumi.get(self, "dns_zone_id")

    @dns_zone_id.setter
    def dns_zone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dns_zone_id", value)

    @property
    @pulumi.getter(name="webAppRoutingIdentities")
    def web_app_routing_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterWebAppRoutingWebAppRoutingIdentityArgs']]]]:
        """
        A `web_app_routing_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "web_app_routing_identities")

    @web_app_routing_identities.setter
    def web_app_routing_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterWebAppRoutingWebAppRoutingIdentityArgs']]]]):
        pulumi.set(self, "web_app_routing_identities", value)


@pulumi.input_type
class KubernetesClusterWebAppRoutingWebAppRoutingIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 user_assigned_identity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param pulumi.Input[str] user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
               
               > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.

        > **Note:** When `kubelet_identity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identity_ids` must be set.
        """
        return pulumi.get(self, "user_assigned_identity_id")

    @user_assigned_identity_id.setter
    def user_assigned_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity_id", value)


@pulumi.input_type
class KubernetesClusterWindowsProfileArgs:
    def __init__(__self__, *,
                 admin_username: pulumi.Input[str],
                 admin_password: Optional[pulumi.Input[str]] = None,
                 gmsa: Optional[pulumi.Input['KubernetesClusterWindowsProfileGmsaArgs']] = None,
                 license: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_username: The Admin Username for Windows VMs. Changing this forces a new resource to be created.
        :param pulumi.Input[str] admin_password: The Admin Password for Windows VMs. Length must be between 14 and 123 characters.
        :param pulumi.Input['KubernetesClusterWindowsProfileGmsaArgs'] gmsa: A `gmsa` block as defined below.
        :param pulumi.Input[str] license: Specifies the type of on-premise license which should be used for Node Pool Windows Virtual Machine. At this time the only possible value is `Windows_Server`.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if gmsa is not None:
            pulumi.set(__self__, "gmsa", gmsa)
        if license is not None:
            pulumi.set(__self__, "license", license)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        The Admin Username for Windows VMs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        The Admin Password for Windows VMs. Length must be between 14 and 123 characters.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter
    def gmsa(self) -> Optional[pulumi.Input['KubernetesClusterWindowsProfileGmsaArgs']]:
        """
        A `gmsa` block as defined below.
        """
        return pulumi.get(self, "gmsa")

    @gmsa.setter
    def gmsa(self, value: Optional[pulumi.Input['KubernetesClusterWindowsProfileGmsaArgs']]):
        pulumi.set(self, "gmsa", value)

    @property
    @pulumi.getter
    def license(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of on-premise license which should be used for Node Pool Windows Virtual Machine. At this time the only possible value is `Windows_Server`.
        """
        return pulumi.get(self, "license")

    @license.setter
    def license(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license", value)


@pulumi.input_type
class KubernetesClusterWindowsProfileGmsaArgs:
    def __init__(__self__, *,
                 dns_server: pulumi.Input[str],
                 root_domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dns_server: Specifies the DNS server for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.
        :param pulumi.Input[str] root_domain: Specifies the root domain name for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.
               
               > **Note:** The properties `dns_server` and `root_domain` must both either be set or unset, i.e. empty.
        """
        pulumi.set(__self__, "dns_server", dns_server)
        pulumi.set(__self__, "root_domain", root_domain)

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> pulumi.Input[str]:
        """
        Specifies the DNS server for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.
        """
        return pulumi.get(self, "dns_server")

    @dns_server.setter
    def dns_server(self, value: pulumi.Input[str]):
        pulumi.set(self, "dns_server", value)

    @property
    @pulumi.getter(name="rootDomain")
    def root_domain(self) -> pulumi.Input[str]:
        """
        Specifies the root domain name for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.

        > **Note:** The properties `dns_server` and `root_domain` must both either be set or unset, i.e. empty.
        """
        return pulumi.get(self, "root_domain")

    @root_domain.setter
    def root_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "root_domain", value)


@pulumi.input_type
class KubernetesClusterWorkloadAutoscalerProfileArgs:
    def __init__(__self__, *,
                 keda_enabled: Optional[pulumi.Input[bool]] = None,
                 vertical_pod_autoscaler_controlled_values: Optional[pulumi.Input[str]] = None,
                 vertical_pod_autoscaler_enabled: Optional[pulumi.Input[bool]] = None,
                 vertical_pod_autoscaler_update_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] keda_enabled: Specifies whether KEDA Autoscaler can be used for workloads.
               
               > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/AKS-KedaPreview` is enabled and the Resource Provider is re-registered, see the documentation for more information.
        :param pulumi.Input[str] vertical_pod_autoscaler_controlled_values: Which resources values should be controlled.
        :param pulumi.Input[bool] vertical_pod_autoscaler_enabled: Specifies whether Vertical Pod Autoscaler should be enabled.
               
               > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/AKS-VPAPreview` is enabled and the Resource Provider is re-registered, see the documentation for more information.
        :param pulumi.Input[str] vertical_pod_autoscaler_update_mode: How the autoscaler applies changes to pod resources.
        """
        if keda_enabled is not None:
            pulumi.set(__self__, "keda_enabled", keda_enabled)
        if vertical_pod_autoscaler_controlled_values is not None:
            pulumi.set(__self__, "vertical_pod_autoscaler_controlled_values", vertical_pod_autoscaler_controlled_values)
        if vertical_pod_autoscaler_enabled is not None:
            pulumi.set(__self__, "vertical_pod_autoscaler_enabled", vertical_pod_autoscaler_enabled)
        if vertical_pod_autoscaler_update_mode is not None:
            pulumi.set(__self__, "vertical_pod_autoscaler_update_mode", vertical_pod_autoscaler_update_mode)

    @property
    @pulumi.getter(name="kedaEnabled")
    def keda_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether KEDA Autoscaler can be used for workloads.

        > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/AKS-KedaPreview` is enabled and the Resource Provider is re-registered, see the documentation for more information.
        """
        return pulumi.get(self, "keda_enabled")

    @keda_enabled.setter
    def keda_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keda_enabled", value)

    @property
    @pulumi.getter(name="verticalPodAutoscalerControlledValues")
    def vertical_pod_autoscaler_controlled_values(self) -> Optional[pulumi.Input[str]]:
        """
        Which resources values should be controlled.
        """
        return pulumi.get(self, "vertical_pod_autoscaler_controlled_values")

    @vertical_pod_autoscaler_controlled_values.setter
    def vertical_pod_autoscaler_controlled_values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vertical_pod_autoscaler_controlled_values", value)

    @property
    @pulumi.getter(name="verticalPodAutoscalerEnabled")
    def vertical_pod_autoscaler_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Vertical Pod Autoscaler should be enabled.

        > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/AKS-VPAPreview` is enabled and the Resource Provider is re-registered, see the documentation for more information.
        """
        return pulumi.get(self, "vertical_pod_autoscaler_enabled")

    @vertical_pod_autoscaler_enabled.setter
    def vertical_pod_autoscaler_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vertical_pod_autoscaler_enabled", value)

    @property
    @pulumi.getter(name="verticalPodAutoscalerUpdateMode")
    def vertical_pod_autoscaler_update_mode(self) -> Optional[pulumi.Input[str]]:
        """
        How the autoscaler applies changes to pod resources.
        """
        return pulumi.get(self, "vertical_pod_autoscaler_update_mode")

    @vertical_pod_autoscaler_update_mode.setter
    def vertical_pod_autoscaler_update_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vertical_pod_autoscaler_update_mode", value)


@pulumi.input_type
class KubernetesFleetManagerHubProfileArgs:
    def __init__(__self__, *,
                 dns_prefix: pulumi.Input[str],
                 fqdn: Optional[pulumi.Input[str]] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "dns_prefix", dns_prefix)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)

    @property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> pulumi.Input[str]:
        return pulumi.get(self, "dns_prefix")

    @dns_prefix.setter
    def dns_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "dns_prefix", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)


@pulumi.input_type
class RegistryEncryptionArgs:
    def __init__(__self__, *,
                 identity_client_id: pulumi.Input[str],
                 key_vault_key_id: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] identity_client_id: The client ID of the managed identity associated with the encryption key.
               
               > **NOTE** The managed identity used in `encryption` also needs to be part of the `identity` block under `identity_ids`
        :param pulumi.Input[str] key_vault_key_id: The ID of the Key Vault Key.
        :param pulumi.Input[bool] enabled: Boolean value that indicates whether encryption is enabled.
        """
        pulumi.set(__self__, "identity_client_id", identity_client_id)
        pulumi.set(__self__, "key_vault_key_id", key_vault_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> pulumi.Input[str]:
        """
        The client ID of the managed identity associated with the encryption key.

        > **NOTE** The managed identity used in `encryption` also needs to be part of the `identity` block under `identity_ids`
        """
        return pulumi.get(self, "identity_client_id")

    @identity_client_id.setter
    def identity_client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_client_id", value)

    @property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> pulumi.Input[str]:
        """
        The ID of the Key Vault Key.
        """
        return pulumi.get(self, "key_vault_key_id")

    @key_vault_key_id.setter
    def key_vault_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_key_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that indicates whether encryption is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class RegistryGeoreplicationArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[str],
                 regional_endpoint_enabled: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 zone_redundancy_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] location: A location where the container registry should be geo-replicated.
        :param pulumi.Input[bool] regional_endpoint_enabled: Whether regional endpoint is enabled for this Container Registry?
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: A mapping of tags to assign to this replication location.
        :param pulumi.Input[bool] zone_redundancy_enabled: Whether zone redundancy is enabled for this replication location? Defaults to `false`.
               
               > **NOTE:** Changing the `zone_redundancy_enabled` forces the a underlying replication to be created.
        """
        pulumi.set(__self__, "location", location)
        if regional_endpoint_enabled is not None:
            pulumi.set(__self__, "regional_endpoint_enabled", regional_endpoint_enabled)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if zone_redundancy_enabled is not None:
            pulumi.set(__self__, "zone_redundancy_enabled", zone_redundancy_enabled)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[str]:
        """
        A location where the container registry should be geo-replicated.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="regionalEndpointEnabled")
    def regional_endpoint_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether regional endpoint is enabled for this Container Registry?
        """
        return pulumi.get(self, "regional_endpoint_enabled")

    @regional_endpoint_enabled.setter
    def regional_endpoint_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "regional_endpoint_enabled", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping of tags to assign to this replication location.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="zoneRedundancyEnabled")
    def zone_redundancy_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether zone redundancy is enabled for this replication location? Defaults to `false`.

        > **NOTE:** Changing the `zone_redundancy_enabled` forces the a underlying replication to be created.
        """
        return pulumi.get(self, "zone_redundancy_enabled")

    @zone_redundancy_enabled.setter
    def zone_redundancy_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "zone_redundancy_enabled", value)


@pulumi.input_type
class RegistryIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Container Registry. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Container Registry. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class RegistryNetworkRuleSetArgs:
    def __init__(__self__, *,
                 default_action: Optional[pulumi.Input[str]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryNetworkRuleSetIpRuleArgs']]]] = None,
                 virtual_networks: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryNetworkRuleSetVirtualNetworkArgs']]]] = None):
        """
        :param pulumi.Input[str] default_action: The behaviour for requests matching no rules. Either `Allow` or `Deny`. Defaults to `Allow`
        :param pulumi.Input[Sequence[pulumi.Input['RegistryNetworkRuleSetIpRuleArgs']]] ip_rules: One or more `ip_rule` blocks as defined below.
        :param pulumi.Input[Sequence[pulumi.Input['RegistryNetworkRuleSetVirtualNetworkArgs']]] virtual_networks: One or more `virtual_network` blocks as defined below.
               
               > **NOTE:** `network_rule_set` is only supported with the `Premium` SKU at this time.
               
               > **NOTE:** Azure automatically configures Network Rules - to remove these you'll need to specify an `network_rule_set` block with `default_action` set to `Deny`.
        """
        if default_action is not None:
            pulumi.set(__self__, "default_action", default_action)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if virtual_networks is not None:
            pulumi.set(__self__, "virtual_networks", virtual_networks)

    @property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The behaviour for requests matching no rules. Either `Allow` or `Deny`. Defaults to `Allow`
        """
        return pulumi.get(self, "default_action")

    @default_action.setter
    def default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_action", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RegistryNetworkRuleSetIpRuleArgs']]]]:
        """
        One or more `ip_rule` blocks as defined below.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryNetworkRuleSetIpRuleArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="virtualNetworks")
    def virtual_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RegistryNetworkRuleSetVirtualNetworkArgs']]]]:
        """
        One or more `virtual_network` blocks as defined below.

        > **NOTE:** `network_rule_set` is only supported with the `Premium` SKU at this time.

        > **NOTE:** Azure automatically configures Network Rules - to remove these you'll need to specify an `network_rule_set` block with `default_action` set to `Deny`.
        """
        return pulumi.get(self, "virtual_networks")

    @virtual_networks.setter
    def virtual_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryNetworkRuleSetVirtualNetworkArgs']]]]):
        pulumi.set(self, "virtual_networks", value)


@pulumi.input_type
class RegistryNetworkRuleSetIpRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 ip_range: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        :param pulumi.Input[str] ip_range: The CIDR block from which requests will match the rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip_range", ip_range)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> pulumi.Input[str]:
        """
        The CIDR block from which requests will match the rule.
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_range", value)


@pulumi.input_type
class RegistryNetworkRuleSetVirtualNetworkArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        :param pulumi.Input[str] subnet_id: The subnet id from which requests will match the rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The subnet id from which requests will match the rule.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class RegistryRetentionPolicyArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] days: The number of days to retain an untagged manifest after which it gets purged. Default is `7`.
        :param pulumi.Input[bool] enabled: Boolean value that indicates whether the policy is enabled.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days to retain an untagged manifest after which it gets purged. Default is `7`.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that indicates whether the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class RegistryTaskAgentSettingArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[int]):
        """
        :param pulumi.Input[int] cpu: The number of cores required for the Container Registry Task.
        """
        pulumi.set(__self__, "cpu", cpu)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[int]:
        """
        The number of cores required for the Container Registry Task.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[int]):
        pulumi.set(self, "cpu", value)


@pulumi.input_type
class RegistryTaskBaseImageTriggerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 update_trigger_endpoint: Optional[pulumi.Input[str]] = None,
                 update_trigger_payload_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this trigger.
        :param pulumi.Input[str] type: The type of the trigger. Possible values are `All` and `Runtime`.
        :param pulumi.Input[bool] enabled: Should the trigger be enabled? Defaults to `true`.
        :param pulumi.Input[str] update_trigger_endpoint: The endpoint URL for receiving the trigger.
        :param pulumi.Input[str] update_trigger_payload_type: Type of payload body for the trigger. Possible values are `Default` and `Token`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if update_trigger_endpoint is not None:
            pulumi.set(__self__, "update_trigger_endpoint", update_trigger_endpoint)
        if update_trigger_payload_type is not None:
            pulumi.set(__self__, "update_trigger_payload_type", update_trigger_payload_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this trigger.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the trigger. Possible values are `All` and `Runtime`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the trigger be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="updateTriggerEndpoint")
    def update_trigger_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint URL for receiving the trigger.
        """
        return pulumi.get(self, "update_trigger_endpoint")

    @update_trigger_endpoint.setter
    def update_trigger_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_trigger_endpoint", value)

    @property
    @pulumi.getter(name="updateTriggerPayloadType")
    def update_trigger_payload_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of payload body for the trigger. Possible values are `Default` and `Token`.
        """
        return pulumi.get(self, "update_trigger_payload_type")

    @update_trigger_payload_type.setter
    def update_trigger_payload_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_trigger_payload_type", value)


@pulumi.input_type
class RegistryTaskDockerStepArgs:
    def __init__(__self__, *,
                 context_access_token: pulumi.Input[str],
                 context_path: pulumi.Input[str],
                 dockerfile_path: pulumi.Input[str],
                 arguments: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cache_enabled: Optional[pulumi.Input[bool]] = None,
                 image_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 push_enabled: Optional[pulumi.Input[bool]] = None,
                 secret_arguments: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] context_access_token: The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        :param pulumi.Input[str] context_path: The URL (absolute or relative) of the source context for this step. If the context is an url you can reference a specific branch or folder via `#branch:folder`.
        :param pulumi.Input[str] dockerfile_path: The Dockerfile path relative to the source context.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] arguments: Specifies a map of arguments to be used when executing this step.
        :param pulumi.Input[bool] cache_enabled: Should the image cache be enabled? Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] image_names: Specifies a list of fully qualified image names including the repository and tag.
        :param pulumi.Input[bool] push_enabled: Should the image built be pushed to the registry or not? Defaults to `true`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secret_arguments: Specifies a map of *secret* arguments to be used when executing this step.
        :param pulumi.Input[str] target: The name of the target build stage for the docker build.
        """
        pulumi.set(__self__, "context_access_token", context_access_token)
        pulumi.set(__self__, "context_path", context_path)
        pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if cache_enabled is not None:
            pulumi.set(__self__, "cache_enabled", cache_enabled)
        if image_names is not None:
            pulumi.set(__self__, "image_names", image_names)
        if push_enabled is not None:
            pulumi.set(__self__, "push_enabled", push_enabled)
        if secret_arguments is not None:
            pulumi.set(__self__, "secret_arguments", secret_arguments)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="contextAccessToken")
    def context_access_token(self) -> pulumi.Input[str]:
        """
        The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        """
        return pulumi.get(self, "context_access_token")

    @context_access_token.setter
    def context_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "context_access_token", value)

    @property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> pulumi.Input[str]:
        """
        The URL (absolute or relative) of the source context for this step. If the context is an url you can reference a specific branch or folder via `#branch:folder`.
        """
        return pulumi.get(self, "context_path")

    @context_path.setter
    def context_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "context_path", value)

    @property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> pulumi.Input[str]:
        """
        The Dockerfile path relative to the source context.
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "dockerfile_path", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of arguments to be used when executing this step.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter(name="cacheEnabled")
    def cache_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the image cache be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "cache_enabled")

    @cache_enabled.setter
    def cache_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache_enabled", value)

    @property
    @pulumi.getter(name="imageNames")
    def image_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of fully qualified image names including the repository and tag.
        """
        return pulumi.get(self, "image_names")

    @image_names.setter
    def image_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "image_names", value)

    @property
    @pulumi.getter(name="pushEnabled")
    def push_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the image built be pushed to the registry or not? Defaults to `true`.
        """
        return pulumi.get(self, "push_enabled")

    @push_enabled.setter
    def push_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "push_enabled", value)

    @property
    @pulumi.getter(name="secretArguments")
    def secret_arguments(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of *secret* arguments to be used when executing this step.
        """
        return pulumi.get(self, "secret_arguments")

    @secret_arguments.setter
    def secret_arguments(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secret_arguments", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the target build stage for the docker build.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class RegistryTaskEncodedStepArgs:
    def __init__(__self__, *,
                 task_content: pulumi.Input[str],
                 context_access_token: Optional[pulumi.Input[str]] = None,
                 context_path: Optional[pulumi.Input[str]] = None,
                 secret_values: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 value_content: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] task_content: The (optionally base64 encoded) content of the build template.
        :param pulumi.Input[str] context_access_token: The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        :param pulumi.Input[str] context_path: The URL (absolute or relative) of the source context for this step.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secret_values: Specifies a map of secret values that can be passed when running a task.
        :param pulumi.Input[str] value_content: The (optionally base64 encoded) content of the build parameters.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] values: Specifies a map of values that can be passed when running a task.
        """
        pulumi.set(__self__, "task_content", task_content)
        if context_access_token is not None:
            pulumi.set(__self__, "context_access_token", context_access_token)
        if context_path is not None:
            pulumi.set(__self__, "context_path", context_path)
        if secret_values is not None:
            pulumi.set(__self__, "secret_values", secret_values)
        if value_content is not None:
            pulumi.set(__self__, "value_content", value_content)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="taskContent")
    def task_content(self) -> pulumi.Input[str]:
        """
        The (optionally base64 encoded) content of the build template.
        """
        return pulumi.get(self, "task_content")

    @task_content.setter
    def task_content(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_content", value)

    @property
    @pulumi.getter(name="contextAccessToken")
    def context_access_token(self) -> Optional[pulumi.Input[str]]:
        """
        The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        """
        return pulumi.get(self, "context_access_token")

    @context_access_token.setter
    def context_access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_access_token", value)

    @property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[pulumi.Input[str]]:
        """
        The URL (absolute or relative) of the source context for this step.
        """
        return pulumi.get(self, "context_path")

    @context_path.setter
    def context_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_path", value)

    @property
    @pulumi.getter(name="secretValues")
    def secret_values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of secret values that can be passed when running a task.
        """
        return pulumi.get(self, "secret_values")

    @secret_values.setter
    def secret_values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secret_values", value)

    @property
    @pulumi.getter(name="valueContent")
    def value_content(self) -> Optional[pulumi.Input[str]]:
        """
        The (optionally base64 encoded) content of the build parameters.
        """
        return pulumi.get(self, "value_content")

    @value_content.setter
    def value_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_content", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of values that can be passed when running a task.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RegistryTaskFileStepArgs:
    def __init__(__self__, *,
                 task_file_path: pulumi.Input[str],
                 context_access_token: Optional[pulumi.Input[str]] = None,
                 context_path: Optional[pulumi.Input[str]] = None,
                 secret_values: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 value_file_path: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] task_file_path: The task template file path relative to the source context.
        :param pulumi.Input[str] context_access_token: The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        :param pulumi.Input[str] context_path: The URL (absolute or relative) of the source context for this step.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secret_values: Specifies a map of secret values that can be passed when running a task.
        :param pulumi.Input[str] value_file_path: The parameters file path relative to the source context.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] values: Specifies a map of values that can be passed when running a task.
        """
        pulumi.set(__self__, "task_file_path", task_file_path)
        if context_access_token is not None:
            pulumi.set(__self__, "context_access_token", context_access_token)
        if context_path is not None:
            pulumi.set(__self__, "context_path", context_path)
        if secret_values is not None:
            pulumi.set(__self__, "secret_values", secret_values)
        if value_file_path is not None:
            pulumi.set(__self__, "value_file_path", value_file_path)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="taskFilePath")
    def task_file_path(self) -> pulumi.Input[str]:
        """
        The task template file path relative to the source context.
        """
        return pulumi.get(self, "task_file_path")

    @task_file_path.setter
    def task_file_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_file_path", value)

    @property
    @pulumi.getter(name="contextAccessToken")
    def context_access_token(self) -> Optional[pulumi.Input[str]]:
        """
        The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        """
        return pulumi.get(self, "context_access_token")

    @context_access_token.setter
    def context_access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_access_token", value)

    @property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[pulumi.Input[str]]:
        """
        The URL (absolute or relative) of the source context for this step.
        """
        return pulumi.get(self, "context_path")

    @context_path.setter
    def context_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_path", value)

    @property
    @pulumi.getter(name="secretValues")
    def secret_values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of secret values that can be passed when running a task.
        """
        return pulumi.get(self, "secret_values")

    @secret_values.setter
    def secret_values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secret_values", value)

    @property
    @pulumi.getter(name="valueFilePath")
    def value_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The parameters file path relative to the source context.
        """
        return pulumi.get(self, "value_file_path")

    @value_file_path.setter
    def value_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_file_path", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of values that can be passed when running a task.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RegistryTaskIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Container Registry Task. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry Task.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Container Registry Task. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry Task.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class RegistryTaskPlatformArgs:
    def __init__(__self__, *,
                 os: pulumi.Input[str],
                 architecture: Optional[pulumi.Input[str]] = None,
                 variant: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] os: The operating system type required for the task. Possible values are `Windows` and `Linux`.
        :param pulumi.Input[str] architecture: The OS architecture. Possible values are `amd64`, `x86`, `386`, `arm` and `arm64`.
        :param pulumi.Input[str] variant: The variant of the CPU. Possible values are `v6`, `v7`, `v8`.
        """
        pulumi.set(__self__, "os", os)
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if variant is not None:
            pulumi.set(__self__, "variant", variant)

    @property
    @pulumi.getter
    def os(self) -> pulumi.Input[str]:
        """
        The operating system type required for the task. Possible values are `Windows` and `Linux`.
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: pulumi.Input[str]):
        pulumi.set(self, "os", value)

    @property
    @pulumi.getter
    def architecture(self) -> Optional[pulumi.Input[str]]:
        """
        The OS architecture. Possible values are `amd64`, `x86`, `386`, `arm` and `arm64`.
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "architecture", value)

    @property
    @pulumi.getter
    def variant(self) -> Optional[pulumi.Input[str]]:
        """
        The variant of the CPU. Possible values are `v6`, `v7`, `v8`.
        """
        return pulumi.get(self, "variant")

    @variant.setter
    def variant(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "variant", value)


@pulumi.input_type
class RegistryTaskRegistryCredentialArgs:
    def __init__(__self__, *,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryTaskRegistryCredentialCustomArgs']]]] = None,
                 source: Optional[pulumi.Input['RegistryTaskRegistryCredentialSourceArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RegistryTaskRegistryCredentialCustomArgs']]] customs: One or more `custom` blocks as defined above.
        :param pulumi.Input['RegistryTaskRegistryCredentialSourceArgs'] source: One `source` block as defined below.
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RegistryTaskRegistryCredentialCustomArgs']]]]:
        """
        One or more `custom` blocks as defined above.
        """
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryTaskRegistryCredentialCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['RegistryTaskRegistryCredentialSourceArgs']]:
        """
        One `source` block as defined below.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['RegistryTaskRegistryCredentialSourceArgs']]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class RegistryTaskRegistryCredentialCustomArgs:
    def __init__(__self__, *,
                 login_server: pulumi.Input[str],
                 identity: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] login_server: The login server of the custom Container Registry.
        :param pulumi.Input[str] identity: The managed identity assigned to this custom credential. For user assigned identity, the value is the client ID of the identity. For system assigned identity, the value is `[system]`.
        :param pulumi.Input[str] password: The password for logging into the custom Container Registry. It can be either a plain text of password, or a Keyvault Secret ID.
        :param pulumi.Input[str] username: The username for logging into the custom Container Registry. It can be either a plain text of username, or a Keyvault Secret ID.
        """
        pulumi.set(__self__, "login_server", login_server)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="loginServer")
    def login_server(self) -> pulumi.Input[str]:
        """
        The login server of the custom Container Registry.
        """
        return pulumi.get(self, "login_server")

    @login_server.setter
    def login_server(self, value: pulumi.Input[str]):
        pulumi.set(self, "login_server", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[str]]:
        """
        The managed identity assigned to this custom credential. For user assigned identity, the value is the client ID of the identity. For system assigned identity, the value is `[system]`.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password for logging into the custom Container Registry. It can be either a plain text of password, or a Keyvault Secret ID.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username for logging into the custom Container Registry. It can be either a plain text of username, or a Keyvault Secret ID.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class RegistryTaskRegistryCredentialSourceArgs:
    def __init__(__self__, *,
                 login_mode: pulumi.Input[str]):
        """
        :param pulumi.Input[str] login_mode: The login mode for the source registry. Possible values are `None` and `Default`.
        """
        pulumi.set(__self__, "login_mode", login_mode)

    @property
    @pulumi.getter(name="loginMode")
    def login_mode(self) -> pulumi.Input[str]:
        """
        The login mode for the source registry. Possible values are `None` and `Default`.
        """
        return pulumi.get(self, "login_mode")

    @login_mode.setter
    def login_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "login_mode", value)


@pulumi.input_type
class RegistryTaskSourceTriggerArgs:
    def __init__(__self__, *,
                 events: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 repository_url: pulumi.Input[str],
                 source_type: pulumi.Input[str],
                 authentication: Optional[pulumi.Input['RegistryTaskSourceTriggerAuthenticationArgs']] = None,
                 branch: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events: Specifies a list of source events corresponding to the trigger. Possible values are `commit` and `pullrequest`.
        :param pulumi.Input[str] name: The name which should be used for this trigger.
        :param pulumi.Input[str] repository_url: The full URL to the source code repository.
        :param pulumi.Input[str] source_type: The type of the source control service. Possible values are `Github` and `VisualStudioTeamService`.
        :param pulumi.Input['RegistryTaskSourceTriggerAuthenticationArgs'] authentication: A `authentication` block as defined above.
        :param pulumi.Input[str] branch: The branch name of the source code.
        :param pulumi.Input[bool] enabled: Should the trigger be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "repository_url", repository_url)
        pulumi.set(__self__, "source_type", source_type)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def events(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies a list of source events corresponding to the trigger. Possible values are `commit` and `pullrequest`.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this trigger.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> pulumi.Input[str]:
        """
        The full URL to the source code repository.
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_url", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The type of the source control service. Possible values are `Github` and `VisualStudioTeamService`.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['RegistryTaskSourceTriggerAuthenticationArgs']]:
        """
        A `authentication` block as defined above.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['RegistryTaskSourceTriggerAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The branch name of the source code.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the trigger be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class RegistryTaskSourceTriggerAuthenticationArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str],
                 token_type: pulumi.Input[str],
                 expire_in_seconds: Optional[pulumi.Input[int]] = None,
                 refresh_token: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] token: The access token used to access the source control provider.
        :param pulumi.Input[str] token_type: The type of the token. Possible values are `PAT` (personal access token) and `OAuth`.
        :param pulumi.Input[int] expire_in_seconds: Time in seconds that the token remains valid.
        :param pulumi.Input[str] refresh_token: The refresh token used to refresh the access token.
        :param pulumi.Input[str] scope: The scope of the access token.
        """
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "token_type", token_type)
        if expire_in_seconds is not None:
            pulumi.set(__self__, "expire_in_seconds", expire_in_seconds)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The access token used to access the source control provider.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="tokenType")
    def token_type(self) -> pulumi.Input[str]:
        """
        The type of the token. Possible values are `PAT` (personal access token) and `OAuth`.
        """
        return pulumi.get(self, "token_type")

    @token_type.setter
    def token_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_type", value)

    @property
    @pulumi.getter(name="expireInSeconds")
    def expire_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Time in seconds that the token remains valid.
        """
        return pulumi.get(self, "expire_in_seconds")

    @expire_in_seconds.setter
    def expire_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_in_seconds", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[str]]:
        """
        The refresh token used to refresh the access token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The scope of the access token.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class RegistryTaskTimerTriggerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this trigger.
        :param pulumi.Input[str] schedule: The CRON expression for the task schedule.
        :param pulumi.Input[bool] enabled: Should the trigger be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this trigger.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input[str]:
        """
        The CRON expression for the task schedule.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the trigger be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class RegistryTrustPolicyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Boolean value that indicates whether the policy is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that indicates whether the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class TokenPasswordPassword1Args:
    def __init__(__self__, *,
                 expiry: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expiry: The expiration date of the password in RFC3339 format. Changing this forces a new resource to be created.
        :param pulumi.Input[str] value: The value of the password (Sensitive).
        """
        if expiry is not None:
            pulumi.set(__self__, "expiry", expiry)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expiry(self) -> Optional[pulumi.Input[str]]:
        """
        The expiration date of the password in RFC3339 format. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "expiry")

    @expiry.setter
    def expiry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the password (Sensitive).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TokenPasswordPassword2Args:
    def __init__(__self__, *,
                 expiry: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expiry: The expiration date of the password in RFC3339 format. Changing this forces a new resource to be created.
        :param pulumi.Input[str] value: The value of the password (Sensitive).
        """
        if expiry is not None:
            pulumi.set(__self__, "expiry", expiry)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expiry(self) -> Optional[pulumi.Input[str]]:
        """
        The expiration date of the password in RFC3339 format. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "expiry")

    @expiry.setter
    def expiry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the password (Sensitive).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


