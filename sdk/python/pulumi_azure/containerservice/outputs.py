# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'GroupContainer',
    'GroupContainerGpu',
    'GroupContainerLivenessProbe',
    'GroupContainerLivenessProbeHttpGet',
    'GroupContainerPort',
    'GroupContainerReadinessProbe',
    'GroupContainerReadinessProbeHttpGet',
    'GroupContainerVolume',
    'GroupContainerVolumeGitRepo',
    'GroupDiagnostics',
    'GroupDiagnosticsLogAnalytics',
    'GroupDnsConfig',
    'GroupIdentity',
    'GroupImageRegistryCredential',
    'KubernetesClusterAddonProfile',
    'KubernetesClusterAddonProfileAciConnectorLinux',
    'KubernetesClusterAddonProfileAzurePolicy',
    'KubernetesClusterAddonProfileHttpApplicationRouting',
    'KubernetesClusterAddonProfileKubeDashboard',
    'KubernetesClusterAddonProfileOmsAgent',
    'KubernetesClusterAddonProfileOmsAgentOmsAgentIdentity',
    'KubernetesClusterAutoScalerProfile',
    'KubernetesClusterDefaultNodePool',
    'KubernetesClusterDefaultNodePoolUpgradeSettings',
    'KubernetesClusterIdentity',
    'KubernetesClusterKubeAdminConfig',
    'KubernetesClusterKubeConfig',
    'KubernetesClusterKubeletIdentity',
    'KubernetesClusterLinuxProfile',
    'KubernetesClusterLinuxProfileSshKey',
    'KubernetesClusterNetworkProfile',
    'KubernetesClusterNetworkProfileLoadBalancerProfile',
    'KubernetesClusterNodePoolUpgradeSettings',
    'KubernetesClusterRoleBasedAccessControl',
    'KubernetesClusterRoleBasedAccessControlAzureActiveDirectory',
    'KubernetesClusterServicePrincipal',
    'KubernetesClusterWindowsProfile',
    'RegistryNetworkRuleSet',
    'RegistryNetworkRuleSetIpRule',
    'RegistryNetworkRuleSetVirtualNetwork',
    'RegistryRetentionPolicy',
    'RegistryTrustPolicy',
    'GetClusterNodePoolUpgradeSettingResult',
    'GetKubernetesClusterAddonProfileResult',
    'GetKubernetesClusterAddonProfileAzurePolicyResult',
    'GetKubernetesClusterAddonProfileHttpApplicationRoutingResult',
    'GetKubernetesClusterAddonProfileKubeDashboardResult',
    'GetKubernetesClusterAddonProfileOmsAgentResult',
    'GetKubernetesClusterAddonProfileOmsAgentOmsAgentIdentityResult',
    'GetKubernetesClusterAgentPoolProfileResult',
    'GetKubernetesClusterAgentPoolProfileUpgradeSettingResult',
    'GetKubernetesClusterIdentityResult',
    'GetKubernetesClusterKubeAdminConfigResult',
    'GetKubernetesClusterKubeConfigResult',
    'GetKubernetesClusterKubeletIdentityResult',
    'GetKubernetesClusterLinuxProfileResult',
    'GetKubernetesClusterLinuxProfileSshKeyResult',
    'GetKubernetesClusterNetworkProfileResult',
    'GetKubernetesClusterRoleBasedAccessControlResult',
    'GetKubernetesClusterRoleBasedAccessControlAzureActiveDirectoryResult',
    'GetKubernetesClusterServicePrincipalResult',
    'GetKubernetesClusterWindowsProfileResult',
]

@pulumi.output_type
class GroupContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "secureEnvironmentVariables":
            suggest = "secure_environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: float,
                 image: str,
                 memory: float,
                 name: str,
                 commands: Optional[Sequence[str]] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 gpu: Optional['outputs.GroupContainerGpu'] = None,
                 liveness_probe: Optional['outputs.GroupContainerLivenessProbe'] = None,
                 ports: Optional[Sequence['outputs.GroupContainerPort']] = None,
                 readiness_probe: Optional['outputs.GroupContainerReadinessProbe'] = None,
                 secure_environment_variables: Optional[Mapping[str, str]] = None,
                 volumes: Optional[Sequence['outputs.GroupContainerVolume']] = None):
        """
        :param float cpu: The required number of CPU cores of the containers. Changing this forces a new resource to be created.
        :param str image: The container image name. Changing this forces a new resource to be created.
        :param float memory: The required memory of the containers in GB. Changing this forces a new resource to be created.
        :param str name: Specifies the name of the Container Group. Changing this forces a new resource to be created.
        :param Sequence[str] commands: A list of commands which should be run on the container. Changing this forces a new resource to be created.
        :param Mapping[str, str] environment_variables: A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param 'GroupContainerGpuArgs' gpu: A `gpu` block as defined below. Changing this forces a new resource to be created.
        :param 'GroupContainerLivenessProbeArgs' liveness_probe: The definition of a readiness probe for this container as documented in the `liveness_probe` block below. Changing this forces a new resource to be created.
        :param Sequence['GroupContainerPortArgs'] ports: A set of public ports for the container. Changing this forces a new resource to be created. Set as documented in the `ports` block below.
        :param 'GroupContainerReadinessProbeArgs' readiness_probe: The definition of a readiness probe for this container as documented in the `readiness_probe` block below. Changing this forces a new resource to be created.
        :param Mapping[str, str] secure_environment_variables: A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param Sequence['GroupContainerVolumeArgs'] volumes: The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if secure_environment_variables is not None:
            pulumi.set(__self__, "secure_environment_variables", secure_environment_variables)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def cpu(self) -> float:
        """
        The required number of CPU cores of the containers. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        The container image name. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def memory(self) -> float:
        """
        The required memory of the containers in GB. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Container Group. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        A list of commands which should be run on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter
    def gpu(self) -> Optional['outputs.GroupContainerGpu']:
        """
        A `gpu` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "gpu")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.GroupContainerLivenessProbe']:
        """
        The definition of a readiness probe for this container as documented in the `liveness_probe` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.GroupContainerPort']]:
        """
        A set of public ports for the container. Changing this forces a new resource to be created. Set as documented in the `ports` block below.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.GroupContainerReadinessProbe']:
        """
        The definition of a readiness probe for this container as documented in the `readiness_probe` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="secureEnvironmentVariables")
    def secure_environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secure_environment_variables")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.GroupContainerVolume']]:
        """
        The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GroupContainerGpu(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 sku: Optional[str] = None):
        """
        :param int count: The number of GPUs which should be assigned to this container. Allowed values are `1`, `2`, or `4`. Changing this forces a new resource to be created.
        :param str sku: The Sku which should be used for the GPU. Possible values are `K80`, `P100`, or `V100`. Changing this forces a new resource to be created.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of GPUs which should be assigned to this container. Allowed values are `1`, `2`, or `4`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        """
        The Sku which should be used for the GPU. Possible values are `K80`, `P100`, or `V100`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "sku")


@pulumi.output_type
class GroupContainerLivenessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGets":
            suggest = "http_gets"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainerLivenessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainerLivenessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainerLivenessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execs: Optional[Sequence[str]] = None,
                 failure_threshold: Optional[int] = None,
                 http_gets: Optional[Sequence['outputs.GroupContainerLivenessProbeHttpGet']] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param Sequence[str] execs: Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        :param int failure_threshold: How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param Sequence['GroupContainerLivenessProbeHttpGetArgs'] http_gets: The definition of the httpget for this container as documented in the `httpget` block below. Changing this forces a new resource to be created.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        :param int period_seconds: How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param int timeout_seconds: Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        if execs is not None:
            pulumi.set(__self__, "execs", execs)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def execs(self) -> Optional[Sequence[str]]:
        """
        Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "execs")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[Sequence['outputs.GroupContainerLivenessProbeHttpGet']]:
        """
        The definition of the httpget for this container as documented in the `httpget` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_gets")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GroupContainerLivenessProbeHttpGet(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        """
        :param str path: Path to access on the HTTP server. Changing this forces a new resource to be created.
        :param int port: The port number the container will expose. Changing this forces a new resource to be created.
        :param str scheme: Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number the container will expose. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GroupContainerPort(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None):
        """
        :param int port: The port number the container will expose. Changing this forces a new resource to be created.
        :param str protocol: The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number the container will expose. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GroupContainerReadinessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGets":
            suggest = "http_gets"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainerReadinessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainerReadinessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainerReadinessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execs: Optional[Sequence[str]] = None,
                 failure_threshold: Optional[int] = None,
                 http_gets: Optional[Sequence['outputs.GroupContainerReadinessProbeHttpGet']] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param Sequence[str] execs: Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        :param int failure_threshold: How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param Sequence['GroupContainerReadinessProbeHttpGetArgs'] http_gets: The definition of the httpget for this container as documented in the `httpget` block below. Changing this forces a new resource to be created.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        :param int period_seconds: How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        :param int timeout_seconds: Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        if execs is not None:
            pulumi.set(__self__, "execs", execs)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def execs(self) -> Optional[Sequence[str]]:
        """
        Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "execs")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[Sequence['outputs.GroupContainerReadinessProbeHttpGet']]:
        """
        The definition of the httpget for this container as documented in the `httpget` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_gets")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GroupContainerReadinessProbeHttpGet(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        """
        :param str path: Path to access on the HTTP server. Changing this forces a new resource to be created.
        :param int port: The port number the container will expose. Changing this forces a new resource to be created.
        :param str scheme: Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number the container will expose. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GroupContainerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "emptyDir":
            suggest = "empty_dir"
        elif key == "gitRepo":
            suggest = "git_repo"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageAccountName":
            suggest = "storage_account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 empty_dir: Optional[bool] = None,
                 git_repo: Optional['outputs.GroupContainerVolumeGitRepo'] = None,
                 read_only: Optional[bool] = None,
                 secret: Optional[Mapping[str, str]] = None,
                 share_name: Optional[str] = None,
                 storage_account_key: Optional[str] = None,
                 storage_account_name: Optional[str] = None):
        """
        :param str mount_path: The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        :param str name: Specifies the name of the Container Group. Changing this forces a new resource to be created.
        :param bool empty_dir: Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        :param 'GroupContainerVolumeGitRepoArgs' git_repo: A `git_repo` block as defined below.
        :param bool read_only: Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        :param Mapping[str, str] secret: A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.
        :param str share_name: The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        :param str storage_account_key: The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        :param str storage_account_name: The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if empty_dir is not None:
            pulumi.set(__self__, "empty_dir", empty_dir)
        if git_repo is not None:
            pulumi.set(__self__, "git_repo", git_repo)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if storage_account_key is not None:
            pulumi.set(__self__, "storage_account_key", storage_account_key)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the Container Group. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="emptyDir")
    def empty_dir(self) -> Optional[bool]:
        """
        Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "empty_dir")

    @property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> Optional['outputs.GroupContainerVolumeGitRepo']:
        """
        A `git_repo` block as defined below.
        """
        return pulumi.get(self, "git_repo")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter
    def secret(self) -> Optional[Mapping[str, str]]:
        """
        A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[str]:
        """
        The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> Optional[str]:
        """
        The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[str]:
        """
        The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_name")


@pulumi.output_type
class GroupContainerVolumeGitRepo(dict):
    def __init__(__self__, *,
                 url: str,
                 directory: Optional[str] = None,
                 revision: Optional[str] = None):
        """
        :param str url: Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        :param str directory: Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        :param str revision: Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "url", url)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def revision(self) -> Optional[str]:
        """
        Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "revision")


@pulumi.output_type
class GroupDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalytics":
            suggest = "log_analytics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics: 'outputs.GroupDiagnosticsLogAnalytics'):
        """
        :param 'GroupDiagnosticsLogAnalyticsArgs' log_analytics: A `log_analytics` block as defined below. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "log_analytics", log_analytics)

    @property
    @pulumi.getter(name="logAnalytics")
    def log_analytics(self) -> 'outputs.GroupDiagnosticsLogAnalytics':
        """
        A `log_analytics` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "log_analytics")


@pulumi.output_type
class GroupDiagnosticsLogAnalytics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"
        elif key == "workspaceKey":
            suggest = "workspace_key"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupDiagnosticsLogAnalytics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupDiagnosticsLogAnalytics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupDiagnosticsLogAnalytics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: str,
                 workspace_key: str,
                 log_type: Optional[str] = None,
                 metadata: Optional[Mapping[str, str]] = None):
        """
        :param str workspace_id: The Workspace ID of the Log Analytics Workspace. Changing this forces a new resource to be created.
        :param str workspace_key: The Workspace Key of the Log Analytics Workspace. Changing this forces a new resource to be created.
        :param str log_type: The log type which should be used. Possible values are `ContainerInsights` and `ContainerInstanceLogs`. Changing this forces a new resource to be created.
        :param Mapping[str, str] metadata: Any metadata required for Log Analytics. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)
        pulumi.set(__self__, "workspace_key", workspace_key)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        The Workspace ID of the Log Analytics Workspace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "workspace_id")

    @property
    @pulumi.getter(name="workspaceKey")
    def workspace_key(self) -> str:
        """
        The Workspace Key of the Log Analytics Workspace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "workspace_key")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[str]:
        """
        The log type which should be used. Possible values are `ContainerInsights` and `ContainerInstanceLogs`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "log_type")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        Any metadata required for Log Analytics. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class GroupDnsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "searchDomains":
            suggest = "search_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupDnsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupDnsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupDnsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nameservers: Sequence[str],
                 options: Sequence[str],
                 search_domains: Sequence[str]):
        """
        :param Sequence[str] nameservers: A list of nameservers the containers will search out to resolve requests.
        :param Sequence[str] options: A list of [resolver configuration options](https://man7.org/linux/man-pages/man5/resolv.conf.5.html).
        :param Sequence[str] search_domains: A list of search domains that DNS requests will search along.
        """
        pulumi.set(__self__, "nameservers", nameservers)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "search_domains", search_domains)

    @property
    @pulumi.getter
    def nameservers(self) -> Sequence[str]:
        """
        A list of nameservers the containers will search out to resolve requests.
        """
        return pulumi.get(self, "nameservers")

    @property
    @pulumi.getter
    def options(self) -> Sequence[str]:
        """
        A list of [resolver configuration options](https://man7.org/linux/man-pages/man5/resolv.conf.5.html).
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="searchDomains")
    def search_domains(self) -> Sequence[str]:
        """
        A list of search domains that DNS requests will search along.
        """
        return pulumi.get(self, "search_domains")


@pulumi.output_type
class GroupIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None):
        """
        :param str type: The Managed Service Identity Type of this container group. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities. Changing this forces a new resource to be created.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The Managed Service Identity Type of this container group. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class GroupImageRegistryCredential(dict):
    def __init__(__self__, *,
                 password: str,
                 server: str,
                 username: str):
        """
        :param str password: The password with which to connect to the registry. Changing this forces a new resource to be created.
        :param str server: The address to use to connect to the registry without protocol ("https"/"http"). For example: "myacr.acr.io". Changing this forces a new resource to be created.
        :param str username: The username with which to connect to the registry. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password with which to connect to the registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The address to use to connect to the registry without protocol ("https"/"http"). For example: "myacr.acr.io". Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username with which to connect to the registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KubernetesClusterAddonProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aciConnectorLinux":
            suggest = "aci_connector_linux"
        elif key == "azurePolicy":
            suggest = "azure_policy"
        elif key == "httpApplicationRouting":
            suggest = "http_application_routing"
        elif key == "kubeDashboard":
            suggest = "kube_dashboard"
        elif key == "omsAgent":
            suggest = "oms_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAddonProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAddonProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAddonProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aci_connector_linux: Optional['outputs.KubernetesClusterAddonProfileAciConnectorLinux'] = None,
                 azure_policy: Optional['outputs.KubernetesClusterAddonProfileAzurePolicy'] = None,
                 http_application_routing: Optional['outputs.KubernetesClusterAddonProfileHttpApplicationRouting'] = None,
                 kube_dashboard: Optional['outputs.KubernetesClusterAddonProfileKubeDashboard'] = None,
                 oms_agent: Optional['outputs.KubernetesClusterAddonProfileOmsAgent'] = None):
        """
        :param 'KubernetesClusterAddonProfileAciConnectorLinuxArgs' aci_connector_linux: A `aci_connector_linux` block. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/en-us/azure/aks/virtual-nodes-portal).
        :param 'KubernetesClusterAddonProfileAzurePolicyArgs' azure_policy: A `azure_policy` block as defined below. For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
        :param 'KubernetesClusterAddonProfileHttpApplicationRoutingArgs' http_application_routing: A `http_application_routing` block as defined below.
        :param 'KubernetesClusterAddonProfileKubeDashboardArgs' kube_dashboard: A `kube_dashboard` block as defined below.
        :param 'KubernetesClusterAddonProfileOmsAgentArgs' oms_agent: A `oms_agent` block as defined below. For more details, please visit [How to onboard Azure Monitor for containers](https://docs.microsoft.com/en-us/azure/monitoring/monitoring-container-insights-onboard).
        """
        if aci_connector_linux is not None:
            pulumi.set(__self__, "aci_connector_linux", aci_connector_linux)
        if azure_policy is not None:
            pulumi.set(__self__, "azure_policy", azure_policy)
        if http_application_routing is not None:
            pulumi.set(__self__, "http_application_routing", http_application_routing)
        if kube_dashboard is not None:
            pulumi.set(__self__, "kube_dashboard", kube_dashboard)
        if oms_agent is not None:
            pulumi.set(__self__, "oms_agent", oms_agent)

    @property
    @pulumi.getter(name="aciConnectorLinux")
    def aci_connector_linux(self) -> Optional['outputs.KubernetesClusterAddonProfileAciConnectorLinux']:
        """
        A `aci_connector_linux` block. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/en-us/azure/aks/virtual-nodes-portal).
        """
        return pulumi.get(self, "aci_connector_linux")

    @property
    @pulumi.getter(name="azurePolicy")
    def azure_policy(self) -> Optional['outputs.KubernetesClusterAddonProfileAzurePolicy']:
        """
        A `azure_policy` block as defined below. For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
        """
        return pulumi.get(self, "azure_policy")

    @property
    @pulumi.getter(name="httpApplicationRouting")
    def http_application_routing(self) -> Optional['outputs.KubernetesClusterAddonProfileHttpApplicationRouting']:
        """
        A `http_application_routing` block as defined below.
        """
        return pulumi.get(self, "http_application_routing")

    @property
    @pulumi.getter(name="kubeDashboard")
    def kube_dashboard(self) -> Optional['outputs.KubernetesClusterAddonProfileKubeDashboard']:
        """
        A `kube_dashboard` block as defined below.
        """
        return pulumi.get(self, "kube_dashboard")

    @property
    @pulumi.getter(name="omsAgent")
    def oms_agent(self) -> Optional['outputs.KubernetesClusterAddonProfileOmsAgent']:
        """
        A `oms_agent` block as defined below. For more details, please visit [How to onboard Azure Monitor for containers](https://docs.microsoft.com/en-us/azure/monitoring/monitoring-container-insights-onboard).
        """
        return pulumi.get(self, "oms_agent")


@pulumi.output_type
class KubernetesClusterAddonProfileAciConnectorLinux(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetName":
            suggest = "subnet_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAddonProfileAciConnectorLinux. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAddonProfileAciConnectorLinux.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAddonProfileAciConnectorLinux.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 subnet_name: Optional[str] = None):
        """
        :param bool enabled: Is the virtual node addon enabled?
        :param str subnet_name: The subnet name for the virtual nodes to run. This is required when `aci_connector_linux` `enabled` argument is set to `true`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the virtual node addon enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[str]:
        """
        The subnet name for the virtual nodes to run. This is required when `aci_connector_linux` `enabled` argument is set to `true`.
        """
        return pulumi.get(self, "subnet_name")


@pulumi.output_type
class KubernetesClusterAddonProfileAzurePolicy(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Is the Azure Policy for Kubernetes Add On enabled?
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Azure Policy for Kubernetes Add On enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class KubernetesClusterAddonProfileHttpApplicationRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpApplicationRoutingZoneName":
            suggest = "http_application_routing_zone_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAddonProfileHttpApplicationRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAddonProfileHttpApplicationRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAddonProfileHttpApplicationRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 http_application_routing_zone_name: Optional[str] = None):
        """
        :param bool enabled: Is HTTP Application Routing Enabled?
        :param str http_application_routing_zone_name: The Zone Name of the HTTP Application Routing.
        """
        pulumi.set(__self__, "enabled", enabled)
        if http_application_routing_zone_name is not None:
            pulumi.set(__self__, "http_application_routing_zone_name", http_application_routing_zone_name)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is HTTP Application Routing Enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="httpApplicationRoutingZoneName")
    def http_application_routing_zone_name(self) -> Optional[str]:
        """
        The Zone Name of the HTTP Application Routing.
        """
        return pulumi.get(self, "http_application_routing_zone_name")


@pulumi.output_type
class KubernetesClusterAddonProfileKubeDashboard(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Is the Kubernetes Dashboard enabled?
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the Kubernetes Dashboard enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class KubernetesClusterAddonProfileOmsAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "omsAgentIdentities":
            suggest = "oms_agent_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAddonProfileOmsAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAddonProfileOmsAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAddonProfileOmsAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 log_analytics_workspace_id: Optional[str] = None,
                 oms_agent_identities: Optional[Sequence['outputs.KubernetesClusterAddonProfileOmsAgentOmsAgentIdentity']] = None):
        """
        :param bool enabled: Is the OMS Agent Enabled?
        :param str log_analytics_workspace_id: The ID of the Log Analytics Workspace which the OMS Agent should send data to. Must be present if `enabled` is `true`.
        :param Sequence['KubernetesClusterAddonProfileOmsAgentOmsAgentIdentityArgs'] oms_agent_identities: An `oms_agent_identity` block is exported. The exported attributes are defined below.
        """
        pulumi.set(__self__, "enabled", enabled)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)
        if oms_agent_identities is not None:
            pulumi.set(__self__, "oms_agent_identities", oms_agent_identities)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is the OMS Agent Enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[str]:
        """
        The ID of the Log Analytics Workspace which the OMS Agent should send data to. Must be present if `enabled` is `true`.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="omsAgentIdentities")
    def oms_agent_identities(self) -> Optional[Sequence['outputs.KubernetesClusterAddonProfileOmsAgentOmsAgentIdentity']]:
        """
        An `oms_agent_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "oms_agent_identities")


@pulumi.output_type
class KubernetesClusterAddonProfileOmsAgentOmsAgentIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAddonProfileOmsAgentOmsAgentIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAddonProfileOmsAgentOmsAgentIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAddonProfileOmsAgentOmsAgentIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 object_id: Optional[str] = None,
                 user_assigned_identity_id: Optional[str] = None):
        """
        :param str client_id: The Client ID for the Service Principal.
        :param str object_id: The Object ID of the user-defined Managed Identity used by the OMS Agents.
        :param str user_assigned_identity_id: The ID of a user assigned identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID for the Service Principal.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        The Object ID of the user-defined Managed Identity used by the OMS Agents.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[str]:
        """
        The ID of a user assigned identity.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class KubernetesClusterAutoScalerProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "balanceSimilarNodeGroups":
            suggest = "balance_similar_node_groups"
        elif key == "maxGracefulTerminationSec":
            suggest = "max_graceful_termination_sec"
        elif key == "newPodScaleUpDelay":
            suggest = "new_pod_scale_up_delay"
        elif key == "scaleDownDelayAfterAdd":
            suggest = "scale_down_delay_after_add"
        elif key == "scaleDownDelayAfterDelete":
            suggest = "scale_down_delay_after_delete"
        elif key == "scaleDownDelayAfterFailure":
            suggest = "scale_down_delay_after_failure"
        elif key == "scaleDownUnneeded":
            suggest = "scale_down_unneeded"
        elif key == "scaleDownUnready":
            suggest = "scale_down_unready"
        elif key == "scaleDownUtilizationThreshold":
            suggest = "scale_down_utilization_threshold"
        elif key == "scanInterval":
            suggest = "scan_interval"
        elif key == "skipNodesWithLocalStorage":
            suggest = "skip_nodes_with_local_storage"
        elif key == "skipNodesWithSystemPods":
            suggest = "skip_nodes_with_system_pods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAutoScalerProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAutoScalerProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAutoScalerProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 balance_similar_node_groups: Optional[bool] = None,
                 expander: Optional[str] = None,
                 max_graceful_termination_sec: Optional[str] = None,
                 new_pod_scale_up_delay: Optional[str] = None,
                 scale_down_delay_after_add: Optional[str] = None,
                 scale_down_delay_after_delete: Optional[str] = None,
                 scale_down_delay_after_failure: Optional[str] = None,
                 scale_down_unneeded: Optional[str] = None,
                 scale_down_unready: Optional[str] = None,
                 scale_down_utilization_threshold: Optional[str] = None,
                 scan_interval: Optional[str] = None,
                 skip_nodes_with_local_storage: Optional[bool] = None,
                 skip_nodes_with_system_pods: Optional[bool] = None):
        """
        :param bool balance_similar_node_groups: Detect similar node groups and balance the number of nodes between them. Defaults to `false`.
        :param str expander: Expander to use. Possible values are `least-waste`, `priority`, `most-pods` and `random`. Defaults to `random`.
        :param str max_graceful_termination_sec: Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. Defaults to `600`.
        :param str new_pod_scale_up_delay: For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. Defaults to `10s`.
        :param str scale_down_delay_after_add: How long after the scale up of AKS nodes the scale down evaluation resumes. Defaults to `10m`.
        :param str scale_down_delay_after_delete: How long after node deletion that scale down evaluation resumes. Defaults to the value used for `scan_interval`.
        :param str scale_down_delay_after_failure: How long after scale down failure that scale down evaluation resumes. Defaults to `3m`.
        :param str scale_down_unneeded: How long a node should be unneeded before it is eligible for scale down. Defaults to `10m`.
        :param str scale_down_unready: How long an unready node should be unneeded before it is eligible for scale down. Defaults to `20m`.
        :param str scale_down_utilization_threshold: Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. Defaults to `0.5`.
        :param str scan_interval: How often the AKS Cluster should be re-evaluated for scale up/down. Defaults to `10s`.
        :param bool skip_nodes_with_local_storage: If `true` cluster autoscaler will never delete nodes with pods with local storage, for example, EmptyDir or HostPath. Defaults to `true`.
        :param bool skip_nodes_with_system_pods: If `true` cluster autoscaler will never delete nodes with pods from kube-system (except for DaemonSet or mirror pods). Defaults to `true`.
        """
        if balance_similar_node_groups is not None:
            pulumi.set(__self__, "balance_similar_node_groups", balance_similar_node_groups)
        if expander is not None:
            pulumi.set(__self__, "expander", expander)
        if max_graceful_termination_sec is not None:
            pulumi.set(__self__, "max_graceful_termination_sec", max_graceful_termination_sec)
        if new_pod_scale_up_delay is not None:
            pulumi.set(__self__, "new_pod_scale_up_delay", new_pod_scale_up_delay)
        if scale_down_delay_after_add is not None:
            pulumi.set(__self__, "scale_down_delay_after_add", scale_down_delay_after_add)
        if scale_down_delay_after_delete is not None:
            pulumi.set(__self__, "scale_down_delay_after_delete", scale_down_delay_after_delete)
        if scale_down_delay_after_failure is not None:
            pulumi.set(__self__, "scale_down_delay_after_failure", scale_down_delay_after_failure)
        if scale_down_unneeded is not None:
            pulumi.set(__self__, "scale_down_unneeded", scale_down_unneeded)
        if scale_down_unready is not None:
            pulumi.set(__self__, "scale_down_unready", scale_down_unready)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)
        if scan_interval is not None:
            pulumi.set(__self__, "scan_interval", scan_interval)
        if skip_nodes_with_local_storage is not None:
            pulumi.set(__self__, "skip_nodes_with_local_storage", skip_nodes_with_local_storage)
        if skip_nodes_with_system_pods is not None:
            pulumi.set(__self__, "skip_nodes_with_system_pods", skip_nodes_with_system_pods)

    @property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> Optional[bool]:
        """
        Detect similar node groups and balance the number of nodes between them. Defaults to `false`.
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @property
    @pulumi.getter
    def expander(self) -> Optional[str]:
        """
        Expander to use. Possible values are `least-waste`, `priority`, `most-pods` and `random`. Defaults to `random`.
        """
        return pulumi.get(self, "expander")

    @property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> Optional[str]:
        """
        Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. Defaults to `600`.
        """
        return pulumi.get(self, "max_graceful_termination_sec")

    @property
    @pulumi.getter(name="newPodScaleUpDelay")
    def new_pod_scale_up_delay(self) -> Optional[str]:
        """
        For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. Defaults to `10s`.
        """
        return pulumi.get(self, "new_pod_scale_up_delay")

    @property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> Optional[str]:
        """
        How long after the scale up of AKS nodes the scale down evaluation resumes. Defaults to `10m`.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @property
    @pulumi.getter(name="scaleDownDelayAfterDelete")
    def scale_down_delay_after_delete(self) -> Optional[str]:
        """
        How long after node deletion that scale down evaluation resumes. Defaults to the value used for `scan_interval`.
        """
        return pulumi.get(self, "scale_down_delay_after_delete")

    @property
    @pulumi.getter(name="scaleDownDelayAfterFailure")
    def scale_down_delay_after_failure(self) -> Optional[str]:
        """
        How long after scale down failure that scale down evaluation resumes. Defaults to `3m`.
        """
        return pulumi.get(self, "scale_down_delay_after_failure")

    @property
    @pulumi.getter(name="scaleDownUnneeded")
    def scale_down_unneeded(self) -> Optional[str]:
        """
        How long a node should be unneeded before it is eligible for scale down. Defaults to `10m`.
        """
        return pulumi.get(self, "scale_down_unneeded")

    @property
    @pulumi.getter(name="scaleDownUnready")
    def scale_down_unready(self) -> Optional[str]:
        """
        How long an unready node should be unneeded before it is eligible for scale down. Defaults to `20m`.
        """
        return pulumi.get(self, "scale_down_unready")

    @property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[str]:
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. Defaults to `0.5`.
        """
        return pulumi.get(self, "scale_down_utilization_threshold")

    @property
    @pulumi.getter(name="scanInterval")
    def scan_interval(self) -> Optional[str]:
        """
        How often the AKS Cluster should be re-evaluated for scale up/down. Defaults to `10s`.
        """
        return pulumi.get(self, "scan_interval")

    @property
    @pulumi.getter(name="skipNodesWithLocalStorage")
    def skip_nodes_with_local_storage(self) -> Optional[bool]:
        """
        If `true` cluster autoscaler will never delete nodes with pods with local storage, for example, EmptyDir or HostPath. Defaults to `true`.
        """
        return pulumi.get(self, "skip_nodes_with_local_storage")

    @property
    @pulumi.getter(name="skipNodesWithSystemPods")
    def skip_nodes_with_system_pods(self) -> Optional[bool]:
        """
        If `true` cluster autoscaler will never delete nodes with pods from kube-system (except for DaemonSet or mirror pods). Defaults to `true`.
        """
        return pulumi.get(self, "skip_nodes_with_system_pods")


@pulumi.output_type
class KubernetesClusterDefaultNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "enableAutoScaling":
            suggest = "enable_auto_scaling"
        elif key == "enableHostEncryption":
            suggest = "enable_host_encryption"
        elif key == "enableNodePublicIp":
            suggest = "enable_node_public_ip"
        elif key == "maxCount":
            suggest = "max_count"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "minCount":
            suggest = "min_count"
        elif key == "nodeCount":
            suggest = "node_count"
        elif key == "nodeLabels":
            suggest = "node_labels"
        elif key == "nodeTaints":
            suggest = "node_taints"
        elif key == "onlyCriticalAddonsEnabled":
            suggest = "only_critical_addons_enabled"
        elif key == "orchestratorVersion":
            suggest = "orchestrator_version"
        elif key == "osDiskSizeGb":
            suggest = "os_disk_size_gb"
        elif key == "osDiskType":
            suggest = "os_disk_type"
        elif key == "proximityPlacementGroupId":
            suggest = "proximity_placement_group_id"
        elif key == "upgradeSettings":
            suggest = "upgrade_settings"
        elif key == "vnetSubnetId":
            suggest = "vnet_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterDefaultNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterDefaultNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterDefaultNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vm_size: str,
                 availability_zones: Optional[Sequence[str]] = None,
                 enable_auto_scaling: Optional[bool] = None,
                 enable_host_encryption: Optional[bool] = None,
                 enable_node_public_ip: Optional[bool] = None,
                 max_count: Optional[int] = None,
                 max_pods: Optional[int] = None,
                 min_count: Optional[int] = None,
                 node_count: Optional[int] = None,
                 node_labels: Optional[Mapping[str, str]] = None,
                 node_taints: Optional[Sequence[str]] = None,
                 only_critical_addons_enabled: Optional[bool] = None,
                 orchestrator_version: Optional[str] = None,
                 os_disk_size_gb: Optional[int] = None,
                 os_disk_type: Optional[str] = None,
                 proximity_placement_group_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 type: Optional[str] = None,
                 upgrade_settings: Optional['outputs.KubernetesClusterDefaultNodePoolUpgradeSettings'] = None,
                 vnet_subnet_id: Optional[str] = None):
        """
        :param str name: The name which should be used for the default Kubernetes Node Pool. Changing this forces a new resource to be created.
        :param str vm_size: The size of the Virtual Machine, such as `Standard_DS2_v2`.
        :param Sequence[str] availability_zones: A list of Availability Zones across which the Node Pool should be spread. Changing this forces a new resource to be created.
        :param bool enable_auto_scaling: Should [the Kubernetes Auto Scaler](https://docs.microsoft.com/en-us/azure/aks/cluster-autoscaler) be enabled for this Node Pool? Defaults to `false`.
        :param bool enable_host_encryption: Should the nodes in the Default Node Pool have host encryption enabled? Defaults to `false`.
        :param bool enable_node_public_ip: Should nodes in this Node Pool have a Public IP Address? Defaults to `false`.
        :param int max_count: The maximum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
        :param int max_pods: The maximum number of pods that can run on each agent. Changing this forces a new resource to be created.
        :param int min_count: The minimum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
        :param int node_count: The initial number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000` and between `min_count` and `max_count`.
        :param Mapping[str, str] node_labels: A map of Kubernetes labels which should be applied to nodes in the Default Node Pool. Changing this forces a new resource to be created.
        :param bool only_critical_addons_enabled: Enabling this option will taint default node pool with `CriticalAddonsOnly=true:NoSchedule` taint. Changing this forces a new resource to be created.
        :param str orchestrator_version: Version of Kubernetes used for the Agents. If not specified, the latest recommended version will be used at provisioning time (but won't auto-upgrade)
        :param int os_disk_size_gb: The size of the OS Disk which should be used for each agent in the Node Pool. Changing this forces a new resource to be created.
        :param str os_disk_type: The type of disk which should be used for the Operating System. Possible values are `Ephemeral` and `Managed`. Defaults to `Managed`. Changing this forces a new resource to be created.
        :param Mapping[str, str] tags: A mapping of tags to assign to the Node Pool.
        :param str type: The type of Node Pool which should be created. Possible values are `AvailabilitySet` and `VirtualMachineScaleSets`. Defaults to `VirtualMachineScaleSets`.
        :param 'KubernetesClusterDefaultNodePoolUpgradeSettingsArgs' upgrade_settings: A `upgrade_settings` block as documented below.
        :param str vnet_subnet_id: The ID of a Subnet where the Kubernetes Node Pool should exist. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vm_size", vm_size)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if enable_auto_scaling is not None:
            pulumi.set(__self__, "enable_auto_scaling", enable_auto_scaling)
        if enable_host_encryption is not None:
            pulumi.set(__self__, "enable_host_encryption", enable_host_encryption)
        if enable_node_public_ip is not None:
            pulumi.set(__self__, "enable_node_public_ip", enable_node_public_ip)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if node_labels is not None:
            pulumi.set(__self__, "node_labels", node_labels)
        if node_taints is not None:
            pulumi.set(__self__, "node_taints", node_taints)
        if only_critical_addons_enabled is not None:
            pulumi.set(__self__, "only_critical_addons_enabled", only_critical_addons_enabled)
        if orchestrator_version is not None:
            pulumi.set(__self__, "orchestrator_version", orchestrator_version)
        if os_disk_size_gb is not None:
            pulumi.set(__self__, "os_disk_size_gb", os_disk_size_gb)
        if os_disk_type is not None:
            pulumi.set(__self__, "os_disk_type", os_disk_type)
        if proximity_placement_group_id is not None:
            pulumi.set(__self__, "proximity_placement_group_id", proximity_placement_group_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if upgrade_settings is not None:
            pulumi.set(__self__, "upgrade_settings", upgrade_settings)
        if vnet_subnet_id is not None:
            pulumi.set(__self__, "vnet_subnet_id", vnet_subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name which should be used for the default Kubernetes Node Pool. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The size of the Virtual Machine, such as `Standard_DS2_v2`.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        """
        A list of Availability Zones across which the Node Pool should be spread. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="enableAutoScaling")
    def enable_auto_scaling(self) -> Optional[bool]:
        """
        Should [the Kubernetes Auto Scaler](https://docs.microsoft.com/en-us/azure/aks/cluster-autoscaler) be enabled for this Node Pool? Defaults to `false`.
        """
        return pulumi.get(self, "enable_auto_scaling")

    @property
    @pulumi.getter(name="enableHostEncryption")
    def enable_host_encryption(self) -> Optional[bool]:
        """
        Should the nodes in the Default Node Pool have host encryption enabled? Defaults to `false`.
        """
        return pulumi.get(self, "enable_host_encryption")

    @property
    @pulumi.getter(name="enableNodePublicIp")
    def enable_node_public_ip(self) -> Optional[bool]:
        """
        Should nodes in this Node Pool have a Public IP Address? Defaults to `false`.
        """
        return pulumi.get(self, "enable_node_public_ip")

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[int]:
        """
        The maximum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
        """
        return pulumi.get(self, "max_count")

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[int]:
        """
        The maximum number of pods that can run on each agent. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[int]:
        """
        The minimum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
        """
        return pulumi.get(self, "min_count")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        The initial number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000` and between `min_count` and `max_count`.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of Kubernetes labels which should be applied to nodes in the Default Node Pool. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "node_labels")

    @property
    @pulumi.getter(name="nodeTaints")
    def node_taints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "node_taints")

    @property
    @pulumi.getter(name="onlyCriticalAddonsEnabled")
    def only_critical_addons_enabled(self) -> Optional[bool]:
        """
        Enabling this option will taint default node pool with `CriticalAddonsOnly=true:NoSchedule` taint. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "only_critical_addons_enabled")

    @property
    @pulumi.getter(name="orchestratorVersion")
    def orchestrator_version(self) -> Optional[str]:
        """
        Version of Kubernetes used for the Agents. If not specified, the latest recommended version will be used at provisioning time (but won't auto-upgrade)
        """
        return pulumi.get(self, "orchestrator_version")

    @property
    @pulumi.getter(name="osDiskSizeGb")
    def os_disk_size_gb(self) -> Optional[int]:
        """
        The size of the OS Disk which should be used for each agent in the Node Pool. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "os_disk_size_gb")

    @property
    @pulumi.getter(name="osDiskType")
    def os_disk_type(self) -> Optional[str]:
        """
        The type of disk which should be used for the Operating System. Possible values are `Ephemeral` and `Managed`. Defaults to `Managed`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "os_disk_type")

    @property
    @pulumi.getter(name="proximityPlacementGroupId")
    def proximity_placement_group_id(self) -> Optional[str]:
        return pulumi.get(self, "proximity_placement_group_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        A mapping of tags to assign to the Node Pool.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of Node Pool which should be created. Possible values are `AvailabilitySet` and `VirtualMachineScaleSets`. Defaults to `VirtualMachineScaleSets`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="upgradeSettings")
    def upgrade_settings(self) -> Optional['outputs.KubernetesClusterDefaultNodePoolUpgradeSettings']:
        """
        A `upgrade_settings` block as documented below.
        """
        return pulumi.get(self, "upgrade_settings")

    @property
    @pulumi.getter(name="vnetSubnetId")
    def vnet_subnet_id(self) -> Optional[str]:
        """
        The ID of a Subnet where the Kubernetes Node Pool should exist. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "vnet_subnet_id")


@pulumi.output_type
class KubernetesClusterDefaultNodePoolUpgradeSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterDefaultNodePoolUpgradeSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterDefaultNodePoolUpgradeSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterDefaultNodePoolUpgradeSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: str):
        """
        :param str max_surge: The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        pulumi.set(__self__, "max_surge", max_surge)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> str:
        """
        The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        return pulumi.get(self, "max_surge")


@pulumi.output_type
class KubernetesClusterIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 principal_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 user_assigned_identity_id: Optional[str] = None):
        """
        :param str type: The type of identity used for the managed cluster. Possible values are `SystemAssigned` and `UserAssigned`. If `UserAssigned` is set, a `user_assigned_identity_id` must be set as well.
        :param str principal_id: The principal id of the system assigned identity which is used by master components.
        :param str tenant_id: The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        :param str user_assigned_identity_id: The ID of a user assigned identity.
        """
        pulumi.set(__self__, "type", type)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of identity used for the managed cluster. Possible values are `SystemAssigned` and `UserAssigned`. If `UserAssigned` is set, a `user_assigned_identity_id` must be set as well.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The principal id of the system assigned identity which is used by master components.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[str]:
        """
        The ID of a user assigned identity.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class KubernetesClusterKubeAdminConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKubeAdminConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKubeAdminConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKubeAdminConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 cluster_ca_certificate: Optional[str] = None,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param str client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param str cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param str host: The Kubernetes cluster server host.
        :param str password: A password or token used to authenticate to the Kubernetes cluster.
        :param str username: A username used to authenticate to the Kubernetes cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[str]:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KubernetesClusterKubeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKubeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKubeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKubeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 cluster_ca_certificate: Optional[str] = None,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param str client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param str cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param str host: The Kubernetes cluster server host.
        :param str password: A password or token used to authenticate to the Kubernetes cluster.
        :param str username: A username used to authenticate to the Kubernetes cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[str]:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KubernetesClusterKubeletIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKubeletIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKubeletIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKubeletIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 object_id: Optional[str] = None,
                 user_assigned_identity_id: Optional[str] = None):
        """
        :param str client_id: The Client ID for the Service Principal.
        :param str object_id: The Object ID of the user-defined Managed Identity used by the OMS Agents.
        :param str user_assigned_identity_id: The ID of a user assigned identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID for the Service Principal.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        The Object ID of the user-defined Managed Identity used by the OMS Agents.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[str]:
        """
        The ID of a user assigned identity.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class KubernetesClusterLinuxProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "sshKey":
            suggest = "ssh_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterLinuxProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterLinuxProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterLinuxProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: str,
                 ssh_key: 'outputs.KubernetesClusterLinuxProfileSshKey'):
        """
        :param str admin_username: The Admin Username for the Cluster. Changing this forces a new resource to be created.
        :param 'KubernetesClusterLinuxProfileSshKeyArgs' ssh_key: An `ssh_key` block. Only one is currently allowed. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "ssh_key", ssh_key)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        The Admin Username for the Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> 'outputs.KubernetesClusterLinuxProfileSshKey':
        """
        An `ssh_key` block. Only one is currently allowed. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "ssh_key")


@pulumi.output_type
class KubernetesClusterLinuxProfileSshKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyData":
            suggest = "key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterLinuxProfileSshKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterLinuxProfileSshKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterLinuxProfileSshKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_data: str):
        """
        :param str key_data: The Public SSH Key used to access the cluster. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "key_data", key_data)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> str:
        """
        The Public SSH Key used to access the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "key_data")


@pulumi.output_type
class KubernetesClusterNetworkProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkPlugin":
            suggest = "network_plugin"
        elif key == "dnsServiceIp":
            suggest = "dns_service_ip"
        elif key == "dockerBridgeCidr":
            suggest = "docker_bridge_cidr"
        elif key == "loadBalancerProfile":
            suggest = "load_balancer_profile"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "networkMode":
            suggest = "network_mode"
        elif key == "networkPolicy":
            suggest = "network_policy"
        elif key == "outboundType":
            suggest = "outbound_type"
        elif key == "podCidr":
            suggest = "pod_cidr"
        elif key == "serviceCidr":
            suggest = "service_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNetworkProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNetworkProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNetworkProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_plugin: str,
                 dns_service_ip: Optional[str] = None,
                 docker_bridge_cidr: Optional[str] = None,
                 load_balancer_profile: Optional['outputs.KubernetesClusterNetworkProfileLoadBalancerProfile'] = None,
                 load_balancer_sku: Optional[str] = None,
                 network_mode: Optional[str] = None,
                 network_policy: Optional[str] = None,
                 outbound_type: Optional[str] = None,
                 pod_cidr: Optional[str] = None,
                 service_cidr: Optional[str] = None):
        """
        :param str network_plugin: Network plugin to use for networking. Currently supported values are `azure` and `kubenet`. Changing this forces a new resource to be created.
        :param str dns_service_ip: IP address within the Kubernetes service address range that will be used by cluster service discovery (kube-dns). Changing this forces a new resource to be created.
        :param str docker_bridge_cidr: IP address (in CIDR notation) used as the Docker bridge IP address on nodes. Changing this forces a new resource to be created.
        :param 'KubernetesClusterNetworkProfileLoadBalancerProfileArgs' load_balancer_profile: A `load_balancer_profile` block. This can only be specified when `load_balancer_sku` is set to `Standard`.
        :param str load_balancer_sku: Specifies the SKU of the Load Balancer used for this Kubernetes Cluster. Possible values are `Basic` and `Standard`. Defaults to `Standard`.
        :param str network_mode: Network mode to be used with Azure CNI. Possible values are `bridge` and `transparent`. Changing this forces a new resource to be created.
        :param str network_policy: Sets up network policy to be used with Azure CNI. [Network policy allows us to control the traffic flow between pods](https://docs.microsoft.com/en-us/azure/aks/use-network-policies). Currently supported values are `calico` and `azure`. Changing this forces a new resource to be created.
        :param str outbound_type: The outbound (egress) routing method which should be used for this Kubernetes Cluster. Possible values are `loadBalancer` and `userDefinedRouting`. Defaults to `loadBalancer`.
        :param str pod_cidr: The CIDR to use for pod IP addresses. This field can only be set when `network_plugin` is set to `kubenet`. Changing this forces a new resource to be created.
        :param str service_cidr: The Network Range used by the Kubernetes service. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "network_plugin", network_plugin)
        if dns_service_ip is not None:
            pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        if docker_bridge_cidr is not None:
            pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        if load_balancer_profile is not None:
            pulumi.set(__self__, "load_balancer_profile", load_balancer_profile)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)

    @property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> str:
        """
        Network plugin to use for networking. Currently supported values are `azure` and `kubenet`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "network_plugin")

    @property
    @pulumi.getter(name="dnsServiceIp")
    def dns_service_ip(self) -> Optional[str]:
        """
        IP address within the Kubernetes service address range that will be used by cluster service discovery (kube-dns). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "dns_service_ip")

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[str]:
        """
        IP address (in CIDR notation) used as the Docker bridge IP address on nodes. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @property
    @pulumi.getter(name="loadBalancerProfile")
    def load_balancer_profile(self) -> Optional['outputs.KubernetesClusterNetworkProfileLoadBalancerProfile']:
        """
        A `load_balancer_profile` block. This can only be specified when `load_balancer_sku` is set to `Standard`.
        """
        return pulumi.get(self, "load_balancer_profile")

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[str]:
        """
        Specifies the SKU of the Load Balancer used for this Kubernetes Cluster. Possible values are `Basic` and `Standard`. Defaults to `Standard`.
        """
        return pulumi.get(self, "load_balancer_sku")

    @property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[str]:
        """
        Network mode to be used with Azure CNI. Possible values are `bridge` and `transparent`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "network_mode")

    @property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional[str]:
        """
        Sets up network policy to be used with Azure CNI. [Network policy allows us to control the traffic flow between pods](https://docs.microsoft.com/en-us/azure/aks/use-network-policies). Currently supported values are `calico` and `azure`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "network_policy")

    @property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[str]:
        """
        The outbound (egress) routing method which should be used for this Kubernetes Cluster. Possible values are `loadBalancer` and `userDefinedRouting`. Defaults to `loadBalancer`.
        """
        return pulumi.get(self, "outbound_type")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[str]:
        """
        The CIDR to use for pod IP addresses. This field can only be set when `network_plugin` is set to `kubenet`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[str]:
        """
        The Network Range used by the Kubernetes service. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "service_cidr")


@pulumi.output_type
class KubernetesClusterNetworkProfileLoadBalancerProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveOutboundIps":
            suggest = "effective_outbound_ips"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "managedOutboundIpCount":
            suggest = "managed_outbound_ip_count"
        elif key == "outboundIpAddressIds":
            suggest = "outbound_ip_address_ids"
        elif key == "outboundIpPrefixIds":
            suggest = "outbound_ip_prefix_ids"
        elif key == "outboundPortsAllocated":
            suggest = "outbound_ports_allocated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNetworkProfileLoadBalancerProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNetworkProfileLoadBalancerProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNetworkProfileLoadBalancerProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_outbound_ips: Optional[Sequence[str]] = None,
                 idle_timeout_in_minutes: Optional[int] = None,
                 managed_outbound_ip_count: Optional[int] = None,
                 outbound_ip_address_ids: Optional[Sequence[str]] = None,
                 outbound_ip_prefix_ids: Optional[Sequence[str]] = None,
                 outbound_ports_allocated: Optional[int] = None):
        """
        :param Sequence[str] effective_outbound_ips: The outcome (resource IDs) of the specified arguments.
        :param int idle_timeout_in_minutes: Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `120` inclusive. Defaults to `30`.
        :param int managed_outbound_ip_count: Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
        :param Sequence[str] outbound_ip_address_ids: The ID of the Public IP Addresses which should be used for outbound communication for the cluster load balancer.
        :param Sequence[str] outbound_ip_prefix_ids: The ID of the outbound Public IP Address Prefixes which should be used for the cluster load balancer.
        :param int outbound_ports_allocated: Number of desired SNAT port for each VM in the clusters load balancer. Must be between `0` and `64000` inclusive. Defaults to `0`.
        """
        if effective_outbound_ips is not None:
            pulumi.set(__self__, "effective_outbound_ips", effective_outbound_ips)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if managed_outbound_ip_count is not None:
            pulumi.set(__self__, "managed_outbound_ip_count", managed_outbound_ip_count)
        if outbound_ip_address_ids is not None:
            pulumi.set(__self__, "outbound_ip_address_ids", outbound_ip_address_ids)
        if outbound_ip_prefix_ids is not None:
            pulumi.set(__self__, "outbound_ip_prefix_ids", outbound_ip_prefix_ids)
        if outbound_ports_allocated is not None:
            pulumi.set(__self__, "outbound_ports_allocated", outbound_ports_allocated)

    @property
    @pulumi.getter(name="effectiveOutboundIps")
    def effective_outbound_ips(self) -> Optional[Sequence[str]]:
        """
        The outcome (resource IDs) of the specified arguments.
        """
        return pulumi.get(self, "effective_outbound_ips")

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[int]:
        """
        Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `120` inclusive. Defaults to `30`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @property
    @pulumi.getter(name="managedOutboundIpCount")
    def managed_outbound_ip_count(self) -> Optional[int]:
        """
        Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
        """
        return pulumi.get(self, "managed_outbound_ip_count")

    @property
    @pulumi.getter(name="outboundIpAddressIds")
    def outbound_ip_address_ids(self) -> Optional[Sequence[str]]:
        """
        The ID of the Public IP Addresses which should be used for outbound communication for the cluster load balancer.
        """
        return pulumi.get(self, "outbound_ip_address_ids")

    @property
    @pulumi.getter(name="outboundIpPrefixIds")
    def outbound_ip_prefix_ids(self) -> Optional[Sequence[str]]:
        """
        The ID of the outbound Public IP Address Prefixes which should be used for the cluster load balancer.
        """
        return pulumi.get(self, "outbound_ip_prefix_ids")

    @property
    @pulumi.getter(name="outboundPortsAllocated")
    def outbound_ports_allocated(self) -> Optional[int]:
        """
        Number of desired SNAT port for each VM in the clusters load balancer. Must be between `0` and `64000` inclusive. Defaults to `0`.
        """
        return pulumi.get(self, "outbound_ports_allocated")


@pulumi.output_type
class KubernetesClusterNodePoolUpgradeSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePoolUpgradeSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePoolUpgradeSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePoolUpgradeSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: str):
        """
        :param str max_surge: The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        pulumi.set(__self__, "max_surge", max_surge)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> str:
        """
        The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        return pulumi.get(self, "max_surge")


@pulumi.output_type
class KubernetesClusterRoleBasedAccessControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureActiveDirectory":
            suggest = "azure_active_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterRoleBasedAccessControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterRoleBasedAccessControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterRoleBasedAccessControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 azure_active_directory: Optional['outputs.KubernetesClusterRoleBasedAccessControlAzureActiveDirectory'] = None):
        """
        :param bool enabled: Is Role Based Access Control Enabled? Changing this forces a new resource to be created.
        :param 'KubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs' azure_active_directory: An `azure_active_directory` block.
        """
        pulumi.set(__self__, "enabled", enabled)
        if azure_active_directory is not None:
            pulumi.set(__self__, "azure_active_directory", azure_active_directory)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Role Based Access Control Enabled? Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="azureActiveDirectory")
    def azure_active_directory(self) -> Optional['outputs.KubernetesClusterRoleBasedAccessControlAzureActiveDirectory']:
        """
        An `azure_active_directory` block.
        """
        return pulumi.get(self, "azure_active_directory")


@pulumi.output_type
class KubernetesClusterRoleBasedAccessControlAzureActiveDirectory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminGroupObjectIds":
            suggest = "admin_group_object_ids"
        elif key == "clientAppId":
            suggest = "client_app_id"
        elif key == "serverAppId":
            suggest = "server_app_id"
        elif key == "serverAppSecret":
            suggest = "server_app_secret"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterRoleBasedAccessControlAzureActiveDirectory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterRoleBasedAccessControlAzureActiveDirectory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterRoleBasedAccessControlAzureActiveDirectory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_group_object_ids: Optional[Sequence[str]] = None,
                 client_app_id: Optional[str] = None,
                 managed: Optional[bool] = None,
                 server_app_id: Optional[str] = None,
                 server_app_secret: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param Sequence[str] admin_group_object_ids: A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
        :param str client_app_id: The Client ID of an Azure Active Directory Application.
        :param bool managed: Is the Azure Active Directory integration Managed, meaning that Azure will create/manage the Service Principal used for integration.
        :param str server_app_id: The Server ID of an Azure Active Directory Application.
        :param str server_app_secret: The Server Secret of an Azure Active Directory Application.
        :param str tenant_id: The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        """
        if admin_group_object_ids is not None:
            pulumi.set(__self__, "admin_group_object_ids", admin_group_object_ids)
        if client_app_id is not None:
            pulumi.set(__self__, "client_app_id", client_app_id)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if server_app_id is not None:
            pulumi.set(__self__, "server_app_id", server_app_id)
        if server_app_secret is not None:
            pulumi.set(__self__, "server_app_secret", server_app_secret)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="adminGroupObjectIds")
    def admin_group_object_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
        """
        return pulumi.get(self, "admin_group_object_ids")

    @property
    @pulumi.getter(name="clientAppId")
    def client_app_id(self) -> Optional[str]:
        """
        The Client ID of an Azure Active Directory Application.
        """
        return pulumi.get(self, "client_app_id")

    @property
    @pulumi.getter
    def managed(self) -> Optional[bool]:
        """
        Is the Azure Active Directory integration Managed, meaning that Azure will create/manage the Service Principal used for integration.
        """
        return pulumi.get(self, "managed")

    @property
    @pulumi.getter(name="serverAppId")
    def server_app_id(self) -> Optional[str]:
        """
        The Server ID of an Azure Active Directory Application.
        """
        return pulumi.get(self, "server_app_id")

    @property
    @pulumi.getter(name="serverAppSecret")
    def server_app_secret(self) -> Optional[str]:
        """
        The Server Secret of an Azure Active Directory Application.
        """
        return pulumi.get(self, "server_app_secret")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class KubernetesClusterServicePrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterServicePrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterServicePrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterServicePrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str):
        """
        :param str client_id: The Client ID for the Service Principal.
        :param str client_secret: The Client Secret for the Service Principal.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID for the Service Principal.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret for the Service Principal.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class KubernetesClusterWindowsProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "adminPassword":
            suggest = "admin_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterWindowsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterWindowsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterWindowsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: str,
                 admin_password: Optional[str] = None):
        """
        :param str admin_username: The Admin Username for Windows VMs.
        :param str admin_password: The Admin Password for Windows VMs. Length must be between 14 and 123 characters.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        The Admin Username for Windows VMs.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        The Admin Password for Windows VMs. Length must be between 14 and 123 characters.
        """
        return pulumi.get(self, "admin_password")


@pulumi.output_type
class RegistryNetworkRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultAction":
            suggest = "default_action"
        elif key == "ipRules":
            suggest = "ip_rules"
        elif key == "virtualNetworks":
            suggest = "virtual_networks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryNetworkRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryNetworkRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryNetworkRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_action: Optional[str] = None,
                 ip_rules: Optional[Sequence['outputs.RegistryNetworkRuleSetIpRule']] = None,
                 virtual_networks: Optional[Sequence['outputs.RegistryNetworkRuleSetVirtualNetwork']] = None):
        """
        :param str default_action: The behaviour for requests matching no rules. Either `Allow` or `Deny`. Defaults to `Allow`
        :param Sequence['RegistryNetworkRuleSetIpRuleArgs'] ip_rules: One or more `ip_rule` blocks as defined below.
        :param Sequence['RegistryNetworkRuleSetVirtualNetworkArgs'] virtual_networks: One or more `virtual_network` blocks as defined below.
        """
        if default_action is not None:
            pulumi.set(__self__, "default_action", default_action)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)
        if virtual_networks is not None:
            pulumi.set(__self__, "virtual_networks", virtual_networks)

    @property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> Optional[str]:
        """
        The behaviour for requests matching no rules. Either `Allow` or `Deny`. Defaults to `Allow`
        """
        return pulumi.get(self, "default_action")

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[Sequence['outputs.RegistryNetworkRuleSetIpRule']]:
        """
        One or more `ip_rule` blocks as defined below.
        """
        return pulumi.get(self, "ip_rules")

    @property
    @pulumi.getter(name="virtualNetworks")
    def virtual_networks(self) -> Optional[Sequence['outputs.RegistryNetworkRuleSetVirtualNetwork']]:
        """
        One or more `virtual_network` blocks as defined below.
        """
        return pulumi.get(self, "virtual_networks")


@pulumi.output_type
class RegistryNetworkRuleSetIpRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryNetworkRuleSetIpRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryNetworkRuleSetIpRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryNetworkRuleSetIpRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 ip_range: str):
        """
        :param str action: The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        :param str ip_range: The CIDR block from which requests will match the rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip_range", ip_range)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> str:
        """
        The CIDR block from which requests will match the rule.
        """
        return pulumi.get(self, "ip_range")


@pulumi.output_type
class RegistryNetworkRuleSetVirtualNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryNetworkRuleSetVirtualNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryNetworkRuleSetVirtualNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryNetworkRuleSetVirtualNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 subnet_id: str):
        """
        :param str action: The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        :param str subnet_id: The subnet id from which requests will match the rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The subnet id from which requests will match the rule.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class RegistryRetentionPolicy(dict):
    def __init__(__self__, *,
                 days: Optional[int] = None,
                 enabled: Optional[bool] = None):
        """
        :param int days: The number of days to retain an untagged manifest after which it gets purged. Default is `7`.
        :param bool enabled: Boolean value that indicates whether the policy is enabled.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        The number of days to retain an untagged manifest after which it gets purged. Default is `7`.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Boolean value that indicates whether the policy is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RegistryTrustPolicy(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Boolean value that indicates whether the policy is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Boolean value that indicates whether the policy is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterNodePoolUpgradeSettingResult(dict):
    def __init__(__self__, *,
                 max_surge: str):
        """
        :param str max_surge: The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        pulumi.set(__self__, "max_surge", max_surge)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> str:
        """
        The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        return pulumi.get(self, "max_surge")


@pulumi.output_type
class GetKubernetesClusterAddonProfileResult(dict):
    def __init__(__self__, *,
                 azure_policies: Sequence['outputs.GetKubernetesClusterAddonProfileAzurePolicyResult'],
                 http_application_routings: Sequence['outputs.GetKubernetesClusterAddonProfileHttpApplicationRoutingResult'],
                 kube_dashboards: Sequence['outputs.GetKubernetesClusterAddonProfileKubeDashboardResult'],
                 oms_agents: Sequence['outputs.GetKubernetesClusterAddonProfileOmsAgentResult']):
        """
        :param Sequence['GetKubernetesClusterAddonProfileAzurePolicyArgs'] azure_policies: A `azure_policy` block.
        :param Sequence['GetKubernetesClusterAddonProfileHttpApplicationRoutingArgs'] http_application_routings: A `http_application_routing` block.
        :param Sequence['GetKubernetesClusterAddonProfileKubeDashboardArgs'] kube_dashboards: A `kube_dashboard` block.
        :param Sequence['GetKubernetesClusterAddonProfileOmsAgentArgs'] oms_agents: A `oms_agent` block.
        """
        pulumi.set(__self__, "azure_policies", azure_policies)
        pulumi.set(__self__, "http_application_routings", http_application_routings)
        pulumi.set(__self__, "kube_dashboards", kube_dashboards)
        pulumi.set(__self__, "oms_agents", oms_agents)

    @property
    @pulumi.getter(name="azurePolicies")
    def azure_policies(self) -> Sequence['outputs.GetKubernetesClusterAddonProfileAzurePolicyResult']:
        """
        A `azure_policy` block.
        """
        return pulumi.get(self, "azure_policies")

    @property
    @pulumi.getter(name="httpApplicationRoutings")
    def http_application_routings(self) -> Sequence['outputs.GetKubernetesClusterAddonProfileHttpApplicationRoutingResult']:
        """
        A `http_application_routing` block.
        """
        return pulumi.get(self, "http_application_routings")

    @property
    @pulumi.getter(name="kubeDashboards")
    def kube_dashboards(self) -> Sequence['outputs.GetKubernetesClusterAddonProfileKubeDashboardResult']:
        """
        A `kube_dashboard` block.
        """
        return pulumi.get(self, "kube_dashboards")

    @property
    @pulumi.getter(name="omsAgents")
    def oms_agents(self) -> Sequence['outputs.GetKubernetesClusterAddonProfileOmsAgentResult']:
        """
        A `oms_agent` block.
        """
        return pulumi.get(self, "oms_agents")


@pulumi.output_type
class GetKubernetesClusterAddonProfileAzurePolicyResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Is Role Based Access Control enabled?
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Role Based Access Control enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetKubernetesClusterAddonProfileHttpApplicationRoutingResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 http_application_routing_zone_name: str):
        """
        :param bool enabled: Is Role Based Access Control enabled?
        :param str http_application_routing_zone_name: The Zone Name of the HTTP Application Routing.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "http_application_routing_zone_name", http_application_routing_zone_name)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Role Based Access Control enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="httpApplicationRoutingZoneName")
    def http_application_routing_zone_name(self) -> str:
        """
        The Zone Name of the HTTP Application Routing.
        """
        return pulumi.get(self, "http_application_routing_zone_name")


@pulumi.output_type
class GetKubernetesClusterAddonProfileKubeDashboardResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Is Role Based Access Control enabled?
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Role Based Access Control enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetKubernetesClusterAddonProfileOmsAgentResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 log_analytics_workspace_id: str,
                 oms_agent_identities: Sequence['outputs.GetKubernetesClusterAddonProfileOmsAgentOmsAgentIdentityResult']):
        """
        :param bool enabled: Is Role Based Access Control enabled?
        :param str log_analytics_workspace_id: The ID of the Log Analytics Workspace which the OMS Agent should send data to.
        :param Sequence['GetKubernetesClusterAddonProfileOmsAgentOmsAgentIdentityArgs'] oms_agent_identities: An `oms_agent_identity` block as defined below.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)
        pulumi.set(__self__, "oms_agent_identities", oms_agent_identities)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Role Based Access Control enabled?
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> str:
        """
        The ID of the Log Analytics Workspace which the OMS Agent should send data to.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @property
    @pulumi.getter(name="omsAgentIdentities")
    def oms_agent_identities(self) -> Sequence['outputs.GetKubernetesClusterAddonProfileOmsAgentOmsAgentIdentityResult']:
        """
        An `oms_agent_identity` block as defined below.
        """
        return pulumi.get(self, "oms_agent_identities")


@pulumi.output_type
class GetKubernetesClusterAddonProfileOmsAgentOmsAgentIdentityResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 object_id: str,
                 user_assigned_identity_id: str):
        """
        :param str client_id: The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        :param str object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        :param str user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> str:
        """
        The ID of the User Assigned Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class GetKubernetesClusterAgentPoolProfileResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[str],
                 count: int,
                 enable_auto_scaling: bool,
                 enable_node_public_ip: bool,
                 max_count: int,
                 max_pods: int,
                 min_count: int,
                 name: str,
                 node_labels: Mapping[str, str],
                 node_taints: Sequence[str],
                 orchestrator_version: str,
                 os_disk_size_gb: int,
                 os_type: str,
                 tags: Mapping[str, str],
                 type: str,
                 upgrade_settings: Sequence['outputs.GetKubernetesClusterAgentPoolProfileUpgradeSettingResult'],
                 vm_size: str,
                 vnet_subnet_id: str):
        """
        :param Sequence[str] availability_zones: The availability zones used for the nodes.
        :param int count: The number of Agents (VM's) in the Pool.
        :param bool enable_auto_scaling: If the auto-scaler is enabled.
        :param int max_count: Maximum number of nodes for auto-scaling
        :param int max_pods: The maximum number of pods that can run on each agent.
        :param int min_count: Minimum number of nodes for auto-scaling
        :param str name: The name of the managed Kubernetes Cluster.
        :param str orchestrator_version: Kubernetes version used for the Agents.
        :param int os_disk_size_gb: The size of the Agent VM's Operating System Disk in GB.
        :param str os_type: The Operating System used for the Agents.
        :param Mapping[str, str] tags: A mapping of tags to assign to the resource.
        :param str type: The type of identity used for the managed cluster.
        :param Sequence['GetKubernetesClusterAgentPoolProfileUpgradeSettingArgs'] upgrade_settings: A `upgrade_settings` block as documented below.
        :param str vm_size: The size of each VM in the Agent Pool (e.g. `Standard_F1`).
        :param str vnet_subnet_id: The ID of the Subnet where the Agents in the Pool are provisioned.
        """
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "enable_auto_scaling", enable_auto_scaling)
        pulumi.set(__self__, "enable_node_public_ip", enable_node_public_ip)
        pulumi.set(__self__, "max_count", max_count)
        pulumi.set(__self__, "max_pods", max_pods)
        pulumi.set(__self__, "min_count", min_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_labels", node_labels)
        pulumi.set(__self__, "node_taints", node_taints)
        pulumi.set(__self__, "orchestrator_version", orchestrator_version)
        pulumi.set(__self__, "os_disk_size_gb", os_disk_size_gb)
        pulumi.set(__self__, "os_type", os_type)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "upgrade_settings", upgrade_settings)
        pulumi.set(__self__, "vm_size", vm_size)
        pulumi.set(__self__, "vnet_subnet_id", vnet_subnet_id)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[str]:
        """
        The availability zones used for the nodes.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of Agents (VM's) in the Pool.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="enableAutoScaling")
    def enable_auto_scaling(self) -> bool:
        """
        If the auto-scaler is enabled.
        """
        return pulumi.get(self, "enable_auto_scaling")

    @property
    @pulumi.getter(name="enableNodePublicIp")
    def enable_node_public_ip(self) -> bool:
        return pulumi.get(self, "enable_node_public_ip")

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> int:
        """
        Maximum number of nodes for auto-scaling
        """
        return pulumi.get(self, "max_count")

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> int:
        """
        The maximum number of pods that can run on each agent.
        """
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="minCount")
    def min_count(self) -> int:
        """
        Minimum number of nodes for auto-scaling
        """
        return pulumi.get(self, "min_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the managed Kubernetes Cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "node_labels")

    @property
    @pulumi.getter(name="nodeTaints")
    def node_taints(self) -> Sequence[str]:
        return pulumi.get(self, "node_taints")

    @property
    @pulumi.getter(name="orchestratorVersion")
    def orchestrator_version(self) -> str:
        """
        Kubernetes version used for the Agents.
        """
        return pulumi.get(self, "orchestrator_version")

    @property
    @pulumi.getter(name="osDiskSizeGb")
    def os_disk_size_gb(self) -> int:
        """
        The size of the Agent VM's Operating System Disk in GB.
        """
        return pulumi.get(self, "os_disk_size_gb")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> str:
        """
        The Operating System used for the Agents.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of identity used for the managed cluster.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="upgradeSettings")
    def upgrade_settings(self) -> Sequence['outputs.GetKubernetesClusterAgentPoolProfileUpgradeSettingResult']:
        """
        A `upgrade_settings` block as documented below.
        """
        return pulumi.get(self, "upgrade_settings")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The size of each VM in the Agent Pool (e.g. `Standard_F1`).
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter(name="vnetSubnetId")
    def vnet_subnet_id(self) -> str:
        """
        The ID of the Subnet where the Agents in the Pool are provisioned.
        """
        return pulumi.get(self, "vnet_subnet_id")


@pulumi.output_type
class GetKubernetesClusterAgentPoolProfileUpgradeSettingResult(dict):
    def __init__(__self__, *,
                 max_surge: str):
        """
        :param str max_surge: The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        pulumi.set(__self__, "max_surge", max_surge)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> str:
        """
        The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        return pulumi.get(self, "max_surge")


@pulumi.output_type
class GetKubernetesClusterIdentityResult(dict):
    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identity_id: str):
        """
        :param str principal_id: The principal id of the system assigned identity which is used by primary components.
        :param str tenant_id: The tenant id of the system assigned identity which is used by primary components.
        :param str type: The type of identity used for the managed cluster.
        :param str user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of the system assigned identity which is used by primary components.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant id of the system assigned identity which is used by primary components.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of identity used for the managed cluster.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> str:
        """
        The ID of the User Assigned Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class GetKubernetesClusterKubeAdminConfigResult(dict):
    def __init__(__self__, *,
                 client_certificate: str,
                 client_key: str,
                 cluster_ca_certificate: str,
                 host: str,
                 password: str,
                 username: str):
        """
        :param str client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param str client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param str cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param str host: The Kubernetes cluster server host.
        :param str password: A password or token used to authenticate to the Kubernetes cluster.
        :param str username: A username used to authenticate to the Kubernetes cluster.
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> str:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> str:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> str:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetKubernetesClusterKubeConfigResult(dict):
    def __init__(__self__, *,
                 client_certificate: str,
                 client_key: str,
                 cluster_ca_certificate: str,
                 host: str,
                 password: str,
                 username: str):
        """
        :param str client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param str client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param str cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param str host: The Kubernetes cluster server host.
        :param str password: A password or token used to authenticate to the Kubernetes cluster.
        :param str username: A username used to authenticate to the Kubernetes cluster.
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> str:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> str:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> str:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetKubernetesClusterKubeletIdentityResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 object_id: str,
                 user_assigned_identity_id: str):
        """
        :param str client_id: The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        :param str object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        :param str user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> str:
        """
        The ID of the User Assigned Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class GetKubernetesClusterLinuxProfileResult(dict):
    def __init__(__self__, *,
                 admin_username: str,
                 ssh_keys: Sequence['outputs.GetKubernetesClusterLinuxProfileSshKeyResult']):
        """
        :param str admin_username: The username associated with the administrator account of the Windows VMs.
        :param Sequence['GetKubernetesClusterLinuxProfileSshKeyArgs'] ssh_keys: An `ssh_key` block as defined below.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "ssh_keys", ssh_keys)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        The username associated with the administrator account of the Windows VMs.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence['outputs.GetKubernetesClusterLinuxProfileSshKeyResult']:
        """
        An `ssh_key` block as defined below.
        """
        return pulumi.get(self, "ssh_keys")


@pulumi.output_type
class GetKubernetesClusterLinuxProfileSshKeyResult(dict):
    def __init__(__self__, *,
                 key_data: str):
        """
        :param str key_data: The Public SSH Key used to access the cluster.
        """
        pulumi.set(__self__, "key_data", key_data)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> str:
        """
        The Public SSH Key used to access the cluster.
        """
        return pulumi.get(self, "key_data")


@pulumi.output_type
class GetKubernetesClusterNetworkProfileResult(dict):
    def __init__(__self__, *,
                 dns_service_ip: str,
                 docker_bridge_cidr: str,
                 load_balancer_sku: str,
                 network_plugin: str,
                 network_policy: str,
                 pod_cidr: str,
                 service_cidr: str):
        """
        :param str dns_service_ip: IP address within the Kubernetes service address range used by cluster service discovery (kube-dns).
        :param str docker_bridge_cidr: IP address (in CIDR notation) used as the Docker bridge IP address on nodes.
        :param str network_plugin: Network plugin used such as `azure` or `kubenet`.
        :param str network_policy: Network policy to be used with Azure CNI. Eg: `calico` or `azure`
        :param str pod_cidr: The CIDR used for pod IP addresses.
        :param str service_cidr: Network range used by the Kubernetes service.
        """
        pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        pulumi.set(__self__, "network_plugin", network_plugin)
        pulumi.set(__self__, "network_policy", network_policy)
        pulumi.set(__self__, "pod_cidr", pod_cidr)
        pulumi.set(__self__, "service_cidr", service_cidr)

    @property
    @pulumi.getter(name="dnsServiceIp")
    def dns_service_ip(self) -> str:
        """
        IP address within the Kubernetes service address range used by cluster service discovery (kube-dns).
        """
        return pulumi.get(self, "dns_service_ip")

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> str:
        """
        IP address (in CIDR notation) used as the Docker bridge IP address on nodes.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> str:
        return pulumi.get(self, "load_balancer_sku")

    @property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> str:
        """
        Network plugin used such as `azure` or `kubenet`.
        """
        return pulumi.get(self, "network_plugin")

    @property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> str:
        """
        Network policy to be used with Azure CNI. Eg: `calico` or `azure`
        """
        return pulumi.get(self, "network_policy")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> str:
        """
        The CIDR used for pod IP addresses.
        """
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> str:
        """
        Network range used by the Kubernetes service.
        """
        return pulumi.get(self, "service_cidr")


@pulumi.output_type
class GetKubernetesClusterRoleBasedAccessControlResult(dict):
    def __init__(__self__, *,
                 azure_active_directories: Sequence['outputs.GetKubernetesClusterRoleBasedAccessControlAzureActiveDirectoryResult'],
                 enabled: bool):
        """
        :param Sequence['GetKubernetesClusterRoleBasedAccessControlAzureActiveDirectoryArgs'] azure_active_directories: A `azure_active_directory` block as documented above.
        :param bool enabled: Is Role Based Access Control enabled?
        """
        pulumi.set(__self__, "azure_active_directories", azure_active_directories)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="azureActiveDirectories")
    def azure_active_directories(self) -> Sequence['outputs.GetKubernetesClusterRoleBasedAccessControlAzureActiveDirectoryResult']:
        """
        A `azure_active_directory` block as documented above.
        """
        return pulumi.get(self, "azure_active_directories")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Is Role Based Access Control enabled?
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetKubernetesClusterRoleBasedAccessControlAzureActiveDirectoryResult(dict):
    def __init__(__self__, *,
                 admin_group_object_ids: Sequence[str],
                 client_app_id: str,
                 managed: bool,
                 server_app_id: str,
                 tenant_id: str):
        """
        :param Sequence[str] admin_group_object_ids: The list of Object IDs of Azure Active Directory Groups which have Admin Role on the Cluster (when using a Managed integration).
        :param str client_app_id: The Client ID of an Azure Active Directory Application.
        :param bool managed: Is the Azure Active Directory Integration managed (also known as AAD Integration V2)?
        :param str server_app_id: The Server ID of an Azure Active Directory Application.
        :param str tenant_id: The tenant id of the system assigned identity which is used by primary components.
        """
        pulumi.set(__self__, "admin_group_object_ids", admin_group_object_ids)
        pulumi.set(__self__, "client_app_id", client_app_id)
        pulumi.set(__self__, "managed", managed)
        pulumi.set(__self__, "server_app_id", server_app_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="adminGroupObjectIds")
    def admin_group_object_ids(self) -> Sequence[str]:
        """
        The list of Object IDs of Azure Active Directory Groups which have Admin Role on the Cluster (when using a Managed integration).
        """
        return pulumi.get(self, "admin_group_object_ids")

    @property
    @pulumi.getter(name="clientAppId")
    def client_app_id(self) -> str:
        """
        The Client ID of an Azure Active Directory Application.
        """
        return pulumi.get(self, "client_app_id")

    @property
    @pulumi.getter
    def managed(self) -> bool:
        """
        Is the Azure Active Directory Integration managed (also known as AAD Integration V2)?
        """
        return pulumi.get(self, "managed")

    @property
    @pulumi.getter(name="serverAppId")
    def server_app_id(self) -> str:
        """
        The Server ID of an Azure Active Directory Application.
        """
        return pulumi.get(self, "server_app_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant id of the system assigned identity which is used by primary components.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetKubernetesClusterServicePrincipalResult(dict):
    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class GetKubernetesClusterWindowsProfileResult(dict):
    def __init__(__self__, *,
                 admin_username: str):
        """
        :param str admin_username: The username associated with the administrator account of the Windows VMs.
        """
        pulumi.set(__self__, "admin_username", admin_username)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        The username associated with the administrator account of the Windows VMs.
        """
        return pulumi.get(self, "admin_username")


