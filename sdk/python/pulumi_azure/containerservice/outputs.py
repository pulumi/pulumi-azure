# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ConnectedRegistryNotification',
    'FleetUpdateRunManagedClusterUpdate',
    'FleetUpdateRunManagedClusterUpdateNodeImageSelection',
    'FleetUpdateRunManagedClusterUpdateUpgrade',
    'FleetUpdateRunStage',
    'FleetUpdateRunStageGroup',
    'FleetUpdateStrategyStage',
    'FleetUpdateStrategyStageGroup',
    'FluxConfigurationBlobStorage',
    'FluxConfigurationBlobStorageManagedIdentity',
    'FluxConfigurationBlobStorageServicePrincipal',
    'FluxConfigurationBucket',
    'FluxConfigurationGitRepository',
    'FluxConfigurationKustomization',
    'FluxConfigurationKustomizationPostBuild',
    'FluxConfigurationKustomizationPostBuildSubstituteFrom',
    'GroupContainer',
    'GroupContainerLivenessProbe',
    'GroupContainerLivenessProbeHttpGet',
    'GroupContainerPort',
    'GroupContainerReadinessProbe',
    'GroupContainerReadinessProbeHttpGet',
    'GroupContainerSecurity',
    'GroupContainerVolume',
    'GroupContainerVolumeGitRepo',
    'GroupDiagnostics',
    'GroupDiagnosticsLogAnalytics',
    'GroupDnsConfig',
    'GroupExposedPort',
    'GroupIdentity',
    'GroupImageRegistryCredential',
    'GroupInitContainer',
    'GroupInitContainerSecurity',
    'GroupInitContainerVolume',
    'GroupInitContainerVolumeGitRepo',
    'KubernetesClusterAciConnectorLinux',
    'KubernetesClusterAciConnectorLinuxConnectorIdentity',
    'KubernetesClusterApiServerAccessProfile',
    'KubernetesClusterAutoScalerProfile',
    'KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl',
    'KubernetesClusterBootstrapProfile',
    'KubernetesClusterConfidentialComputing',
    'KubernetesClusterDefaultNodePool',
    'KubernetesClusterDefaultNodePoolKubeletConfig',
    'KubernetesClusterDefaultNodePoolLinuxOsConfig',
    'KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig',
    'KubernetesClusterDefaultNodePoolNodeNetworkProfile',
    'KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPort',
    'KubernetesClusterDefaultNodePoolUpgradeSettings',
    'KubernetesClusterExtensionAksAssignedIdentity',
    'KubernetesClusterExtensionPlan',
    'KubernetesClusterHttpProxyConfig',
    'KubernetesClusterIdentity',
    'KubernetesClusterIngressApplicationGateway',
    'KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity',
    'KubernetesClusterKeyManagementService',
    'KubernetesClusterKeyVaultSecretsProvider',
    'KubernetesClusterKeyVaultSecretsProviderSecretIdentity',
    'KubernetesClusterKubeAdminConfig',
    'KubernetesClusterKubeConfig',
    'KubernetesClusterKubeletIdentity',
    'KubernetesClusterLinuxProfile',
    'KubernetesClusterLinuxProfileSshKey',
    'KubernetesClusterMaintenanceWindow',
    'KubernetesClusterMaintenanceWindowAllowed',
    'KubernetesClusterMaintenanceWindowAutoUpgrade',
    'KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowed',
    'KubernetesClusterMaintenanceWindowNodeOs',
    'KubernetesClusterMaintenanceWindowNodeOsNotAllowed',
    'KubernetesClusterMaintenanceWindowNotAllowed',
    'KubernetesClusterMicrosoftDefender',
    'KubernetesClusterMonitorMetrics',
    'KubernetesClusterNetworkProfile',
    'KubernetesClusterNetworkProfileAdvancedNetworking',
    'KubernetesClusterNetworkProfileLoadBalancerProfile',
    'KubernetesClusterNetworkProfileNatGatewayProfile',
    'KubernetesClusterNodePoolKubeletConfig',
    'KubernetesClusterNodePoolLinuxOsConfig',
    'KubernetesClusterNodePoolLinuxOsConfigSysctlConfig',
    'KubernetesClusterNodePoolNodeNetworkProfile',
    'KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPort',
    'KubernetesClusterNodePoolUpgradeSettings',
    'KubernetesClusterNodePoolWindowsProfile',
    'KubernetesClusterNodeProvisioningProfile',
    'KubernetesClusterOmsAgent',
    'KubernetesClusterOmsAgentOmsAgentIdentity',
    'KubernetesClusterServiceMeshProfile',
    'KubernetesClusterServiceMeshProfileCertificateAuthority',
    'KubernetesClusterServicePrincipal',
    'KubernetesClusterStorageProfile',
    'KubernetesClusterUpgradeOverride',
    'KubernetesClusterWebAppRouting',
    'KubernetesClusterWebAppRoutingWebAppRoutingIdentity',
    'KubernetesClusterWindowsProfile',
    'KubernetesClusterWindowsProfileGmsa',
    'KubernetesClusterWorkloadAutoscalerProfile',
    'KubernetesFleetManagerHubProfile',
    'RegistryCredentialSetAuthenticationCredentials',
    'RegistryCredentialSetIdentity',
    'RegistryEncryption',
    'RegistryGeoreplication',
    'RegistryIdentity',
    'RegistryNetworkRuleSet',
    'RegistryNetworkRuleSetIpRule',
    'RegistryTaskAgentSetting',
    'RegistryTaskBaseImageTrigger',
    'RegistryTaskDockerStep',
    'RegistryTaskEncodedStep',
    'RegistryTaskFileStep',
    'RegistryTaskIdentity',
    'RegistryTaskPlatform',
    'RegistryTaskRegistryCredential',
    'RegistryTaskRegistryCredentialCustom',
    'RegistryTaskRegistryCredentialSource',
    'RegistryTaskSourceTrigger',
    'RegistryTaskSourceTriggerAuthentication',
    'RegistryTaskTimerTrigger',
    'TokenPasswordPassword1',
    'TokenPasswordPassword2',
    'GetClusterNodePoolUpgradeSettingResult',
    'GetGroupIdentityResult',
    'GetKubernetesClusterAciConnectorLinuxResult',
    'GetKubernetesClusterAgentPoolProfileResult',
    'GetKubernetesClusterAgentPoolProfileUpgradeSettingResult',
    'GetKubernetesClusterAzureActiveDirectoryRoleBasedAccessControlResult',
    'GetKubernetesClusterIdentityResult',
    'GetKubernetesClusterIngressApplicationGatewayResult',
    'GetKubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityResult',
    'GetKubernetesClusterKeyManagementServiceResult',
    'GetKubernetesClusterKeyVaultSecretsProviderResult',
    'GetKubernetesClusterKeyVaultSecretsProviderSecretIdentityResult',
    'GetKubernetesClusterKubeAdminConfigResult',
    'GetKubernetesClusterKubeConfigResult',
    'GetKubernetesClusterKubeletIdentityResult',
    'GetKubernetesClusterLinuxProfileResult',
    'GetKubernetesClusterLinuxProfileSshKeyResult',
    'GetKubernetesClusterMicrosoftDefenderResult',
    'GetKubernetesClusterNetworkProfileResult',
    'GetKubernetesClusterOmsAgentResult',
    'GetKubernetesClusterOmsAgentOmsAgentIdentityResult',
    'GetKubernetesClusterServiceMeshProfileResult',
    'GetKubernetesClusterServiceMeshProfileCertificateAuthorityResult',
    'GetKubernetesClusterServicePrincipalResult',
    'GetKubernetesClusterStorageProfileResult',
    'GetKubernetesClusterWindowsProfileResult',
]

@pulumi.output_type
class ConnectedRegistryNotification(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 name: _builtins.str,
                 digest: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: The action of the artifact that wants to be subscribed for the Connected Registry. Possible values are `push`, `delete` and `*` (i.e. any).
        :param _builtins.str name: The name of the artifact that wants to be subscribed for the Connected Registry.
        :param _builtins.str digest: The digest of the artifact that wants to be subscribed for the Connected Registry.
               
               > **Note:** One of either `tag` or `digest` can be specified.
        :param _builtins.str tag: The tag of the artifact that wants to be subscribed for the Connected Registry.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action of the artifact that wants to be subscribed for the Connected Registry. Possible values are `push`, `delete` and `*` (i.e. any).
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the artifact that wants to be subscribed for the Connected Registry.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[_builtins.str]:
        """
        The digest of the artifact that wants to be subscribed for the Connected Registry.

        > **Note:** One of either `tag` or `digest` can be specified.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        The tag of the artifact that wants to be subscribed for the Connected Registry.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class FleetUpdateRunManagedClusterUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeImageSelection":
            suggest = "node_image_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetUpdateRunManagedClusterUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetUpdateRunManagedClusterUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetUpdateRunManagedClusterUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 upgrade: 'outputs.FleetUpdateRunManagedClusterUpdateUpgrade',
                 node_image_selection: Optional['outputs.FleetUpdateRunManagedClusterUpdateNodeImageSelection'] = None):
        """
        :param 'FleetUpdateRunManagedClusterUpdateUpgradeArgs' upgrade: A `upgrade` block as defined below.
        :param 'FleetUpdateRunManagedClusterUpdateNodeImageSelectionArgs' node_image_selection: A `node_image_selection` block as defined below.
        """
        pulumi.set(__self__, "upgrade", upgrade)
        if node_image_selection is not None:
            pulumi.set(__self__, "node_image_selection", node_image_selection)

    @_builtins.property
    @pulumi.getter
    def upgrade(self) -> 'outputs.FleetUpdateRunManagedClusterUpdateUpgrade':
        """
        A `upgrade` block as defined below.
        """
        return pulumi.get(self, "upgrade")

    @_builtins.property
    @pulumi.getter(name="nodeImageSelection")
    def node_image_selection(self) -> Optional['outputs.FleetUpdateRunManagedClusterUpdateNodeImageSelection']:
        """
        A `node_image_selection` block as defined below.
        """
        return pulumi.get(self, "node_image_selection")


@pulumi.output_type
class FleetUpdateRunManagedClusterUpdateNodeImageSelection(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Specifies the node image upgrade type. Possible values are `Latest` and `Consistent`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the node image upgrade type. Possible values are `Latest` and `Consistent`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FleetUpdateRunManagedClusterUpdateUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubernetesVersion":
            suggest = "kubernetes_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetUpdateRunManagedClusterUpdateUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetUpdateRunManagedClusterUpdateUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetUpdateRunManagedClusterUpdateUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 kubernetes_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the type of upgrade to perform. Possible values are `Full` and `NodeImageOnly`.
        :param _builtins.str kubernetes_version: Specifies the Kubernetes version to upgrade the member clusters to. This is required if `type` is set to `Full`.
        """
        pulumi.set(__self__, "type", type)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of upgrade to perform. Possible values are `Full` and `NodeImageOnly`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        """
        Specifies the Kubernetes version to upgrade the member clusters to. This is required if `type` is set to `Full`.
        """
        return pulumi.get(self, "kubernetes_version")


@pulumi.output_type
class FleetUpdateRunStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterStageWaitInSeconds":
            suggest = "after_stage_wait_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetUpdateRunStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetUpdateRunStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetUpdateRunStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 groups: Sequence['outputs.FleetUpdateRunStageGroup'],
                 name: _builtins.str,
                 after_stage_wait_in_seconds: Optional[_builtins.int] = None):
        """
        :param Sequence['FleetUpdateRunStageGroupArgs'] groups: One or more `group` blocks as defined below.
        :param _builtins.str name: The name which should be used for this stage.
        :param _builtins.int after_stage_wait_in_seconds: Specifies the time in seconds to wait at the end of this stage before starting the next one.
        """
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "name", name)
        if after_stage_wait_in_seconds is not None:
            pulumi.set(__self__, "after_stage_wait_in_seconds", after_stage_wait_in_seconds)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.FleetUpdateRunStageGroup']:
        """
        One or more `group` blocks as defined below.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name which should be used for this stage.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="afterStageWaitInSeconds")
    def after_stage_wait_in_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the time in seconds to wait at the end of this stage before starting the next one.
        """
        return pulumi.get(self, "after_stage_wait_in_seconds")


@pulumi.output_type
class FleetUpdateRunStageGroup(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name which should be used for this group.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name which should be used for this group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FleetUpdateStrategyStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterStageWaitInSeconds":
            suggest = "after_stage_wait_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetUpdateStrategyStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetUpdateStrategyStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetUpdateStrategyStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 groups: Sequence['outputs.FleetUpdateStrategyStageGroup'],
                 name: _builtins.str,
                 after_stage_wait_in_seconds: Optional[_builtins.int] = None):
        """
        :param Sequence['FleetUpdateStrategyStageGroupArgs'] groups: One or more `group` blocks as defined below.
        :param _builtins.str name: The name which should be used for this stage.
        :param _builtins.int after_stage_wait_in_seconds: Specifies the time in seconds to wait at the end of this stage before starting the next one.
        """
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "name", name)
        if after_stage_wait_in_seconds is not None:
            pulumi.set(__self__, "after_stage_wait_in_seconds", after_stage_wait_in_seconds)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.FleetUpdateStrategyStageGroup']:
        """
        One or more `group` blocks as defined below.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name which should be used for this stage.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="afterStageWaitInSeconds")
    def after_stage_wait_in_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the time in seconds to wait at the end of this stage before starting the next one.
        """
        return pulumi.get(self, "after_stage_wait_in_seconds")


@pulumi.output_type
class FleetUpdateStrategyStageGroup(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name which should be used for this group.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name which should be used for this group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FluxConfigurationBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerId":
            suggest = "container_id"
        elif key == "accountKey":
            suggest = "account_key"
        elif key == "localAuthReference":
            suggest = "local_auth_reference"
        elif key == "managedIdentity":
            suggest = "managed_identity"
        elif key == "sasToken":
            suggest = "sas_token"
        elif key == "servicePrincipal":
            suggest = "service_principal"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FluxConfigurationBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FluxConfigurationBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FluxConfigurationBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_id: _builtins.str,
                 account_key: Optional[_builtins.str] = None,
                 local_auth_reference: Optional[_builtins.str] = None,
                 managed_identity: Optional['outputs.FluxConfigurationBlobStorageManagedIdentity'] = None,
                 sas_token: Optional[_builtins.str] = None,
                 service_principal: Optional['outputs.FluxConfigurationBlobStorageServicePrincipal'] = None,
                 sync_interval_in_seconds: Optional[_builtins.int] = None,
                 timeout_in_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str container_id: Specifies the Azure Blob container ID.
        :param _builtins.str account_key: Specifies the account key (shared key) to access the storage account.
        :param _builtins.str local_auth_reference: Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param 'FluxConfigurationBlobStorageManagedIdentityArgs' managed_identity: A `managed_identity` block as defined below.
        :param _builtins.str sas_token: Specifies the shared access token to access the storage container.
        :param 'FluxConfigurationBlobStorageServicePrincipalArgs' service_principal: A `service_principal` block as defined below.
        :param _builtins.int sync_interval_in_seconds: Specifies the interval at which to re-reconcile the cluster Azure Blob source with the remote.
        :param _builtins.int timeout_in_seconds: Specifies the maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
        """
        pulumi.set(__self__, "container_id", container_id)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if local_auth_reference is not None:
            pulumi.set(__self__, "local_auth_reference", local_auth_reference)
        if managed_identity is not None:
            pulumi.set(__self__, "managed_identity", managed_identity)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if service_principal is not None:
            pulumi.set(__self__, "service_principal", service_principal)
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="containerId")
    def container_id(self) -> _builtins.str:
        """
        Specifies the Azure Blob container ID.
        """
        return pulumi.get(self, "container_id")

    @_builtins.property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[_builtins.str]:
        """
        Specifies the account key (shared key) to access the storage account.
        """
        return pulumi.get(self, "account_key")

    @_builtins.property
    @pulumi.getter(name="localAuthReference")
    def local_auth_reference(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_reference")

    @_builtins.property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> Optional['outputs.FluxConfigurationBlobStorageManagedIdentity']:
        """
        A `managed_identity` block as defined below.
        """
        return pulumi.get(self, "managed_identity")

    @_builtins.property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[_builtins.str]:
        """
        Specifies the shared access token to access the storage container.
        """
        return pulumi.get(self, "sas_token")

    @_builtins.property
    @pulumi.getter(name="servicePrincipal")
    def service_principal(self) -> Optional['outputs.FluxConfigurationBlobStorageServicePrincipal']:
        """
        A `service_principal` block as defined below.
        """
        return pulumi.get(self, "service_principal")

    @_builtins.property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the interval at which to re-reconcile the cluster Azure Blob source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")


@pulumi.output_type
class FluxConfigurationBlobStorageManagedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FluxConfigurationBlobStorageManagedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FluxConfigurationBlobStorageManagedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FluxConfigurationBlobStorageManagedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str):
        """
        :param _builtins.str client_id: Specifies the client ID for authenticating a Managed Identity.
        """
        pulumi.set(__self__, "client_id", client_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Specifies the client ID for authenticating a Managed Identity.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class FluxConfigurationBlobStorageServicePrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "clientCertificateBase64":
            suggest = "client_certificate_base64"
        elif key == "clientCertificatePassword":
            suggest = "client_certificate_password"
        elif key == "clientCertificateSendChain":
            suggest = "client_certificate_send_chain"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FluxConfigurationBlobStorageServicePrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FluxConfigurationBlobStorageServicePrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FluxConfigurationBlobStorageServicePrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 tenant_id: _builtins.str,
                 client_certificate_base64: Optional[_builtins.str] = None,
                 client_certificate_password: Optional[_builtins.str] = None,
                 client_certificate_send_chain: Optional[_builtins.bool] = None,
                 client_secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: Specifies the client ID for authenticating a Service Principal.
        :param _builtins.str tenant_id: Specifies the tenant ID for authenticating a Service Principal.
        :param _builtins.str client_certificate_base64: Base64-encoded certificate used to authenticate a Service Principal .
        :param _builtins.str client_certificate_password: Specifies the password for the certificate used to authenticate a Service Principal .
        :param _builtins.bool client_certificate_send_chain: Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the client certificate.
        :param _builtins.str client_secret: Specifies the client secret for authenticating a Service Principal.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if client_certificate_base64 is not None:
            pulumi.set(__self__, "client_certificate_base64", client_certificate_base64)
        if client_certificate_password is not None:
            pulumi.set(__self__, "client_certificate_password", client_certificate_password)
        if client_certificate_send_chain is not None:
            pulumi.set(__self__, "client_certificate_send_chain", client_certificate_send_chain)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Specifies the client ID for authenticating a Service Principal.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        Specifies the tenant ID for authenticating a Service Principal.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="clientCertificateBase64")
    def client_certificate_base64(self) -> Optional[_builtins.str]:
        """
        Base64-encoded certificate used to authenticate a Service Principal .
        """
        return pulumi.get(self, "client_certificate_base64")

    @_builtins.property
    @pulumi.getter(name="clientCertificatePassword")
    def client_certificate_password(self) -> Optional[_builtins.str]:
        """
        Specifies the password for the certificate used to authenticate a Service Principal .
        """
        return pulumi.get(self, "client_certificate_password")

    @_builtins.property
    @pulumi.getter(name="clientCertificateSendChain")
    def client_certificate_send_chain(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the client certificate.
        """
        return pulumi.get(self, "client_certificate_send_chain")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        Specifies the client secret for authenticating a Service Principal.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class FluxConfigurationBucket(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "localAuthReference":
            suggest = "local_auth_reference"
        elif key == "secretKeyBase64":
            suggest = "secret_key_base64"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"
        elif key == "tlsEnabled":
            suggest = "tls_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FluxConfigurationBucket. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FluxConfigurationBucket.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FluxConfigurationBucket.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 url: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 local_auth_reference: Optional[_builtins.str] = None,
                 secret_key_base64: Optional[_builtins.str] = None,
                 sync_interval_in_seconds: Optional[_builtins.int] = None,
                 timeout_in_seconds: Optional[_builtins.int] = None,
                 tls_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket_name: Specifies the bucket name to sync from the url endpoint for the flux configuration.
        :param _builtins.str url: Specifies the URL to sync for the flux configuration S3 bucket. It must start with `http://` or `https://`.
        :param _builtins.str access_key: Specifies the plaintext access key used to securely access the S3 bucket.
        :param _builtins.str local_auth_reference: Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
        :param _builtins.str secret_key_base64: Specifies the Base64-encoded secret key used to authenticate with the bucket source.
        :param _builtins.int sync_interval_in_seconds: Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
        :param _builtins.int timeout_in_seconds: Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
        :param _builtins.bool tls_enabled: Specify whether to communicate with a bucket using TLS is enabled. Defaults to `true`.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "url", url)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if local_auth_reference is not None:
            pulumi.set(__self__, "local_auth_reference", local_auth_reference)
        if secret_key_base64 is not None:
            pulumi.set(__self__, "secret_key_base64", secret_key_base64)
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if tls_enabled is not None:
            pulumi.set(__self__, "tls_enabled", tls_enabled)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Specifies the bucket name to sync from the url endpoint for the flux configuration.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL to sync for the flux configuration S3 bucket. It must start with `http://` or `https://`.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        Specifies the plaintext access key used to securely access the S3 bucket.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="localAuthReference")
    def local_auth_reference(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
        """
        return pulumi.get(self, "local_auth_reference")

    @_builtins.property
    @pulumi.getter(name="secretKeyBase64")
    def secret_key_base64(self) -> Optional[_builtins.str]:
        """
        Specifies the Base64-encoded secret key used to authenticate with the bucket source.
        """
        return pulumi.get(self, "secret_key_base64")

    @_builtins.property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @_builtins.property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> Optional[_builtins.bool]:
        """
        Specify whether to communicate with a bucket using TLS is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "tls_enabled")


@pulumi.output_type
class FluxConfigurationGitRepository(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceType":
            suggest = "reference_type"
        elif key == "referenceValue":
            suggest = "reference_value"
        elif key == "httpsCaCertBase64":
            suggest = "https_ca_cert_base64"
        elif key == "httpsKeyBase64":
            suggest = "https_key_base64"
        elif key == "httpsUser":
            suggest = "https_user"
        elif key == "localAuthReference":
            suggest = "local_auth_reference"
        elif key == "sshKnownHostsBase64":
            suggest = "ssh_known_hosts_base64"
        elif key == "sshPrivateKeyBase64":
            suggest = "ssh_private_key_base64"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FluxConfigurationGitRepository. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FluxConfigurationGitRepository.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FluxConfigurationGitRepository.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_type: _builtins.str,
                 reference_value: _builtins.str,
                 url: _builtins.str,
                 https_ca_cert_base64: Optional[_builtins.str] = None,
                 https_key_base64: Optional[_builtins.str] = None,
                 https_user: Optional[_builtins.str] = None,
                 local_auth_reference: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 ssh_known_hosts_base64: Optional[_builtins.str] = None,
                 ssh_private_key_base64: Optional[_builtins.str] = None,
                 sync_interval_in_seconds: Optional[_builtins.int] = None,
                 timeout_in_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str reference_type: Specifies the source reference type for the GitRepository object. Possible values are `branch`, `commit`, `semver` and `tag`.
        :param _builtins.str reference_value: Specifies the source reference value for the GitRepository object.
        :param _builtins.str url: Specifies the URL to sync for the flux configuration git repository. It must start with `http://`, `https://`, `git@` or `ssh://`.
        :param _builtins.str https_ca_cert_base64: Specifies the Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS.
        :param _builtins.str https_key_base64: Specifies the Base64-encoded HTTPS personal access token or password that will be used to access the repository.
        :param _builtins.str https_user: Specifies the plaintext HTTPS username used to access private git repositories over HTTPS.
        :param _builtins.str local_auth_reference: Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
        :param _builtins.str provider: Specifies the OIDC provider used for workload identity federation authentication against git repositories. Possible values are `Azure`, `Generic`.
        :param _builtins.str ssh_known_hosts_base64: Specifies the Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH.
        :param _builtins.str ssh_private_key_base64: Specifies the Base64-encoded SSH private key in PEM format.
        :param _builtins.int sync_interval_in_seconds: Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
        :param _builtins.int timeout_in_seconds: Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        pulumi.set(__self__, "reference_type", reference_type)
        pulumi.set(__self__, "reference_value", reference_value)
        pulumi.set(__self__, "url", url)
        if https_ca_cert_base64 is not None:
            pulumi.set(__self__, "https_ca_cert_base64", https_ca_cert_base64)
        if https_key_base64 is not None:
            pulumi.set(__self__, "https_key_base64", https_key_base64)
        if https_user is not None:
            pulumi.set(__self__, "https_user", https_user)
        if local_auth_reference is not None:
            pulumi.set(__self__, "local_auth_reference", local_auth_reference)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if ssh_known_hosts_base64 is not None:
            pulumi.set(__self__, "ssh_known_hosts_base64", ssh_known_hosts_base64)
        if ssh_private_key_base64 is not None:
            pulumi.set(__self__, "ssh_private_key_base64", ssh_private_key_base64)
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> _builtins.str:
        """
        Specifies the source reference type for the GitRepository object. Possible values are `branch`, `commit`, `semver` and `tag`.
        """
        return pulumi.get(self, "reference_type")

    @_builtins.property
    @pulumi.getter(name="referenceValue")
    def reference_value(self) -> _builtins.str:
        """
        Specifies the source reference value for the GitRepository object.
        """
        return pulumi.get(self, "reference_value")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL to sync for the flux configuration git repository. It must start with `http://`, `https://`, `git@` or `ssh://`.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpsCaCertBase64")
    def https_ca_cert_base64(self) -> Optional[_builtins.str]:
        """
        Specifies the Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS.
        """
        return pulumi.get(self, "https_ca_cert_base64")

    @_builtins.property
    @pulumi.getter(name="httpsKeyBase64")
    def https_key_base64(self) -> Optional[_builtins.str]:
        """
        Specifies the Base64-encoded HTTPS personal access token or password that will be used to access the repository.
        """
        return pulumi.get(self, "https_key_base64")

    @_builtins.property
    @pulumi.getter(name="httpsUser")
    def https_user(self) -> Optional[_builtins.str]:
        """
        Specifies the plaintext HTTPS username used to access private git repositories over HTTPS.
        """
        return pulumi.get(self, "https_user")

    @_builtins.property
    @pulumi.getter(name="localAuthReference")
    def local_auth_reference(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
        """
        return pulumi.get(self, "local_auth_reference")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Specifies the OIDC provider used for workload identity federation authentication against git repositories. Possible values are `Azure`, `Generic`.
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="sshKnownHostsBase64")
    def ssh_known_hosts_base64(self) -> Optional[_builtins.str]:
        """
        Specifies the Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH.
        """
        return pulumi.get(self, "ssh_known_hosts_base64")

    @_builtins.property
    @pulumi.getter(name="sshPrivateKeyBase64")
    def ssh_private_key_base64(self) -> Optional[_builtins.str]:
        """
        Specifies the Base64-encoded SSH private key in PEM format.
        """
        return pulumi.get(self, "ssh_private_key_base64")

    @_builtins.property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
        """
        return pulumi.get(self, "timeout_in_seconds")


@pulumi.output_type
class FluxConfigurationKustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependsOns":
            suggest = "depends_ons"
        elif key == "garbageCollectionEnabled":
            suggest = "garbage_collection_enabled"
        elif key == "postBuild":
            suggest = "post_build"
        elif key == "recreatingEnabled":
            suggest = "recreating_enabled"
        elif key == "retryIntervalInSeconds":
            suggest = "retry_interval_in_seconds"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FluxConfigurationKustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FluxConfigurationKustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FluxConfigurationKustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 depends_ons: Optional[Sequence[_builtins.str]] = None,
                 garbage_collection_enabled: Optional[_builtins.bool] = None,
                 path: Optional[_builtins.str] = None,
                 post_build: Optional['outputs.FluxConfigurationKustomizationPostBuild'] = None,
                 recreating_enabled: Optional[_builtins.bool] = None,
                 retry_interval_in_seconds: Optional[_builtins.int] = None,
                 sync_interval_in_seconds: Optional[_builtins.int] = None,
                 timeout_in_seconds: Optional[_builtins.int] = None,
                 wait: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Specifies the name of the kustomization.
        :param Sequence[_builtins.str] depends_ons: Specifies other kustomizations that this kustomization depends on. This kustomization will not reconcile until all dependencies have completed their reconciliation.
        :param _builtins.bool garbage_collection_enabled: Whether garbage collections of Kubernetes objects created by this kustomization is enabled. Defaults to `false`.
        :param _builtins.str path: Specifies the path in the source reference to reconcile on the cluster.
        :param 'FluxConfigurationKustomizationPostBuildArgs' post_build: A `post_build` block as defined below.
        :param _builtins.bool recreating_enabled: Whether re-creating Kubernetes resources on the cluster is enabled when patching fails due to an immutable field change. Defaults to `false`.
        :param _builtins.int retry_interval_in_seconds: The interval at which to re-reconcile the kustomization on the cluster in the event of failure on reconciliation. Defaults to `600`.
        :param _builtins.int sync_interval_in_seconds: The interval at which to re-reconcile the kustomization on the cluster. Defaults to `600`.
        :param _builtins.int timeout_in_seconds: The maximum time to attempt to reconcile the kustomization on the cluster. Defaults to `600`.
        :param _builtins.bool wait: Whether to enable health check for all Kubernetes objects created by this Kustomization. Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if garbage_collection_enabled is not None:
            pulumi.set(__self__, "garbage_collection_enabled", garbage_collection_enabled)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if post_build is not None:
            pulumi.set(__self__, "post_build", post_build)
        if recreating_enabled is not None:
            pulumi.set(__self__, "recreating_enabled", recreating_enabled)
        if retry_interval_in_seconds is not None:
            pulumi.set(__self__, "retry_interval_in_seconds", retry_interval_in_seconds)
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the kustomization.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies other kustomizations that this kustomization depends on. This kustomization will not reconcile until all dependencies have completed their reconciliation.
        """
        return pulumi.get(self, "depends_ons")

    @_builtins.property
    @pulumi.getter(name="garbageCollectionEnabled")
    def garbage_collection_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether garbage collections of Kubernetes objects created by this kustomization is enabled. Defaults to `false`.
        """
        return pulumi.get(self, "garbage_collection_enabled")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Specifies the path in the source reference to reconcile on the cluster.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="postBuild")
    def post_build(self) -> Optional['outputs.FluxConfigurationKustomizationPostBuild']:
        """
        A `post_build` block as defined below.
        """
        return pulumi.get(self, "post_build")

    @_builtins.property
    @pulumi.getter(name="recreatingEnabled")
    def recreating_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether re-creating Kubernetes resources on the cluster is enabled when patching fails due to an immutable field change. Defaults to `false`.
        """
        return pulumi.get(self, "recreating_enabled")

    @_builtins.property
    @pulumi.getter(name="retryIntervalInSeconds")
    def retry_interval_in_seconds(self) -> Optional[_builtins.int]:
        """
        The interval at which to re-reconcile the kustomization on the cluster in the event of failure on reconciliation. Defaults to `600`.
        """
        return pulumi.get(self, "retry_interval_in_seconds")

    @_builtins.property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[_builtins.int]:
        """
        The interval at which to re-reconcile the kustomization on the cluster. Defaults to `600`.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        The maximum time to attempt to reconcile the kustomization on the cluster. Defaults to `600`.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @_builtins.property
    @pulumi.getter
    def wait(self) -> Optional[_builtins.bool]:
        """
        Whether to enable health check for all Kubernetes objects created by this Kustomization. Defaults to `true`.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class FluxConfigurationKustomizationPostBuild(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "substituteFroms":
            suggest = "substitute_froms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FluxConfigurationKustomizationPostBuild. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FluxConfigurationKustomizationPostBuild.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FluxConfigurationKustomizationPostBuild.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 substitute: Optional[Mapping[str, _builtins.str]] = None,
                 substitute_froms: Optional[Sequence['outputs.FluxConfigurationKustomizationPostBuildSubstituteFrom']] = None):
        """
        :param Mapping[str, _builtins.str] substitute: Specifies the key/value pairs holding the variables to be substituted in this Kustomization.
        :param Sequence['FluxConfigurationKustomizationPostBuildSubstituteFromArgs'] substitute_froms: A `substitute_from` block as defined below.
        """
        if substitute is not None:
            pulumi.set(__self__, "substitute", substitute)
        if substitute_froms is not None:
            pulumi.set(__self__, "substitute_froms", substitute_froms)

    @_builtins.property
    @pulumi.getter
    def substitute(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the key/value pairs holding the variables to be substituted in this Kustomization.
        """
        return pulumi.get(self, "substitute")

    @_builtins.property
    @pulumi.getter(name="substituteFroms")
    def substitute_froms(self) -> Optional[Sequence['outputs.FluxConfigurationKustomizationPostBuildSubstituteFrom']]:
        """
        A `substitute_from` block as defined below.
        """
        return pulumi.get(self, "substitute_froms")


@pulumi.output_type
class FluxConfigurationKustomizationPostBuildSubstituteFrom(dict):
    def __init__(__self__, *,
                 kind: _builtins.str,
                 name: _builtins.str,
                 optional: Optional[_builtins.bool] = None):
        """
        :param _builtins.str kind: Specifies the source kind to hold the variables to be used in substitution. Possible values are `ConfigMap` and `Secret`.
        :param _builtins.str name: Specifies the name of the ConfigMap/Secret that holds the variables to be used in substitution.
        :param _builtins.bool optional: Whether to proceed without ConfigMap/Secret if it is not present. Defaults to `false`.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Specifies the source kind to hold the variables to be used in substitution. Possible values are `ConfigMap` and `Secret`.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the ConfigMap/Secret that holds the variables to be used in substitution.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[_builtins.bool]:
        """
        Whether to proceed without ConfigMap/Secret if it is not present. Defaults to `false`.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GroupContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "secureEnvironmentVariables":
            suggest = "secure_environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: _builtins.float,
                 image: _builtins.str,
                 memory: _builtins.float,
                 name: _builtins.str,
                 commands: Optional[Sequence[_builtins.str]] = None,
                 cpu_limit: Optional[_builtins.float] = None,
                 environment_variables: Optional[Mapping[str, _builtins.str]] = None,
                 liveness_probe: Optional['outputs.GroupContainerLivenessProbe'] = None,
                 memory_limit: Optional[_builtins.float] = None,
                 ports: Optional[Sequence['outputs.GroupContainerPort']] = None,
                 readiness_probe: Optional['outputs.GroupContainerReadinessProbe'] = None,
                 secure_environment_variables: Optional[Mapping[str, _builtins.str]] = None,
                 securities: Optional[Sequence['outputs.GroupContainerSecurity']] = None,
                 volumes: Optional[Sequence['outputs.GroupContainerVolume']] = None):
        """
        :param _builtins.float cpu: The required number of CPU cores of the containers. Changing this forces a new resource to be created.
        :param _builtins.str image: The container image name. Changing this forces a new resource to be created.
        :param _builtins.float memory: The required memory of the containers in GB. Changing this forces a new resource to be created.
        :param _builtins.str name: Specifies the name of the Container. Changing this forces a new resource to be created.
        :param Sequence[_builtins.str] commands: A list of commands which should be run on the container. Changing this forces a new resource to be created.
        :param _builtins.float cpu_limit: The upper limit of the number of CPU cores of the containers.
        :param Mapping[str, _builtins.str] environment_variables: A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param 'GroupContainerLivenessProbeArgs' liveness_probe: The definition of a readiness probe for this container as documented in the `liveness_probe` block below. Changing this forces a new resource to be created.
        :param _builtins.float memory_limit: The upper limit of the memory of the containers in GB.
        :param Sequence['GroupContainerPortArgs'] ports: A set of public ports for the container. Changing this forces a new resource to be created. Set as documented in the `ports` block below.
        :param 'GroupContainerReadinessProbeArgs' readiness_probe: The definition of a readiness probe for this container as documented in the `readiness_probe` block below. Changing this forces a new resource to be created.
        :param Mapping[str, _builtins.str] secure_environment_variables: A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param Sequence['GroupContainerSecurityArgs'] securities: The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
        :param Sequence['GroupContainerVolumeArgs'] volumes: The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if secure_environment_variables is not None:
            pulumi.set(__self__, "secure_environment_variables", secure_environment_variables)
        if securities is not None:
            pulumi.set(__self__, "securities", securities)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.float:
        """
        The required number of CPU cores of the containers. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        The container image name. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        The required memory of the containers in GB. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the Container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of commands which should be run on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[_builtins.float]:
        """
        The upper limit of the number of CPU cores of the containers.
        """
        return pulumi.get(self, "cpu_limit")

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "environment_variables")

    @_builtins.property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.GroupContainerLivenessProbe']:
        """
        The definition of a readiness probe for this container as documented in the `liveness_probe` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "liveness_probe")

    @_builtins.property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[_builtins.float]:
        """
        The upper limit of the memory of the containers in GB.
        """
        return pulumi.get(self, "memory_limit")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.GroupContainerPort']]:
        """
        A set of public ports for the container. Changing this forces a new resource to be created. Set as documented in the `ports` block below.
        """
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.GroupContainerReadinessProbe']:
        """
        The definition of a readiness probe for this container as documented in the `readiness_probe` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "readiness_probe")

    @_builtins.property
    @pulumi.getter(name="secureEnvironmentVariables")
    def secure_environment_variables(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secure_environment_variables")

    @_builtins.property
    @pulumi.getter
    def securities(self) -> Optional[Sequence['outputs.GroupContainerSecurity']]:
        """
        The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "securities")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.GroupContainerVolume']]:
        """
        The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GroupContainerLivenessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGets":
            suggest = "http_gets"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainerLivenessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainerLivenessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainerLivenessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execs: Optional[Sequence[_builtins.str]] = None,
                 failure_threshold: Optional[_builtins.int] = None,
                 http_gets: Optional[Sequence['outputs.GroupContainerLivenessProbeHttpGet']] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 success_threshold: Optional[_builtins.int] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] execs: Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        :param _builtins.int failure_threshold: How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). Changing this forces a new resource to be created.
        :param Sequence['GroupContainerLivenessProbeHttpGetArgs'] http_gets: The definition of the http_get for this container as documented in the `http_get` block below. Changing this forces a new resource to be created.
        :param _builtins.int initial_delay_seconds: Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        :param _builtins.int period_seconds: How often (in seconds) to perform the probe. Changing this forces a new resource to be created.
        :param _builtins.int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Changing this forces a new resource to be created.
        :param _builtins.int timeout_seconds: Number of seconds after which the probe times out. Changing this forces a new resource to be created.
        """
        if execs is not None:
            pulumi.set(__self__, "execs", execs)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def execs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "execs")

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[_builtins.int]:
        """
        How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[Sequence['outputs.GroupContainerLivenessProbeHttpGet']]:
        """
        The definition of the http_get for this container as documented in the `http_get` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_gets")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        How often (in seconds) to perform the probe. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[_builtins.int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "success_threshold")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds after which the probe times out. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GroupContainerLivenessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainerLivenessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainerLivenessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainerLivenessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 path: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 scheme: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] http_headers: A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
        :param _builtins.str path: Path to access on the HTTP server. Changing this forces a new resource to be created.
        :param _builtins.int port: Number of the port to access on the container. Changing this forces a new resource to be created.
        :param _builtins.str scheme: Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to access on the HTTP server. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Number of the port to access on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        """
        Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GroupContainerPort(dict):
    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.int port: The port number the container will expose. Changing this forces a new resource to be created.
        :param _builtins.str protocol: The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created. Defaults to `TCP`.
               
               > **Note:** Omitting these blocks will default the exposed ports on the group to all ports on all containers defined in the `container` blocks of this group.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port number the container will expose. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created. Defaults to `TCP`.

        > **Note:** Omitting these blocks will default the exposed ports on the group to all ports on all containers defined in the `container` blocks of this group.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GroupContainerReadinessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGets":
            suggest = "http_gets"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainerReadinessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainerReadinessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainerReadinessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execs: Optional[Sequence[_builtins.str]] = None,
                 failure_threshold: Optional[_builtins.int] = None,
                 http_gets: Optional[Sequence['outputs.GroupContainerReadinessProbeHttpGet']] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 success_threshold: Optional[_builtins.int] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] execs: Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        :param _builtins.int failure_threshold: How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). Changing this forces a new resource to be created.
        :param Sequence['GroupContainerReadinessProbeHttpGetArgs'] http_gets: The definition of the http_get for this container as documented in the `http_get` block below. Changing this forces a new resource to be created.
        :param _builtins.int initial_delay_seconds: Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        :param _builtins.int period_seconds: How often (in seconds) to perform the probe. Changing this forces a new resource to be created.
        :param _builtins.int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Changing this forces a new resource to be created.
        :param _builtins.int timeout_seconds: Number of seconds after which the probe times out. Changing this forces a new resource to be created.
        """
        if execs is not None:
            pulumi.set(__self__, "execs", execs)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def execs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Commands to be run to validate container readiness. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "execs")

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[_builtins.int]:
        """
        How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[Sequence['outputs.GroupContainerReadinessProbeHttpGet']]:
        """
        The definition of the http_get for this container as documented in the `http_get` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_gets")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        How often (in seconds) to perform the probe. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[_builtins.int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "success_threshold")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds after which the probe times out. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GroupContainerReadinessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainerReadinessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainerReadinessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainerReadinessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 path: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 scheme: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] http_headers: A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
        :param _builtins.str path: Path to access on the HTTP server. Changing this forces a new resource to be created.
        :param _builtins.int port: Number of the port to access on the container. Changing this forces a new resource to be created.
        :param _builtins.str scheme: Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to access on the HTTP server. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Number of the port to access on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        """
        Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GroupContainerSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privilegeEnabled":
            suggest = "privilege_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainerSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainerSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainerSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 privilege_enabled: _builtins.bool):
        """
        :param _builtins.bool privilege_enabled: Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.
               
               > **Note:** Currently, this only applies when the `os_type` is `Linux` and the `sku` is `Confidential`.
        """
        pulumi.set(__self__, "privilege_enabled", privilege_enabled)

    @_builtins.property
    @pulumi.getter(name="privilegeEnabled")
    def privilege_enabled(self) -> _builtins.bool:
        """
        Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.

        > **Note:** Currently, this only applies when the `os_type` is `Linux` and the `sku` is `Confidential`.
        """
        return pulumi.get(self, "privilege_enabled")


@pulumi.output_type
class GroupContainerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "emptyDir":
            suggest = "empty_dir"
        elif key == "gitRepo":
            suggest = "git_repo"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageAccountName":
            suggest = "storage_account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContainerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContainerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContainerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: _builtins.str,
                 name: _builtins.str,
                 empty_dir: Optional[_builtins.bool] = None,
                 git_repo: Optional['outputs.GroupContainerVolumeGitRepo'] = None,
                 read_only: Optional[_builtins.bool] = None,
                 secret: Optional[Mapping[str, _builtins.str]] = None,
                 share_name: Optional[_builtins.str] = None,
                 storage_account_key: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str mount_path: The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        :param _builtins.str name: The name of the volume mount. Changing this forces a new resource to be created.
        :param _builtins.bool empty_dir: Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        :param 'GroupContainerVolumeGitRepoArgs' git_repo: A `git_repo` block as defined below. Changing this forces a new resource to be created.
        :param _builtins.bool read_only: Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        :param Mapping[str, _builtins.str] secret: A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.
               
               > **Note:** Exactly one of `empty_dir` volume, `git_repo` volume, `secret` volume or storage account volume (`share_name`, `storage_account_name`, and `storage_account_key`) must be specified.
               
               > **Note:** when using a storage account volume, all of `share_name`, `storage_account_name`, and `storage_account_key` must be specified.
               
               > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
        :param _builtins.str share_name: The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        :param _builtins.str storage_account_key: The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        :param _builtins.str storage_account_name: The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if empty_dir is not None:
            pulumi.set(__self__, "empty_dir", empty_dir)
        if git_repo is not None:
            pulumi.set(__self__, "git_repo", git_repo)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if storage_account_key is not None:
            pulumi.set(__self__, "storage_account_key", storage_account_key)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> _builtins.str:
        """
        The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the volume mount. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="emptyDir")
    def empty_dir(self) -> Optional[_builtins.bool]:
        """
        Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "empty_dir")

    @_builtins.property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> Optional['outputs.GroupContainerVolumeGitRepo']:
        """
        A `git_repo` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "git_repo")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.

        > **Note:** Exactly one of `empty_dir` volume, `git_repo` volume, `secret` volume or storage account volume (`share_name`, `storage_account_name`, and `storage_account_key`) must be specified.

        > **Note:** when using a storage account volume, all of `share_name`, `storage_account_name`, and `storage_account_key` must be specified.

        > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[_builtins.str]:
        """
        The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "share_name")

    @_builtins.property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> Optional[_builtins.str]:
        """
        The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        """
        The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_name")


@pulumi.output_type
class GroupContainerVolumeGitRepo(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 directory: Optional[_builtins.str] = None,
                 revision: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        :param _builtins.str directory: Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        :param _builtins.str revision: Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "url", url)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def directory(self) -> Optional[_builtins.str]:
        """
        Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "directory")

    @_builtins.property
    @pulumi.getter
    def revision(self) -> Optional[_builtins.str]:
        """
        Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "revision")


@pulumi.output_type
class GroupDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalytics":
            suggest = "log_analytics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics: 'outputs.GroupDiagnosticsLogAnalytics'):
        """
        :param 'GroupDiagnosticsLogAnalyticsArgs' log_analytics: A `log_analytics` block as defined below. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "log_analytics", log_analytics)

    @_builtins.property
    @pulumi.getter(name="logAnalytics")
    def log_analytics(self) -> 'outputs.GroupDiagnosticsLogAnalytics':
        """
        A `log_analytics` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "log_analytics")


@pulumi.output_type
class GroupDiagnosticsLogAnalytics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"
        elif key == "workspaceKey":
            suggest = "workspace_key"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupDiagnosticsLogAnalytics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupDiagnosticsLogAnalytics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupDiagnosticsLogAnalytics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str,
                 workspace_key: _builtins.str,
                 log_type: Optional[_builtins.str] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str workspace_id: The Workspace ID of the Log Analytics Workspace. Changing this forces a new resource to be created.
        :param _builtins.str workspace_key: The Workspace Key of the Log Analytics Workspace. Changing this forces a new resource to be created.
        :param _builtins.str log_type: The log type which should be used. Possible values are `ContainerInsights` and `ContainerInstanceLogs`. Changing this forces a new resource to be created.
        :param Mapping[str, _builtins.str] metadata: Any metadata required for Log Analytics. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)
        pulumi.set(__self__, "workspace_key", workspace_key)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        The Workspace ID of the Log Analytics Workspace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "workspace_id")

    @_builtins.property
    @pulumi.getter(name="workspaceKey")
    def workspace_key(self) -> _builtins.str:
        """
        The Workspace Key of the Log Analytics Workspace. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "workspace_key")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[_builtins.str]:
        """
        The log type which should be used. Possible values are `ContainerInsights` and `ContainerInstanceLogs`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "log_type")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Any metadata required for Log Analytics. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class GroupDnsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "searchDomains":
            suggest = "search_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupDnsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupDnsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupDnsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nameservers: Sequence[_builtins.str],
                 options: Optional[Sequence[_builtins.str]] = None,
                 search_domains: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] nameservers: A list of nameservers the containers will search out to resolve requests. Changing this forces a new resource to be created.
        :param Sequence[_builtins.str] options: A list of [resolver configuration options](https://man7.org/linux/man-pages/man5/resolv.conf.5.html). Changing this forces a new resource to be created.
        :param Sequence[_builtins.str] search_domains: A list of search domains that DNS requests will search along. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "nameservers", nameservers)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if search_domains is not None:
            pulumi.set(__self__, "search_domains", search_domains)

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Sequence[_builtins.str]:
        """
        A list of nameservers the containers will search out to resolve requests. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "nameservers")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of [resolver configuration options](https://man7.org/linux/man-pages/man5/resolv.conf.5.html). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter(name="searchDomains")
    def search_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of search domains that DNS requests will search along. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "search_domains")


@pulumi.output_type
class GroupExposedPort(dict):
    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.int port: The port number the container will expose. Changing this forces a new resource to be created.
        :param _builtins.str protocol: The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created. Defaults to `TCP`.
               
               > **Note:** Removing all `exposed_port` blocks requires setting `exposed_port = []`.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port number the container will expose. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created. Defaults to `TCP`.

        > **Note:** Removing all `exposed_port` blocks requires setting `exposed_port = []`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GroupIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 identity_ids: Optional[Sequence[_builtins.str]] = None,
                 principal_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the type of Managed Service Identity that should be configured on this Container Group. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
               
               > **Note:** When `type` is set to `SystemAssigned`, the identity of the Principal ID can be retrieved after the container group has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information.
        :param Sequence[_builtins.str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Group.
               
               > **Note:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
               
               > **Note:** Currently you can't use a managed identity in a container group deployed to a virtual network.
        :param _builtins.str principal_id: The Principal ID associated with this Managed Service Identity.
        :param _builtins.str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Container Group. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).

        > **Note:** When `type` is set to `SystemAssigned`, the identity of the Principal ID can be retrieved after the container group has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Group.

        > **Note:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.

        > **Note:** Currently you can't use a managed identity in a container group deployed to a virtual network.
        """
        return pulumi.get(self, "identity_ids")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[_builtins.str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GroupImageRegistryCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupImageRegistryCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupImageRegistryCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupImageRegistryCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 user_assigned_identity_id: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str server: The address to use to connect to the registry without protocol ("https"/"http"). For example: "myacr.acr.io". Changing this forces a new resource to be created.
        :param _builtins.str password: The password with which to connect to the registry. Changing this forces a new resource to be created.
        :param _builtins.str user_assigned_identity_id: The identity ID for the private registry. Changing this forces a new resource to be created.
        :param _builtins.str username: The username with which to connect to the registry. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "server", server)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        """
        The address to use to connect to the registry without protocol ("https"/"http"). For example: "myacr.acr.io". Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password with which to connect to the registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        The identity ID for the private registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "user_assigned_identity_id")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username with which to connect to the registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GroupInitContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "secureEnvironmentVariables":
            suggest = "secure_environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupInitContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupInitContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupInitContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: _builtins.str,
                 name: _builtins.str,
                 commands: Optional[Sequence[_builtins.str]] = None,
                 environment_variables: Optional[Mapping[str, _builtins.str]] = None,
                 secure_environment_variables: Optional[Mapping[str, _builtins.str]] = None,
                 securities: Optional[Sequence['outputs.GroupInitContainerSecurity']] = None,
                 volumes: Optional[Sequence['outputs.GroupInitContainerVolume']] = None):
        """
        :param _builtins.str image: The container image name. Changing this forces a new resource to be created.
        :param _builtins.str name: Specifies the name of the Container. Changing this forces a new resource to be created.
        :param Sequence[_builtins.str] commands: A list of commands which should be run on the container. Changing this forces a new resource to be created.
        :param Mapping[str, _builtins.str] environment_variables: A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param Mapping[str, _builtins.str] secure_environment_variables: A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        :param Sequence['GroupInitContainerSecurityArgs'] securities: The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
        :param Sequence['GroupInitContainerVolumeArgs'] volumes: The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "name", name)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if secure_environment_variables is not None:
            pulumi.set(__self__, "secure_environment_variables", secure_environment_variables)
        if securities is not None:
            pulumi.set(__self__, "securities", securities)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        The container image name. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the Container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of commands which should be run on the container. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "environment_variables")

    @_builtins.property
    @pulumi.getter(name="secureEnvironmentVariables")
    def secure_environment_variables(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "secure_environment_variables")

    @_builtins.property
    @pulumi.getter
    def securities(self) -> Optional[Sequence['outputs.GroupInitContainerSecurity']]:
        """
        The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "securities")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.GroupInitContainerVolume']]:
        """
        The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GroupInitContainerSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privilegeEnabled":
            suggest = "privilege_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupInitContainerSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupInitContainerSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupInitContainerSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 privilege_enabled: _builtins.bool):
        """
        :param _builtins.bool privilege_enabled: Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.
               
               > **Note:** Currently, this only applies when the `os_type` is `Linux` and the `sku` is `Confidential`.
        """
        pulumi.set(__self__, "privilege_enabled", privilege_enabled)

    @_builtins.property
    @pulumi.getter(name="privilegeEnabled")
    def privilege_enabled(self) -> _builtins.bool:
        """
        Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.

        > **Note:** Currently, this only applies when the `os_type` is `Linux` and the `sku` is `Confidential`.
        """
        return pulumi.get(self, "privilege_enabled")


@pulumi.output_type
class GroupInitContainerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "emptyDir":
            suggest = "empty_dir"
        elif key == "gitRepo":
            suggest = "git_repo"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "storageAccountKey":
            suggest = "storage_account_key"
        elif key == "storageAccountName":
            suggest = "storage_account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupInitContainerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupInitContainerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupInitContainerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: _builtins.str,
                 name: _builtins.str,
                 empty_dir: Optional[_builtins.bool] = None,
                 git_repo: Optional['outputs.GroupInitContainerVolumeGitRepo'] = None,
                 read_only: Optional[_builtins.bool] = None,
                 secret: Optional[Mapping[str, _builtins.str]] = None,
                 share_name: Optional[_builtins.str] = None,
                 storage_account_key: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str mount_path: The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        :param _builtins.str name: The name of the volume mount. Changing this forces a new resource to be created.
        :param _builtins.bool empty_dir: Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        :param 'GroupInitContainerVolumeGitRepoArgs' git_repo: A `git_repo` block as defined below. Changing this forces a new resource to be created.
        :param _builtins.bool read_only: Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        :param Mapping[str, _builtins.str] secret: A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.
               
               > **Note:** Exactly one of `empty_dir` volume, `git_repo` volume, `secret` volume or storage account volume (`share_name`, `storage_account_name`, and `storage_account_key`) must be specified.
               
               > **Note:** when using a storage account volume, all of `share_name`, `storage_account_name`, and `storage_account_key` must be specified.
               
               > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
        :param _builtins.str share_name: The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        :param _builtins.str storage_account_key: The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        :param _builtins.str storage_account_name: The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if empty_dir is not None:
            pulumi.set(__self__, "empty_dir", empty_dir)
        if git_repo is not None:
            pulumi.set(__self__, "git_repo", git_repo)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if storage_account_key is not None:
            pulumi.set(__self__, "storage_account_key", storage_account_key)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> _builtins.str:
        """
        The path on which this volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the volume mount. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="emptyDir")
    def empty_dir(self) -> Optional[_builtins.bool]:
        """
        Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "empty_dir")

    @_builtins.property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> Optional['outputs.GroupInitContainerVolumeGitRepo']:
        """
        A `git_repo` block as defined below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "git_repo")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.

        > **Note:** Exactly one of `empty_dir` volume, `git_repo` volume, `secret` volume or storage account volume (`share_name`, `storage_account_name`, and `storage_account_key`) must be specified.

        > **Note:** when using a storage account volume, all of `share_name`, `storage_account_name`, and `storage_account_key` must be specified.

        > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[_builtins.str]:
        """
        The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "share_name")

    @_builtins.property
    @pulumi.getter(name="storageAccountKey")
    def storage_account_key(self) -> Optional[_builtins.str]:
        """
        The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_key")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        """
        The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "storage_account_name")


@pulumi.output_type
class GroupInitContainerVolumeGitRepo(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 directory: Optional[_builtins.str] = None,
                 revision: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        :param _builtins.str directory: Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        :param _builtins.str revision: Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "url", url)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def directory(self) -> Optional[_builtins.str]:
        """
        Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "directory")

    @_builtins.property
    @pulumi.getter
    def revision(self) -> Optional[_builtins.str]:
        """
        Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "revision")


@pulumi.output_type
class KubernetesClusterAciConnectorLinux(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetName":
            suggest = "subnet_name"
        elif key == "connectorIdentities":
            suggest = "connector_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAciConnectorLinux. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAciConnectorLinux.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAciConnectorLinux.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_name: _builtins.str,
                 connector_identities: Optional[Sequence['outputs.KubernetesClusterAciConnectorLinuxConnectorIdentity']] = None):
        """
        :param _builtins.str subnet_name: The subnet name for the virtual nodes to run.
               
               > **Note:** At this time ACI Connectors are not supported in Azure China.
               
               > **Note:** AKS will add a delegation to the subnet named here. To prevent further runs from failing you should make sure that the subnet you create for virtual nodes has a delegation, like so.
               
               ```python
               import pulumi
               import pulumi_azure as azure
               
               virtual = azure.network.Subnet("virtual", delegations=[{
                   "name": "aciDelegation",
                   "service_delegation": {
                       "name": "Microsoft.ContainerInstance/containerGroups",
                       "actions": ["Microsoft.Network/virtualNetworks/subnets/action"],
                   },
               }])
               ```
        :param Sequence['KubernetesClusterAciConnectorLinuxConnectorIdentityArgs'] connector_identities: A `connector_identity` block is exported. The exported attributes are defined below.
        """
        pulumi.set(__self__, "subnet_name", subnet_name)
        if connector_identities is not None:
            pulumi.set(__self__, "connector_identities", connector_identities)

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> _builtins.str:
        """
        The subnet name for the virtual nodes to run.

        > **Note:** At this time ACI Connectors are not supported in Azure China.

        > **Note:** AKS will add a delegation to the subnet named here. To prevent further runs from failing you should make sure that the subnet you create for virtual nodes has a delegation, like so.

        ```python
        import pulumi
        import pulumi_azure as azure

        virtual = azure.network.Subnet("virtual", delegations=[{
            "name": "aciDelegation",
            "service_delegation": {
                "name": "Microsoft.ContainerInstance/containerGroups",
                "actions": ["Microsoft.Network/virtualNetworks/subnets/action"],
            },
        }])
        ```
        """
        return pulumi.get(self, "subnet_name")

    @_builtins.property
    @pulumi.getter(name="connectorIdentities")
    def connector_identities(self) -> Optional[Sequence['outputs.KubernetesClusterAciConnectorLinuxConnectorIdentity']]:
        """
        A `connector_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "connector_identities")


@pulumi.output_type
class KubernetesClusterAciConnectorLinuxConnectorIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAciConnectorLinuxConnectorIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAciConnectorLinuxConnectorIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAciConnectorLinuxConnectorIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 user_assigned_identity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity used for Web App Routing.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity used for Web App Routing
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity used for Web App Routing.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of the user-defined Managed Identity used for Web App Routing.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The Object ID of the user-defined Managed Identity used for Web App Routing
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        The ID of the User Assigned Identity used for Web App Routing.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class KubernetesClusterApiServerAccessProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedIpRanges":
            suggest = "authorized_ip_ranges"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "virtualNetworkIntegrationEnabled":
            suggest = "virtual_network_integration_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterApiServerAccessProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterApiServerAccessProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterApiServerAccessProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 virtual_network_integration_enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] authorized_ip_ranges: Set of authorized IP ranges to allow access to API server, e.g. ["198.51.100.0/24"].
        :param _builtins.str subnet_id: The ID of the Subnet where the API server endpoint is delegated to.
        :param _builtins.bool virtual_network_integration_enabled: Whether to enable virtual network integration for the API Server. Defaults to `false`.
        """
        if authorized_ip_ranges is not None:
            pulumi.set(__self__, "authorized_ip_ranges", authorized_ip_ranges)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if virtual_network_integration_enabled is not None:
            pulumi.set(__self__, "virtual_network_integration_enabled", virtual_network_integration_enabled)

    @_builtins.property
    @pulumi.getter(name="authorizedIpRanges")
    def authorized_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        Set of authorized IP ranges to allow access to API server, e.g. ["198.51.100.0/24"].
        """
        return pulumi.get(self, "authorized_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Subnet where the API server endpoint is delegated to.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="virtualNetworkIntegrationEnabled")
    def virtual_network_integration_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable virtual network integration for the API Server. Defaults to `false`.
        """
        return pulumi.get(self, "virtual_network_integration_enabled")


@pulumi.output_type
class KubernetesClusterAutoScalerProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "balanceSimilarNodeGroups":
            suggest = "balance_similar_node_groups"
        elif key == "daemonsetEvictionForEmptyNodesEnabled":
            suggest = "daemonset_eviction_for_empty_nodes_enabled"
        elif key == "daemonsetEvictionForOccupiedNodesEnabled":
            suggest = "daemonset_eviction_for_occupied_nodes_enabled"
        elif key == "emptyBulkDeleteMax":
            suggest = "empty_bulk_delete_max"
        elif key == "ignoreDaemonsetsUtilizationEnabled":
            suggest = "ignore_daemonsets_utilization_enabled"
        elif key == "maxGracefulTerminationSec":
            suggest = "max_graceful_termination_sec"
        elif key == "maxNodeProvisioningTime":
            suggest = "max_node_provisioning_time"
        elif key == "maxUnreadyNodes":
            suggest = "max_unready_nodes"
        elif key == "maxUnreadyPercentage":
            suggest = "max_unready_percentage"
        elif key == "newPodScaleUpDelay":
            suggest = "new_pod_scale_up_delay"
        elif key == "scaleDownDelayAfterAdd":
            suggest = "scale_down_delay_after_add"
        elif key == "scaleDownDelayAfterDelete":
            suggest = "scale_down_delay_after_delete"
        elif key == "scaleDownDelayAfterFailure":
            suggest = "scale_down_delay_after_failure"
        elif key == "scaleDownUnneeded":
            suggest = "scale_down_unneeded"
        elif key == "scaleDownUnready":
            suggest = "scale_down_unready"
        elif key == "scaleDownUtilizationThreshold":
            suggest = "scale_down_utilization_threshold"
        elif key == "scanInterval":
            suggest = "scan_interval"
        elif key == "skipNodesWithLocalStorage":
            suggest = "skip_nodes_with_local_storage"
        elif key == "skipNodesWithSystemPods":
            suggest = "skip_nodes_with_system_pods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAutoScalerProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAutoScalerProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAutoScalerProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 balance_similar_node_groups: Optional[_builtins.bool] = None,
                 daemonset_eviction_for_empty_nodes_enabled: Optional[_builtins.bool] = None,
                 daemonset_eviction_for_occupied_nodes_enabled: Optional[_builtins.bool] = None,
                 empty_bulk_delete_max: Optional[_builtins.str] = None,
                 expander: Optional[_builtins.str] = None,
                 ignore_daemonsets_utilization_enabled: Optional[_builtins.bool] = None,
                 max_graceful_termination_sec: Optional[_builtins.str] = None,
                 max_node_provisioning_time: Optional[_builtins.str] = None,
                 max_unready_nodes: Optional[_builtins.int] = None,
                 max_unready_percentage: Optional[_builtins.float] = None,
                 new_pod_scale_up_delay: Optional[_builtins.str] = None,
                 scale_down_delay_after_add: Optional[_builtins.str] = None,
                 scale_down_delay_after_delete: Optional[_builtins.str] = None,
                 scale_down_delay_after_failure: Optional[_builtins.str] = None,
                 scale_down_unneeded: Optional[_builtins.str] = None,
                 scale_down_unready: Optional[_builtins.str] = None,
                 scale_down_utilization_threshold: Optional[_builtins.str] = None,
                 scan_interval: Optional[_builtins.str] = None,
                 skip_nodes_with_local_storage: Optional[_builtins.bool] = None,
                 skip_nodes_with_system_pods: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool balance_similar_node_groups: Detect similar node groups and balance the number of nodes between them. Defaults to `false`.
        :param _builtins.bool daemonset_eviction_for_empty_nodes_enabled: Whether DaemonSet pods will be gracefully terminated from empty nodes. Defaults to `false`.
        :param _builtins.bool daemonset_eviction_for_occupied_nodes_enabled: Whether DaemonSet pods will be gracefully terminated from non-empty nodes. Defaults to `true`.
        :param _builtins.str empty_bulk_delete_max: Maximum number of empty nodes that can be deleted at the same time. Defaults to `10`.
        :param _builtins.str expander: Expander to use. Possible values are `least-waste`, `priority`, `most-pods` and `random`. Defaults to `random`.
        :param _builtins.bool ignore_daemonsets_utilization_enabled: Whether DaemonSet pods will be ignored when calculating resource utilization for scale down. Defaults to `false`.
        :param _builtins.str max_graceful_termination_sec: Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. Defaults to `600`.
        :param _builtins.str max_node_provisioning_time: Maximum time the autoscaler waits for a node to be provisioned. Defaults to `15m`.
        :param _builtins.int max_unready_nodes: Maximum Number of allowed unready nodes. Defaults to `3`.
        :param _builtins.float max_unready_percentage: Maximum percentage of unready nodes the cluster autoscaler will stop if the percentage is exceeded. Defaults to `45`.
        :param _builtins.str new_pod_scale_up_delay: For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. Defaults to `10s`.
        :param _builtins.str scale_down_delay_after_add: How long after the scale up of AKS nodes the scale down evaluation resumes. Defaults to `10m`.
        :param _builtins.str scale_down_delay_after_delete: How long after node deletion that scale down evaluation resumes. Defaults to the value used for `scan_interval`.
        :param _builtins.str scale_down_delay_after_failure: How long after scale down failure that scale down evaluation resumes. Defaults to `3m`.
        :param _builtins.str scale_down_unneeded: How long a node should be unneeded before it is eligible for scale down. Defaults to `10m`.
        :param _builtins.str scale_down_unready: How long an unready node should be unneeded before it is eligible for scale down. Defaults to `20m`.
        :param _builtins.str scale_down_utilization_threshold: Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. Defaults to `0.5`.
        :param _builtins.str scan_interval: How often the AKS Cluster should be re-evaluated for scale up/down. Defaults to `10s`.
        :param _builtins.bool skip_nodes_with_system_pods: If `true` cluster autoscaler will never delete nodes with pods from kube-system (except for DaemonSet or mirror pods). Defaults to `true`.
        """
        if balance_similar_node_groups is not None:
            pulumi.set(__self__, "balance_similar_node_groups", balance_similar_node_groups)
        if daemonset_eviction_for_empty_nodes_enabled is not None:
            pulumi.set(__self__, "daemonset_eviction_for_empty_nodes_enabled", daemonset_eviction_for_empty_nodes_enabled)
        if daemonset_eviction_for_occupied_nodes_enabled is not None:
            pulumi.set(__self__, "daemonset_eviction_for_occupied_nodes_enabled", daemonset_eviction_for_occupied_nodes_enabled)
        if empty_bulk_delete_max is not None:
            pulumi.set(__self__, "empty_bulk_delete_max", empty_bulk_delete_max)
        if expander is not None:
            pulumi.set(__self__, "expander", expander)
        if ignore_daemonsets_utilization_enabled is not None:
            pulumi.set(__self__, "ignore_daemonsets_utilization_enabled", ignore_daemonsets_utilization_enabled)
        if max_graceful_termination_sec is not None:
            pulumi.set(__self__, "max_graceful_termination_sec", max_graceful_termination_sec)
        if max_node_provisioning_time is not None:
            pulumi.set(__self__, "max_node_provisioning_time", max_node_provisioning_time)
        if max_unready_nodes is not None:
            pulumi.set(__self__, "max_unready_nodes", max_unready_nodes)
        if max_unready_percentage is not None:
            pulumi.set(__self__, "max_unready_percentage", max_unready_percentage)
        if new_pod_scale_up_delay is not None:
            pulumi.set(__self__, "new_pod_scale_up_delay", new_pod_scale_up_delay)
        if scale_down_delay_after_add is not None:
            pulumi.set(__self__, "scale_down_delay_after_add", scale_down_delay_after_add)
        if scale_down_delay_after_delete is not None:
            pulumi.set(__self__, "scale_down_delay_after_delete", scale_down_delay_after_delete)
        if scale_down_delay_after_failure is not None:
            pulumi.set(__self__, "scale_down_delay_after_failure", scale_down_delay_after_failure)
        if scale_down_unneeded is not None:
            pulumi.set(__self__, "scale_down_unneeded", scale_down_unneeded)
        if scale_down_unready is not None:
            pulumi.set(__self__, "scale_down_unready", scale_down_unready)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)
        if scan_interval is not None:
            pulumi.set(__self__, "scan_interval", scan_interval)
        if skip_nodes_with_local_storage is not None:
            pulumi.set(__self__, "skip_nodes_with_local_storage", skip_nodes_with_local_storage)
        if skip_nodes_with_system_pods is not None:
            pulumi.set(__self__, "skip_nodes_with_system_pods", skip_nodes_with_system_pods)

    @_builtins.property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> Optional[_builtins.bool]:
        """
        Detect similar node groups and balance the number of nodes between them. Defaults to `false`.
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @_builtins.property
    @pulumi.getter(name="daemonsetEvictionForEmptyNodesEnabled")
    def daemonset_eviction_for_empty_nodes_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether DaemonSet pods will be gracefully terminated from empty nodes. Defaults to `false`.
        """
        return pulumi.get(self, "daemonset_eviction_for_empty_nodes_enabled")

    @_builtins.property
    @pulumi.getter(name="daemonsetEvictionForOccupiedNodesEnabled")
    def daemonset_eviction_for_occupied_nodes_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether DaemonSet pods will be gracefully terminated from non-empty nodes. Defaults to `true`.
        """
        return pulumi.get(self, "daemonset_eviction_for_occupied_nodes_enabled")

    @_builtins.property
    @pulumi.getter(name="emptyBulkDeleteMax")
    def empty_bulk_delete_max(self) -> Optional[_builtins.str]:
        """
        Maximum number of empty nodes that can be deleted at the same time. Defaults to `10`.
        """
        return pulumi.get(self, "empty_bulk_delete_max")

    @_builtins.property
    @pulumi.getter
    def expander(self) -> Optional[_builtins.str]:
        """
        Expander to use. Possible values are `least-waste`, `priority`, `most-pods` and `random`. Defaults to `random`.
        """
        return pulumi.get(self, "expander")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonsetsUtilizationEnabled")
    def ignore_daemonsets_utilization_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether DaemonSet pods will be ignored when calculating resource utilization for scale down. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_daemonsets_utilization_enabled")

    @_builtins.property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> Optional[_builtins.str]:
        """
        Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. Defaults to `600`.
        """
        return pulumi.get(self, "max_graceful_termination_sec")

    @_builtins.property
    @pulumi.getter(name="maxNodeProvisioningTime")
    def max_node_provisioning_time(self) -> Optional[_builtins.str]:
        """
        Maximum time the autoscaler waits for a node to be provisioned. Defaults to `15m`.
        """
        return pulumi.get(self, "max_node_provisioning_time")

    @_builtins.property
    @pulumi.getter(name="maxUnreadyNodes")
    def max_unready_nodes(self) -> Optional[_builtins.int]:
        """
        Maximum Number of allowed unready nodes. Defaults to `3`.
        """
        return pulumi.get(self, "max_unready_nodes")

    @_builtins.property
    @pulumi.getter(name="maxUnreadyPercentage")
    def max_unready_percentage(self) -> Optional[_builtins.float]:
        """
        Maximum percentage of unready nodes the cluster autoscaler will stop if the percentage is exceeded. Defaults to `45`.
        """
        return pulumi.get(self, "max_unready_percentage")

    @_builtins.property
    @pulumi.getter(name="newPodScaleUpDelay")
    def new_pod_scale_up_delay(self) -> Optional[_builtins.str]:
        """
        For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. Defaults to `10s`.
        """
        return pulumi.get(self, "new_pod_scale_up_delay")

    @_builtins.property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> Optional[_builtins.str]:
        """
        How long after the scale up of AKS nodes the scale down evaluation resumes. Defaults to `10m`.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @_builtins.property
    @pulumi.getter(name="scaleDownDelayAfterDelete")
    def scale_down_delay_after_delete(self) -> Optional[_builtins.str]:
        """
        How long after node deletion that scale down evaluation resumes. Defaults to the value used for `scan_interval`.
        """
        return pulumi.get(self, "scale_down_delay_after_delete")

    @_builtins.property
    @pulumi.getter(name="scaleDownDelayAfterFailure")
    def scale_down_delay_after_failure(self) -> Optional[_builtins.str]:
        """
        How long after scale down failure that scale down evaluation resumes. Defaults to `3m`.
        """
        return pulumi.get(self, "scale_down_delay_after_failure")

    @_builtins.property
    @pulumi.getter(name="scaleDownUnneeded")
    def scale_down_unneeded(self) -> Optional[_builtins.str]:
        """
        How long a node should be unneeded before it is eligible for scale down. Defaults to `10m`.
        """
        return pulumi.get(self, "scale_down_unneeded")

    @_builtins.property
    @pulumi.getter(name="scaleDownUnready")
    def scale_down_unready(self) -> Optional[_builtins.str]:
        """
        How long an unready node should be unneeded before it is eligible for scale down. Defaults to `20m`.
        """
        return pulumi.get(self, "scale_down_unready")

    @_builtins.property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[_builtins.str]:
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. Defaults to `0.5`.
        """
        return pulumi.get(self, "scale_down_utilization_threshold")

    @_builtins.property
    @pulumi.getter(name="scanInterval")
    def scan_interval(self) -> Optional[_builtins.str]:
        """
        How often the AKS Cluster should be re-evaluated for scale up/down. Defaults to `10s`.
        """
        return pulumi.get(self, "scan_interval")

    @_builtins.property
    @pulumi.getter(name="skipNodesWithLocalStorage")
    def skip_nodes_with_local_storage(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "skip_nodes_with_local_storage")

    @_builtins.property
    @pulumi.getter(name="skipNodesWithSystemPods")
    def skip_nodes_with_system_pods(self) -> Optional[_builtins.bool]:
        """
        If `true` cluster autoscaler will never delete nodes with pods from kube-system (except for DaemonSet or mirror pods). Defaults to `true`.
        """
        return pulumi.get(self, "skip_nodes_with_system_pods")


@pulumi.output_type
class KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminGroupObjectIds":
            suggest = "admin_group_object_ids"
        elif key == "azureRbacEnabled":
            suggest = "azure_rbac_enabled"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_group_object_ids: Optional[Sequence[_builtins.str]] = None,
                 azure_rbac_enabled: Optional[_builtins.bool] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] admin_group_object_ids: A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
        :param _builtins.bool azure_rbac_enabled: Is Role Based Access Control based on Azure AD enabled?
        :param _builtins.str tenant_id: The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        """
        if admin_group_object_ids is not None:
            pulumi.set(__self__, "admin_group_object_ids", admin_group_object_ids)
        if azure_rbac_enabled is not None:
            pulumi.set(__self__, "azure_rbac_enabled", azure_rbac_enabled)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="adminGroupObjectIds")
    def admin_group_object_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
        """
        return pulumi.get(self, "admin_group_object_ids")

    @_builtins.property
    @pulumi.getter(name="azureRbacEnabled")
    def azure_rbac_enabled(self) -> Optional[_builtins.bool]:
        """
        Is Role Based Access Control based on Azure AD enabled?
        """
        return pulumi.get(self, "azure_rbac_enabled")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class KubernetesClusterBootstrapProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactSource":
            suggest = "artifact_source"
        elif key == "containerRegistryId":
            suggest = "container_registry_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterBootstrapProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterBootstrapProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterBootstrapProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_source: Optional[_builtins.str] = None,
                 container_registry_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str artifact_source: The artifact source. The source where the artifacts are downloaded from. Possible values are `Cache` and `Direct`. Defaults to `Direct`.
               
               > **Note:** If the `artifact_source` is set to `Cache` and the `outbound_type` has been specified, the managed ACR and related resources will **not** be automatically deleted and must be removed manually. Please see the product [documentation](https://learn.microsoft.com/azure/aks/concepts-network-isolated#how-a-network-isolated-cluster-works) for more information.
        :param _builtins.str container_registry_id: The resource Id of Azure Container Registry.
               
               > **Note:** The `container_registry_id` requires an ACR with a private link to the cluster. You must manage permissions, cache rules, the associated private link and the private endpoint. Please see the product [documentation](https://learn.microsoft.com/azure/container-registry/container-registry-private-link) for more information on configuring an ACR with a private endpoint.
        """
        if artifact_source is not None:
            pulumi.set(__self__, "artifact_source", artifact_source)
        if container_registry_id is not None:
            pulumi.set(__self__, "container_registry_id", container_registry_id)

    @_builtins.property
    @pulumi.getter(name="artifactSource")
    def artifact_source(self) -> Optional[_builtins.str]:
        """
        The artifact source. The source where the artifacts are downloaded from. Possible values are `Cache` and `Direct`. Defaults to `Direct`.

        > **Note:** If the `artifact_source` is set to `Cache` and the `outbound_type` has been specified, the managed ACR and related resources will **not** be automatically deleted and must be removed manually. Please see the product [documentation](https://learn.microsoft.com/azure/aks/concepts-network-isolated#how-a-network-isolated-cluster-works) for more information.
        """
        return pulumi.get(self, "artifact_source")

    @_builtins.property
    @pulumi.getter(name="containerRegistryId")
    def container_registry_id(self) -> Optional[_builtins.str]:
        """
        The resource Id of Azure Container Registry.

        > **Note:** The `container_registry_id` requires an ACR with a private link to the cluster. You must manage permissions, cache rules, the associated private link and the private endpoint. Please see the product [documentation](https://learn.microsoft.com/azure/container-registry/container-registry-private-link) for more information on configuring an ACR with a private endpoint.
        """
        return pulumi.get(self, "container_registry_id")


@pulumi.output_type
class KubernetesClusterConfidentialComputing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sgxQuoteHelperEnabled":
            suggest = "sgx_quote_helper_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterConfidentialComputing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterConfidentialComputing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterConfidentialComputing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sgx_quote_helper_enabled: _builtins.bool):
        """
        :param _builtins.bool sgx_quote_helper_enabled: Should the SGX quote helper be enabled?
        """
        pulumi.set(__self__, "sgx_quote_helper_enabled", sgx_quote_helper_enabled)

    @_builtins.property
    @pulumi.getter(name="sgxQuoteHelperEnabled")
    def sgx_quote_helper_enabled(self) -> _builtins.bool:
        """
        Should the SGX quote helper be enabled?
        """
        return pulumi.get(self, "sgx_quote_helper_enabled")


@pulumi.output_type
class KubernetesClusterDefaultNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScalingEnabled":
            suggest = "auto_scaling_enabled"
        elif key == "capacityReservationGroupId":
            suggest = "capacity_reservation_group_id"
        elif key == "fipsEnabled":
            suggest = "fips_enabled"
        elif key == "gpuDriver":
            suggest = "gpu_driver"
        elif key == "gpuInstance":
            suggest = "gpu_instance"
        elif key == "hostEncryptionEnabled":
            suggest = "host_encryption_enabled"
        elif key == "hostGroupId":
            suggest = "host_group_id"
        elif key == "kubeletConfig":
            suggest = "kubelet_config"
        elif key == "kubeletDiskType":
            suggest = "kubelet_disk_type"
        elif key == "linuxOsConfig":
            suggest = "linux_os_config"
        elif key == "maxCount":
            suggest = "max_count"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "minCount":
            suggest = "min_count"
        elif key == "nodeCount":
            suggest = "node_count"
        elif key == "nodeLabels":
            suggest = "node_labels"
        elif key == "nodeNetworkProfile":
            suggest = "node_network_profile"
        elif key == "nodePublicIpEnabled":
            suggest = "node_public_ip_enabled"
        elif key == "nodePublicIpPrefixId":
            suggest = "node_public_ip_prefix_id"
        elif key == "onlyCriticalAddonsEnabled":
            suggest = "only_critical_addons_enabled"
        elif key == "orchestratorVersion":
            suggest = "orchestrator_version"
        elif key == "osDiskSizeGb":
            suggest = "os_disk_size_gb"
        elif key == "osDiskType":
            suggest = "os_disk_type"
        elif key == "osSku":
            suggest = "os_sku"
        elif key == "podSubnetId":
            suggest = "pod_subnet_id"
        elif key == "proximityPlacementGroupId":
            suggest = "proximity_placement_group_id"
        elif key == "scaleDownMode":
            suggest = "scale_down_mode"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "temporaryNameForRotation":
            suggest = "temporary_name_for_rotation"
        elif key == "ultraSsdEnabled":
            suggest = "ultra_ssd_enabled"
        elif key == "upgradeSettings":
            suggest = "upgrade_settings"
        elif key == "vmSize":
            suggest = "vm_size"
        elif key == "vnetSubnetId":
            suggest = "vnet_subnet_id"
        elif key == "workloadRuntime":
            suggest = "workload_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterDefaultNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterDefaultNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterDefaultNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 auto_scaling_enabled: Optional[_builtins.bool] = None,
                 capacity_reservation_group_id: Optional[_builtins.str] = None,
                 fips_enabled: Optional[_builtins.bool] = None,
                 gpu_driver: Optional[_builtins.str] = None,
                 gpu_instance: Optional[_builtins.str] = None,
                 host_encryption_enabled: Optional[_builtins.bool] = None,
                 host_group_id: Optional[_builtins.str] = None,
                 kubelet_config: Optional['outputs.KubernetesClusterDefaultNodePoolKubeletConfig'] = None,
                 kubelet_disk_type: Optional[_builtins.str] = None,
                 linux_os_config: Optional['outputs.KubernetesClusterDefaultNodePoolLinuxOsConfig'] = None,
                 max_count: Optional[_builtins.int] = None,
                 max_pods: Optional[_builtins.int] = None,
                 min_count: Optional[_builtins.int] = None,
                 node_count: Optional[_builtins.int] = None,
                 node_labels: Optional[Mapping[str, _builtins.str]] = None,
                 node_network_profile: Optional['outputs.KubernetesClusterDefaultNodePoolNodeNetworkProfile'] = None,
                 node_public_ip_enabled: Optional[_builtins.bool] = None,
                 node_public_ip_prefix_id: Optional[_builtins.str] = None,
                 only_critical_addons_enabled: Optional[_builtins.bool] = None,
                 orchestrator_version: Optional[_builtins.str] = None,
                 os_disk_size_gb: Optional[_builtins.int] = None,
                 os_disk_type: Optional[_builtins.str] = None,
                 os_sku: Optional[_builtins.str] = None,
                 pod_subnet_id: Optional[_builtins.str] = None,
                 proximity_placement_group_id: Optional[_builtins.str] = None,
                 scale_down_mode: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 temporary_name_for_rotation: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 ultra_ssd_enabled: Optional[_builtins.bool] = None,
                 upgrade_settings: Optional['outputs.KubernetesClusterDefaultNodePoolUpgradeSettings'] = None,
                 vm_size: Optional[_builtins.str] = None,
                 vnet_subnet_id: Optional[_builtins.str] = None,
                 workload_runtime: Optional[_builtins.str] = None,
                 zones: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: The name which should be used for the default Kubernetes Node Pool.
        :param _builtins.bool auto_scaling_enabled: Should [the Kubernetes Auto Scaler](https://docs.microsoft.com/azure/aks/cluster-autoscaler) be enabled for this Node Pool?
               
               > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets`.
               
               > **Note:** If you're using AutoScaling, you may wish to use [`ignoreChanges` functionality](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) to ignore changes to the `node_count` field.
        :param _builtins.str capacity_reservation_group_id: Specifies the ID of the Capacity Reservation Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
        :param _builtins.bool fips_enabled: Should the nodes in this Node Pool have Federal Information Processing Standard enabled? `temporary_name_for_rotation` must be specified when changing this block.
        :param _builtins.str gpu_driver: Specifies the driver type for GPU nodes. Possible values are `Install` and `None`. Changing this forces a new resource to be created.
        :param _builtins.str gpu_instance: Specifies the GPU MIG instance profile for supported GPU VM SKU. The allowed values are `MIG1g`, `MIG2g`, `MIG3g`, `MIG4g` and `MIG7g`. Changing this forces a new resource to be created.
        :param _builtins.bool host_encryption_enabled: Should the nodes in the Default Node Pool have host encryption enabled? `temporary_name_for_rotation` must be specified when changing this property.
               
               > **Note:** This requires that the Feature `Microsoft.Compute/EncryptionAtHost` is enabled and the Resource Provider is registered.
        :param _builtins.str host_group_id: Specifies the ID of the Host Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
        :param 'KubernetesClusterDefaultNodePoolKubeletConfigArgs' kubelet_config: A `kubelet_config` block as defined below. `temporary_name_for_rotation` must be specified when changing this block.
        :param _builtins.str kubelet_disk_type: The type of disk used by kubelet. Possible values are `OS` and `Temporary`. `temporary_name_for_rotation` must be specified when changing this block.
        :param 'KubernetesClusterDefaultNodePoolLinuxOsConfigArgs' linux_os_config: A `linux_os_config` block as defined below. `temporary_name_for_rotation` must be specified when changing this block.
        :param _builtins.int max_pods: The maximum number of pods that can run on each agent. `temporary_name_for_rotation` must be specified when changing this property.
        :param Mapping[str, _builtins.str] node_labels: A map of Kubernetes labels which should be applied to nodes in the Default Node Pool.
        :param 'KubernetesClusterDefaultNodePoolNodeNetworkProfileArgs' node_network_profile: A `node_network_profile` block as documented below.
        :param _builtins.bool node_public_ip_enabled: Should nodes in this Node Pool have a Public IP Address? `temporary_name_for_rotation` must be specified when changing this property.
        :param _builtins.str node_public_ip_prefix_id: Resource ID for the Public IP Addresses Prefix for the nodes in this Node Pool. `node_public_ip_enabled` should be `true`. Changing this forces a new resource to be created.
        :param _builtins.bool only_critical_addons_enabled: Enabling this option will taint default node pool with `CriticalAddonsOnly=true:NoSchedule` taint. `temporary_name_for_rotation` must be specified when changing this property.
        :param _builtins.str orchestrator_version: Version of Kubernetes used for the Agents. If not specified, the default node pool will be created with the version specified by `kubernetes_version`. If both are unspecified, the latest recommended version will be used at provisioning time (but won't auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version's latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
               
               > **Note:** This version must be supported by the Kubernetes Cluster - as such the version of Kubernetes used on the Cluster/Control Plane may need to be upgraded first.
        :param _builtins.int os_disk_size_gb: The size of the OS Disk which should be used for each agent in the Node Pool. `temporary_name_for_rotation` must be specified when attempting a change.
        :param _builtins.str os_disk_type: The type of disk which should be used for the Operating System. Possible values are `Ephemeral` and `Managed`. Defaults to `Managed`. `temporary_name_for_rotation` must be specified when attempting a change.
        :param _builtins.str os_sku: Specifies the OS SKU used by the agent pool. Possible values are `AzureLinux`, `AzureLinux3`, `Ubuntu`, `Ubuntu2204`, `Windows2019` and `Windows2022`. If not specified, the default is `Ubuntu` if OSType=Linux or `Windows2019` if OSType=Windows. And the default Windows OSSKU will be changed to `Windows2022` after Windows2019 is deprecated. Changing this from `AzureLinux` or `Ubuntu` to `AzureLinux` or `Ubuntu` will not replace the resource, otherwise `temporary_name_for_rotation` must be specified when attempting a change.
        :param _builtins.str pod_subnet_id: The ID of the Subnet where the pods in the default Node Pool should exist.
        :param _builtins.str proximity_placement_group_id: The ID of the Proximity Placement Group. Changing this forces a new resource to be created.
        :param _builtins.str scale_down_mode: Specifies the autoscaling behaviour of the Kubernetes Cluster. Allowed values are `Delete` and `Deallocate`. Defaults to `Delete`.
        :param _builtins.str snapshot_id: The ID of the Snapshot which should be used to create this default Node Pool. `temporary_name_for_rotation` must be specified when changing this property.
        :param Mapping[str, _builtins.str] tags: A mapping of tags to assign to the Node Pool.
               
               > At this time there's a bug in the AKS API where Tags for a Node Pool are not stored in the correct case - you may wish to use `ignore_changes` functionality to ignore changes to the casing until this is fixed in the AKS API.
        :param _builtins.str temporary_name_for_rotation: Specifies the name of the temporary node pool used to cycle the default node pool for VM resizing.
        :param _builtins.str type: The type of Node Pool which should be created. Possible values are `VirtualMachineScaleSets`. Defaults to `VirtualMachineScaleSets`. Changing this forces a new resource to be created.
               
               > **Note:** When creating a cluster that supports multiple node pools, the cluster must use `VirtualMachineScaleSets`. For more information on the limitations of clusters using multiple node pools see [the documentation](https://learn.microsoft.com/en-us/azure/aks/use-multiple-node-pools#limitations).
        :param _builtins.bool ultra_ssd_enabled: Used to specify whether the UltraSSD is enabled in the Default Node Pool. Defaults to `false`. See [the documentation](https://docs.microsoft.com/azure/aks/use-ultra-disks) for more information. `temporary_name_for_rotation` must be specified when attempting a change.
        :param 'KubernetesClusterDefaultNodePoolUpgradeSettingsArgs' upgrade_settings: A `upgrade_settings` block as documented below.
        :param _builtins.str vm_size: The size of the Virtual Machine, such as `Standard_DS2_v2`. `temporary_name_for_rotation` must be specified when attempting a resize.
        :param _builtins.str vnet_subnet_id: The ID of a Subnet where the Kubernetes Node Pool should exist.
               
               > **Note:** A Route Table must be configured on this Subnet.
        :param _builtins.str workload_runtime: Specifies the workload runtime used by the node pool. Possible value is `OCIContainer`.
        :param Sequence[_builtins.str] zones: Specifies a list of Availability Zones in which this Kubernetes Cluster should be located. `temporary_name_for_rotation` must be specified when changing this property.
               
               > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets` and that `load_balancer_sku` is set to `standard`.
        """
        pulumi.set(__self__, "name", name)
        if auto_scaling_enabled is not None:
            pulumi.set(__self__, "auto_scaling_enabled", auto_scaling_enabled)
        if capacity_reservation_group_id is not None:
            pulumi.set(__self__, "capacity_reservation_group_id", capacity_reservation_group_id)
        if fips_enabled is not None:
            pulumi.set(__self__, "fips_enabled", fips_enabled)
        if gpu_driver is not None:
            pulumi.set(__self__, "gpu_driver", gpu_driver)
        if gpu_instance is not None:
            pulumi.set(__self__, "gpu_instance", gpu_instance)
        if host_encryption_enabled is not None:
            pulumi.set(__self__, "host_encryption_enabled", host_encryption_enabled)
        if host_group_id is not None:
            pulumi.set(__self__, "host_group_id", host_group_id)
        if kubelet_config is not None:
            pulumi.set(__self__, "kubelet_config", kubelet_config)
        if kubelet_disk_type is not None:
            pulumi.set(__self__, "kubelet_disk_type", kubelet_disk_type)
        if linux_os_config is not None:
            pulumi.set(__self__, "linux_os_config", linux_os_config)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if node_labels is not None:
            pulumi.set(__self__, "node_labels", node_labels)
        if node_network_profile is not None:
            pulumi.set(__self__, "node_network_profile", node_network_profile)
        if node_public_ip_enabled is not None:
            pulumi.set(__self__, "node_public_ip_enabled", node_public_ip_enabled)
        if node_public_ip_prefix_id is not None:
            pulumi.set(__self__, "node_public_ip_prefix_id", node_public_ip_prefix_id)
        if only_critical_addons_enabled is not None:
            pulumi.set(__self__, "only_critical_addons_enabled", only_critical_addons_enabled)
        if orchestrator_version is not None:
            pulumi.set(__self__, "orchestrator_version", orchestrator_version)
        if os_disk_size_gb is not None:
            pulumi.set(__self__, "os_disk_size_gb", os_disk_size_gb)
        if os_disk_type is not None:
            pulumi.set(__self__, "os_disk_type", os_disk_type)
        if os_sku is not None:
            pulumi.set(__self__, "os_sku", os_sku)
        if pod_subnet_id is not None:
            pulumi.set(__self__, "pod_subnet_id", pod_subnet_id)
        if proximity_placement_group_id is not None:
            pulumi.set(__self__, "proximity_placement_group_id", proximity_placement_group_id)
        if scale_down_mode is not None:
            pulumi.set(__self__, "scale_down_mode", scale_down_mode)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if temporary_name_for_rotation is not None:
            pulumi.set(__self__, "temporary_name_for_rotation", temporary_name_for_rotation)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if ultra_ssd_enabled is not None:
            pulumi.set(__self__, "ultra_ssd_enabled", ultra_ssd_enabled)
        if upgrade_settings is not None:
            pulumi.set(__self__, "upgrade_settings", upgrade_settings)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)
        if vnet_subnet_id is not None:
            pulumi.set(__self__, "vnet_subnet_id", vnet_subnet_id)
        if workload_runtime is not None:
            pulumi.set(__self__, "workload_runtime", workload_runtime)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name which should be used for the default Kubernetes Node Pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="autoScalingEnabled")
    def auto_scaling_enabled(self) -> Optional[_builtins.bool]:
        """
        Should [the Kubernetes Auto Scaler](https://docs.microsoft.com/azure/aks/cluster-autoscaler) be enabled for this Node Pool?

        > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets`.

        > **Note:** If you're using AutoScaling, you may wish to use [`ignoreChanges` functionality](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) to ignore changes to the `node_count` field.
        """
        return pulumi.get(self, "auto_scaling_enabled")

    @_builtins.property
    @pulumi.getter(name="capacityReservationGroupId")
    def capacity_reservation_group_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the Capacity Reservation Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "capacity_reservation_group_id")

    @_builtins.property
    @pulumi.getter(name="fipsEnabled")
    def fips_enabled(self) -> Optional[_builtins.bool]:
        """
        Should the nodes in this Node Pool have Federal Information Processing Standard enabled? `temporary_name_for_rotation` must be specified when changing this block.
        """
        return pulumi.get(self, "fips_enabled")

    @_builtins.property
    @pulumi.getter(name="gpuDriver")
    def gpu_driver(self) -> Optional[_builtins.str]:
        """
        Specifies the driver type for GPU nodes. Possible values are `Install` and `None`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "gpu_driver")

    @_builtins.property
    @pulumi.getter(name="gpuInstance")
    def gpu_instance(self) -> Optional[_builtins.str]:
        """
        Specifies the GPU MIG instance profile for supported GPU VM SKU. The allowed values are `MIG1g`, `MIG2g`, `MIG3g`, `MIG4g` and `MIG7g`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "gpu_instance")

    @_builtins.property
    @pulumi.getter(name="hostEncryptionEnabled")
    def host_encryption_enabled(self) -> Optional[_builtins.bool]:
        """
        Should the nodes in the Default Node Pool have host encryption enabled? `temporary_name_for_rotation` must be specified when changing this property.

        > **Note:** This requires that the Feature `Microsoft.Compute/EncryptionAtHost` is enabled and the Resource Provider is registered.
        """
        return pulumi.get(self, "host_encryption_enabled")

    @_builtins.property
    @pulumi.getter(name="hostGroupId")
    def host_group_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the Host Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "host_group_id")

    @_builtins.property
    @pulumi.getter(name="kubeletConfig")
    def kubelet_config(self) -> Optional['outputs.KubernetesClusterDefaultNodePoolKubeletConfig']:
        """
        A `kubelet_config` block as defined below. `temporary_name_for_rotation` must be specified when changing this block.
        """
        return pulumi.get(self, "kubelet_config")

    @_builtins.property
    @pulumi.getter(name="kubeletDiskType")
    def kubelet_disk_type(self) -> Optional[_builtins.str]:
        """
        The type of disk used by kubelet. Possible values are `OS` and `Temporary`. `temporary_name_for_rotation` must be specified when changing this block.
        """
        return pulumi.get(self, "kubelet_disk_type")

    @_builtins.property
    @pulumi.getter(name="linuxOsConfig")
    def linux_os_config(self) -> Optional['outputs.KubernetesClusterDefaultNodePoolLinuxOsConfig']:
        """
        A `linux_os_config` block as defined below. `temporary_name_for_rotation` must be specified when changing this block.
        """
        return pulumi.get(self, "linux_os_config")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[_builtins.int]:
        """
        The maximum number of pods that can run on each agent. `temporary_name_for_rotation` must be specified when changing this property.
        """
        return pulumi.get(self, "max_pods")

    @_builtins.property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_count")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of Kubernetes labels which should be applied to nodes in the Default Node Pool.
        """
        return pulumi.get(self, "node_labels")

    @_builtins.property
    @pulumi.getter(name="nodeNetworkProfile")
    def node_network_profile(self) -> Optional['outputs.KubernetesClusterDefaultNodePoolNodeNetworkProfile']:
        """
        A `node_network_profile` block as documented below.
        """
        return pulumi.get(self, "node_network_profile")

    @_builtins.property
    @pulumi.getter(name="nodePublicIpEnabled")
    def node_public_ip_enabled(self) -> Optional[_builtins.bool]:
        """
        Should nodes in this Node Pool have a Public IP Address? `temporary_name_for_rotation` must be specified when changing this property.
        """
        return pulumi.get(self, "node_public_ip_enabled")

    @_builtins.property
    @pulumi.getter(name="nodePublicIpPrefixId")
    def node_public_ip_prefix_id(self) -> Optional[_builtins.str]:
        """
        Resource ID for the Public IP Addresses Prefix for the nodes in this Node Pool. `node_public_ip_enabled` should be `true`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "node_public_ip_prefix_id")

    @_builtins.property
    @pulumi.getter(name="onlyCriticalAddonsEnabled")
    def only_critical_addons_enabled(self) -> Optional[_builtins.bool]:
        """
        Enabling this option will taint default node pool with `CriticalAddonsOnly=true:NoSchedule` taint. `temporary_name_for_rotation` must be specified when changing this property.
        """
        return pulumi.get(self, "only_critical_addons_enabled")

    @_builtins.property
    @pulumi.getter(name="orchestratorVersion")
    def orchestrator_version(self) -> Optional[_builtins.str]:
        """
        Version of Kubernetes used for the Agents. If not specified, the default node pool will be created with the version specified by `kubernetes_version`. If both are unspecified, the latest recommended version will be used at provisioning time (but won't auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version's latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).

        > **Note:** This version must be supported by the Kubernetes Cluster - as such the version of Kubernetes used on the Cluster/Control Plane may need to be upgraded first.
        """
        return pulumi.get(self, "orchestrator_version")

    @_builtins.property
    @pulumi.getter(name="osDiskSizeGb")
    def os_disk_size_gb(self) -> Optional[_builtins.int]:
        """
        The size of the OS Disk which should be used for each agent in the Node Pool. `temporary_name_for_rotation` must be specified when attempting a change.
        """
        return pulumi.get(self, "os_disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="osDiskType")
    def os_disk_type(self) -> Optional[_builtins.str]:
        """
        The type of disk which should be used for the Operating System. Possible values are `Ephemeral` and `Managed`. Defaults to `Managed`. `temporary_name_for_rotation` must be specified when attempting a change.
        """
        return pulumi.get(self, "os_disk_type")

    @_builtins.property
    @pulumi.getter(name="osSku")
    def os_sku(self) -> Optional[_builtins.str]:
        """
        Specifies the OS SKU used by the agent pool. Possible values are `AzureLinux`, `AzureLinux3`, `Ubuntu`, `Ubuntu2204`, `Windows2019` and `Windows2022`. If not specified, the default is `Ubuntu` if OSType=Linux or `Windows2019` if OSType=Windows. And the default Windows OSSKU will be changed to `Windows2022` after Windows2019 is deprecated. Changing this from `AzureLinux` or `Ubuntu` to `AzureLinux` or `Ubuntu` will not replace the resource, otherwise `temporary_name_for_rotation` must be specified when attempting a change.
        """
        return pulumi.get(self, "os_sku")

    @_builtins.property
    @pulumi.getter(name="podSubnetId")
    def pod_subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Subnet where the pods in the default Node Pool should exist.
        """
        return pulumi.get(self, "pod_subnet_id")

    @_builtins.property
    @pulumi.getter(name="proximityPlacementGroupId")
    def proximity_placement_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Proximity Placement Group. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "proximity_placement_group_id")

    @_builtins.property
    @pulumi.getter(name="scaleDownMode")
    def scale_down_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the autoscaling behaviour of the Kubernetes Cluster. Allowed values are `Delete` and `Deallocate`. Defaults to `Delete`.
        """
        return pulumi.get(self, "scale_down_mode")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Snapshot which should be used to create this default Node Pool. `temporary_name_for_rotation` must be specified when changing this property.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A mapping of tags to assign to the Node Pool.

        > At this time there's a bug in the AKS API where Tags for a Node Pool are not stored in the correct case - you may wish to use `ignore_changes` functionality to ignore changes to the casing until this is fixed in the AKS API.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="temporaryNameForRotation")
    def temporary_name_for_rotation(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the temporary node pool used to cycle the default node pool for VM resizing.
        """
        return pulumi.get(self, "temporary_name_for_rotation")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of Node Pool which should be created. Possible values are `VirtualMachineScaleSets`. Defaults to `VirtualMachineScaleSets`. Changing this forces a new resource to be created.

        > **Note:** When creating a cluster that supports multiple node pools, the cluster must use `VirtualMachineScaleSets`. For more information on the limitations of clusters using multiple node pools see [the documentation](https://learn.microsoft.com/en-us/azure/aks/use-multiple-node-pools#limitations).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="ultraSsdEnabled")
    def ultra_ssd_enabled(self) -> Optional[_builtins.bool]:
        """
        Used to specify whether the UltraSSD is enabled in the Default Node Pool. Defaults to `false`. See [the documentation](https://docs.microsoft.com/azure/aks/use-ultra-disks) for more information. `temporary_name_for_rotation` must be specified when attempting a change.
        """
        return pulumi.get(self, "ultra_ssd_enabled")

    @_builtins.property
    @pulumi.getter(name="upgradeSettings")
    def upgrade_settings(self) -> Optional['outputs.KubernetesClusterDefaultNodePoolUpgradeSettings']:
        """
        A `upgrade_settings` block as documented below.
        """
        return pulumi.get(self, "upgrade_settings")

    @_builtins.property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[_builtins.str]:
        """
        The size of the Virtual Machine, such as `Standard_DS2_v2`. `temporary_name_for_rotation` must be specified when attempting a resize.
        """
        return pulumi.get(self, "vm_size")

    @_builtins.property
    @pulumi.getter(name="vnetSubnetId")
    def vnet_subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of a Subnet where the Kubernetes Node Pool should exist.

        > **Note:** A Route Table must be configured on this Subnet.
        """
        return pulumi.get(self, "vnet_subnet_id")

    @_builtins.property
    @pulumi.getter(name="workloadRuntime")
    def workload_runtime(self) -> Optional[_builtins.str]:
        """
        Specifies the workload runtime used by the node pool. Possible value is `OCIContainer`.
        """
        return pulumi.get(self, "workload_runtime")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of Availability Zones in which this Kubernetes Cluster should be located. `temporary_name_for_rotation` must be specified when changing this property.

        > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets` and that `load_balancer_sku` is set to `standard`.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class KubernetesClusterDefaultNodePoolKubeletConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedUnsafeSysctls":
            suggest = "allowed_unsafe_sysctls"
        elif key == "containerLogMaxLine":
            suggest = "container_log_max_line"
        elif key == "containerLogMaxSizeMb":
            suggest = "container_log_max_size_mb"
        elif key == "cpuCfsQuotaEnabled":
            suggest = "cpu_cfs_quota_enabled"
        elif key == "cpuCfsQuotaPeriod":
            suggest = "cpu_cfs_quota_period"
        elif key == "cpuManagerPolicy":
            suggest = "cpu_manager_policy"
        elif key == "imageGcHighThreshold":
            suggest = "image_gc_high_threshold"
        elif key == "imageGcLowThreshold":
            suggest = "image_gc_low_threshold"
        elif key == "podMaxPid":
            suggest = "pod_max_pid"
        elif key == "topologyManagerPolicy":
            suggest = "topology_manager_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterDefaultNodePoolKubeletConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterDefaultNodePoolKubeletConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterDefaultNodePoolKubeletConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_unsafe_sysctls: Optional[Sequence[_builtins.str]] = None,
                 container_log_max_line: Optional[_builtins.int] = None,
                 container_log_max_size_mb: Optional[_builtins.int] = None,
                 cpu_cfs_quota_enabled: Optional[_builtins.bool] = None,
                 cpu_cfs_quota_period: Optional[_builtins.str] = None,
                 cpu_manager_policy: Optional[_builtins.str] = None,
                 image_gc_high_threshold: Optional[_builtins.int] = None,
                 image_gc_low_threshold: Optional[_builtins.int] = None,
                 pod_max_pid: Optional[_builtins.int] = None,
                 topology_manager_policy: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_unsafe_sysctls: Specifies the allow list of unsafe sysctls command or patterns (ending in `*`).
        :param _builtins.int container_log_max_line: Specifies the maximum number of container log files that can be present for a container. must be at least 2.
        :param _builtins.int container_log_max_size_mb: Specifies the maximum size (e.g. 10MB) of container log file before it is rotated.
        :param _builtins.bool cpu_cfs_quota_enabled: Is CPU CFS quota enforcement for containers enabled? Defaults to `true`.
        :param _builtins.str cpu_cfs_quota_period: Specifies the CPU CFS quota period value.
        :param _builtins.str cpu_manager_policy: Specifies the CPU Manager policy to use. Possible values are `none` and `static`,.
        :param _builtins.int image_gc_high_threshold: Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`.
        :param _builtins.int image_gc_low_threshold: Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`.
        :param _builtins.int pod_max_pid: Specifies the maximum number of processes per pod.
        :param _builtins.str topology_manager_policy: Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`.
        """
        if allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        if container_log_max_line is not None:
            pulumi.set(__self__, "container_log_max_line", container_log_max_line)
        if container_log_max_size_mb is not None:
            pulumi.set(__self__, "container_log_max_size_mb", container_log_max_size_mb)
        if cpu_cfs_quota_enabled is not None:
            pulumi.set(__self__, "cpu_cfs_quota_enabled", cpu_cfs_quota_enabled)
        if cpu_cfs_quota_period is not None:
            pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if image_gc_high_threshold is not None:
            pulumi.set(__self__, "image_gc_high_threshold", image_gc_high_threshold)
        if image_gc_low_threshold is not None:
            pulumi.set(__self__, "image_gc_low_threshold", image_gc_low_threshold)
        if pod_max_pid is not None:
            pulumi.set(__self__, "pod_max_pid", pod_max_pid)
        if topology_manager_policy is not None:
            pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)

    @_builtins.property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the allow list of unsafe sysctls command or patterns (ending in `*`).
        """
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @_builtins.property
    @pulumi.getter(name="containerLogMaxLine")
    def container_log_max_line(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of container log files that can be present for a container. must be at least 2.
        """
        return pulumi.get(self, "container_log_max_line")

    @_builtins.property
    @pulumi.getter(name="containerLogMaxSizeMb")
    def container_log_max_size_mb(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum size (e.g. 10MB) of container log file before it is rotated.
        """
        return pulumi.get(self, "container_log_max_size_mb")

    @_builtins.property
    @pulumi.getter(name="cpuCfsQuotaEnabled")
    def cpu_cfs_quota_enabled(self) -> Optional[_builtins.bool]:
        """
        Is CPU CFS quota enforcement for containers enabled? Defaults to `true`.
        """
        return pulumi.get(self, "cpu_cfs_quota_enabled")

    @_builtins.property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> Optional[_builtins.str]:
        """
        Specifies the CPU CFS quota period value.
        """
        return pulumi.get(self, "cpu_cfs_quota_period")

    @_builtins.property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[_builtins.str]:
        """
        Specifies the CPU Manager policy to use. Possible values are `none` and `static`,.
        """
        return pulumi.get(self, "cpu_manager_policy")

    @_builtins.property
    @pulumi.getter(name="imageGcHighThreshold")
    def image_gc_high_threshold(self) -> Optional[_builtins.int]:
        """
        Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`.
        """
        return pulumi.get(self, "image_gc_high_threshold")

    @_builtins.property
    @pulumi.getter(name="imageGcLowThreshold")
    def image_gc_low_threshold(self) -> Optional[_builtins.int]:
        """
        Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`.
        """
        return pulumi.get(self, "image_gc_low_threshold")

    @_builtins.property
    @pulumi.getter(name="podMaxPid")
    def pod_max_pid(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of processes per pod.
        """
        return pulumi.get(self, "pod_max_pid")

    @_builtins.property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> Optional[_builtins.str]:
        """
        Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`.
        """
        return pulumi.get(self, "topology_manager_policy")


@pulumi.output_type
class KubernetesClusterDefaultNodePoolLinuxOsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "swapFileSizeMb":
            suggest = "swap_file_size_mb"
        elif key == "sysctlConfig":
            suggest = "sysctl_config"
        elif key == "transparentHugePage":
            suggest = "transparent_huge_page"
        elif key == "transparentHugePageDefrag":
            suggest = "transparent_huge_page_defrag"
        elif key == "transparentHugePageEnabled":
            suggest = "transparent_huge_page_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterDefaultNodePoolLinuxOsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterDefaultNodePoolLinuxOsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterDefaultNodePoolLinuxOsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 swap_file_size_mb: Optional[_builtins.int] = None,
                 sysctl_config: Optional['outputs.KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig'] = None,
                 transparent_huge_page: Optional[_builtins.str] = None,
                 transparent_huge_page_defrag: Optional[_builtins.str] = None,
                 transparent_huge_page_enabled: Optional[_builtins.str] = None):
        """
        :param _builtins.int swap_file_size_mb: Specifies the size of the swap file on each node in MB.
        :param 'KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfigArgs' sysctl_config: A `sysctl_config` block as defined below.
        :param _builtins.str transparent_huge_page: Specifies the Transparent Huge Page configuration. Possible values are `always`, `madvise` and `never`.
        :param _builtins.str transparent_huge_page_defrag: specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`.
        """
        if swap_file_size_mb is not None:
            pulumi.set(__self__, "swap_file_size_mb", swap_file_size_mb)
        if sysctl_config is not None:
            pulumi.set(__self__, "sysctl_config", sysctl_config)
        if transparent_huge_page is not None:
            pulumi.set(__self__, "transparent_huge_page", transparent_huge_page)
        if transparent_huge_page_defrag is not None:
            pulumi.set(__self__, "transparent_huge_page_defrag", transparent_huge_page_defrag)
        if transparent_huge_page_enabled is not None:
            pulumi.set(__self__, "transparent_huge_page_enabled", transparent_huge_page_enabled)

    @_builtins.property
    @pulumi.getter(name="swapFileSizeMb")
    def swap_file_size_mb(self) -> Optional[_builtins.int]:
        """
        Specifies the size of the swap file on each node in MB.
        """
        return pulumi.get(self, "swap_file_size_mb")

    @_builtins.property
    @pulumi.getter(name="sysctlConfig")
    def sysctl_config(self) -> Optional['outputs.KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig']:
        """
        A `sysctl_config` block as defined below.
        """
        return pulumi.get(self, "sysctl_config")

    @_builtins.property
    @pulumi.getter(name="transparentHugePage")
    def transparent_huge_page(self) -> Optional[_builtins.str]:
        """
        Specifies the Transparent Huge Page configuration. Possible values are `always`, `madvise` and `never`.
        """
        return pulumi.get(self, "transparent_huge_page")

    @_builtins.property
    @pulumi.getter(name="transparentHugePageDefrag")
    def transparent_huge_page_defrag(self) -> Optional[_builtins.str]:
        """
        specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`.
        """
        return pulumi.get(self, "transparent_huge_page_defrag")

    @_builtins.property
    @pulumi.getter(name="transparentHugePageEnabled")
    @_utilities.deprecated("""this property has been deprecated in favour of `transparent_huge_page` and will be removed in version 5.0 of the Provider.""")
    def transparent_huge_page_enabled(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transparent_huge_page_enabled")


@pulumi.output_type
class KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fsAioMaxNr":
            suggest = "fs_aio_max_nr"
        elif key == "fsFileMax":
            suggest = "fs_file_max"
        elif key == "fsInotifyMaxUserWatches":
            suggest = "fs_inotify_max_user_watches"
        elif key == "fsNrOpen":
            suggest = "fs_nr_open"
        elif key == "kernelThreadsMax":
            suggest = "kernel_threads_max"
        elif key == "netCoreNetdevMaxBacklog":
            suggest = "net_core_netdev_max_backlog"
        elif key == "netCoreOptmemMax":
            suggest = "net_core_optmem_max"
        elif key == "netCoreRmemDefault":
            suggest = "net_core_rmem_default"
        elif key == "netCoreRmemMax":
            suggest = "net_core_rmem_max"
        elif key == "netCoreSomaxconn":
            suggest = "net_core_somaxconn"
        elif key == "netCoreWmemDefault":
            suggest = "net_core_wmem_default"
        elif key == "netCoreWmemMax":
            suggest = "net_core_wmem_max"
        elif key == "netIpv4IpLocalPortRangeMax":
            suggest = "net_ipv4_ip_local_port_range_max"
        elif key == "netIpv4IpLocalPortRangeMin":
            suggest = "net_ipv4_ip_local_port_range_min"
        elif key == "netIpv4NeighDefaultGcThresh1":
            suggest = "net_ipv4_neigh_default_gc_thresh1"
        elif key == "netIpv4NeighDefaultGcThresh2":
            suggest = "net_ipv4_neigh_default_gc_thresh2"
        elif key == "netIpv4NeighDefaultGcThresh3":
            suggest = "net_ipv4_neigh_default_gc_thresh3"
        elif key == "netIpv4TcpFinTimeout":
            suggest = "net_ipv4_tcp_fin_timeout"
        elif key == "netIpv4TcpKeepaliveIntvl":
            suggest = "net_ipv4_tcp_keepalive_intvl"
        elif key == "netIpv4TcpKeepaliveProbes":
            suggest = "net_ipv4_tcp_keepalive_probes"
        elif key == "netIpv4TcpKeepaliveTime":
            suggest = "net_ipv4_tcp_keepalive_time"
        elif key == "netIpv4TcpMaxSynBacklog":
            suggest = "net_ipv4_tcp_max_syn_backlog"
        elif key == "netIpv4TcpMaxTwBuckets":
            suggest = "net_ipv4_tcp_max_tw_buckets"
        elif key == "netIpv4TcpTwReuse":
            suggest = "net_ipv4_tcp_tw_reuse"
        elif key == "netNetfilterNfConntrackBuckets":
            suggest = "net_netfilter_nf_conntrack_buckets"
        elif key == "netNetfilterNfConntrackMax":
            suggest = "net_netfilter_nf_conntrack_max"
        elif key == "vmMaxMapCount":
            suggest = "vm_max_map_count"
        elif key == "vmSwappiness":
            suggest = "vm_swappiness"
        elif key == "vmVfsCachePressure":
            suggest = "vm_vfs_cache_pressure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fs_aio_max_nr: Optional[_builtins.int] = None,
                 fs_file_max: Optional[_builtins.int] = None,
                 fs_inotify_max_user_watches: Optional[_builtins.int] = None,
                 fs_nr_open: Optional[_builtins.int] = None,
                 kernel_threads_max: Optional[_builtins.int] = None,
                 net_core_netdev_max_backlog: Optional[_builtins.int] = None,
                 net_core_optmem_max: Optional[_builtins.int] = None,
                 net_core_rmem_default: Optional[_builtins.int] = None,
                 net_core_rmem_max: Optional[_builtins.int] = None,
                 net_core_somaxconn: Optional[_builtins.int] = None,
                 net_core_wmem_default: Optional[_builtins.int] = None,
                 net_core_wmem_max: Optional[_builtins.int] = None,
                 net_ipv4_ip_local_port_range_max: Optional[_builtins.int] = None,
                 net_ipv4_ip_local_port_range_min: Optional[_builtins.int] = None,
                 net_ipv4_neigh_default_gc_thresh1: Optional[_builtins.int] = None,
                 net_ipv4_neigh_default_gc_thresh2: Optional[_builtins.int] = None,
                 net_ipv4_neigh_default_gc_thresh3: Optional[_builtins.int] = None,
                 net_ipv4_tcp_fin_timeout: Optional[_builtins.int] = None,
                 net_ipv4_tcp_keepalive_intvl: Optional[_builtins.int] = None,
                 net_ipv4_tcp_keepalive_probes: Optional[_builtins.int] = None,
                 net_ipv4_tcp_keepalive_time: Optional[_builtins.int] = None,
                 net_ipv4_tcp_max_syn_backlog: Optional[_builtins.int] = None,
                 net_ipv4_tcp_max_tw_buckets: Optional[_builtins.int] = None,
                 net_ipv4_tcp_tw_reuse: Optional[_builtins.bool] = None,
                 net_netfilter_nf_conntrack_buckets: Optional[_builtins.int] = None,
                 net_netfilter_nf_conntrack_max: Optional[_builtins.int] = None,
                 vm_max_map_count: Optional[_builtins.int] = None,
                 vm_swappiness: Optional[_builtins.int] = None,
                 vm_vfs_cache_pressure: Optional[_builtins.int] = None):
        """
        :param _builtins.int fs_aio_max_nr: The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`.
        :param _builtins.int fs_file_max: The sysctl setting fs.file-max. Must be between `8192` and `12000500`.
        :param _builtins.int fs_inotify_max_user_watches: The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`.
        :param _builtins.int fs_nr_open: The sysctl setting fs.nr_open. Must be between `8192` and `20000500`.
        :param _builtins.int kernel_threads_max: The sysctl setting kernel.threads-max. Must be between `20` and `513785`.
        :param _builtins.int net_core_netdev_max_backlog: The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`.
        :param _builtins.int net_core_optmem_max: The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`.
        :param _builtins.int net_core_rmem_default: The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`.
        :param _builtins.int net_core_rmem_max: The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`.
        :param _builtins.int net_core_somaxconn: The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`.
        :param _builtins.int net_core_wmem_default: The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`.
        :param _builtins.int net_core_wmem_max: The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`.
        :param _builtins.int net_ipv4_ip_local_port_range_max: The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`.
        :param _builtins.int net_ipv4_ip_local_port_range_min: The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`.
        :param _builtins.int net_ipv4_neigh_default_gc_thresh1: The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`.
        :param _builtins.int net_ipv4_neigh_default_gc_thresh2: The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`.
        :param _builtins.int net_ipv4_neigh_default_gc_thresh3: The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`.
        :param _builtins.int net_ipv4_tcp_fin_timeout: The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`.
        :param _builtins.int net_ipv4_tcp_keepalive_intvl: The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`.
        :param _builtins.int net_ipv4_tcp_keepalive_probes: The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`.
        :param _builtins.int net_ipv4_tcp_keepalive_time: The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`.
        :param _builtins.int net_ipv4_tcp_max_syn_backlog: The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`.
        :param _builtins.int net_ipv4_tcp_max_tw_buckets: The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`.
        :param _builtins.bool net_ipv4_tcp_tw_reuse: The sysctl setting net.ipv4.tcp_tw_reuse.
        :param _builtins.int net_netfilter_nf_conntrack_buckets: The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`.
        :param _builtins.int net_netfilter_nf_conntrack_max: The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`.
        :param _builtins.int vm_max_map_count: The sysctl setting vm.max_map_count. Must be between `65530` and `262144`.
        :param _builtins.int vm_swappiness: The sysctl setting vm.swappiness. Must be between `0` and `100`.
        :param _builtins.int vm_vfs_cache_pressure: The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`.
        """
        if fs_aio_max_nr is not None:
            pulumi.set(__self__, "fs_aio_max_nr", fs_aio_max_nr)
        if fs_file_max is not None:
            pulumi.set(__self__, "fs_file_max", fs_file_max)
        if fs_inotify_max_user_watches is not None:
            pulumi.set(__self__, "fs_inotify_max_user_watches", fs_inotify_max_user_watches)
        if fs_nr_open is not None:
            pulumi.set(__self__, "fs_nr_open", fs_nr_open)
        if kernel_threads_max is not None:
            pulumi.set(__self__, "kernel_threads_max", kernel_threads_max)
        if net_core_netdev_max_backlog is not None:
            pulumi.set(__self__, "net_core_netdev_max_backlog", net_core_netdev_max_backlog)
        if net_core_optmem_max is not None:
            pulumi.set(__self__, "net_core_optmem_max", net_core_optmem_max)
        if net_core_rmem_default is not None:
            pulumi.set(__self__, "net_core_rmem_default", net_core_rmem_default)
        if net_core_rmem_max is not None:
            pulumi.set(__self__, "net_core_rmem_max", net_core_rmem_max)
        if net_core_somaxconn is not None:
            pulumi.set(__self__, "net_core_somaxconn", net_core_somaxconn)
        if net_core_wmem_default is not None:
            pulumi.set(__self__, "net_core_wmem_default", net_core_wmem_default)
        if net_core_wmem_max is not None:
            pulumi.set(__self__, "net_core_wmem_max", net_core_wmem_max)
        if net_ipv4_ip_local_port_range_max is not None:
            pulumi.set(__self__, "net_ipv4_ip_local_port_range_max", net_ipv4_ip_local_port_range_max)
        if net_ipv4_ip_local_port_range_min is not None:
            pulumi.set(__self__, "net_ipv4_ip_local_port_range_min", net_ipv4_ip_local_port_range_min)
        if net_ipv4_neigh_default_gc_thresh1 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh1", net_ipv4_neigh_default_gc_thresh1)
        if net_ipv4_neigh_default_gc_thresh2 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh2", net_ipv4_neigh_default_gc_thresh2)
        if net_ipv4_neigh_default_gc_thresh3 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh3", net_ipv4_neigh_default_gc_thresh3)
        if net_ipv4_tcp_fin_timeout is not None:
            pulumi.set(__self__, "net_ipv4_tcp_fin_timeout", net_ipv4_tcp_fin_timeout)
        if net_ipv4_tcp_keepalive_intvl is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_intvl", net_ipv4_tcp_keepalive_intvl)
        if net_ipv4_tcp_keepalive_probes is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_probes", net_ipv4_tcp_keepalive_probes)
        if net_ipv4_tcp_keepalive_time is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_time", net_ipv4_tcp_keepalive_time)
        if net_ipv4_tcp_max_syn_backlog is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_syn_backlog", net_ipv4_tcp_max_syn_backlog)
        if net_ipv4_tcp_max_tw_buckets is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_tw_buckets", net_ipv4_tcp_max_tw_buckets)
        if net_ipv4_tcp_tw_reuse is not None:
            pulumi.set(__self__, "net_ipv4_tcp_tw_reuse", net_ipv4_tcp_tw_reuse)
        if net_netfilter_nf_conntrack_buckets is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_buckets", net_netfilter_nf_conntrack_buckets)
        if net_netfilter_nf_conntrack_max is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_max", net_netfilter_nf_conntrack_max)
        if vm_max_map_count is not None:
            pulumi.set(__self__, "vm_max_map_count", vm_max_map_count)
        if vm_swappiness is not None:
            pulumi.set(__self__, "vm_swappiness", vm_swappiness)
        if vm_vfs_cache_pressure is not None:
            pulumi.set(__self__, "vm_vfs_cache_pressure", vm_vfs_cache_pressure)

    @_builtins.property
    @pulumi.getter(name="fsAioMaxNr")
    def fs_aio_max_nr(self) -> Optional[_builtins.int]:
        """
        The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`.
        """
        return pulumi.get(self, "fs_aio_max_nr")

    @_builtins.property
    @pulumi.getter(name="fsFileMax")
    def fs_file_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting fs.file-max. Must be between `8192` and `12000500`.
        """
        return pulumi.get(self, "fs_file_max")

    @_builtins.property
    @pulumi.getter(name="fsInotifyMaxUserWatches")
    def fs_inotify_max_user_watches(self) -> Optional[_builtins.int]:
        """
        The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`.
        """
        return pulumi.get(self, "fs_inotify_max_user_watches")

    @_builtins.property
    @pulumi.getter(name="fsNrOpen")
    def fs_nr_open(self) -> Optional[_builtins.int]:
        """
        The sysctl setting fs.nr_open. Must be between `8192` and `20000500`.
        """
        return pulumi.get(self, "fs_nr_open")

    @_builtins.property
    @pulumi.getter(name="kernelThreadsMax")
    def kernel_threads_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting kernel.threads-max. Must be between `20` and `513785`.
        """
        return pulumi.get(self, "kernel_threads_max")

    @_builtins.property
    @pulumi.getter(name="netCoreNetdevMaxBacklog")
    def net_core_netdev_max_backlog(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`.
        """
        return pulumi.get(self, "net_core_netdev_max_backlog")

    @_builtins.property
    @pulumi.getter(name="netCoreOptmemMax")
    def net_core_optmem_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`.
        """
        return pulumi.get(self, "net_core_optmem_max")

    @_builtins.property
    @pulumi.getter(name="netCoreRmemDefault")
    def net_core_rmem_default(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`.
        """
        return pulumi.get(self, "net_core_rmem_default")

    @_builtins.property
    @pulumi.getter(name="netCoreRmemMax")
    def net_core_rmem_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`.
        """
        return pulumi.get(self, "net_core_rmem_max")

    @_builtins.property
    @pulumi.getter(name="netCoreSomaxconn")
    def net_core_somaxconn(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`.
        """
        return pulumi.get(self, "net_core_somaxconn")

    @_builtins.property
    @pulumi.getter(name="netCoreWmemDefault")
    def net_core_wmem_default(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`.
        """
        return pulumi.get(self, "net_core_wmem_default")

    @_builtins.property
    @pulumi.getter(name="netCoreWmemMax")
    def net_core_wmem_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`.
        """
        return pulumi.get(self, "net_core_wmem_max")

    @_builtins.property
    @pulumi.getter(name="netIpv4IpLocalPortRangeMax")
    def net_ipv4_ip_local_port_range_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`.
        """
        return pulumi.get(self, "net_ipv4_ip_local_port_range_max")

    @_builtins.property
    @pulumi.getter(name="netIpv4IpLocalPortRangeMin")
    def net_ipv4_ip_local_port_range_min(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`.
        """
        return pulumi.get(self, "net_ipv4_ip_local_port_range_min")

    @_builtins.property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh1")
    def net_ipv4_neigh_default_gc_thresh1(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh1")

    @_builtins.property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh2")
    def net_ipv4_neigh_default_gc_thresh2(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh2")

    @_builtins.property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh3")
    def net_ipv4_neigh_default_gc_thresh3(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh3")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpFinTimeout")
    def net_ipv4_tcp_fin_timeout(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`.
        """
        return pulumi.get(self, "net_ipv4_tcp_fin_timeout")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpKeepaliveIntvl")
    def net_ipv4_tcp_keepalive_intvl(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_intvl")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpKeepaliveProbes")
    def net_ipv4_tcp_keepalive_probes(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_probes")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpKeepaliveTime")
    def net_ipv4_tcp_keepalive_time(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_time")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpMaxSynBacklog")
    def net_ipv4_tcp_max_syn_backlog(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_syn_backlog")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpMaxTwBuckets")
    def net_ipv4_tcp_max_tw_buckets(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_tw_buckets")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpTwReuse")
    def net_ipv4_tcp_tw_reuse(self) -> Optional[_builtins.bool]:
        """
        The sysctl setting net.ipv4.tcp_tw_reuse.
        """
        return pulumi.get(self, "net_ipv4_tcp_tw_reuse")

    @_builtins.property
    @pulumi.getter(name="netNetfilterNfConntrackBuckets")
    def net_netfilter_nf_conntrack_buckets(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_buckets")

    @_builtins.property
    @pulumi.getter(name="netNetfilterNfConntrackMax")
    def net_netfilter_nf_conntrack_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_max")

    @_builtins.property
    @pulumi.getter(name="vmMaxMapCount")
    def vm_max_map_count(self) -> Optional[_builtins.int]:
        """
        The sysctl setting vm.max_map_count. Must be between `65530` and `262144`.
        """
        return pulumi.get(self, "vm_max_map_count")

    @_builtins.property
    @pulumi.getter(name="vmSwappiness")
    def vm_swappiness(self) -> Optional[_builtins.int]:
        """
        The sysctl setting vm.swappiness. Must be between `0` and `100`.
        """
        return pulumi.get(self, "vm_swappiness")

    @_builtins.property
    @pulumi.getter(name="vmVfsCachePressure")
    def vm_vfs_cache_pressure(self) -> Optional[_builtins.int]:
        """
        The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`.
        """
        return pulumi.get(self, "vm_vfs_cache_pressure")


@pulumi.output_type
class KubernetesClusterDefaultNodePoolNodeNetworkProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedHostPorts":
            suggest = "allowed_host_ports"
        elif key == "applicationSecurityGroupIds":
            suggest = "application_security_group_ids"
        elif key == "nodePublicIpTags":
            suggest = "node_public_ip_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterDefaultNodePoolNodeNetworkProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterDefaultNodePoolNodeNetworkProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterDefaultNodePoolNodeNetworkProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_host_ports: Optional[Sequence['outputs.KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPort']] = None,
                 application_security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 node_public_ip_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence['KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPortArgs'] allowed_host_ports: One or more `allowed_host_ports` blocks as defined below.
        :param Sequence[_builtins.str] application_security_group_ids: A list of Application Security Group IDs which should be associated with this Node Pool.
        :param Mapping[str, _builtins.str] node_public_ip_tags: Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.
        """
        if allowed_host_ports is not None:
            pulumi.set(__self__, "allowed_host_ports", allowed_host_ports)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if node_public_ip_tags is not None:
            pulumi.set(__self__, "node_public_ip_tags", node_public_ip_tags)

    @_builtins.property
    @pulumi.getter(name="allowedHostPorts")
    def allowed_host_ports(self) -> Optional[Sequence['outputs.KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPort']]:
        """
        One or more `allowed_host_ports` blocks as defined below.
        """
        return pulumi.get(self, "allowed_host_ports")

    @_builtins.property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of Application Security Group IDs which should be associated with this Node Pool.
        """
        return pulumi.get(self, "application_security_group_ids")

    @_builtins.property
    @pulumi.getter(name="nodePublicIpTags")
    def node_public_ip_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "node_public_ip_tags")


@pulumi.output_type
class KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portEnd":
            suggest = "port_end"
        elif key == "portStart":
            suggest = "port_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_end: Optional[_builtins.int] = None,
                 port_start: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.int port_end: Specifies the end of the port range.
        :param _builtins.int port_start: Specifies the start of the port range.
        :param _builtins.str protocol: Specifies the protocol of the port range. Possible values are `TCP` and `UDP`.
        """
        if port_end is not None:
            pulumi.set(__self__, "port_end", port_end)
        if port_start is not None:
            pulumi.set(__self__, "port_start", port_start)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="portEnd")
    def port_end(self) -> Optional[_builtins.int]:
        """
        Specifies the end of the port range.
        """
        return pulumi.get(self, "port_end")

    @_builtins.property
    @pulumi.getter(name="portStart")
    def port_start(self) -> Optional[_builtins.int]:
        """
        Specifies the start of the port range.
        """
        return pulumi.get(self, "port_start")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Specifies the protocol of the port range. Possible values are `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class KubernetesClusterDefaultNodePoolUpgradeSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"
        elif key == "drainTimeoutInMinutes":
            suggest = "drain_timeout_in_minutes"
        elif key == "nodeSoakDurationInMinutes":
            suggest = "node_soak_duration_in_minutes"
        elif key == "undrainableNodeBehavior":
            suggest = "undrainable_node_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterDefaultNodePoolUpgradeSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterDefaultNodePoolUpgradeSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterDefaultNodePoolUpgradeSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: _builtins.str,
                 drain_timeout_in_minutes: Optional[_builtins.int] = None,
                 node_soak_duration_in_minutes: Optional[_builtins.int] = None,
                 undrainable_node_behavior: Optional[_builtins.str] = None):
        """
        :param _builtins.str max_surge: The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
               
               > **Note:** If a percentage is provided, the number of surge nodes is calculated from the `node_count` value on the current cluster. Node surge can allow a cluster to have more nodes than `max_count` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
        :param _builtins.int drain_timeout_in_minutes: The amount of time in minutes to wait on eviction of pods and graceful termination per node. This eviction wait time honors pod disruption budgets for upgrades. If this time is exceeded, the upgrade fails. Unsetting this after configuring it will force a new resource to be created.
        :param _builtins.int node_soak_duration_in_minutes: The amount of time in minutes to wait after draining a node and before reimaging and moving on to next node.
               
               > **Note:** The default value for `node_soak_duration_in_minutes` is `0`. <!-- The 0 default happens in code, not in Schema -->.
        :param _builtins.str undrainable_node_behavior: Specifies the action when a node is undrainable during upgrade. Possible values are `Cordon` and `Schedule`. Unsetting this after configuring it will force a new resource to be created.
        """
        pulumi.set(__self__, "max_surge", max_surge)
        if drain_timeout_in_minutes is not None:
            pulumi.set(__self__, "drain_timeout_in_minutes", drain_timeout_in_minutes)
        if node_soak_duration_in_minutes is not None:
            pulumi.set(__self__, "node_soak_duration_in_minutes", node_soak_duration_in_minutes)
        if undrainable_node_behavior is not None:
            pulumi.set(__self__, "undrainable_node_behavior", undrainable_node_behavior)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> _builtins.str:
        """
        The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.

        > **Note:** If a percentage is provided, the number of surge nodes is calculated from the `node_count` value on the current cluster. Node surge can allow a cluster to have more nodes than `max_count` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="drainTimeoutInMinutes")
    def drain_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        The amount of time in minutes to wait on eviction of pods and graceful termination per node. This eviction wait time honors pod disruption budgets for upgrades. If this time is exceeded, the upgrade fails. Unsetting this after configuring it will force a new resource to be created.
        """
        return pulumi.get(self, "drain_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="nodeSoakDurationInMinutes")
    def node_soak_duration_in_minutes(self) -> Optional[_builtins.int]:
        """
        The amount of time in minutes to wait after draining a node and before reimaging and moving on to next node.

        > **Note:** The default value for `node_soak_duration_in_minutes` is `0`. <!-- The 0 default happens in code, not in Schema -->.
        """
        return pulumi.get(self, "node_soak_duration_in_minutes")

    @_builtins.property
    @pulumi.getter(name="undrainableNodeBehavior")
    def undrainable_node_behavior(self) -> Optional[_builtins.str]:
        """
        Specifies the action when a node is undrainable during upgrade. Possible values are `Cordon` and `Schedule`. Unsetting this after configuring it will force a new resource to be created.
        """
        return pulumi.get(self, "undrainable_node_behavior")


@pulumi.output_type
class KubernetesClusterExtensionAksAssignedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterExtensionAksAssignedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterExtensionAksAssignedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterExtensionAksAssignedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str principal_id: The principal ID of resource identity.
        :param _builtins.str tenant_id: The tenant ID of resource.
        :param _builtins.str type: The identity type.
        """
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[_builtins.str]:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KubernetesClusterExtensionPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promotionCode":
            suggest = "promotion_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterExtensionPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterExtensionPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterExtensionPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 product: _builtins.str,
                 publisher: _builtins.str,
                 promotion_code: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the name of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
        :param _builtins.str product: Specifies the product of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
        :param _builtins.str publisher: Specifies the publisher of the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
        :param _builtins.str promotion_code: Specifies the promotion code to use with the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
        :param _builtins.str version: Specifies the version of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
               
               > **Note:** When `plan` is specified, legal terms must be accepted for this item on this subscription before creating the Kubernetes Cluster Extension. The `marketplace.Agreement` resource or AZ CLI tool can be used to do this.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def product(self) -> _builtins.str:
        """
        Specifies the product of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> _builtins.str:
        """
        Specifies the publisher of the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
        """
        return pulumi.get(self, "publisher")

    @_builtins.property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[_builtins.str]:
        """
        Specifies the promotion code to use with the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
        """
        return pulumi.get(self, "promotion_code")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Specifies the version of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.

        > **Note:** When `plan` is specified, legal terms must be accepted for this item on this subscription before creating the Kubernetes Cluster Extension. The `marketplace.Agreement` resource or AZ CLI tool can be used to do this.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class KubernetesClusterHttpProxyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpProxy":
            suggest = "http_proxy"
        elif key == "httpsProxy":
            suggest = "https_proxy"
        elif key == "noProxies":
            suggest = "no_proxies"
        elif key == "trustedCa":
            suggest = "trusted_ca"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterHttpProxyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterHttpProxyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterHttpProxyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_proxy: Optional[_builtins.str] = None,
                 https_proxy: Optional[_builtins.str] = None,
                 no_proxies: Optional[Sequence[_builtins.str]] = None,
                 trusted_ca: Optional[_builtins.str] = None):
        """
        :param _builtins.str http_proxy: The proxy address to be used when communicating over HTTP.
        :param _builtins.str https_proxy: The proxy address to be used when communicating over HTTPS.
        :param _builtins.str trusted_ca: The base64 encoded alternative CA certificate content in PEM format.
        """
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if no_proxies is not None:
            pulumi.set(__self__, "no_proxies", no_proxies)
        if trusted_ca is not None:
            pulumi.set(__self__, "trusted_ca", trusted_ca)

    @_builtins.property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[_builtins.str]:
        """
        The proxy address to be used when communicating over HTTP.
        """
        return pulumi.get(self, "http_proxy")

    @_builtins.property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[_builtins.str]:
        """
        The proxy address to be used when communicating over HTTPS.
        """
        return pulumi.get(self, "https_proxy")

    @_builtins.property
    @pulumi.getter(name="noProxies")
    def no_proxies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "no_proxies")

    @_builtins.property
    @pulumi.getter(name="trustedCa")
    def trusted_ca(self) -> Optional[_builtins.str]:
        """
        The base64 encoded alternative CA certificate content in PEM format.
        """
        return pulumi.get(self, "trusted_ca")


@pulumi.output_type
class KubernetesClusterIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 identity_ids: Optional[Sequence[_builtins.str]] = None,
                 principal_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the type of Managed Service Identity that should be configured on this Kubernetes Cluster. Possible values are `SystemAssigned` or `UserAssigned`.
        :param Sequence[_builtins.str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Kubernetes Cluster.
               
               > **Note:** This is required when `type` is set to `UserAssigned`. Currently only one User Assigned Identity is supported.
        :param _builtins.str principal_id: The Principal ID associated with this Managed Service Identity.
        :param _builtins.str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Kubernetes Cluster. Possible values are `SystemAssigned` or `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Kubernetes Cluster.

        > **Note:** This is required when `type` is set to `UserAssigned`. Currently only one User Assigned Identity is supported.
        """
        return pulumi.get(self, "identity_ids")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[_builtins.str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class KubernetesClusterIngressApplicationGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveGatewayId":
            suggest = "effective_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "gatewayName":
            suggest = "gateway_name"
        elif key == "ingressApplicationGatewayIdentities":
            suggest = "ingress_application_gateway_identities"
        elif key == "subnetCidr":
            suggest = "subnet_cidr"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterIngressApplicationGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterIngressApplicationGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterIngressApplicationGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 gateway_name: Optional[_builtins.str] = None,
                 ingress_application_gateway_identities: Optional[Sequence['outputs.KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity']] = None,
                 subnet_cidr: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str effective_gateway_id: The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
        :param _builtins.str gateway_id: The ID of the Application Gateway to integrate with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-existing) page for further details.
        :param _builtins.str gateway_name: The name of the Application Gateway to be used or created in the Nodepool Resource Group, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
        :param Sequence['KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityArgs'] ingress_application_gateway_identities: An `ingress_application_gateway_identity` block is exported. The exported attributes are defined below.
        :param _builtins.str subnet_cidr: The subnet CIDR to be used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
        :param _builtins.str subnet_id: The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
               
               > **Note:** Exactly one of `gateway_id`, `subnet_id` or `subnet_cidr` must be specified.
               
               > **Note:** If specifying `ingress_application_gateway` in conjunction with `only_critical_addons_enabled`, the AGIC pod will fail to start. A separate `containerservice.KubernetesClusterNodePool` is required to run the AGIC pod successfully. This is because AGIC is classed as a "non-critical addon".
        """
        if effective_gateway_id is not None:
            pulumi.set(__self__, "effective_gateway_id", effective_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if gateway_name is not None:
            pulumi.set(__self__, "gateway_name", gateway_name)
        if ingress_application_gateway_identities is not None:
            pulumi.set(__self__, "ingress_application_gateway_identities", ingress_application_gateway_identities)
        if subnet_cidr is not None:
            pulumi.set(__self__, "subnet_cidr", subnet_cidr)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="effectiveGatewayId")
    def effective_gateway_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
        """
        return pulumi.get(self, "effective_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Application Gateway to integrate with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-existing) page for further details.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayName")
    def gateway_name(self) -> Optional[_builtins.str]:
        """
        The name of the Application Gateway to be used or created in the Nodepool Resource Group, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
        """
        return pulumi.get(self, "gateway_name")

    @_builtins.property
    @pulumi.getter(name="ingressApplicationGatewayIdentities")
    def ingress_application_gateway_identities(self) -> Optional[Sequence['outputs.KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity']]:
        """
        An `ingress_application_gateway_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "ingress_application_gateway_identities")

    @_builtins.property
    @pulumi.getter(name="subnetCidr")
    def subnet_cidr(self) -> Optional[_builtins.str]:
        """
        The subnet CIDR to be used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
        """
        return pulumi.get(self, "subnet_cidr")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.

        > **Note:** Exactly one of `gateway_id`, `subnet_id` or `subnet_cidr` must be specified.

        > **Note:** If specifying `ingress_application_gateway` in conjunction with `only_critical_addons_enabled`, the AGIC pod will fail to start. A separate `containerservice.KubernetesClusterNodePool` is required to run the AGIC pod successfully. This is because AGIC is classed as a "non-critical addon".
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 user_assigned_identity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity used for Web App Routing.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity used for Web App Routing
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity used for Web App Routing.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of the user-defined Managed Identity used for Web App Routing.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The Object ID of the user-defined Managed Identity used for Web App Routing
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        The ID of the User Assigned Identity used for Web App Routing.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class KubernetesClusterKeyManagementService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultKeyId":
            suggest = "key_vault_key_id"
        elif key == "keyVaultNetworkAccess":
            suggest = "key_vault_network_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKeyManagementService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKeyManagementService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKeyManagementService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_key_id: _builtins.str,
                 key_vault_network_access: Optional[_builtins.str] = None):
        """
        :param _builtins.str key_vault_key_id: Identifier of Azure Key Vault key. See [key identifier format](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details.
        :param _builtins.str key_vault_network_access: Network access of the key vault Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. Defaults to `Public`.
        """
        pulumi.set(__self__, "key_vault_key_id", key_vault_key_id)
        if key_vault_network_access is not None:
            pulumi.set(__self__, "key_vault_network_access", key_vault_network_access)

    @_builtins.property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> _builtins.str:
        """
        Identifier of Azure Key Vault key. See [key identifier format](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details.
        """
        return pulumi.get(self, "key_vault_key_id")

    @_builtins.property
    @pulumi.getter(name="keyVaultNetworkAccess")
    def key_vault_network_access(self) -> Optional[_builtins.str]:
        """
        Network access of the key vault Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. Defaults to `Public`.
        """
        return pulumi.get(self, "key_vault_network_access")


@pulumi.output_type
class KubernetesClusterKeyVaultSecretsProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretIdentities":
            suggest = "secret_identities"
        elif key == "secretRotationEnabled":
            suggest = "secret_rotation_enabled"
        elif key == "secretRotationInterval":
            suggest = "secret_rotation_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKeyVaultSecretsProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKeyVaultSecretsProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKeyVaultSecretsProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_identities: Optional[Sequence['outputs.KubernetesClusterKeyVaultSecretsProviderSecretIdentity']] = None,
                 secret_rotation_enabled: Optional[_builtins.bool] = None,
                 secret_rotation_interval: Optional[_builtins.str] = None):
        """
        :param Sequence['KubernetesClusterKeyVaultSecretsProviderSecretIdentityArgs'] secret_identities: An `secret_identity` block is exported. The exported attributes are defined below.
        :param _builtins.bool secret_rotation_enabled: Should the secret store CSI driver on the AKS cluster be enabled?
        :param _builtins.str secret_rotation_interval: The interval to poll for secret rotation. This attribute is only set when `secret_rotation_enabled` is true. Defaults to `2m`.
               
               > **Note:** To enable`key_vault_secrets_provider` either `secret_rotation_enabled` or `secret_rotation_interval` must be specified.
        """
        if secret_identities is not None:
            pulumi.set(__self__, "secret_identities", secret_identities)
        if secret_rotation_enabled is not None:
            pulumi.set(__self__, "secret_rotation_enabled", secret_rotation_enabled)
        if secret_rotation_interval is not None:
            pulumi.set(__self__, "secret_rotation_interval", secret_rotation_interval)

    @_builtins.property
    @pulumi.getter(name="secretIdentities")
    def secret_identities(self) -> Optional[Sequence['outputs.KubernetesClusterKeyVaultSecretsProviderSecretIdentity']]:
        """
        An `secret_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "secret_identities")

    @_builtins.property
    @pulumi.getter(name="secretRotationEnabled")
    def secret_rotation_enabled(self) -> Optional[_builtins.bool]:
        """
        Should the secret store CSI driver on the AKS cluster be enabled?
        """
        return pulumi.get(self, "secret_rotation_enabled")

    @_builtins.property
    @pulumi.getter(name="secretRotationInterval")
    def secret_rotation_interval(self) -> Optional[_builtins.str]:
        """
        The interval to poll for secret rotation. This attribute is only set when `secret_rotation_enabled` is true. Defaults to `2m`.

        > **Note:** To enable`key_vault_secrets_provider` either `secret_rotation_enabled` or `secret_rotation_interval` must be specified.
        """
        return pulumi.get(self, "secret_rotation_interval")


@pulumi.output_type
class KubernetesClusterKeyVaultSecretsProviderSecretIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKeyVaultSecretsProviderSecretIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKeyVaultSecretsProviderSecretIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKeyVaultSecretsProviderSecretIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 user_assigned_identity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity used for Web App Routing.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity used for Web App Routing
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity used for Web App Routing.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of the user-defined Managed Identity used for Web App Routing.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The Object ID of the user-defined Managed Identity used for Web App Routing
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        The ID of the User Assigned Identity used for Web App Routing.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class KubernetesClusterKubeAdminConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKubeAdminConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKubeAdminConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKubeAdminConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 cluster_ca_certificate: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param _builtins.str client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param _builtins.str cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param _builtins.str host: The Kubernetes cluster server host.
        :param _builtins.str password: A password or token used to authenticate to the Kubernetes cluster.
        :param _builtins.str username: A username used to authenticate to the Kubernetes cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[_builtins.str]:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KubernetesClusterKubeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKubeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKubeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKubeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 cluster_ca_certificate: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param _builtins.str client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param _builtins.str cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param _builtins.str host: The Kubernetes cluster server host.
        :param _builtins.str password: A password or token used to authenticate to the Kubernetes cluster.
        :param _builtins.str username: A username used to authenticate to the Kubernetes cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[_builtins.str]:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KubernetesClusterKubeletIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKubeletIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKubeletIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKubeletIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 user_assigned_identity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class KubernetesClusterLinuxProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "sshKey":
            suggest = "ssh_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterLinuxProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterLinuxProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterLinuxProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: _builtins.str,
                 ssh_key: 'outputs.KubernetesClusterLinuxProfileSshKey'):
        """
        :param _builtins.str admin_username: The Admin Username for the Cluster. Changing this forces a new resource to be created.
        :param 'KubernetesClusterLinuxProfileSshKeyArgs' ssh_key: An `ssh_key` block as defined below. Only one is currently allowed. Changing this will update the key on all node pools. More information can be found in [the documentation](https://learn.microsoft.com/en-us/azure/aks/node-access#update-ssh-key-on-an-existing-aks-cluster-preview).
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "ssh_key", ssh_key)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> _builtins.str:
        """
        The Admin Username for the Cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "admin_username")

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> 'outputs.KubernetesClusterLinuxProfileSshKey':
        """
        An `ssh_key` block as defined below. Only one is currently allowed. Changing this will update the key on all node pools. More information can be found in [the documentation](https://learn.microsoft.com/en-us/azure/aks/node-access#update-ssh-key-on-an-existing-aks-cluster-preview).
        """
        return pulumi.get(self, "ssh_key")


@pulumi.output_type
class KubernetesClusterLinuxProfileSshKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyData":
            suggest = "key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterLinuxProfileSshKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterLinuxProfileSshKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterLinuxProfileSshKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_data: _builtins.str):
        """
        :param _builtins.str key_data: The Public SSH Key used to access the cluster. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "key_data", key_data)

    @_builtins.property
    @pulumi.getter(name="keyData")
    def key_data(self) -> _builtins.str:
        """
        The Public SSH Key used to access the cluster. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "key_data")


@pulumi.output_type
class KubernetesClusterMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notAlloweds":
            suggest = "not_alloweds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alloweds: Optional[Sequence['outputs.KubernetesClusterMaintenanceWindowAllowed']] = None,
                 not_alloweds: Optional[Sequence['outputs.KubernetesClusterMaintenanceWindowNotAllowed']] = None):
        """
        :param Sequence['KubernetesClusterMaintenanceWindowAllowedArgs'] alloweds: One or more `allowed` blocks as defined below.
        :param Sequence['KubernetesClusterMaintenanceWindowNotAllowedArgs'] not_alloweds: One or more `not_allowed` block as defined below.
        """
        if alloweds is not None:
            pulumi.set(__self__, "alloweds", alloweds)
        if not_alloweds is not None:
            pulumi.set(__self__, "not_alloweds", not_alloweds)

    @_builtins.property
    @pulumi.getter
    def alloweds(self) -> Optional[Sequence['outputs.KubernetesClusterMaintenanceWindowAllowed']]:
        """
        One or more `allowed` blocks as defined below.
        """
        return pulumi.get(self, "alloweds")

    @_builtins.property
    @pulumi.getter(name="notAlloweds")
    def not_alloweds(self) -> Optional[Sequence['outputs.KubernetesClusterMaintenanceWindowNotAllowed']]:
        """
        One or more `not_allowed` block as defined below.
        """
        return pulumi.get(self, "not_alloweds")


@pulumi.output_type
class KubernetesClusterMaintenanceWindowAllowed(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 hours: Sequence[_builtins.int]):
        """
        :param _builtins.str day: A day in a week. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
        :param Sequence[_builtins.int] hours: An array of hour slots in a day. For example, specifying `1` will allow maintenance from 1:00am to 2:00am. Specifying `1`, `2` will allow maintenance from 1:00am to 3:00m. Possible values are between `0` and `23`.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hours", hours)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        A day in a week. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Sequence[_builtins.int]:
        """
        An array of hour slots in a day. For example, specifying `1` will allow maintenance from 1:00am to 2:00am. Specifying `1`, `2` will allow maintenance from 1:00am to 3:00m. Possible values are between `0` and `23`.
        """
        return pulumi.get(self, "hours")


@pulumi.output_type
class KubernetesClusterMaintenanceWindowAutoUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "notAlloweds":
            suggest = "not_alloweds"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "utcOffset":
            suggest = "utc_offset"
        elif key == "weekIndex":
            suggest = "week_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMaintenanceWindowAutoUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMaintenanceWindowAutoUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMaintenanceWindowAutoUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: _builtins.int,
                 frequency: _builtins.str,
                 interval: _builtins.int,
                 day_of_month: Optional[_builtins.int] = None,
                 day_of_week: Optional[_builtins.str] = None,
                 not_alloweds: Optional[Sequence['outputs.KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowed']] = None,
                 start_date: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 utc_offset: Optional[_builtins.str] = None,
                 week_index: Optional[_builtins.str] = None):
        """
        :param _builtins.int duration: The duration of the window for maintenance to run in hours. Possible options are between `4` to `24`.
        :param _builtins.str frequency: Frequency of maintenance. Possible options are `Daily`, `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
        :param _builtins.int interval: The interval for maintenance runs. Depending on the frequency this interval is week or month based.
        :param _builtins.int day_of_month: The day of the month for the maintenance run. Required in combination with AbsoluteMonthly frequency. Value between 0 and 31 (inclusive).
        :param _builtins.str day_of_week: The day of the week for the maintenance run. Required in combination with weekly frequency. Possible values are `Friday`, `Monday`, `Saturday`, `Sunday`, `Thursday`, `Tuesday` and `Wednesday`.
        :param Sequence['KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowedArgs'] not_alloweds: One or more `not_allowed` block as defined below.
        :param _builtins.str start_date: The date on which the maintenance window begins to take effect.
        :param _builtins.str start_time: The time for maintenance to begin, based on the timezone determined by `utc_offset`. Format is `HH:mm`.
        :param _builtins.str utc_offset: Used to determine the timezone for cluster maintenance.
        :param _builtins.str week_index: Specifies on which instance of the allowed days specified in `day_of_week` the maintenance occurs. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
               Required in combination with relative monthly frequency.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if not_alloweds is not None:
            pulumi.set(__self__, "not_alloweds", not_alloweds)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if utc_offset is not None:
            pulumi.set(__self__, "utc_offset", utc_offset)
        if week_index is not None:
            pulumi.set(__self__, "week_index", week_index)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        The duration of the window for maintenance to run in hours. Possible options are between `4` to `24`.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        """
        Frequency of maintenance. Possible options are `Daily`, `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.int:
        """
        The interval for maintenance runs. Depending on the frequency this interval is week or month based.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[_builtins.int]:
        """
        The day of the month for the maintenance run. Required in combination with AbsoluteMonthly frequency. Value between 0 and 31 (inclusive).
        """
        return pulumi.get(self, "day_of_month")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        The day of the week for the maintenance run. Required in combination with weekly frequency. Possible values are `Friday`, `Monday`, `Saturday`, `Sunday`, `Thursday`, `Tuesday` and `Wednesday`.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="notAlloweds")
    def not_alloweds(self) -> Optional[Sequence['outputs.KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowed']]:
        """
        One or more `not_allowed` block as defined below.
        """
        return pulumi.get(self, "not_alloweds")

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[_builtins.str]:
        """
        The date on which the maintenance window begins to take effect.
        """
        return pulumi.get(self, "start_date")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The time for maintenance to begin, based on the timezone determined by `utc_offset`. Format is `HH:mm`.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="utcOffset")
    def utc_offset(self) -> Optional[_builtins.str]:
        """
        Used to determine the timezone for cluster maintenance.
        """
        return pulumi.get(self, "utc_offset")

    @_builtins.property
    @pulumi.getter(name="weekIndex")
    def week_index(self) -> Optional[_builtins.str]:
        """
        Specifies on which instance of the allowed days specified in `day_of_week` the maintenance occurs. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
        Required in combination with relative monthly frequency.
        """
        return pulumi.get(self, "week_index")


@pulumi.output_type
class KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowed(dict):
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        """
        :param _builtins.str end: The end of a time span, formatted as an RFC3339 string.
        :param _builtins.str start: The start of a time span, formatted as an RFC3339 string.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        """
        The end of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        The start of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class KubernetesClusterMaintenanceWindowNodeOs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "notAlloweds":
            suggest = "not_alloweds"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "utcOffset":
            suggest = "utc_offset"
        elif key == "weekIndex":
            suggest = "week_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMaintenanceWindowNodeOs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMaintenanceWindowNodeOs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMaintenanceWindowNodeOs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: _builtins.int,
                 frequency: _builtins.str,
                 interval: _builtins.int,
                 day_of_month: Optional[_builtins.int] = None,
                 day_of_week: Optional[_builtins.str] = None,
                 not_alloweds: Optional[Sequence['outputs.KubernetesClusterMaintenanceWindowNodeOsNotAllowed']] = None,
                 start_date: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 utc_offset: Optional[_builtins.str] = None,
                 week_index: Optional[_builtins.str] = None):
        """
        :param _builtins.int duration: The duration of the window for maintenance to run in hours. Possible options are between `4` to `24`.
        :param _builtins.str frequency: Frequency of maintenance. Possible options are `Daily`, `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
        :param _builtins.int interval: The interval for maintenance runs. Depending on the frequency this interval is week or month based.
        :param _builtins.int day_of_month: The day of the month for the maintenance run. Required in combination with AbsoluteMonthly frequency. Value between 0 and 31 (inclusive).
        :param _builtins.str day_of_week: The day of the week for the maintenance run. Required in combination with weekly frequency. Possible values are `Friday`, `Monday`, `Saturday`, `Sunday`, `Thursday`, `Tuesday` and `Wednesday`.
        :param Sequence['KubernetesClusterMaintenanceWindowNodeOsNotAllowedArgs'] not_alloweds: One or more `not_allowed` block as defined below.
        :param _builtins.str start_date: The date on which the maintenance window begins to take effect.
        :param _builtins.str start_time: The time for maintenance to begin, based on the timezone determined by `utc_offset`. Format is `HH:mm`.
        :param _builtins.str utc_offset: Used to determine the timezone for cluster maintenance.
        :param _builtins.str week_index: The week in the month used for the maintenance run. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if not_alloweds is not None:
            pulumi.set(__self__, "not_alloweds", not_alloweds)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if utc_offset is not None:
            pulumi.set(__self__, "utc_offset", utc_offset)
        if week_index is not None:
            pulumi.set(__self__, "week_index", week_index)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        The duration of the window for maintenance to run in hours. Possible options are between `4` to `24`.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        """
        Frequency of maintenance. Possible options are `Daily`, `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.int:
        """
        The interval for maintenance runs. Depending on the frequency this interval is week or month based.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[_builtins.int]:
        """
        The day of the month for the maintenance run. Required in combination with AbsoluteMonthly frequency. Value between 0 and 31 (inclusive).
        """
        return pulumi.get(self, "day_of_month")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        The day of the week for the maintenance run. Required in combination with weekly frequency. Possible values are `Friday`, `Monday`, `Saturday`, `Sunday`, `Thursday`, `Tuesday` and `Wednesday`.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="notAlloweds")
    def not_alloweds(self) -> Optional[Sequence['outputs.KubernetesClusterMaintenanceWindowNodeOsNotAllowed']]:
        """
        One or more `not_allowed` block as defined below.
        """
        return pulumi.get(self, "not_alloweds")

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[_builtins.str]:
        """
        The date on which the maintenance window begins to take effect.
        """
        return pulumi.get(self, "start_date")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The time for maintenance to begin, based on the timezone determined by `utc_offset`. Format is `HH:mm`.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="utcOffset")
    def utc_offset(self) -> Optional[_builtins.str]:
        """
        Used to determine the timezone for cluster maintenance.
        """
        return pulumi.get(self, "utc_offset")

    @_builtins.property
    @pulumi.getter(name="weekIndex")
    def week_index(self) -> Optional[_builtins.str]:
        """
        The week in the month used for the maintenance run. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
        """
        return pulumi.get(self, "week_index")


@pulumi.output_type
class KubernetesClusterMaintenanceWindowNodeOsNotAllowed(dict):
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        """
        :param _builtins.str end: The end of a time span, formatted as an RFC3339 string.
        :param _builtins.str start: The start of a time span, formatted as an RFC3339 string.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        """
        The end of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        The start of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class KubernetesClusterMaintenanceWindowNotAllowed(dict):
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        """
        :param _builtins.str end: The end of a time span, formatted as an RFC3339 string.
        :param _builtins.str start: The start of a time span, formatted as an RFC3339 string.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        """
        The end of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        The start of a time span, formatted as an RFC3339 string.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class KubernetesClusterMicrosoftDefender(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMicrosoftDefender. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMicrosoftDefender.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMicrosoftDefender.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: _builtins.str):
        """
        :param _builtins.str log_analytics_workspace_id: Specifies the ID of the Log Analytics Workspace where the audit logs collected by Microsoft Defender should be sent to.
        """
        pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> _builtins.str:
        """
        Specifies the ID of the Log Analytics Workspace where the audit logs collected by Microsoft Defender should be sent to.
        """
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class KubernetesClusterMonitorMetrics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "annotationsAllowed":
            suggest = "annotations_allowed"
        elif key == "labelsAllowed":
            suggest = "labels_allowed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMonitorMetrics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMonitorMetrics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMonitorMetrics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations_allowed: Optional[_builtins.str] = None,
                 labels_allowed: Optional[_builtins.str] = None):
        """
        :param _builtins.str annotations_allowed: Specifies a comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric.
        :param _builtins.str labels_allowed: Specifies a Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.
               
               > **Note:** Both properties `annotations_allowed` and `labels_allowed` are required if you are enabling Managed Prometheus with an existing Azure Monitor Workspace.
        """
        if annotations_allowed is not None:
            pulumi.set(__self__, "annotations_allowed", annotations_allowed)
        if labels_allowed is not None:
            pulumi.set(__self__, "labels_allowed", labels_allowed)

    @_builtins.property
    @pulumi.getter(name="annotationsAllowed")
    def annotations_allowed(self) -> Optional[_builtins.str]:
        """
        Specifies a comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric.
        """
        return pulumi.get(self, "annotations_allowed")

    @_builtins.property
    @pulumi.getter(name="labelsAllowed")
    def labels_allowed(self) -> Optional[_builtins.str]:
        """
        Specifies a Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.

        > **Note:** Both properties `annotations_allowed` and `labels_allowed` are required if you are enabling Managed Prometheus with an existing Azure Monitor Workspace.
        """
        return pulumi.get(self, "labels_allowed")


@pulumi.output_type
class KubernetesClusterNetworkProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkPlugin":
            suggest = "network_plugin"
        elif key == "advancedNetworking":
            suggest = "advanced_networking"
        elif key == "dnsServiceIp":
            suggest = "dns_service_ip"
        elif key == "ipVersions":
            suggest = "ip_versions"
        elif key == "loadBalancerProfile":
            suggest = "load_balancer_profile"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "natGatewayProfile":
            suggest = "nat_gateway_profile"
        elif key == "networkDataPlane":
            suggest = "network_data_plane"
        elif key == "networkMode":
            suggest = "network_mode"
        elif key == "networkPluginMode":
            suggest = "network_plugin_mode"
        elif key == "networkPolicy":
            suggest = "network_policy"
        elif key == "outboundType":
            suggest = "outbound_type"
        elif key == "podCidr":
            suggest = "pod_cidr"
        elif key == "podCidrs":
            suggest = "pod_cidrs"
        elif key == "serviceCidr":
            suggest = "service_cidr"
        elif key == "serviceCidrs":
            suggest = "service_cidrs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNetworkProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNetworkProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNetworkProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_plugin: _builtins.str,
                 advanced_networking: Optional['outputs.KubernetesClusterNetworkProfileAdvancedNetworking'] = None,
                 dns_service_ip: Optional[_builtins.str] = None,
                 ip_versions: Optional[Sequence[_builtins.str]] = None,
                 load_balancer_profile: Optional['outputs.KubernetesClusterNetworkProfileLoadBalancerProfile'] = None,
                 load_balancer_sku: Optional[_builtins.str] = None,
                 nat_gateway_profile: Optional['outputs.KubernetesClusterNetworkProfileNatGatewayProfile'] = None,
                 network_data_plane: Optional[_builtins.str] = None,
                 network_mode: Optional[_builtins.str] = None,
                 network_plugin_mode: Optional[_builtins.str] = None,
                 network_policy: Optional[_builtins.str] = None,
                 outbound_type: Optional[_builtins.str] = None,
                 pod_cidr: Optional[_builtins.str] = None,
                 pod_cidrs: Optional[Sequence[_builtins.str]] = None,
                 service_cidr: Optional[_builtins.str] = None,
                 service_cidrs: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str network_plugin: Network plugin to use for networking. Currently supported values are `azure`, `kubenet` and `none`. Changing this forces a new resource to be created.
               
               > **Note:** When `network_plugin` is set to `azure` - the `pod_cidr` field must not be set, unless specifying `network_plugin_mode` to `overlay`.
        :param 'KubernetesClusterNetworkProfileAdvancedNetworkingArgs' advanced_networking: An `advanced_networking` block as defined below. This can only be specified when `network_plugin` is set to `azure` and `network_data_plane` is set to `cilium`.
        :param _builtins.str dns_service_ip: IP address within the Kubernetes service address range that will be used by cluster service discovery (kube-dns). Changing this forces a new resource to be created.
        :param Sequence[_builtins.str] ip_versions: Specifies a list of IP versions the Kubernetes Cluster will use to assign IP addresses to its nodes and pods. Possible values are `IPv4` and/or `IPv6`. `IPv4` must always be specified. Changing this forces a new resource to be created.
               
               ->**Note:** To configure dual-stack networking `ip_versions` should be set to `["IPv4", "IPv6"]`.
               
               ->**Note:** Dual-stack networking requires that the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` is enabled and the Resource Provider is re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
        :param 'KubernetesClusterNetworkProfileLoadBalancerProfileArgs' load_balancer_profile: A `load_balancer_profile` block as defined below. This can only be specified when `load_balancer_sku` is set to `standard`. Changing this forces a new resource to be created.
        :param _builtins.str load_balancer_sku: Specifies the SKU of the Load Balancer used for this Kubernetes Cluster. Possible values are `basic` and `standard`. Defaults to `standard`. Changing this forces a new resource to be created.
        :param 'KubernetesClusterNetworkProfileNatGatewayProfileArgs' nat_gateway_profile: A `nat_gateway_profile` block as defined below. This can only be specified when `load_balancer_sku` is set to `standard` and `outbound_type` is set to `managedNATGateway` or `userAssignedNATGateway`. Changing this forces a new resource to be created.
        :param _builtins.str network_data_plane: Specifies the data plane used for building the Kubernetes network. Possible values are `azure` and `cilium`. Defaults to `azure`. Disabling this forces a new resource to be created.
               
               > **Note:** When `network_data_plane` is set to `cilium`, the `network_plugin` field can only be set to `azure`.
               
               > **Note:** When `network_data_plane` is set to `cilium`, one of either `network_plugin_mode = "overlay"` or `pod_subnet_id` must be specified.
        :param _builtins.str network_mode: Network mode to be used with Azure CNI. Possible values are `bridge` and `transparent`. Changing this forces a new resource to be created.
               
               > **Note:** `network_mode` can only be set to `bridge` for existing Kubernetes Clusters and cannot be used to provision new Clusters - this will be removed by Azure in the future.
               
               > **Note:** This property can only be set when `network_plugin` is set to `azure`.
        :param _builtins.str network_plugin_mode: Specifies the network plugin mode used for building the Kubernetes network. Possible value is `overlay`.
               
               > **Note:** When `network_plugin_mode` is set to `overlay`, the `network_plugin` field can only be set to `azure`. When upgrading from Azure CNI without overlay, `pod_subnet_id` must be specified.
        :param _builtins.str network_policy: Sets up network policy to be used with Azure CNI. [Network policy allows us to control the traffic flow between pods](https://docs.microsoft.com/azure/aks/use-network-policies). Currently supported values are `calico`, `azure` and `cilium`.
               
               > **Note:** When `network_policy` is set to `azure`, the `network_plugin` field can only be set to `azure`.
               
               > **Note:** When `network_policy` is set to `cilium`, the `network_data_plane` field must be set to `cilium`.
        :param _builtins.str outbound_type: The outbound (egress) routing method which should be used for this Kubernetes Cluster. Possible values are `loadBalancer`, `userDefinedRouting`, `managedNATGateway`, `userAssignedNATGateway` and `none`. Defaults to `loadBalancer`.
               
               > **Note:** For more information on supported `outbound_type` migration paths please see the product [documentation](https://learn.microsoft.com/azure/aks/egress-outboundtype#updating-outboundtype-after-cluster-creation).
        :param _builtins.str pod_cidr: The CIDR to use for pod IP addresses. This field can only be set when `network_plugin` is set to `kubenet` or `network_plugin_mode` is set to `overlay`. Changing this forces a new resource to be created.
        :param Sequence[_builtins.str] pod_cidrs: A list of CIDRs to use for pod IP addresses. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.
        :param _builtins.str service_cidr: The Network Range used by the Kubernetes service. Changing this forces a new resource to be created.
        :param Sequence[_builtins.str] service_cidrs: A list of CIDRs to use for Kubernetes services. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.
               
               > **Note:** This range should not be used by any network element on or connected to this VNet. Service address CIDR must be smaller than /12. `docker_bridge_cidr`, `dns_service_ip` and `service_cidr` should all be empty or all should be set.
        """
        pulumi.set(__self__, "network_plugin", network_plugin)
        if advanced_networking is not None:
            pulumi.set(__self__, "advanced_networking", advanced_networking)
        if dns_service_ip is not None:
            pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        if ip_versions is not None:
            pulumi.set(__self__, "ip_versions", ip_versions)
        if load_balancer_profile is not None:
            pulumi.set(__self__, "load_balancer_profile", load_balancer_profile)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if nat_gateway_profile is not None:
            pulumi.set(__self__, "nat_gateway_profile", nat_gateway_profile)
        if network_data_plane is not None:
            pulumi.set(__self__, "network_data_plane", network_data_plane)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if network_plugin_mode is not None:
            pulumi.set(__self__, "network_plugin_mode", network_plugin_mode)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_cidrs is not None:
            pulumi.set(__self__, "pod_cidrs", pod_cidrs)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if service_cidrs is not None:
            pulumi.set(__self__, "service_cidrs", service_cidrs)

    @_builtins.property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> _builtins.str:
        """
        Network plugin to use for networking. Currently supported values are `azure`, `kubenet` and `none`. Changing this forces a new resource to be created.

        > **Note:** When `network_plugin` is set to `azure` - the `pod_cidr` field must not be set, unless specifying `network_plugin_mode` to `overlay`.
        """
        return pulumi.get(self, "network_plugin")

    @_builtins.property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional['outputs.KubernetesClusterNetworkProfileAdvancedNetworking']:
        """
        An `advanced_networking` block as defined below. This can only be specified when `network_plugin` is set to `azure` and `network_data_plane` is set to `cilium`.
        """
        return pulumi.get(self, "advanced_networking")

    @_builtins.property
    @pulumi.getter(name="dnsServiceIp")
    def dns_service_ip(self) -> Optional[_builtins.str]:
        """
        IP address within the Kubernetes service address range that will be used by cluster service discovery (kube-dns). Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "dns_service_ip")

    @_builtins.property
    @pulumi.getter(name="ipVersions")
    def ip_versions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of IP versions the Kubernetes Cluster will use to assign IP addresses to its nodes and pods. Possible values are `IPv4` and/or `IPv6`. `IPv4` must always be specified. Changing this forces a new resource to be created.

        ->**Note:** To configure dual-stack networking `ip_versions` should be set to `["IPv4", "IPv6"]`.

        ->**Note:** Dual-stack networking requires that the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` is enabled and the Resource Provider is re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
        """
        return pulumi.get(self, "ip_versions")

    @_builtins.property
    @pulumi.getter(name="loadBalancerProfile")
    def load_balancer_profile(self) -> Optional['outputs.KubernetesClusterNetworkProfileLoadBalancerProfile']:
        """
        A `load_balancer_profile` block as defined below. This can only be specified when `load_balancer_sku` is set to `standard`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "load_balancer_profile")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[_builtins.str]:
        """
        Specifies the SKU of the Load Balancer used for this Kubernetes Cluster. Possible values are `basic` and `standard`. Defaults to `standard`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "load_balancer_sku")

    @_builtins.property
    @pulumi.getter(name="natGatewayProfile")
    def nat_gateway_profile(self) -> Optional['outputs.KubernetesClusterNetworkProfileNatGatewayProfile']:
        """
        A `nat_gateway_profile` block as defined below. This can only be specified when `load_balancer_sku` is set to `standard` and `outbound_type` is set to `managedNATGateway` or `userAssignedNATGateway`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "nat_gateway_profile")

    @_builtins.property
    @pulumi.getter(name="networkDataPlane")
    def network_data_plane(self) -> Optional[_builtins.str]:
        """
        Specifies the data plane used for building the Kubernetes network. Possible values are `azure` and `cilium`. Defaults to `azure`. Disabling this forces a new resource to be created.

        > **Note:** When `network_data_plane` is set to `cilium`, the `network_plugin` field can only be set to `azure`.

        > **Note:** When `network_data_plane` is set to `cilium`, one of either `network_plugin_mode = "overlay"` or `pod_subnet_id` must be specified.
        """
        return pulumi.get(self, "network_data_plane")

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[_builtins.str]:
        """
        Network mode to be used with Azure CNI. Possible values are `bridge` and `transparent`. Changing this forces a new resource to be created.

        > **Note:** `network_mode` can only be set to `bridge` for existing Kubernetes Clusters and cannot be used to provision new Clusters - this will be removed by Azure in the future.

        > **Note:** This property can only be set when `network_plugin` is set to `azure`.
        """
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="networkPluginMode")
    def network_plugin_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the network plugin mode used for building the Kubernetes network. Possible value is `overlay`.

        > **Note:** When `network_plugin_mode` is set to `overlay`, the `network_plugin` field can only be set to `azure`. When upgrading from Azure CNI without overlay, `pod_subnet_id` must be specified.
        """
        return pulumi.get(self, "network_plugin_mode")

    @_builtins.property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional[_builtins.str]:
        """
        Sets up network policy to be used with Azure CNI. [Network policy allows us to control the traffic flow between pods](https://docs.microsoft.com/azure/aks/use-network-policies). Currently supported values are `calico`, `azure` and `cilium`.

        > **Note:** When `network_policy` is set to `azure`, the `network_plugin` field can only be set to `azure`.

        > **Note:** When `network_policy` is set to `cilium`, the `network_data_plane` field must be set to `cilium`.
        """
        return pulumi.get(self, "network_policy")

    @_builtins.property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[_builtins.str]:
        """
        The outbound (egress) routing method which should be used for this Kubernetes Cluster. Possible values are `loadBalancer`, `userDefinedRouting`, `managedNATGateway`, `userAssignedNATGateway` and `none`. Defaults to `loadBalancer`.

        > **Note:** For more information on supported `outbound_type` migration paths please see the product [documentation](https://learn.microsoft.com/azure/aks/egress-outboundtype#updating-outboundtype-after-cluster-creation).
        """
        return pulumi.get(self, "outbound_type")

    @_builtins.property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[_builtins.str]:
        """
        The CIDR to use for pod IP addresses. This field can only be set when `network_plugin` is set to `kubenet` or `network_plugin_mode` is set to `overlay`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "pod_cidr")

    @_builtins.property
    @pulumi.getter(name="podCidrs")
    def pod_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of CIDRs to use for pod IP addresses. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "pod_cidrs")

    @_builtins.property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[_builtins.str]:
        """
        The Network Range used by the Kubernetes service. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "service_cidr")

    @_builtins.property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of CIDRs to use for Kubernetes services. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.

        > **Note:** This range should not be used by any network element on or connected to this VNet. Service address CIDR must be smaller than /12. `docker_bridge_cidr`, `dns_service_ip` and `service_cidr` should all be empty or all should be set.
        """
        return pulumi.get(self, "service_cidrs")


@pulumi.output_type
class KubernetesClusterNetworkProfileAdvancedNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "observabilityEnabled":
            suggest = "observability_enabled"
        elif key == "securityEnabled":
            suggest = "security_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNetworkProfileAdvancedNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNetworkProfileAdvancedNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNetworkProfileAdvancedNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 observability_enabled: Optional[_builtins.bool] = None,
                 security_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool observability_enabled: Is observability enabled? Defaults to `false`.
        :param _builtins.bool security_enabled: Is security enabled? Defaults to `false`.
        """
        if observability_enabled is not None:
            pulumi.set(__self__, "observability_enabled", observability_enabled)
        if security_enabled is not None:
            pulumi.set(__self__, "security_enabled", security_enabled)

    @_builtins.property
    @pulumi.getter(name="observabilityEnabled")
    def observability_enabled(self) -> Optional[_builtins.bool]:
        """
        Is observability enabled? Defaults to `false`.
        """
        return pulumi.get(self, "observability_enabled")

    @_builtins.property
    @pulumi.getter(name="securityEnabled")
    def security_enabled(self) -> Optional[_builtins.bool]:
        """
        Is security enabled? Defaults to `false`.
        """
        return pulumi.get(self, "security_enabled")


@pulumi.output_type
class KubernetesClusterNetworkProfileLoadBalancerProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendPoolType":
            suggest = "backend_pool_type"
        elif key == "effectiveOutboundIps":
            suggest = "effective_outbound_ips"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "managedOutboundIpCount":
            suggest = "managed_outbound_ip_count"
        elif key == "managedOutboundIpv6Count":
            suggest = "managed_outbound_ipv6_count"
        elif key == "outboundIpAddressIds":
            suggest = "outbound_ip_address_ids"
        elif key == "outboundIpPrefixIds":
            suggest = "outbound_ip_prefix_ids"
        elif key == "outboundPortsAllocated":
            suggest = "outbound_ports_allocated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNetworkProfileLoadBalancerProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNetworkProfileLoadBalancerProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNetworkProfileLoadBalancerProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_pool_type: Optional[_builtins.str] = None,
                 effective_outbound_ips: Optional[Sequence[_builtins.str]] = None,
                 idle_timeout_in_minutes: Optional[_builtins.int] = None,
                 managed_outbound_ip_count: Optional[_builtins.int] = None,
                 managed_outbound_ipv6_count: Optional[_builtins.int] = None,
                 outbound_ip_address_ids: Optional[Sequence[_builtins.str]] = None,
                 outbound_ip_prefix_ids: Optional[Sequence[_builtins.str]] = None,
                 outbound_ports_allocated: Optional[_builtins.int] = None):
        """
        :param _builtins.str backend_pool_type: The type of the managed inbound Load Balancer Backend Pool. Possible values are `NodeIP` and `NodeIPConfiguration`. Defaults to `NodeIPConfiguration`. See [the documentation](https://learn.microsoft.com/en-us/azure/aks/load-balancer-standard#change-the-inbound-pool-type) for more information.
        :param Sequence[_builtins.str] effective_outbound_ips: The outcome (resource IDs) of the specified arguments.
        :param _builtins.int idle_timeout_in_minutes: Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `100` inclusive. Defaults to `30`.
        :param _builtins.int managed_outbound_ip_count: Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
        :param _builtins.int managed_outbound_ipv6_count: The desired number of IPv6 outbound IPs created and managed by Azure for the cluster load balancer. Must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.
               
               > **Note:** `managed_outbound_ipv6_count` requires dual-stack networking. To enable dual-stack networking the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` needs to be enabled and the Resource Provider re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
        :param Sequence[_builtins.str] outbound_ip_address_ids: The ID of the Public IP Addresses which should be used for outbound communication for the cluster load balancer.
               
               > **Note:** Set `outbound_ip_address_ids` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outbound_ip_address_ids` will revert the load balancing for the cluster back to a managed one.
        :param Sequence[_builtins.str] outbound_ip_prefix_ids: The ID of the outbound Public IP Address Prefixes which should be used for the cluster load balancer.
               
               > **Note:** Set `outbound_ip_prefix_ids` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outbound_ip_prefix_ids` will revert the load balancing for the cluster back to a managed one.
        :param _builtins.int outbound_ports_allocated: Number of desired SNAT port for each VM in the clusters load balancer. Must be between `0` and `64000` inclusive. Defaults to `0`.
        """
        if backend_pool_type is not None:
            pulumi.set(__self__, "backend_pool_type", backend_pool_type)
        if effective_outbound_ips is not None:
            pulumi.set(__self__, "effective_outbound_ips", effective_outbound_ips)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if managed_outbound_ip_count is not None:
            pulumi.set(__self__, "managed_outbound_ip_count", managed_outbound_ip_count)
        if managed_outbound_ipv6_count is not None:
            pulumi.set(__self__, "managed_outbound_ipv6_count", managed_outbound_ipv6_count)
        if outbound_ip_address_ids is not None:
            pulumi.set(__self__, "outbound_ip_address_ids", outbound_ip_address_ids)
        if outbound_ip_prefix_ids is not None:
            pulumi.set(__self__, "outbound_ip_prefix_ids", outbound_ip_prefix_ids)
        if outbound_ports_allocated is not None:
            pulumi.set(__self__, "outbound_ports_allocated", outbound_ports_allocated)

    @_builtins.property
    @pulumi.getter(name="backendPoolType")
    def backend_pool_type(self) -> Optional[_builtins.str]:
        """
        The type of the managed inbound Load Balancer Backend Pool. Possible values are `NodeIP` and `NodeIPConfiguration`. Defaults to `NodeIPConfiguration`. See [the documentation](https://learn.microsoft.com/en-us/azure/aks/load-balancer-standard#change-the-inbound-pool-type) for more information.
        """
        return pulumi.get(self, "backend_pool_type")

    @_builtins.property
    @pulumi.getter(name="effectiveOutboundIps")
    def effective_outbound_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        The outcome (resource IDs) of the specified arguments.
        """
        return pulumi.get(self, "effective_outbound_ips")

    @_builtins.property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `100` inclusive. Defaults to `30`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="managedOutboundIpCount")
    def managed_outbound_ip_count(self) -> Optional[_builtins.int]:
        """
        Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
        """
        return pulumi.get(self, "managed_outbound_ip_count")

    @_builtins.property
    @pulumi.getter(name="managedOutboundIpv6Count")
    def managed_outbound_ipv6_count(self) -> Optional[_builtins.int]:
        """
        The desired number of IPv6 outbound IPs created and managed by Azure for the cluster load balancer. Must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.

        > **Note:** `managed_outbound_ipv6_count` requires dual-stack networking. To enable dual-stack networking the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` needs to be enabled and the Resource Provider re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
        """
        return pulumi.get(self, "managed_outbound_ipv6_count")

    @_builtins.property
    @pulumi.getter(name="outboundIpAddressIds")
    def outbound_ip_address_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ID of the Public IP Addresses which should be used for outbound communication for the cluster load balancer.

        > **Note:** Set `outbound_ip_address_ids` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outbound_ip_address_ids` will revert the load balancing for the cluster back to a managed one.
        """
        return pulumi.get(self, "outbound_ip_address_ids")

    @_builtins.property
    @pulumi.getter(name="outboundIpPrefixIds")
    def outbound_ip_prefix_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ID of the outbound Public IP Address Prefixes which should be used for the cluster load balancer.

        > **Note:** Set `outbound_ip_prefix_ids` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outbound_ip_prefix_ids` will revert the load balancing for the cluster back to a managed one.
        """
        return pulumi.get(self, "outbound_ip_prefix_ids")

    @_builtins.property
    @pulumi.getter(name="outboundPortsAllocated")
    def outbound_ports_allocated(self) -> Optional[_builtins.int]:
        """
        Number of desired SNAT port for each VM in the clusters load balancer. Must be between `0` and `64000` inclusive. Defaults to `0`.
        """
        return pulumi.get(self, "outbound_ports_allocated")


@pulumi.output_type
class KubernetesClusterNetworkProfileNatGatewayProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveOutboundIps":
            suggest = "effective_outbound_ips"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "managedOutboundIpCount":
            suggest = "managed_outbound_ip_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNetworkProfileNatGatewayProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNetworkProfileNatGatewayProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNetworkProfileNatGatewayProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_outbound_ips: Optional[Sequence[_builtins.str]] = None,
                 idle_timeout_in_minutes: Optional[_builtins.int] = None,
                 managed_outbound_ip_count: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] effective_outbound_ips: The outcome (resource IDs) of the specified arguments.
        :param _builtins.int idle_timeout_in_minutes: Desired outbound flow idle timeout in minutes for the managed nat gateway. Must be between `4` and `120` inclusive. Defaults to `4`.
        :param _builtins.int managed_outbound_ip_count: Count of desired managed outbound IPs for the managed nat gateway. Must be between `1` and `16` inclusive.
        """
        if effective_outbound_ips is not None:
            pulumi.set(__self__, "effective_outbound_ips", effective_outbound_ips)
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if managed_outbound_ip_count is not None:
            pulumi.set(__self__, "managed_outbound_ip_count", managed_outbound_ip_count)

    @_builtins.property
    @pulumi.getter(name="effectiveOutboundIps")
    def effective_outbound_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        The outcome (resource IDs) of the specified arguments.
        """
        return pulumi.get(self, "effective_outbound_ips")

    @_builtins.property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        Desired outbound flow idle timeout in minutes for the managed nat gateway. Must be between `4` and `120` inclusive. Defaults to `4`.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="managedOutboundIpCount")
    def managed_outbound_ip_count(self) -> Optional[_builtins.int]:
        """
        Count of desired managed outbound IPs for the managed nat gateway. Must be between `1` and `16` inclusive.
        """
        return pulumi.get(self, "managed_outbound_ip_count")


@pulumi.output_type
class KubernetesClusterNodePoolKubeletConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedUnsafeSysctls":
            suggest = "allowed_unsafe_sysctls"
        elif key == "containerLogMaxLine":
            suggest = "container_log_max_line"
        elif key == "containerLogMaxSizeMb":
            suggest = "container_log_max_size_mb"
        elif key == "cpuCfsQuotaEnabled":
            suggest = "cpu_cfs_quota_enabled"
        elif key == "cpuCfsQuotaPeriod":
            suggest = "cpu_cfs_quota_period"
        elif key == "cpuManagerPolicy":
            suggest = "cpu_manager_policy"
        elif key == "imageGcHighThreshold":
            suggest = "image_gc_high_threshold"
        elif key == "imageGcLowThreshold":
            suggest = "image_gc_low_threshold"
        elif key == "podMaxPid":
            suggest = "pod_max_pid"
        elif key == "topologyManagerPolicy":
            suggest = "topology_manager_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePoolKubeletConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePoolKubeletConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePoolKubeletConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_unsafe_sysctls: Optional[Sequence[_builtins.str]] = None,
                 container_log_max_line: Optional[_builtins.int] = None,
                 container_log_max_size_mb: Optional[_builtins.int] = None,
                 cpu_cfs_quota_enabled: Optional[_builtins.bool] = None,
                 cpu_cfs_quota_period: Optional[_builtins.str] = None,
                 cpu_manager_policy: Optional[_builtins.str] = None,
                 image_gc_high_threshold: Optional[_builtins.int] = None,
                 image_gc_low_threshold: Optional[_builtins.int] = None,
                 pod_max_pid: Optional[_builtins.int] = None,
                 topology_manager_policy: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] allowed_unsafe_sysctls: Specifies the allow list of unsafe sysctls command or patterns (ending in `*`).
        :param _builtins.int container_log_max_line: Specifies the maximum number of container log files that can be present for a container. must be at least 2.
        :param _builtins.int container_log_max_size_mb: Specifies the maximum size (e.g. 10MB) of container log file before it is rotated.
        :param _builtins.bool cpu_cfs_quota_enabled: Is CPU CFS quota enforcement for containers enabled? Defaults to `true`.
        :param _builtins.str cpu_cfs_quota_period: Specifies the CPU CFS quota period value.
        :param _builtins.str cpu_manager_policy: Specifies the CPU Manager policy to use. Possible values are `none` and `static`,
        :param _builtins.int image_gc_high_threshold: Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`.
        :param _builtins.int image_gc_low_threshold: Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`.
        :param _builtins.int pod_max_pid: Specifies the maximum number of processes per pod.
        :param _builtins.str topology_manager_policy: Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`.
        """
        if allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        if container_log_max_line is not None:
            pulumi.set(__self__, "container_log_max_line", container_log_max_line)
        if container_log_max_size_mb is not None:
            pulumi.set(__self__, "container_log_max_size_mb", container_log_max_size_mb)
        if cpu_cfs_quota_enabled is not None:
            pulumi.set(__self__, "cpu_cfs_quota_enabled", cpu_cfs_quota_enabled)
        if cpu_cfs_quota_period is not None:
            pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if image_gc_high_threshold is not None:
            pulumi.set(__self__, "image_gc_high_threshold", image_gc_high_threshold)
        if image_gc_low_threshold is not None:
            pulumi.set(__self__, "image_gc_low_threshold", image_gc_low_threshold)
        if pod_max_pid is not None:
            pulumi.set(__self__, "pod_max_pid", pod_max_pid)
        if topology_manager_policy is not None:
            pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)

    @_builtins.property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the allow list of unsafe sysctls command or patterns (ending in `*`).
        """
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @_builtins.property
    @pulumi.getter(name="containerLogMaxLine")
    def container_log_max_line(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of container log files that can be present for a container. must be at least 2.
        """
        return pulumi.get(self, "container_log_max_line")

    @_builtins.property
    @pulumi.getter(name="containerLogMaxSizeMb")
    def container_log_max_size_mb(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum size (e.g. 10MB) of container log file before it is rotated.
        """
        return pulumi.get(self, "container_log_max_size_mb")

    @_builtins.property
    @pulumi.getter(name="cpuCfsQuotaEnabled")
    def cpu_cfs_quota_enabled(self) -> Optional[_builtins.bool]:
        """
        Is CPU CFS quota enforcement for containers enabled? Defaults to `true`.
        """
        return pulumi.get(self, "cpu_cfs_quota_enabled")

    @_builtins.property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> Optional[_builtins.str]:
        """
        Specifies the CPU CFS quota period value.
        """
        return pulumi.get(self, "cpu_cfs_quota_period")

    @_builtins.property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[_builtins.str]:
        """
        Specifies the CPU Manager policy to use. Possible values are `none` and `static`,
        """
        return pulumi.get(self, "cpu_manager_policy")

    @_builtins.property
    @pulumi.getter(name="imageGcHighThreshold")
    def image_gc_high_threshold(self) -> Optional[_builtins.int]:
        """
        Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`.
        """
        return pulumi.get(self, "image_gc_high_threshold")

    @_builtins.property
    @pulumi.getter(name="imageGcLowThreshold")
    def image_gc_low_threshold(self) -> Optional[_builtins.int]:
        """
        Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`.
        """
        return pulumi.get(self, "image_gc_low_threshold")

    @_builtins.property
    @pulumi.getter(name="podMaxPid")
    def pod_max_pid(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of processes per pod.
        """
        return pulumi.get(self, "pod_max_pid")

    @_builtins.property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> Optional[_builtins.str]:
        """
        Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`.
        """
        return pulumi.get(self, "topology_manager_policy")


@pulumi.output_type
class KubernetesClusterNodePoolLinuxOsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "swapFileSizeMb":
            suggest = "swap_file_size_mb"
        elif key == "sysctlConfig":
            suggest = "sysctl_config"
        elif key == "transparentHugePage":
            suggest = "transparent_huge_page"
        elif key == "transparentHugePageDefrag":
            suggest = "transparent_huge_page_defrag"
        elif key == "transparentHugePageEnabled":
            suggest = "transparent_huge_page_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePoolLinuxOsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePoolLinuxOsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePoolLinuxOsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 swap_file_size_mb: Optional[_builtins.int] = None,
                 sysctl_config: Optional['outputs.KubernetesClusterNodePoolLinuxOsConfigSysctlConfig'] = None,
                 transparent_huge_page: Optional[_builtins.str] = None,
                 transparent_huge_page_defrag: Optional[_builtins.str] = None,
                 transparent_huge_page_enabled: Optional[_builtins.str] = None):
        """
        :param _builtins.int swap_file_size_mb: Specifies the size of swap file on each node in MB.
        :param 'KubernetesClusterNodePoolLinuxOsConfigSysctlConfigArgs' sysctl_config: A `sysctl_config` block as defined below.
        :param _builtins.str transparent_huge_page: Specifies the Transparent Huge Page configuration. Possible values are `always`, `madvise` and `never`.
        :param _builtins.str transparent_huge_page_defrag: specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`.
        """
        if swap_file_size_mb is not None:
            pulumi.set(__self__, "swap_file_size_mb", swap_file_size_mb)
        if sysctl_config is not None:
            pulumi.set(__self__, "sysctl_config", sysctl_config)
        if transparent_huge_page is not None:
            pulumi.set(__self__, "transparent_huge_page", transparent_huge_page)
        if transparent_huge_page_defrag is not None:
            pulumi.set(__self__, "transparent_huge_page_defrag", transparent_huge_page_defrag)
        if transparent_huge_page_enabled is not None:
            pulumi.set(__self__, "transparent_huge_page_enabled", transparent_huge_page_enabled)

    @_builtins.property
    @pulumi.getter(name="swapFileSizeMb")
    def swap_file_size_mb(self) -> Optional[_builtins.int]:
        """
        Specifies the size of swap file on each node in MB.
        """
        return pulumi.get(self, "swap_file_size_mb")

    @_builtins.property
    @pulumi.getter(name="sysctlConfig")
    def sysctl_config(self) -> Optional['outputs.KubernetesClusterNodePoolLinuxOsConfigSysctlConfig']:
        """
        A `sysctl_config` block as defined below.
        """
        return pulumi.get(self, "sysctl_config")

    @_builtins.property
    @pulumi.getter(name="transparentHugePage")
    def transparent_huge_page(self) -> Optional[_builtins.str]:
        """
        Specifies the Transparent Huge Page configuration. Possible values are `always`, `madvise` and `never`.
        """
        return pulumi.get(self, "transparent_huge_page")

    @_builtins.property
    @pulumi.getter(name="transparentHugePageDefrag")
    def transparent_huge_page_defrag(self) -> Optional[_builtins.str]:
        """
        specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`.
        """
        return pulumi.get(self, "transparent_huge_page_defrag")

    @_builtins.property
    @pulumi.getter(name="transparentHugePageEnabled")
    @_utilities.deprecated("""this property has been deprecated in favour of `transparent_huge_page` and will be removed in version 5.0 of the Provider.""")
    def transparent_huge_page_enabled(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "transparent_huge_page_enabled")


@pulumi.output_type
class KubernetesClusterNodePoolLinuxOsConfigSysctlConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fsAioMaxNr":
            suggest = "fs_aio_max_nr"
        elif key == "fsFileMax":
            suggest = "fs_file_max"
        elif key == "fsInotifyMaxUserWatches":
            suggest = "fs_inotify_max_user_watches"
        elif key == "fsNrOpen":
            suggest = "fs_nr_open"
        elif key == "kernelThreadsMax":
            suggest = "kernel_threads_max"
        elif key == "netCoreNetdevMaxBacklog":
            suggest = "net_core_netdev_max_backlog"
        elif key == "netCoreOptmemMax":
            suggest = "net_core_optmem_max"
        elif key == "netCoreRmemDefault":
            suggest = "net_core_rmem_default"
        elif key == "netCoreRmemMax":
            suggest = "net_core_rmem_max"
        elif key == "netCoreSomaxconn":
            suggest = "net_core_somaxconn"
        elif key == "netCoreWmemDefault":
            suggest = "net_core_wmem_default"
        elif key == "netCoreWmemMax":
            suggest = "net_core_wmem_max"
        elif key == "netIpv4IpLocalPortRangeMax":
            suggest = "net_ipv4_ip_local_port_range_max"
        elif key == "netIpv4IpLocalPortRangeMin":
            suggest = "net_ipv4_ip_local_port_range_min"
        elif key == "netIpv4NeighDefaultGcThresh1":
            suggest = "net_ipv4_neigh_default_gc_thresh1"
        elif key == "netIpv4NeighDefaultGcThresh2":
            suggest = "net_ipv4_neigh_default_gc_thresh2"
        elif key == "netIpv4NeighDefaultGcThresh3":
            suggest = "net_ipv4_neigh_default_gc_thresh3"
        elif key == "netIpv4TcpFinTimeout":
            suggest = "net_ipv4_tcp_fin_timeout"
        elif key == "netIpv4TcpKeepaliveIntvl":
            suggest = "net_ipv4_tcp_keepalive_intvl"
        elif key == "netIpv4TcpKeepaliveProbes":
            suggest = "net_ipv4_tcp_keepalive_probes"
        elif key == "netIpv4TcpKeepaliveTime":
            suggest = "net_ipv4_tcp_keepalive_time"
        elif key == "netIpv4TcpMaxSynBacklog":
            suggest = "net_ipv4_tcp_max_syn_backlog"
        elif key == "netIpv4TcpMaxTwBuckets":
            suggest = "net_ipv4_tcp_max_tw_buckets"
        elif key == "netIpv4TcpTwReuse":
            suggest = "net_ipv4_tcp_tw_reuse"
        elif key == "netNetfilterNfConntrackBuckets":
            suggest = "net_netfilter_nf_conntrack_buckets"
        elif key == "netNetfilterNfConntrackMax":
            suggest = "net_netfilter_nf_conntrack_max"
        elif key == "vmMaxMapCount":
            suggest = "vm_max_map_count"
        elif key == "vmSwappiness":
            suggest = "vm_swappiness"
        elif key == "vmVfsCachePressure":
            suggest = "vm_vfs_cache_pressure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePoolLinuxOsConfigSysctlConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePoolLinuxOsConfigSysctlConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePoolLinuxOsConfigSysctlConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fs_aio_max_nr: Optional[_builtins.int] = None,
                 fs_file_max: Optional[_builtins.int] = None,
                 fs_inotify_max_user_watches: Optional[_builtins.int] = None,
                 fs_nr_open: Optional[_builtins.int] = None,
                 kernel_threads_max: Optional[_builtins.int] = None,
                 net_core_netdev_max_backlog: Optional[_builtins.int] = None,
                 net_core_optmem_max: Optional[_builtins.int] = None,
                 net_core_rmem_default: Optional[_builtins.int] = None,
                 net_core_rmem_max: Optional[_builtins.int] = None,
                 net_core_somaxconn: Optional[_builtins.int] = None,
                 net_core_wmem_default: Optional[_builtins.int] = None,
                 net_core_wmem_max: Optional[_builtins.int] = None,
                 net_ipv4_ip_local_port_range_max: Optional[_builtins.int] = None,
                 net_ipv4_ip_local_port_range_min: Optional[_builtins.int] = None,
                 net_ipv4_neigh_default_gc_thresh1: Optional[_builtins.int] = None,
                 net_ipv4_neigh_default_gc_thresh2: Optional[_builtins.int] = None,
                 net_ipv4_neigh_default_gc_thresh3: Optional[_builtins.int] = None,
                 net_ipv4_tcp_fin_timeout: Optional[_builtins.int] = None,
                 net_ipv4_tcp_keepalive_intvl: Optional[_builtins.int] = None,
                 net_ipv4_tcp_keepalive_probes: Optional[_builtins.int] = None,
                 net_ipv4_tcp_keepalive_time: Optional[_builtins.int] = None,
                 net_ipv4_tcp_max_syn_backlog: Optional[_builtins.int] = None,
                 net_ipv4_tcp_max_tw_buckets: Optional[_builtins.int] = None,
                 net_ipv4_tcp_tw_reuse: Optional[_builtins.bool] = None,
                 net_netfilter_nf_conntrack_buckets: Optional[_builtins.int] = None,
                 net_netfilter_nf_conntrack_max: Optional[_builtins.int] = None,
                 vm_max_map_count: Optional[_builtins.int] = None,
                 vm_swappiness: Optional[_builtins.int] = None,
                 vm_vfs_cache_pressure: Optional[_builtins.int] = None):
        """
        :param _builtins.int fs_aio_max_nr: The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`.
        :param _builtins.int fs_file_max: The sysctl setting fs.file-max. Must be between `8192` and `12000500`.
        :param _builtins.int fs_inotify_max_user_watches: The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`.
        :param _builtins.int fs_nr_open: The sysctl setting fs.nr_open. Must be between `8192` and `20000500`.
        :param _builtins.int kernel_threads_max: The sysctl setting kernel.threads-max. Must be between `20` and `513785`.
        :param _builtins.int net_core_netdev_max_backlog: The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`.
        :param _builtins.int net_core_optmem_max: The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`.
        :param _builtins.int net_core_rmem_default: The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`.
        :param _builtins.int net_core_rmem_max: The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`.
        :param _builtins.int net_core_somaxconn: The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`.
        :param _builtins.int net_core_wmem_default: The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`.
        :param _builtins.int net_core_wmem_max: The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`.
        :param _builtins.int net_ipv4_ip_local_port_range_max: The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`.
        :param _builtins.int net_ipv4_ip_local_port_range_min: The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`.
        :param _builtins.int net_ipv4_neigh_default_gc_thresh1: The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`.
        :param _builtins.int net_ipv4_neigh_default_gc_thresh2: The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`.
        :param _builtins.int net_ipv4_neigh_default_gc_thresh3: The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`.
        :param _builtins.int net_ipv4_tcp_fin_timeout: The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`.
        :param _builtins.int net_ipv4_tcp_keepalive_intvl: The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`.
        :param _builtins.int net_ipv4_tcp_keepalive_probes: The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`.
        :param _builtins.int net_ipv4_tcp_keepalive_time: The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`.
        :param _builtins.int net_ipv4_tcp_max_syn_backlog: The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`.
        :param _builtins.int net_ipv4_tcp_max_tw_buckets: The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`.
        :param _builtins.bool net_ipv4_tcp_tw_reuse: Is sysctl setting net.ipv4.tcp_tw_reuse enabled?
        :param _builtins.int net_netfilter_nf_conntrack_buckets: The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`.
        :param _builtins.int net_netfilter_nf_conntrack_max: The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`.
        :param _builtins.int vm_max_map_count: The sysctl setting vm.max_map_count. Must be between `65530` and `262144`.
        :param _builtins.int vm_swappiness: The sysctl setting vm.swappiness. Must be between `0` and `100`.
        :param _builtins.int vm_vfs_cache_pressure: The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`.
        """
        if fs_aio_max_nr is not None:
            pulumi.set(__self__, "fs_aio_max_nr", fs_aio_max_nr)
        if fs_file_max is not None:
            pulumi.set(__self__, "fs_file_max", fs_file_max)
        if fs_inotify_max_user_watches is not None:
            pulumi.set(__self__, "fs_inotify_max_user_watches", fs_inotify_max_user_watches)
        if fs_nr_open is not None:
            pulumi.set(__self__, "fs_nr_open", fs_nr_open)
        if kernel_threads_max is not None:
            pulumi.set(__self__, "kernel_threads_max", kernel_threads_max)
        if net_core_netdev_max_backlog is not None:
            pulumi.set(__self__, "net_core_netdev_max_backlog", net_core_netdev_max_backlog)
        if net_core_optmem_max is not None:
            pulumi.set(__self__, "net_core_optmem_max", net_core_optmem_max)
        if net_core_rmem_default is not None:
            pulumi.set(__self__, "net_core_rmem_default", net_core_rmem_default)
        if net_core_rmem_max is not None:
            pulumi.set(__self__, "net_core_rmem_max", net_core_rmem_max)
        if net_core_somaxconn is not None:
            pulumi.set(__self__, "net_core_somaxconn", net_core_somaxconn)
        if net_core_wmem_default is not None:
            pulumi.set(__self__, "net_core_wmem_default", net_core_wmem_default)
        if net_core_wmem_max is not None:
            pulumi.set(__self__, "net_core_wmem_max", net_core_wmem_max)
        if net_ipv4_ip_local_port_range_max is not None:
            pulumi.set(__self__, "net_ipv4_ip_local_port_range_max", net_ipv4_ip_local_port_range_max)
        if net_ipv4_ip_local_port_range_min is not None:
            pulumi.set(__self__, "net_ipv4_ip_local_port_range_min", net_ipv4_ip_local_port_range_min)
        if net_ipv4_neigh_default_gc_thresh1 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh1", net_ipv4_neigh_default_gc_thresh1)
        if net_ipv4_neigh_default_gc_thresh2 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh2", net_ipv4_neigh_default_gc_thresh2)
        if net_ipv4_neigh_default_gc_thresh3 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh3", net_ipv4_neigh_default_gc_thresh3)
        if net_ipv4_tcp_fin_timeout is not None:
            pulumi.set(__self__, "net_ipv4_tcp_fin_timeout", net_ipv4_tcp_fin_timeout)
        if net_ipv4_tcp_keepalive_intvl is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_intvl", net_ipv4_tcp_keepalive_intvl)
        if net_ipv4_tcp_keepalive_probes is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_probes", net_ipv4_tcp_keepalive_probes)
        if net_ipv4_tcp_keepalive_time is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_time", net_ipv4_tcp_keepalive_time)
        if net_ipv4_tcp_max_syn_backlog is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_syn_backlog", net_ipv4_tcp_max_syn_backlog)
        if net_ipv4_tcp_max_tw_buckets is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_tw_buckets", net_ipv4_tcp_max_tw_buckets)
        if net_ipv4_tcp_tw_reuse is not None:
            pulumi.set(__self__, "net_ipv4_tcp_tw_reuse", net_ipv4_tcp_tw_reuse)
        if net_netfilter_nf_conntrack_buckets is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_buckets", net_netfilter_nf_conntrack_buckets)
        if net_netfilter_nf_conntrack_max is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_max", net_netfilter_nf_conntrack_max)
        if vm_max_map_count is not None:
            pulumi.set(__self__, "vm_max_map_count", vm_max_map_count)
        if vm_swappiness is not None:
            pulumi.set(__self__, "vm_swappiness", vm_swappiness)
        if vm_vfs_cache_pressure is not None:
            pulumi.set(__self__, "vm_vfs_cache_pressure", vm_vfs_cache_pressure)

    @_builtins.property
    @pulumi.getter(name="fsAioMaxNr")
    def fs_aio_max_nr(self) -> Optional[_builtins.int]:
        """
        The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`.
        """
        return pulumi.get(self, "fs_aio_max_nr")

    @_builtins.property
    @pulumi.getter(name="fsFileMax")
    def fs_file_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting fs.file-max. Must be between `8192` and `12000500`.
        """
        return pulumi.get(self, "fs_file_max")

    @_builtins.property
    @pulumi.getter(name="fsInotifyMaxUserWatches")
    def fs_inotify_max_user_watches(self) -> Optional[_builtins.int]:
        """
        The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`.
        """
        return pulumi.get(self, "fs_inotify_max_user_watches")

    @_builtins.property
    @pulumi.getter(name="fsNrOpen")
    def fs_nr_open(self) -> Optional[_builtins.int]:
        """
        The sysctl setting fs.nr_open. Must be between `8192` and `20000500`.
        """
        return pulumi.get(self, "fs_nr_open")

    @_builtins.property
    @pulumi.getter(name="kernelThreadsMax")
    def kernel_threads_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting kernel.threads-max. Must be between `20` and `513785`.
        """
        return pulumi.get(self, "kernel_threads_max")

    @_builtins.property
    @pulumi.getter(name="netCoreNetdevMaxBacklog")
    def net_core_netdev_max_backlog(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`.
        """
        return pulumi.get(self, "net_core_netdev_max_backlog")

    @_builtins.property
    @pulumi.getter(name="netCoreOptmemMax")
    def net_core_optmem_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`.
        """
        return pulumi.get(self, "net_core_optmem_max")

    @_builtins.property
    @pulumi.getter(name="netCoreRmemDefault")
    def net_core_rmem_default(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`.
        """
        return pulumi.get(self, "net_core_rmem_default")

    @_builtins.property
    @pulumi.getter(name="netCoreRmemMax")
    def net_core_rmem_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`.
        """
        return pulumi.get(self, "net_core_rmem_max")

    @_builtins.property
    @pulumi.getter(name="netCoreSomaxconn")
    def net_core_somaxconn(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`.
        """
        return pulumi.get(self, "net_core_somaxconn")

    @_builtins.property
    @pulumi.getter(name="netCoreWmemDefault")
    def net_core_wmem_default(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`.
        """
        return pulumi.get(self, "net_core_wmem_default")

    @_builtins.property
    @pulumi.getter(name="netCoreWmemMax")
    def net_core_wmem_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`.
        """
        return pulumi.get(self, "net_core_wmem_max")

    @_builtins.property
    @pulumi.getter(name="netIpv4IpLocalPortRangeMax")
    def net_ipv4_ip_local_port_range_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`.
        """
        return pulumi.get(self, "net_ipv4_ip_local_port_range_max")

    @_builtins.property
    @pulumi.getter(name="netIpv4IpLocalPortRangeMin")
    def net_ipv4_ip_local_port_range_min(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`.
        """
        return pulumi.get(self, "net_ipv4_ip_local_port_range_min")

    @_builtins.property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh1")
    def net_ipv4_neigh_default_gc_thresh1(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh1")

    @_builtins.property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh2")
    def net_ipv4_neigh_default_gc_thresh2(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh2")

    @_builtins.property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh3")
    def net_ipv4_neigh_default_gc_thresh3(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh3")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpFinTimeout")
    def net_ipv4_tcp_fin_timeout(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`.
        """
        return pulumi.get(self, "net_ipv4_tcp_fin_timeout")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpKeepaliveIntvl")
    def net_ipv4_tcp_keepalive_intvl(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_intvl")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpKeepaliveProbes")
    def net_ipv4_tcp_keepalive_probes(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_probes")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpKeepaliveTime")
    def net_ipv4_tcp_keepalive_time(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_time")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpMaxSynBacklog")
    def net_ipv4_tcp_max_syn_backlog(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_syn_backlog")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpMaxTwBuckets")
    def net_ipv4_tcp_max_tw_buckets(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_tw_buckets")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpTwReuse")
    def net_ipv4_tcp_tw_reuse(self) -> Optional[_builtins.bool]:
        """
        Is sysctl setting net.ipv4.tcp_tw_reuse enabled?
        """
        return pulumi.get(self, "net_ipv4_tcp_tw_reuse")

    @_builtins.property
    @pulumi.getter(name="netNetfilterNfConntrackBuckets")
    def net_netfilter_nf_conntrack_buckets(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_buckets")

    @_builtins.property
    @pulumi.getter(name="netNetfilterNfConntrackMax")
    def net_netfilter_nf_conntrack_max(self) -> Optional[_builtins.int]:
        """
        The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_max")

    @_builtins.property
    @pulumi.getter(name="vmMaxMapCount")
    def vm_max_map_count(self) -> Optional[_builtins.int]:
        """
        The sysctl setting vm.max_map_count. Must be between `65530` and `262144`.
        """
        return pulumi.get(self, "vm_max_map_count")

    @_builtins.property
    @pulumi.getter(name="vmSwappiness")
    def vm_swappiness(self) -> Optional[_builtins.int]:
        """
        The sysctl setting vm.swappiness. Must be between `0` and `100`.
        """
        return pulumi.get(self, "vm_swappiness")

    @_builtins.property
    @pulumi.getter(name="vmVfsCachePressure")
    def vm_vfs_cache_pressure(self) -> Optional[_builtins.int]:
        """
        The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`.
        """
        return pulumi.get(self, "vm_vfs_cache_pressure")


@pulumi.output_type
class KubernetesClusterNodePoolNodeNetworkProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedHostPorts":
            suggest = "allowed_host_ports"
        elif key == "applicationSecurityGroupIds":
            suggest = "application_security_group_ids"
        elif key == "nodePublicIpTags":
            suggest = "node_public_ip_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePoolNodeNetworkProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePoolNodeNetworkProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePoolNodeNetworkProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_host_ports: Optional[Sequence['outputs.KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPort']] = None,
                 application_security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 node_public_ip_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence['KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPortArgs'] allowed_host_ports: One or more `allowed_host_ports` blocks as defined below.
        :param Sequence[_builtins.str] application_security_group_ids: A list of Application Security Group IDs which should be associated with this Node Pool.
        :param Mapping[str, _builtins.str] node_public_ip_tags: Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.
               
               > **Note:** To set the application security group, you must allow at least one host port. Without this, the configuration will fail silently. [Learn More](https://learn.microsoft.com/en-us/azure/aks/use-node-public-ips#allow-host-port-connections-and-add-node-pools-to-application-security-groups).
        """
        if allowed_host_ports is not None:
            pulumi.set(__self__, "allowed_host_ports", allowed_host_ports)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if node_public_ip_tags is not None:
            pulumi.set(__self__, "node_public_ip_tags", node_public_ip_tags)

    @_builtins.property
    @pulumi.getter(name="allowedHostPorts")
    def allowed_host_ports(self) -> Optional[Sequence['outputs.KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPort']]:
        """
        One or more `allowed_host_ports` blocks as defined below.
        """
        return pulumi.get(self, "allowed_host_ports")

    @_builtins.property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of Application Security Group IDs which should be associated with this Node Pool.
        """
        return pulumi.get(self, "application_security_group_ids")

    @_builtins.property
    @pulumi.getter(name="nodePublicIpTags")
    def node_public_ip_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.

        > **Note:** To set the application security group, you must allow at least one host port. Without this, the configuration will fail silently. [Learn More](https://learn.microsoft.com/en-us/azure/aks/use-node-public-ips#allow-host-port-connections-and-add-node-pools-to-application-security-groups).
        """
        return pulumi.get(self, "node_public_ip_tags")


@pulumi.output_type
class KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portEnd":
            suggest = "port_end"
        elif key == "portStart":
            suggest = "port_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_end: Optional[_builtins.int] = None,
                 port_start: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.int port_end: Specifies the end of the port range.
        :param _builtins.int port_start: Specifies the start of the port range.
        :param _builtins.str protocol: Specifies the protocol of the port range. Possible values are `TCP` and `UDP`.
        """
        if port_end is not None:
            pulumi.set(__self__, "port_end", port_end)
        if port_start is not None:
            pulumi.set(__self__, "port_start", port_start)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="portEnd")
    def port_end(self) -> Optional[_builtins.int]:
        """
        Specifies the end of the port range.
        """
        return pulumi.get(self, "port_end")

    @_builtins.property
    @pulumi.getter(name="portStart")
    def port_start(self) -> Optional[_builtins.int]:
        """
        Specifies the start of the port range.
        """
        return pulumi.get(self, "port_start")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Specifies the protocol of the port range. Possible values are `TCP` and `UDP`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class KubernetesClusterNodePoolUpgradeSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainTimeoutInMinutes":
            suggest = "drain_timeout_in_minutes"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"
        elif key == "nodeSoakDurationInMinutes":
            suggest = "node_soak_duration_in_minutes"
        elif key == "undrainableNodeBehavior":
            suggest = "undrainable_node_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePoolUpgradeSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePoolUpgradeSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePoolUpgradeSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_timeout_in_minutes: Optional[_builtins.int] = None,
                 max_surge: Optional[_builtins.str] = None,
                 max_unavailable: Optional[_builtins.str] = None,
                 node_soak_duration_in_minutes: Optional[_builtins.int] = None,
                 undrainable_node_behavior: Optional[_builtins.str] = None):
        """
        :param _builtins.int drain_timeout_in_minutes: The amount of time in minutes to wait on eviction of pods and graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is exceeded, the upgrade fails. Unsetting this after configuring it will force a new resource to be created.
        :param _builtins.str max_surge: The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        :param _builtins.str max_unavailable: The maximum number or percentage of nodes which can be unavailable during the upgrade.
               
               > **Note:** Exactly one of `max_surge` or `max_unavailable` must be specified.
        :param _builtins.int node_soak_duration_in_minutes: The amount of time in minutes to wait after draining a node and before reimaging and moving on to next node.
        :param _builtins.str undrainable_node_behavior: Specifies the action when a node is undrainable during upgrade. Possible values are `Cordon` and `Schedule`. Unsetting this after configuring it will force a new resource to be created.
        """
        if drain_timeout_in_minutes is not None:
            pulumi.set(__self__, "drain_timeout_in_minutes", drain_timeout_in_minutes)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if node_soak_duration_in_minutes is not None:
            pulumi.set(__self__, "node_soak_duration_in_minutes", node_soak_duration_in_minutes)
        if undrainable_node_behavior is not None:
            pulumi.set(__self__, "undrainable_node_behavior", undrainable_node_behavior)

    @_builtins.property
    @pulumi.getter(name="drainTimeoutInMinutes")
    def drain_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        The amount of time in minutes to wait on eviction of pods and graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is exceeded, the upgrade fails. Unsetting this after configuring it will force a new resource to be created.
        """
        return pulumi.get(self, "drain_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.str]:
        """
        The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.str]:
        """
        The maximum number or percentage of nodes which can be unavailable during the upgrade.

        > **Note:** Exactly one of `max_surge` or `max_unavailable` must be specified.
        """
        return pulumi.get(self, "max_unavailable")

    @_builtins.property
    @pulumi.getter(name="nodeSoakDurationInMinutes")
    def node_soak_duration_in_minutes(self) -> Optional[_builtins.int]:
        """
        The amount of time in minutes to wait after draining a node and before reimaging and moving on to next node.
        """
        return pulumi.get(self, "node_soak_duration_in_minutes")

    @_builtins.property
    @pulumi.getter(name="undrainableNodeBehavior")
    def undrainable_node_behavior(self) -> Optional[_builtins.str]:
        """
        Specifies the action when a node is undrainable during upgrade. Possible values are `Cordon` and `Schedule`. Unsetting this after configuring it will force a new resource to be created.
        """
        return pulumi.get(self, "undrainable_node_behavior")


@pulumi.output_type
class KubernetesClusterNodePoolWindowsProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outboundNatEnabled":
            suggest = "outbound_nat_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePoolWindowsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePoolWindowsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePoolWindowsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 outbound_nat_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool outbound_nat_enabled: Should the Windows nodes in this Node Pool have outbound NAT enabled? Defaults to `true`. Changing this forces a new resource to be created.
               
               > **Note:** If a percentage is provided, the number of surge nodes is calculated from the current node count on the cluster. Node surge can allow a cluster to have more nodes than `max_count` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
        """
        if outbound_nat_enabled is not None:
            pulumi.set(__self__, "outbound_nat_enabled", outbound_nat_enabled)

    @_builtins.property
    @pulumi.getter(name="outboundNatEnabled")
    def outbound_nat_enabled(self) -> Optional[_builtins.bool]:
        """
        Should the Windows nodes in this Node Pool have outbound NAT enabled? Defaults to `true`. Changing this forces a new resource to be created.

        > **Note:** If a percentage is provided, the number of surge nodes is calculated from the current node count on the cluster. Node surge can allow a cluster to have more nodes than `max_count` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
        """
        return pulumi.get(self, "outbound_nat_enabled")


@pulumi.output_type
class KubernetesClusterNodeProvisioningProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultNodePools":
            suggest = "default_node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodeProvisioningProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodeProvisioningProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodeProvisioningProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_node_pools: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_node_pools: Specifies whether default node pools should be provisioned automatically. Possible values are `Auto` and `None`. Defaults to `Auto`. At least one of `mode` or `default_node_pools` must be specified.
        """
        if default_node_pools is not None:
            pulumi.set(__self__, "default_node_pools", default_node_pools)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="defaultNodePools")
    def default_node_pools(self) -> Optional[_builtins.str]:
        """
        Specifies whether default node pools should be provisioned automatically. Possible values are `Auto` and `None`. Defaults to `Auto`. At least one of `mode` or `default_node_pools` must be specified.
        """
        return pulumi.get(self, "default_node_pools")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class KubernetesClusterOmsAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"
        elif key == "msiAuthForMonitoringEnabled":
            suggest = "msi_auth_for_monitoring_enabled"
        elif key == "omsAgentIdentities":
            suggest = "oms_agent_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterOmsAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterOmsAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterOmsAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_id: _builtins.str,
                 msi_auth_for_monitoring_enabled: Optional[_builtins.bool] = None,
                 oms_agent_identities: Optional[Sequence['outputs.KubernetesClusterOmsAgentOmsAgentIdentity']] = None):
        """
        :param _builtins.str log_analytics_workspace_id: The ID of the Log Analytics Workspace which the OMS Agent should send data to.
        :param _builtins.bool msi_auth_for_monitoring_enabled: Is managed identity authentication for monitoring enabled?
        :param Sequence['KubernetesClusterOmsAgentOmsAgentIdentityArgs'] oms_agent_identities: An `oms_agent_identity` block is exported. The exported attributes are defined below.
        """
        pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)
        if msi_auth_for_monitoring_enabled is not None:
            pulumi.set(__self__, "msi_auth_for_monitoring_enabled", msi_auth_for_monitoring_enabled)
        if oms_agent_identities is not None:
            pulumi.set(__self__, "oms_agent_identities", oms_agent_identities)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> _builtins.str:
        """
        The ID of the Log Analytics Workspace which the OMS Agent should send data to.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @_builtins.property
    @pulumi.getter(name="msiAuthForMonitoringEnabled")
    def msi_auth_for_monitoring_enabled(self) -> Optional[_builtins.bool]:
        """
        Is managed identity authentication for monitoring enabled?
        """
        return pulumi.get(self, "msi_auth_for_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="omsAgentIdentities")
    def oms_agent_identities(self) -> Optional[Sequence['outputs.KubernetesClusterOmsAgentOmsAgentIdentity']]:
        """
        An `oms_agent_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "oms_agent_identities")


@pulumi.output_type
class KubernetesClusterOmsAgentOmsAgentIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterOmsAgentOmsAgentIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterOmsAgentOmsAgentIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterOmsAgentOmsAgentIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 user_assigned_identity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity used for Web App Routing.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity used for Web App Routing
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity used for Web App Routing.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of the user-defined Managed Identity used for Web App Routing.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The Object ID of the user-defined Managed Identity used for Web App Routing
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        The ID of the User Assigned Identity used for Web App Routing.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class KubernetesClusterServiceMeshProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "externalIngressGatewayEnabled":
            suggest = "external_ingress_gateway_enabled"
        elif key == "internalIngressGatewayEnabled":
            suggest = "internal_ingress_gateway_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterServiceMeshProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterServiceMeshProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterServiceMeshProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: _builtins.str,
                 revisions: Sequence[_builtins.str],
                 certificate_authority: Optional['outputs.KubernetesClusterServiceMeshProfileCertificateAuthority'] = None,
                 external_ingress_gateway_enabled: Optional[_builtins.bool] = None,
                 internal_ingress_gateway_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str mode: The mode of the service mesh. Possible value is `Istio`.
        :param Sequence[_builtins.str] revisions: Specify 1 or 2 Istio control plane revisions for managing minor upgrades using the canary upgrade process. For example, create the resource with `revisions` set to `["asm-1-25"]`, or leave it empty (the `revisions` will only be known after apply). To start the canary upgrade, change `revisions` to `["asm-1-25", "asm-1-26"]`. To roll back the canary upgrade, revert to `["asm-1-25"]`. To confirm the upgrade, change to `["asm-1-26"]`.
               
               > **NOTE:** Upgrading to a new (canary) revision does not affect existing sidecar proxies. You need to apply the canary revision label to selected namespaces and restart pods with kubectl to inject the new sidecar proxy. [Learn more](https://istio.io/latest/docs/setup/upgrade/canary/#data-plane).
        :param 'KubernetesClusterServiceMeshProfileCertificateAuthorityArgs' certificate_authority: A `certificate_authority` block as defined below. When this property is specified, `key_vault_secrets_provider` is also required to be set. This configuration allows you to bring your own root certificate and keys for Istio CA in the Istio-based service mesh add-on for Azure Kubernetes Service.
        :param _builtins.bool external_ingress_gateway_enabled: Is Istio External Ingress Gateway enabled?
               
               > **NOTE:** Currently only one Internal Ingress Gateway and one External Ingress Gateway are allowed per cluster
        :param _builtins.bool internal_ingress_gateway_enabled: Is Istio Internal Ingress Gateway enabled?
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "revisions", revisions)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if external_ingress_gateway_enabled is not None:
            pulumi.set(__self__, "external_ingress_gateway_enabled", external_ingress_gateway_enabled)
        if internal_ingress_gateway_enabled is not None:
            pulumi.set(__self__, "internal_ingress_gateway_enabled", internal_ingress_gateway_enabled)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode of the service mesh. Possible value is `Istio`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def revisions(self) -> Sequence[_builtins.str]:
        """
        Specify 1 or 2 Istio control plane revisions for managing minor upgrades using the canary upgrade process. For example, create the resource with `revisions` set to `["asm-1-25"]`, or leave it empty (the `revisions` will only be known after apply). To start the canary upgrade, change `revisions` to `["asm-1-25", "asm-1-26"]`. To roll back the canary upgrade, revert to `["asm-1-25"]`. To confirm the upgrade, change to `["asm-1-26"]`.

        > **NOTE:** Upgrading to a new (canary) revision does not affect existing sidecar proxies. You need to apply the canary revision label to selected namespaces and restart pods with kubectl to inject the new sidecar proxy. [Learn more](https://istio.io/latest/docs/setup/upgrade/canary/#data-plane).
        """
        return pulumi.get(self, "revisions")

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional['outputs.KubernetesClusterServiceMeshProfileCertificateAuthority']:
        """
        A `certificate_authority` block as defined below. When this property is specified, `key_vault_secrets_provider` is also required to be set. This configuration allows you to bring your own root certificate and keys for Istio CA in the Istio-based service mesh add-on for Azure Kubernetes Service.
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter(name="externalIngressGatewayEnabled")
    def external_ingress_gateway_enabled(self) -> Optional[_builtins.bool]:
        """
        Is Istio External Ingress Gateway enabled?

        > **NOTE:** Currently only one Internal Ingress Gateway and one External Ingress Gateway are allowed per cluster
        """
        return pulumi.get(self, "external_ingress_gateway_enabled")

    @_builtins.property
    @pulumi.getter(name="internalIngressGatewayEnabled")
    def internal_ingress_gateway_enabled(self) -> Optional[_builtins.bool]:
        """
        Is Istio Internal Ingress Gateway enabled?
        """
        return pulumi.get(self, "internal_ingress_gateway_enabled")


@pulumi.output_type
class KubernetesClusterServiceMeshProfileCertificateAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certChainObjectName":
            suggest = "cert_chain_object_name"
        elif key == "certObjectName":
            suggest = "cert_object_name"
        elif key == "keyObjectName":
            suggest = "key_object_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "rootCertObjectName":
            suggest = "root_cert_object_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterServiceMeshProfileCertificateAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterServiceMeshProfileCertificateAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterServiceMeshProfileCertificateAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_chain_object_name: _builtins.str,
                 cert_object_name: _builtins.str,
                 key_object_name: _builtins.str,
                 key_vault_id: _builtins.str,
                 root_cert_object_name: _builtins.str):
        """
        :param _builtins.str cert_chain_object_name: The certificate chain object name in Azure Key Vault.
        :param _builtins.str cert_object_name: The intermediate certificate object name in Azure Key Vault.
        :param _builtins.str key_object_name: The intermediate certificate private key object name in Azure Key Vault.
               
               > **Note:** For more information on [Istio-based service mesh add-on with plug-in CA certificates and how to generate these certificates](https://learn.microsoft.com/en-us/azure/aks/istio-plugin-ca),
        :param _builtins.str key_vault_id: The resource ID of the Key Vault.
        :param _builtins.str root_cert_object_name: The root certificate object name in Azure Key Vault.
        """
        pulumi.set(__self__, "cert_chain_object_name", cert_chain_object_name)
        pulumi.set(__self__, "cert_object_name", cert_object_name)
        pulumi.set(__self__, "key_object_name", key_object_name)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        pulumi.set(__self__, "root_cert_object_name", root_cert_object_name)

    @_builtins.property
    @pulumi.getter(name="certChainObjectName")
    def cert_chain_object_name(self) -> _builtins.str:
        """
        The certificate chain object name in Azure Key Vault.
        """
        return pulumi.get(self, "cert_chain_object_name")

    @_builtins.property
    @pulumi.getter(name="certObjectName")
    def cert_object_name(self) -> _builtins.str:
        """
        The intermediate certificate object name in Azure Key Vault.
        """
        return pulumi.get(self, "cert_object_name")

    @_builtins.property
    @pulumi.getter(name="keyObjectName")
    def key_object_name(self) -> _builtins.str:
        """
        The intermediate certificate private key object name in Azure Key Vault.

        > **Note:** For more information on [Istio-based service mesh add-on with plug-in CA certificates and how to generate these certificates](https://learn.microsoft.com/en-us/azure/aks/istio-plugin-ca),
        """
        return pulumi.get(self, "key_object_name")

    @_builtins.property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> _builtins.str:
        """
        The resource ID of the Key Vault.
        """
        return pulumi.get(self, "key_vault_id")

    @_builtins.property
    @pulumi.getter(name="rootCertObjectName")
    def root_cert_object_name(self) -> _builtins.str:
        """
        The root certificate object name in Azure Key Vault.
        """
        return pulumi.get(self, "root_cert_object_name")


@pulumi.output_type
class KubernetesClusterServicePrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterServicePrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterServicePrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterServicePrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str):
        """
        :param _builtins.str client_id: The Client ID for the Service Principal.
        :param _builtins.str client_secret: The Client Secret for the Service Principal.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID for the Service Principal.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        The Client Secret for the Service Principal.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class KubernetesClusterStorageProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobDriverEnabled":
            suggest = "blob_driver_enabled"
        elif key == "diskDriverEnabled":
            suggest = "disk_driver_enabled"
        elif key == "fileDriverEnabled":
            suggest = "file_driver_enabled"
        elif key == "snapshotControllerEnabled":
            suggest = "snapshot_controller_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterStorageProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterStorageProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterStorageProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_driver_enabled: Optional[_builtins.bool] = None,
                 disk_driver_enabled: Optional[_builtins.bool] = None,
                 file_driver_enabled: Optional[_builtins.bool] = None,
                 snapshot_controller_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool blob_driver_enabled: Is the Blob CSI driver enabled? Defaults to `false`.
        :param _builtins.bool disk_driver_enabled: Is the Disk CSI driver enabled? Defaults to `true`.
        :param _builtins.bool file_driver_enabled: Is the File CSI driver enabled? Defaults to `true`.
        :param _builtins.bool snapshot_controller_enabled: Is the Snapshot Controller enabled? Defaults to `true`.
        """
        if blob_driver_enabled is not None:
            pulumi.set(__self__, "blob_driver_enabled", blob_driver_enabled)
        if disk_driver_enabled is not None:
            pulumi.set(__self__, "disk_driver_enabled", disk_driver_enabled)
        if file_driver_enabled is not None:
            pulumi.set(__self__, "file_driver_enabled", file_driver_enabled)
        if snapshot_controller_enabled is not None:
            pulumi.set(__self__, "snapshot_controller_enabled", snapshot_controller_enabled)

    @_builtins.property
    @pulumi.getter(name="blobDriverEnabled")
    def blob_driver_enabled(self) -> Optional[_builtins.bool]:
        """
        Is the Blob CSI driver enabled? Defaults to `false`.
        """
        return pulumi.get(self, "blob_driver_enabled")

    @_builtins.property
    @pulumi.getter(name="diskDriverEnabled")
    def disk_driver_enabled(self) -> Optional[_builtins.bool]:
        """
        Is the Disk CSI driver enabled? Defaults to `true`.
        """
        return pulumi.get(self, "disk_driver_enabled")

    @_builtins.property
    @pulumi.getter(name="fileDriverEnabled")
    def file_driver_enabled(self) -> Optional[_builtins.bool]:
        """
        Is the File CSI driver enabled? Defaults to `true`.
        """
        return pulumi.get(self, "file_driver_enabled")

    @_builtins.property
    @pulumi.getter(name="snapshotControllerEnabled")
    def snapshot_controller_enabled(self) -> Optional[_builtins.bool]:
        """
        Is the Snapshot Controller enabled? Defaults to `true`.
        """
        return pulumi.get(self, "snapshot_controller_enabled")


@pulumi.output_type
class KubernetesClusterUpgradeOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forceUpgradeEnabled":
            suggest = "force_upgrade_enabled"
        elif key == "effectiveUntil":
            suggest = "effective_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterUpgradeOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterUpgradeOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterUpgradeOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 force_upgrade_enabled: _builtins.bool,
                 effective_until: Optional[_builtins.str] = None):
        """
        :param _builtins.bool force_upgrade_enabled: Whether to force upgrade the cluster. Possible values are `true` or `false`.
               
               !> **Note:** The `force_upgrade_enabled` field instructs the upgrade operation to bypass upgrade protections (e.g. checking for deprecated API usage) which may render the cluster inoperative after the upgrade process has completed. Use the `force_upgrade_enabled` option with extreme caution only.
        :param _builtins.str effective_until: Specifies the duration, in RFC 3339 format (e.g., `2025-10-01T13:00:00Z`), the `upgrade_override` values are effective. This field must be set for the `upgrade_override` values to take effect. The date-time must be within the next 30 days.
               
               > **Note:** This only matches the start time of an upgrade, and the effectiveness won't change once an upgrade starts even if the `effective_until` value expires as the upgrade proceeds.
        """
        pulumi.set(__self__, "force_upgrade_enabled", force_upgrade_enabled)
        if effective_until is not None:
            pulumi.set(__self__, "effective_until", effective_until)

    @_builtins.property
    @pulumi.getter(name="forceUpgradeEnabled")
    def force_upgrade_enabled(self) -> _builtins.bool:
        """
        Whether to force upgrade the cluster. Possible values are `true` or `false`.

        !> **Note:** The `force_upgrade_enabled` field instructs the upgrade operation to bypass upgrade protections (e.g. checking for deprecated API usage) which may render the cluster inoperative after the upgrade process has completed. Use the `force_upgrade_enabled` option with extreme caution only.
        """
        return pulumi.get(self, "force_upgrade_enabled")

    @_builtins.property
    @pulumi.getter(name="effectiveUntil")
    def effective_until(self) -> Optional[_builtins.str]:
        """
        Specifies the duration, in RFC 3339 format (e.g., `2025-10-01T13:00:00Z`), the `upgrade_override` values are effective. This field must be set for the `upgrade_override` values to take effect. The date-time must be within the next 30 days.

        > **Note:** This only matches the start time of an upgrade, and the effectiveness won't change once an upgrade starts even if the `effective_until` value expires as the upgrade proceeds.
        """
        return pulumi.get(self, "effective_until")


@pulumi.output_type
class KubernetesClusterWebAppRouting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneIds":
            suggest = "dns_zone_ids"
        elif key == "defaultNginxController":
            suggest = "default_nginx_controller"
        elif key == "webAppRoutingIdentities":
            suggest = "web_app_routing_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterWebAppRouting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterWebAppRouting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterWebAppRouting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_zone_ids: Sequence[_builtins.str],
                 default_nginx_controller: Optional[_builtins.str] = None,
                 web_app_routing_identities: Optional[Sequence['outputs.KubernetesClusterWebAppRoutingWebAppRoutingIdentity']] = None):
        """
        :param Sequence[_builtins.str] dns_zone_ids: Specifies the list of the DNS Zone IDs in which DNS entries are created for applications deployed to the cluster when Web App Routing is enabled. If not using Bring-Your-Own DNS zones this property should be set to an empty list.
        :param _builtins.str default_nginx_controller: Specifies the ingress type for the default `NginxIngressController` custom resource. The allowed values are `None`, `Internal`, `External` and `AnnotationControlled`. Defaults to `AnnotationControlled`.
        :param Sequence['KubernetesClusterWebAppRoutingWebAppRoutingIdentityArgs'] web_app_routing_identities: A `web_app_routing_identity` block is exported. The exported attributes are defined below.
        """
        pulumi.set(__self__, "dns_zone_ids", dns_zone_ids)
        if default_nginx_controller is not None:
            pulumi.set(__self__, "default_nginx_controller", default_nginx_controller)
        if web_app_routing_identities is not None:
            pulumi.set(__self__, "web_app_routing_identities", web_app_routing_identities)

    @_builtins.property
    @pulumi.getter(name="dnsZoneIds")
    def dns_zone_ids(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of the DNS Zone IDs in which DNS entries are created for applications deployed to the cluster when Web App Routing is enabled. If not using Bring-Your-Own DNS zones this property should be set to an empty list.
        """
        return pulumi.get(self, "dns_zone_ids")

    @_builtins.property
    @pulumi.getter(name="defaultNginxController")
    def default_nginx_controller(self) -> Optional[_builtins.str]:
        """
        Specifies the ingress type for the default `NginxIngressController` custom resource. The allowed values are `None`, `Internal`, `External` and `AnnotationControlled`. Defaults to `AnnotationControlled`.
        """
        return pulumi.get(self, "default_nginx_controller")

    @_builtins.property
    @pulumi.getter(name="webAppRoutingIdentities")
    def web_app_routing_identities(self) -> Optional[Sequence['outputs.KubernetesClusterWebAppRoutingWebAppRoutingIdentity']]:
        """
        A `web_app_routing_identity` block is exported. The exported attributes are defined below.
        """
        return pulumi.get(self, "web_app_routing_identities")


@pulumi.output_type
class KubernetesClusterWebAppRoutingWebAppRoutingIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "userAssignedIdentityId":
            suggest = "user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterWebAppRoutingWebAppRoutingIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterWebAppRoutingWebAppRoutingIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterWebAppRoutingWebAppRoutingIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 user_assigned_identity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity used for Web App Routing.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity used for Web App Routing
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity used for Web App Routing.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_assigned_identity_id is not None:
            pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of the user-defined Managed Identity used for Web App Routing.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The Object ID of the user-defined Managed Identity used for Web App Routing
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        The ID of the User Assigned Identity used for Web App Routing.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class KubernetesClusterWindowsProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterWindowsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterWindowsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterWindowsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: _builtins.str,
                 admin_username: _builtins.str,
                 gmsa: Optional['outputs.KubernetesClusterWindowsProfileGmsa'] = None,
                 license: Optional[_builtins.str] = None):
        """
        :param _builtins.str admin_password: The Admin Password for Windows VMs. Length must be between 14 and 123 characters.
        :param _builtins.str admin_username: The Admin Username for Windows VMs. Changing this forces a new resource to be created.
        :param 'KubernetesClusterWindowsProfileGmsaArgs' gmsa: A `gmsa` block as defined below.
        :param _builtins.str license: Specifies the type of on-premise license which should be used for Node Pool Windows Virtual Machine. At this time the only possible value is `Windows_Server`.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "admin_username", admin_username)
        if gmsa is not None:
            pulumi.set(__self__, "gmsa", gmsa)
        if license is not None:
            pulumi.set(__self__, "license", license)

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> _builtins.str:
        """
        The Admin Password for Windows VMs. Length must be between 14 and 123 characters.
        """
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> _builtins.str:
        """
        The Admin Username for Windows VMs. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "admin_username")

    @_builtins.property
    @pulumi.getter
    def gmsa(self) -> Optional['outputs.KubernetesClusterWindowsProfileGmsa']:
        """
        A `gmsa` block as defined below.
        """
        return pulumi.get(self, "gmsa")

    @_builtins.property
    @pulumi.getter
    def license(self) -> Optional[_builtins.str]:
        """
        Specifies the type of on-premise license which should be used for Node Pool Windows Virtual Machine. At this time the only possible value is `Windows_Server`.
        """
        return pulumi.get(self, "license")


@pulumi.output_type
class KubernetesClusterWindowsProfileGmsa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServer":
            suggest = "dns_server"
        elif key == "rootDomain":
            suggest = "root_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterWindowsProfileGmsa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterWindowsProfileGmsa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterWindowsProfileGmsa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_server: _builtins.str,
                 root_domain: _builtins.str):
        """
        :param _builtins.str dns_server: Specifies the DNS server for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.
        :param _builtins.str root_domain: Specifies the root domain name for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.
               
               > **Note:** The properties `dns_server` and `root_domain` must both either be set or unset, i.e. empty.
        """
        pulumi.set(__self__, "dns_server", dns_server)
        pulumi.set(__self__, "root_domain", root_domain)

    @_builtins.property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> _builtins.str:
        """
        Specifies the DNS server for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.
        """
        return pulumi.get(self, "dns_server")

    @_builtins.property
    @pulumi.getter(name="rootDomain")
    def root_domain(self) -> _builtins.str:
        """
        Specifies the root domain name for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.

        > **Note:** The properties `dns_server` and `root_domain` must both either be set or unset, i.e. empty.
        """
        return pulumi.get(self, "root_domain")


@pulumi.output_type
class KubernetesClusterWorkloadAutoscalerProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kedaEnabled":
            suggest = "keda_enabled"
        elif key == "verticalPodAutoscalerEnabled":
            suggest = "vertical_pod_autoscaler_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterWorkloadAutoscalerProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterWorkloadAutoscalerProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterWorkloadAutoscalerProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keda_enabled: Optional[_builtins.bool] = None,
                 vertical_pod_autoscaler_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool keda_enabled: Specifies whether KEDA Autoscaler can be used for workloads.
        :param _builtins.bool vertical_pod_autoscaler_enabled: Specifies whether Vertical Pod Autoscaler should be enabled.
        """
        if keda_enabled is not None:
            pulumi.set(__self__, "keda_enabled", keda_enabled)
        if vertical_pod_autoscaler_enabled is not None:
            pulumi.set(__self__, "vertical_pod_autoscaler_enabled", vertical_pod_autoscaler_enabled)

    @_builtins.property
    @pulumi.getter(name="kedaEnabled")
    def keda_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether KEDA Autoscaler can be used for workloads.
        """
        return pulumi.get(self, "keda_enabled")

    @_builtins.property
    @pulumi.getter(name="verticalPodAutoscalerEnabled")
    def vertical_pod_autoscaler_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether Vertical Pod Autoscaler should be enabled.
        """
        return pulumi.get(self, "vertical_pod_autoscaler_enabled")


@pulumi.output_type
class KubernetesFleetManagerHubProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsPrefix":
            suggest = "dns_prefix"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesFleetManagerHubProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesFleetManagerHubProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesFleetManagerHubProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_prefix: _builtins.str,
                 fqdn: Optional[_builtins.str] = None,
                 kubernetes_version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "dns_prefix", dns_prefix)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)

    @_builtins.property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> _builtins.str:
        return pulumi.get(self, "dns_prefix")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kubernetes_version")


@pulumi.output_type
class RegistryCredentialSetAuthenticationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretId":
            suggest = "password_secret_id"
        elif key == "usernameSecretId":
            suggest = "username_secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryCredentialSetAuthenticationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryCredentialSetAuthenticationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryCredentialSetAuthenticationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_secret_id: _builtins.str,
                 username_secret_id: _builtins.str):
        """
        :param _builtins.str password_secret_id: The URI of the secret containing the password in a Key Vault.
               
               > **Note:** Be aware that you will need to permit the Identity that is created for the Container Registry to have `get` on secrets to the Key Vault, e.g. using the `keyvault.AccessPolicy` resource.
        :param _builtins.str username_secret_id: The URI of the secret containing the username in a Key Vault.
        """
        pulumi.set(__self__, "password_secret_id", password_secret_id)
        pulumi.set(__self__, "username_secret_id", username_secret_id)

    @_builtins.property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> _builtins.str:
        """
        The URI of the secret containing the password in a Key Vault.

        > **Note:** Be aware that you will need to permit the Identity that is created for the Container Registry to have `get` on secrets to the Key Vault, e.g. using the `keyvault.AccessPolicy` resource.
        """
        return pulumi.get(self, "password_secret_id")

    @_builtins.property
    @pulumi.getter(name="usernameSecretId")
    def username_secret_id(self) -> _builtins.str:
        """
        The URI of the secret containing the username in a Key Vault.
        """
        return pulumi.get(self, "username_secret_id")


@pulumi.output_type
class RegistryCredentialSetIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryCredentialSetIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryCredentialSetIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryCredentialSetIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 principal_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of Managed Service Identity that is configured on for the Container Registry Credential Set. Currently the only possible value is `SystemAssigned`.
        :param _builtins.str principal_id: The principal ID of the Identity.
        :param _builtins.str tenant_id: The tenant ID of the Identity.
        """
        pulumi.set(__self__, "type", type)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Managed Service Identity that is configured on for the Container Registry Credential Set. Currently the only possible value is `SystemAssigned`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[_builtins.str]:
        """
        The principal ID of the Identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The tenant ID of the Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class RegistryEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityClientId":
            suggest = "identity_client_id"
        elif key == "keyVaultKeyId":
            suggest = "key_vault_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_client_id: _builtins.str,
                 key_vault_key_id: _builtins.str):
        """
        :param _builtins.str identity_client_id: The client ID of the managed identity associated with the encryption key.
        :param _builtins.str key_vault_key_id: The ID of the Key Vault Key.
        """
        pulumi.set(__self__, "identity_client_id", identity_client_id)
        pulumi.set(__self__, "key_vault_key_id", key_vault_key_id)

    @_builtins.property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> _builtins.str:
        """
        The client ID of the managed identity associated with the encryption key.
        """
        return pulumi.get(self, "identity_client_id")

    @_builtins.property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> _builtins.str:
        """
        The ID of the Key Vault Key.
        """
        return pulumi.get(self, "key_vault_key_id")


@pulumi.output_type
class RegistryGeoreplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionalEndpointEnabled":
            suggest = "regional_endpoint_enabled"
        elif key == "zoneRedundancyEnabled":
            suggest = "zone_redundancy_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryGeoreplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryGeoreplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryGeoreplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: _builtins.str,
                 regional_endpoint_enabled: Optional[_builtins.bool] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 zone_redundancy_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str location: A location where the container registry should be geo-replicated.
        :param _builtins.bool regional_endpoint_enabled: Whether regional endpoint is enabled for this Container Registry?
        :param Mapping[str, _builtins.str] tags: A mapping of tags to assign to this replication location.
        :param _builtins.bool zone_redundancy_enabled: Whether zone redundancy is enabled for this replication location? Defaults to `false`.
               
               > **Note:** Changing the `zone_redundancy_enabled` forces an underlying replication to be created.
        """
        pulumi.set(__self__, "location", location)
        if regional_endpoint_enabled is not None:
            pulumi.set(__self__, "regional_endpoint_enabled", regional_endpoint_enabled)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if zone_redundancy_enabled is not None:
            pulumi.set(__self__, "zone_redundancy_enabled", zone_redundancy_enabled)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        A location where the container registry should be geo-replicated.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="regionalEndpointEnabled")
    def regional_endpoint_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether regional endpoint is enabled for this Container Registry?
        """
        return pulumi.get(self, "regional_endpoint_enabled")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A mapping of tags to assign to this replication location.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="zoneRedundancyEnabled")
    def zone_redundancy_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether zone redundancy is enabled for this replication location? Defaults to `false`.

        > **Note:** Changing the `zone_redundancy_enabled` forces an underlying replication to be created.
        """
        return pulumi.get(self, "zone_redundancy_enabled")


@pulumi.output_type
class RegistryIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 identity_ids: Optional[Sequence[_builtins.str]] = None,
                 principal_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the type of Managed Service Identity that should be configured on this Container Registry. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[_builtins.str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry.
               
               > **Note:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param _builtins.str principal_id: The Principal ID associated with this Managed Service Identity.
        :param _builtins.str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Container Registry. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry.

        > **Note:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[_builtins.str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class RegistryNetworkRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultAction":
            suggest = "default_action"
        elif key == "ipRules":
            suggest = "ip_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryNetworkRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryNetworkRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryNetworkRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_action: Optional[_builtins.str] = None,
                 ip_rules: Optional[Sequence['outputs.RegistryNetworkRuleSetIpRule']] = None):
        """
        :param _builtins.str default_action: The behaviour for requests matching no rules. Either `Allow` or `Deny`. Defaults to `Allow`
        :param Sequence['RegistryNetworkRuleSetIpRuleArgs'] ip_rules: One or more `ip_rule` blocks as defined below.
               
               > **Note:** `network_rule_set` is only supported with the `Premium` SKU at this time.
               
               > **Note:** Azure automatically configures Network Rules - to remove these, you'll need to specify an `network_rule_set` block with `default_action` set to `Deny`.
        """
        if default_action is not None:
            pulumi.set(__self__, "default_action", default_action)
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)

    @_builtins.property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> Optional[_builtins.str]:
        """
        The behaviour for requests matching no rules. Either `Allow` or `Deny`. Defaults to `Allow`
        """
        return pulumi.get(self, "default_action")

    @_builtins.property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[Sequence['outputs.RegistryNetworkRuleSetIpRule']]:
        """
        One or more `ip_rule` blocks as defined below.

        > **Note:** `network_rule_set` is only supported with the `Premium` SKU at this time.

        > **Note:** Azure automatically configures Network Rules - to remove these, you'll need to specify an `network_rule_set` block with `default_action` set to `Deny`.
        """
        return pulumi.get(self, "ip_rules")


@pulumi.output_type
class RegistryNetworkRuleSetIpRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryNetworkRuleSetIpRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryNetworkRuleSetIpRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryNetworkRuleSetIpRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 ip_range: _builtins.str):
        """
        :param _builtins.str action: The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        :param _builtins.str ip_range: The CIDR block from which requests will match the rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip_range", ip_range)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The behaviour for requests matching this rule. At this time the only supported value is `Allow`
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> _builtins.str:
        """
        The CIDR block from which requests will match the rule.
        """
        return pulumi.get(self, "ip_range")


@pulumi.output_type
class RegistryTaskAgentSetting(dict):
    def __init__(__self__, *,
                 cpu: _builtins.int):
        """
        :param _builtins.int cpu: The number of cores required for the Container Registry Task. Possible value is `2`.
        """
        pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.int:
        """
        The number of cores required for the Container Registry Task. Possible value is `2`.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class RegistryTaskBaseImageTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTriggerEndpoint":
            suggest = "update_trigger_endpoint"
        elif key == "updateTriggerPayloadType":
            suggest = "update_trigger_payload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryTaskBaseImageTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryTaskBaseImageTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryTaskBaseImageTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 enabled: Optional[_builtins.bool] = None,
                 update_trigger_endpoint: Optional[_builtins.str] = None,
                 update_trigger_payload_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name which should be used for this trigger.
        :param _builtins.str type: The type of the trigger. Possible values are `All` and `Runtime`.
        :param _builtins.bool enabled: Should the trigger be enabled? Defaults to `true`.
        :param _builtins.str update_trigger_endpoint: The endpoint URL for receiving the trigger.
        :param _builtins.str update_trigger_payload_type: Type of payload body for the trigger. Possible values are `Default` and `Token`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if update_trigger_endpoint is not None:
            pulumi.set(__self__, "update_trigger_endpoint", update_trigger_endpoint)
        if update_trigger_payload_type is not None:
            pulumi.set(__self__, "update_trigger_payload_type", update_trigger_payload_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name which should be used for this trigger.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the trigger. Possible values are `All` and `Runtime`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Should the trigger be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="updateTriggerEndpoint")
    def update_trigger_endpoint(self) -> Optional[_builtins.str]:
        """
        The endpoint URL for receiving the trigger.
        """
        return pulumi.get(self, "update_trigger_endpoint")

    @_builtins.property
    @pulumi.getter(name="updateTriggerPayloadType")
    def update_trigger_payload_type(self) -> Optional[_builtins.str]:
        """
        Type of payload body for the trigger. Possible values are `Default` and `Token`.
        """
        return pulumi.get(self, "update_trigger_payload_type")


@pulumi.output_type
class RegistryTaskDockerStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextAccessToken":
            suggest = "context_access_token"
        elif key == "contextPath":
            suggest = "context_path"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "cacheEnabled":
            suggest = "cache_enabled"
        elif key == "imageNames":
            suggest = "image_names"
        elif key == "pushEnabled":
            suggest = "push_enabled"
        elif key == "secretArguments":
            suggest = "secret_arguments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryTaskDockerStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryTaskDockerStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryTaskDockerStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_access_token: _builtins.str,
                 context_path: _builtins.str,
                 dockerfile_path: _builtins.str,
                 arguments: Optional[Mapping[str, _builtins.str]] = None,
                 cache_enabled: Optional[_builtins.bool] = None,
                 image_names: Optional[Sequence[_builtins.str]] = None,
                 push_enabled: Optional[_builtins.bool] = None,
                 secret_arguments: Optional[Mapping[str, _builtins.str]] = None,
                 target: Optional[_builtins.str] = None):
        """
        :param _builtins.str context_access_token: The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        :param _builtins.str context_path: The URL (absolute or relative) of the source context for this step. If the context is an url you can reference a specific branch or folder via `#branch:folder`.
        :param _builtins.str dockerfile_path: The Dockerfile path relative to the source context.
        :param Mapping[str, _builtins.str] arguments: Specifies a map of arguments to be used when executing this step.
        :param _builtins.bool cache_enabled: Should the image cache be enabled? Defaults to `true`.
        :param Sequence[_builtins.str] image_names: Specifies a list of fully qualified image names including the repository and tag.
        :param _builtins.bool push_enabled: Should the image built be pushed to the registry or not? Defaults to `true`.
        :param Mapping[str, _builtins.str] secret_arguments: Specifies a map of *secret* arguments to be used when executing this step.
        :param _builtins.str target: The name of the target build stage for the docker build.
        """
        pulumi.set(__self__, "context_access_token", context_access_token)
        pulumi.set(__self__, "context_path", context_path)
        pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if cache_enabled is not None:
            pulumi.set(__self__, "cache_enabled", cache_enabled)
        if image_names is not None:
            pulumi.set(__self__, "image_names", image_names)
        if push_enabled is not None:
            pulumi.set(__self__, "push_enabled", push_enabled)
        if secret_arguments is not None:
            pulumi.set(__self__, "secret_arguments", secret_arguments)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="contextAccessToken")
    def context_access_token(self) -> _builtins.str:
        """
        The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        """
        return pulumi.get(self, "context_access_token")

    @_builtins.property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> _builtins.str:
        """
        The URL (absolute or relative) of the source context for this step. If the context is an url you can reference a specific branch or folder via `#branch:folder`.
        """
        return pulumi.get(self, "context_path")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> _builtins.str:
        """
        The Dockerfile path relative to the source context.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter
    def arguments(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies a map of arguments to be used when executing this step.
        """
        return pulumi.get(self, "arguments")

    @_builtins.property
    @pulumi.getter(name="cacheEnabled")
    def cache_enabled(self) -> Optional[_builtins.bool]:
        """
        Should the image cache be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "cache_enabled")

    @_builtins.property
    @pulumi.getter(name="imageNames")
    def image_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of fully qualified image names including the repository and tag.
        """
        return pulumi.get(self, "image_names")

    @_builtins.property
    @pulumi.getter(name="pushEnabled")
    def push_enabled(self) -> Optional[_builtins.bool]:
        """
        Should the image built be pushed to the registry or not? Defaults to `true`.
        """
        return pulumi.get(self, "push_enabled")

    @_builtins.property
    @pulumi.getter(name="secretArguments")
    def secret_arguments(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies a map of *secret* arguments to be used when executing this step.
        """
        return pulumi.get(self, "secret_arguments")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        The name of the target build stage for the docker build.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class RegistryTaskEncodedStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskContent":
            suggest = "task_content"
        elif key == "contextAccessToken":
            suggest = "context_access_token"
        elif key == "contextPath":
            suggest = "context_path"
        elif key == "secretValues":
            suggest = "secret_values"
        elif key == "valueContent":
            suggest = "value_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryTaskEncodedStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryTaskEncodedStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryTaskEncodedStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_content: _builtins.str,
                 context_access_token: Optional[_builtins.str] = None,
                 context_path: Optional[_builtins.str] = None,
                 secret_values: Optional[Mapping[str, _builtins.str]] = None,
                 value_content: Optional[_builtins.str] = None,
                 values: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str task_content: The (optionally base64 encoded) content of the build template.
        :param _builtins.str context_access_token: The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        :param _builtins.str context_path: The URL (absolute or relative) of the source context for this step.
        :param Mapping[str, _builtins.str] secret_values: Specifies a map of secret values that can be passed when running a task.
        :param _builtins.str value_content: The (optionally base64 encoded) content of the build parameters.
        :param Mapping[str, _builtins.str] values: Specifies a map of values that can be passed when running a task.
        """
        pulumi.set(__self__, "task_content", task_content)
        if context_access_token is not None:
            pulumi.set(__self__, "context_access_token", context_access_token)
        if context_path is not None:
            pulumi.set(__self__, "context_path", context_path)
        if secret_values is not None:
            pulumi.set(__self__, "secret_values", secret_values)
        if value_content is not None:
            pulumi.set(__self__, "value_content", value_content)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="taskContent")
    def task_content(self) -> _builtins.str:
        """
        The (optionally base64 encoded) content of the build template.
        """
        return pulumi.get(self, "task_content")

    @_builtins.property
    @pulumi.getter(name="contextAccessToken")
    def context_access_token(self) -> Optional[_builtins.str]:
        """
        The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        """
        return pulumi.get(self, "context_access_token")

    @_builtins.property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[_builtins.str]:
        """
        The URL (absolute or relative) of the source context for this step.
        """
        return pulumi.get(self, "context_path")

    @_builtins.property
    @pulumi.getter(name="secretValues")
    def secret_values(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies a map of secret values that can be passed when running a task.
        """
        return pulumi.get(self, "secret_values")

    @_builtins.property
    @pulumi.getter(name="valueContent")
    def value_content(self) -> Optional[_builtins.str]:
        """
        The (optionally base64 encoded) content of the build parameters.
        """
        return pulumi.get(self, "value_content")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies a map of values that can be passed when running a task.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RegistryTaskFileStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskFilePath":
            suggest = "task_file_path"
        elif key == "contextAccessToken":
            suggest = "context_access_token"
        elif key == "contextPath":
            suggest = "context_path"
        elif key == "secretValues":
            suggest = "secret_values"
        elif key == "valueFilePath":
            suggest = "value_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryTaskFileStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryTaskFileStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryTaskFileStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_file_path: _builtins.str,
                 context_access_token: Optional[_builtins.str] = None,
                 context_path: Optional[_builtins.str] = None,
                 secret_values: Optional[Mapping[str, _builtins.str]] = None,
                 value_file_path: Optional[_builtins.str] = None,
                 values: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str task_file_path: The task template file path relative to the source context.
        :param _builtins.str context_access_token: The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        :param _builtins.str context_path: The URL (absolute or relative) of the source context for this step.
        :param Mapping[str, _builtins.str] secret_values: Specifies a map of secret values that can be passed when running a task.
        :param _builtins.str value_file_path: The parameters file path relative to the source context.
        :param Mapping[str, _builtins.str] values: Specifies a map of values that can be passed when running a task.
        """
        pulumi.set(__self__, "task_file_path", task_file_path)
        if context_access_token is not None:
            pulumi.set(__self__, "context_access_token", context_access_token)
        if context_path is not None:
            pulumi.set(__self__, "context_path", context_path)
        if secret_values is not None:
            pulumi.set(__self__, "secret_values", secret_values)
        if value_file_path is not None:
            pulumi.set(__self__, "value_file_path", value_file_path)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="taskFilePath")
    def task_file_path(self) -> _builtins.str:
        """
        The task template file path relative to the source context.
        """
        return pulumi.get(self, "task_file_path")

    @_builtins.property
    @pulumi.getter(name="contextAccessToken")
    def context_access_token(self) -> Optional[_builtins.str]:
        """
        The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
        """
        return pulumi.get(self, "context_access_token")

    @_builtins.property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[_builtins.str]:
        """
        The URL (absolute or relative) of the source context for this step.
        """
        return pulumi.get(self, "context_path")

    @_builtins.property
    @pulumi.getter(name="secretValues")
    def secret_values(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies a map of secret values that can be passed when running a task.
        """
        return pulumi.get(self, "secret_values")

    @_builtins.property
    @pulumi.getter(name="valueFilePath")
    def value_file_path(self) -> Optional[_builtins.str]:
        """
        The parameters file path relative to the source context.
        """
        return pulumi.get(self, "value_file_path")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies a map of values that can be passed when running a task.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class RegistryTaskIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryTaskIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryTaskIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryTaskIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 identity_ids: Optional[Sequence[_builtins.str]] = None,
                 principal_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the type of Managed Service Identity that should be configured on this Container Registry Task. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param Sequence[_builtins.str] identity_ids: Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry Task.
               
               > **Note:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param _builtins.str principal_id: The Principal ID associated with this Managed Service Identity.
        :param _builtins.str tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of Managed Service Identity that should be configured on this Container Registry Task. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry Task.

        > **Note:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[_builtins.str]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class RegistryTaskPlatform(dict):
    def __init__(__self__, *,
                 os: _builtins.str,
                 architecture: Optional[_builtins.str] = None,
                 variant: Optional[_builtins.str] = None):
        """
        :param _builtins.str os: The operating system type required for the task. Possible values are `Windows` and `Linux`.
        :param _builtins.str architecture: The OS architecture. Possible values are `amd64`, `x86`, `386`, `arm` and `arm64`.
        :param _builtins.str variant: The variant of the CPU. Possible values are `v6`, `v7`, `v8`.
        """
        pulumi.set(__self__, "os", os)
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if variant is not None:
            pulumi.set(__self__, "variant", variant)

    @_builtins.property
    @pulumi.getter
    def os(self) -> _builtins.str:
        """
        The operating system type required for the task. Possible values are `Windows` and `Linux`.
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[_builtins.str]:
        """
        The OS architecture. Possible values are `amd64`, `x86`, `386`, `arm` and `arm64`.
        """
        return pulumi.get(self, "architecture")

    @_builtins.property
    @pulumi.getter
    def variant(self) -> Optional[_builtins.str]:
        """
        The variant of the CPU. Possible values are `v6`, `v7`, `v8`.
        """
        return pulumi.get(self, "variant")


@pulumi.output_type
class RegistryTaskRegistryCredential(dict):
    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.RegistryTaskRegistryCredentialCustom']] = None,
                 source: Optional['outputs.RegistryTaskRegistryCredentialSource'] = None):
        """
        :param Sequence['RegistryTaskRegistryCredentialCustomArgs'] customs: One or more `custom` blocks as defined above.
        :param 'RegistryTaskRegistryCredentialSourceArgs' source: One `source` block as defined below.
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.RegistryTaskRegistryCredentialCustom']]:
        """
        One or more `custom` blocks as defined above.
        """
        return pulumi.get(self, "customs")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.RegistryTaskRegistryCredentialSource']:
        """
        One `source` block as defined below.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class RegistryTaskRegistryCredentialCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginServer":
            suggest = "login_server"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryTaskRegistryCredentialCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryTaskRegistryCredentialCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryTaskRegistryCredentialCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_server: _builtins.str,
                 identity: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str login_server: The login server of the custom Container Registry.
        :param _builtins.str identity: The managed identity assigned to this custom credential. For user assigned identity, the value is the client ID of the identity. For system assigned identity, the value is `[system]`.
        :param _builtins.str password: The password for logging into the custom Container Registry. It can be either a plain text of password, or a Keyvault Secret ID.
        :param _builtins.str username: The username for logging into the custom Container Registry. It can be either a plain text of username, or a Keyvault Secret ID.
        """
        pulumi.set(__self__, "login_server", login_server)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="loginServer")
    def login_server(self) -> _builtins.str:
        """
        The login server of the custom Container Registry.
        """
        return pulumi.get(self, "login_server")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        The managed identity assigned to this custom credential. For user assigned identity, the value is the client ID of the identity. For system assigned identity, the value is `[system]`.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password for logging into the custom Container Registry. It can be either a plain text of password, or a Keyvault Secret ID.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username for logging into the custom Container Registry. It can be either a plain text of username, or a Keyvault Secret ID.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class RegistryTaskRegistryCredentialSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginMode":
            suggest = "login_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryTaskRegistryCredentialSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryTaskRegistryCredentialSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryTaskRegistryCredentialSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_mode: _builtins.str):
        """
        :param _builtins.str login_mode: The login mode for the source registry. Possible values are `None` and `Default`.
        """
        pulumi.set(__self__, "login_mode", login_mode)

    @_builtins.property
    @pulumi.getter(name="loginMode")
    def login_mode(self) -> _builtins.str:
        """
        The login mode for the source registry. Possible values are `None` and `Default`.
        """
        return pulumi.get(self, "login_mode")


@pulumi.output_type
class RegistryTaskSourceTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryUrl":
            suggest = "repository_url"
        elif key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryTaskSourceTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryTaskSourceTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryTaskSourceTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 events: Sequence[_builtins.str],
                 name: _builtins.str,
                 repository_url: _builtins.str,
                 source_type: _builtins.str,
                 authentication: Optional['outputs.RegistryTaskSourceTriggerAuthentication'] = None,
                 branch: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] events: Specifies a list of source events corresponding to the trigger. Possible values are `commit` and `pullrequest`.
        :param _builtins.str name: The name which should be used for this trigger.
        :param _builtins.str repository_url: The full URL to the source code repository.
        :param _builtins.str source_type: The type of the source control service. Possible values are `Github` and `VisualStudioTeamService`.
        :param 'RegistryTaskSourceTriggerAuthenticationArgs' authentication: A `authentication` block as defined above.
        :param _builtins.str branch: The branch name of the source code.
        :param _builtins.bool enabled: Should the trigger be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "repository_url", repository_url)
        pulumi.set(__self__, "source_type", source_type)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Sequence[_builtins.str]:
        """
        Specifies a list of source events corresponding to the trigger. Possible values are `commit` and `pullrequest`.
        """
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name which should be used for this trigger.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> _builtins.str:
        """
        The full URL to the source code repository.
        """
        return pulumi.get(self, "repository_url")

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> _builtins.str:
        """
        The type of the source control service. Possible values are `Github` and `VisualStudioTeamService`.
        """
        return pulumi.get(self, "source_type")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.RegistryTaskSourceTriggerAuthentication']:
        """
        A `authentication` block as defined above.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The branch name of the source code.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Should the trigger be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RegistryTaskSourceTriggerAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenType":
            suggest = "token_type"
        elif key == "expireInSeconds":
            suggest = "expire_in_seconds"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryTaskSourceTriggerAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryTaskSourceTriggerAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryTaskSourceTriggerAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token: _builtins.str,
                 token_type: _builtins.str,
                 expire_in_seconds: Optional[_builtins.int] = None,
                 refresh_token: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None):
        """
        :param _builtins.str token: The access token used to access the source control provider.
        :param _builtins.str token_type: The type of the token. Possible values are `PAT` (personal access token) and `OAuth`.
        :param _builtins.int expire_in_seconds: Time in seconds that the token remains valid.
        :param _builtins.str refresh_token: The refresh token used to refresh the access token.
        :param _builtins.str scope: The scope of the access token.
        """
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "token_type", token_type)
        if expire_in_seconds is not None:
            pulumi.set(__self__, "expire_in_seconds", expire_in_seconds)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The access token used to access the source control provider.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="tokenType")
    def token_type(self) -> _builtins.str:
        """
        The type of the token. Possible values are `PAT` (personal access token) and `OAuth`.
        """
        return pulumi.get(self, "token_type")

    @_builtins.property
    @pulumi.getter(name="expireInSeconds")
    def expire_in_seconds(self) -> Optional[_builtins.int]:
        """
        Time in seconds that the token remains valid.
        """
        return pulumi.get(self, "expire_in_seconds")

    @_builtins.property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[_builtins.str]:
        """
        The refresh token used to refresh the access token.
        """
        return pulumi.get(self, "refresh_token")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The scope of the access token.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class RegistryTaskTimerTrigger(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 schedule: _builtins.str,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name which should be used for this trigger.
        :param _builtins.str schedule: The CRON expression for the task schedule.
        :param _builtins.bool enabled: Should the trigger be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name which should be used for this trigger.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        The CRON expression for the task schedule.
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Should the trigger be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class TokenPasswordPassword1(dict):
    def __init__(__self__, *,
                 expiry: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str expiry: The expiration date of the password in RFC3339 format. If not specified, the password never expires. Changing this forces a new resource to be created.
        :param _builtins.str value: The value of the password (Sensitive).
        """
        if expiry is not None:
            pulumi.set(__self__, "expiry", expiry)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def expiry(self) -> Optional[_builtins.str]:
        """
        The expiration date of the password in RFC3339 format. If not specified, the password never expires. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "expiry")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the password (Sensitive).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TokenPasswordPassword2(dict):
    def __init__(__self__, *,
                 expiry: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str expiry: The expiration date of the password in RFC3339 format. If not specified, the password never expires. Changing this forces a new resource to be created.
        :param _builtins.str value: The value of the password (Sensitive).
        """
        if expiry is not None:
            pulumi.set(__self__, "expiry", expiry)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def expiry(self) -> Optional[_builtins.str]:
        """
        The expiration date of the password in RFC3339 format. If not specified, the password never expires. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "expiry")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the password (Sensitive).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterNodePoolUpgradeSettingResult(dict):
    def __init__(__self__, *,
                 drain_timeout_in_minutes: _builtins.int,
                 max_surge: _builtins.str,
                 max_unavailable: _builtins.str,
                 node_soak_duration_in_minutes: _builtins.int,
                 undrainable_node_behavior: _builtins.str):
        """
        :param _builtins.int drain_timeout_in_minutes: The amount of time in minutes to wait on eviction of pods and graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is exceeded, the upgrade fails.
        :param _builtins.str max_surge: The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        :param _builtins.str max_unavailable: The maximum number or percentage of nodes which can be unavailable during the upgrade.
        :param _builtins.int node_soak_duration_in_minutes: The amount of time in minutes to wait after draining a node and before reimaging it and moving on to next node.
        :param _builtins.str undrainable_node_behavior: The action when a node is undrainable during upgrade. Possible values are `Cordon` and `Schedule`.
        """
        pulumi.set(__self__, "drain_timeout_in_minutes", drain_timeout_in_minutes)
        pulumi.set(__self__, "max_surge", max_surge)
        pulumi.set(__self__, "max_unavailable", max_unavailable)
        pulumi.set(__self__, "node_soak_duration_in_minutes", node_soak_duration_in_minutes)
        pulumi.set(__self__, "undrainable_node_behavior", undrainable_node_behavior)

    @_builtins.property
    @pulumi.getter(name="drainTimeoutInMinutes")
    def drain_timeout_in_minutes(self) -> _builtins.int:
        """
        The amount of time in minutes to wait on eviction of pods and graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is exceeded, the upgrade fails.
        """
        return pulumi.get(self, "drain_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> _builtins.str:
        """
        The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> _builtins.str:
        """
        The maximum number or percentage of nodes which can be unavailable during the upgrade.
        """
        return pulumi.get(self, "max_unavailable")

    @_builtins.property
    @pulumi.getter(name="nodeSoakDurationInMinutes")
    def node_soak_duration_in_minutes(self) -> _builtins.int:
        """
        The amount of time in minutes to wait after draining a node and before reimaging it and moving on to next node.
        """
        return pulumi.get(self, "node_soak_duration_in_minutes")

    @_builtins.property
    @pulumi.getter(name="undrainableNodeBehavior")
    def undrainable_node_behavior(self) -> _builtins.str:
        """
        The action when a node is undrainable during upgrade. Possible values are `Cordon` and `Schedule`.
        """
        return pulumi.get(self, "undrainable_node_behavior")


@pulumi.output_type
class GetGroupIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[_builtins.str],
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Container Group.
        :param _builtins.str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Container Group.
        :param _builtins.str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Container Group.
        :param _builtins.str type: Type of Managed Service Identity configured on this Container Group.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[_builtins.str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Container Group.
        """
        return pulumi.get(self, "identity_ids")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Container Group.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Container Group.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of Managed Service Identity configured on this Container Group.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKubernetesClusterAciConnectorLinuxResult(dict):
    def __init__(__self__, *,
                 subnet_name: _builtins.str):
        """
        :param _builtins.str subnet_name: The subnet name for the virtual nodes to run.
        """
        pulumi.set(__self__, "subnet_name", subnet_name)

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> _builtins.str:
        """
        The subnet name for the virtual nodes to run.
        """
        return pulumi.get(self, "subnet_name")


@pulumi.output_type
class GetKubernetesClusterAgentPoolProfileResult(dict):
    def __init__(__self__, *,
                 auto_scaling_enabled: _builtins.bool,
                 count: _builtins.int,
                 max_count: _builtins.int,
                 max_pods: _builtins.int,
                 min_count: _builtins.int,
                 name: _builtins.str,
                 node_labels: Mapping[str, _builtins.str],
                 node_public_ip_enabled: _builtins.bool,
                 node_public_ip_prefix_id: _builtins.str,
                 node_taints: Sequence[_builtins.str],
                 orchestrator_version: _builtins.str,
                 os_disk_size_gb: _builtins.int,
                 os_type: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 type: _builtins.str,
                 upgrade_settings: Sequence['outputs.GetKubernetesClusterAgentPoolProfileUpgradeSettingResult'],
                 vm_size: _builtins.str,
                 vnet_subnet_id: _builtins.str,
                 zones: Sequence[_builtins.str]):
        """
        :param _builtins.bool auto_scaling_enabled: If the auto-scaler is enabled.
        :param _builtins.int count: The number of Agents (VMs) in the Pool.
        :param _builtins.int max_count: Maximum number of nodes for auto-scaling
        :param _builtins.int max_pods: The maximum number of pods that can run on each agent.
        :param _builtins.int min_count: Minimum number of nodes for auto-scaling
        :param _builtins.str name: The name of the managed Kubernetes Cluster.
        :param _builtins.bool node_public_ip_enabled: If the Public IPs for the nodes in this Agent Pool are enabled.
        :param _builtins.str node_public_ip_prefix_id: Resource ID for the Public IP Addresses Prefix for the nodes in this Agent Pool.
        :param _builtins.str orchestrator_version: Kubernetes version used for the Agents.
        :param _builtins.int os_disk_size_gb: The size of the Agent VM's Operating System Disk in GB.
        :param _builtins.str os_type: The Operating System used for the Agents.
        :param Mapping[str, _builtins.str] tags: A mapping of tags to assign to the resource.
        :param _builtins.str type: The type of Managed Service Identity that is configured on this Kubernetes Cluster.
        :param Sequence['GetKubernetesClusterAgentPoolProfileUpgradeSettingArgs'] upgrade_settings: A `upgrade_settings` block as documented below.
        :param _builtins.str vm_size: The size of each VM in the Agent Pool (e.g. `Standard_F1`).
        :param _builtins.str vnet_subnet_id: The ID of the Subnet where the Agents in the Pool are provisioned.
        :param Sequence[_builtins.str] zones: A list of Availability Zones in which this Kubernetes Cluster is located.
        """
        pulumi.set(__self__, "auto_scaling_enabled", auto_scaling_enabled)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "max_count", max_count)
        pulumi.set(__self__, "max_pods", max_pods)
        pulumi.set(__self__, "min_count", min_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_labels", node_labels)
        pulumi.set(__self__, "node_public_ip_enabled", node_public_ip_enabled)
        pulumi.set(__self__, "node_public_ip_prefix_id", node_public_ip_prefix_id)
        pulumi.set(__self__, "node_taints", node_taints)
        pulumi.set(__self__, "orchestrator_version", orchestrator_version)
        pulumi.set(__self__, "os_disk_size_gb", os_disk_size_gb)
        pulumi.set(__self__, "os_type", os_type)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "upgrade_settings", upgrade_settings)
        pulumi.set(__self__, "vm_size", vm_size)
        pulumi.set(__self__, "vnet_subnet_id", vnet_subnet_id)
        pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="autoScalingEnabled")
    def auto_scaling_enabled(self) -> _builtins.bool:
        """
        If the auto-scaler is enabled.
        """
        return pulumi.get(self, "auto_scaling_enabled")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of Agents (VMs) in the Pool.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> _builtins.int:
        """
        Maximum number of nodes for auto-scaling
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> _builtins.int:
        """
        The maximum number of pods that can run on each agent.
        """
        return pulumi.get(self, "max_pods")

    @_builtins.property
    @pulumi.getter(name="minCount")
    def min_count(self) -> _builtins.int:
        """
        Minimum number of nodes for auto-scaling
        """
        return pulumi.get(self, "min_count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the managed Kubernetes Cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "node_labels")

    @_builtins.property
    @pulumi.getter(name="nodePublicIpEnabled")
    def node_public_ip_enabled(self) -> _builtins.bool:
        """
        If the Public IPs for the nodes in this Agent Pool are enabled.
        """
        return pulumi.get(self, "node_public_ip_enabled")

    @_builtins.property
    @pulumi.getter(name="nodePublicIpPrefixId")
    def node_public_ip_prefix_id(self) -> _builtins.str:
        """
        Resource ID for the Public IP Addresses Prefix for the nodes in this Agent Pool.
        """
        return pulumi.get(self, "node_public_ip_prefix_id")

    @_builtins.property
    @pulumi.getter(name="nodeTaints")
    def node_taints(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "node_taints")

    @_builtins.property
    @pulumi.getter(name="orchestratorVersion")
    def orchestrator_version(self) -> _builtins.str:
        """
        Kubernetes version used for the Agents.
        """
        return pulumi.get(self, "orchestrator_version")

    @_builtins.property
    @pulumi.getter(name="osDiskSizeGb")
    def os_disk_size_gb(self) -> _builtins.int:
        """
        The size of the Agent VM's Operating System Disk in GB.
        """
        return pulumi.get(self, "os_disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="osType")
    def os_type(self) -> _builtins.str:
        """
        The Operating System used for the Agents.
        """
        return pulumi.get(self, "os_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        A mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Managed Service Identity that is configured on this Kubernetes Cluster.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="upgradeSettings")
    def upgrade_settings(self) -> Sequence['outputs.GetKubernetesClusterAgentPoolProfileUpgradeSettingResult']:
        """
        A `upgrade_settings` block as documented below.
        """
        return pulumi.get(self, "upgrade_settings")

    @_builtins.property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> _builtins.str:
        """
        The size of each VM in the Agent Pool (e.g. `Standard_F1`).
        """
        return pulumi.get(self, "vm_size")

    @_builtins.property
    @pulumi.getter(name="vnetSubnetId")
    def vnet_subnet_id(self) -> _builtins.str:
        """
        The ID of the Subnet where the Agents in the Pool are provisioned.
        """
        return pulumi.get(self, "vnet_subnet_id")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Sequence[_builtins.str]:
        """
        A list of Availability Zones in which this Kubernetes Cluster is located.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetKubernetesClusterAgentPoolProfileUpgradeSettingResult(dict):
    def __init__(__self__, *,
                 drain_timeout_in_minutes: _builtins.int,
                 max_surge: _builtins.str,
                 max_unavailable: _builtins.str,
                 node_soak_duration_in_minutes: _builtins.int,
                 undrainable_node_behavior: _builtins.str):
        """
        :param _builtins.int drain_timeout_in_minutes: The amount of time in minutes to wait on eviction of pods and graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is exceeded, the upgrade fails.
        :param _builtins.str max_surge: The maximum number or percentage of nodes that will be added to the Node Pool size during an upgrade.
        :param _builtins.int node_soak_duration_in_minutes: The amount of time in minutes to wait after draining a node and before reimaging it and moving on to next node.
        :param _builtins.str undrainable_node_behavior: The action when a node is undrainable during upgrade. Possible values are `Cordon` and `Schedule`.
        """
        pulumi.set(__self__, "drain_timeout_in_minutes", drain_timeout_in_minutes)
        pulumi.set(__self__, "max_surge", max_surge)
        pulumi.set(__self__, "max_unavailable", max_unavailable)
        pulumi.set(__self__, "node_soak_duration_in_minutes", node_soak_duration_in_minutes)
        pulumi.set(__self__, "undrainable_node_behavior", undrainable_node_behavior)

    @_builtins.property
    @pulumi.getter(name="drainTimeoutInMinutes")
    def drain_timeout_in_minutes(self) -> _builtins.int:
        """
        The amount of time in minutes to wait on eviction of pods and graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is exceeded, the upgrade fails.
        """
        return pulumi.get(self, "drain_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> _builtins.str:
        """
        The maximum number or percentage of nodes that will be added to the Node Pool size during an upgrade.
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> _builtins.str:
        return pulumi.get(self, "max_unavailable")

    @_builtins.property
    @pulumi.getter(name="nodeSoakDurationInMinutes")
    def node_soak_duration_in_minutes(self) -> _builtins.int:
        """
        The amount of time in minutes to wait after draining a node and before reimaging it and moving on to next node.
        """
        return pulumi.get(self, "node_soak_duration_in_minutes")

    @_builtins.property
    @pulumi.getter(name="undrainableNodeBehavior")
    def undrainable_node_behavior(self) -> _builtins.str:
        """
        The action when a node is undrainable during upgrade. Possible values are `Cordon` and `Schedule`.
        """
        return pulumi.get(self, "undrainable_node_behavior")


@pulumi.output_type
class GetKubernetesClusterAzureActiveDirectoryRoleBasedAccessControlResult(dict):
    def __init__(__self__, *,
                 admin_group_object_ids: Sequence[_builtins.str],
                 azure_rbac_enabled: _builtins.bool,
                 tenant_id: _builtins.str):
        """
        :param Sequence[_builtins.str] admin_group_object_ids: A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
        :param _builtins.bool azure_rbac_enabled: Is Role Based Access Control based on Azure AD enabled?
        :param _builtins.str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Kubernetes Cluster.
        """
        pulumi.set(__self__, "admin_group_object_ids", admin_group_object_ids)
        pulumi.set(__self__, "azure_rbac_enabled", azure_rbac_enabled)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="adminGroupObjectIds")
    def admin_group_object_ids(self) -> Sequence[_builtins.str]:
        """
        A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
        """
        return pulumi.get(self, "admin_group_object_ids")

    @_builtins.property
    @pulumi.getter(name="azureRbacEnabled")
    def azure_rbac_enabled(self) -> _builtins.bool:
        """
        Is Role Based Access Control based on Azure AD enabled?
        """
        return pulumi.get(self, "azure_rbac_enabled")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Kubernetes Cluster.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetKubernetesClusterIdentityResult(dict):
    def __init__(__self__, *,
                 identity_ids: Sequence[_builtins.str],
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] identity_ids: The list of User Assigned Managed Identity IDs assigned to this Kubernetes Cluster.
        :param _builtins.str principal_id: The Principal ID of the System Assigned Managed Service Identity that is configured on this Kubernetes Cluster.
        :param _builtins.str tenant_id: The Tenant ID of the System Assigned Managed Service Identity that is configured on this Kubernetes Cluster.
        :param _builtins.str type: The type of Managed Service Identity that is configured on this Kubernetes Cluster.
        """
        pulumi.set(__self__, "identity_ids", identity_ids)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Sequence[_builtins.str]:
        """
        The list of User Assigned Managed Identity IDs assigned to this Kubernetes Cluster.
        """
        return pulumi.get(self, "identity_ids")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The Principal ID of the System Assigned Managed Service Identity that is configured on this Kubernetes Cluster.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The Tenant ID of the System Assigned Managed Service Identity that is configured on this Kubernetes Cluster.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Managed Service Identity that is configured on this Kubernetes Cluster.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKubernetesClusterIngressApplicationGatewayResult(dict):
    def __init__(__self__, *,
                 effective_gateway_id: _builtins.str,
                 gateway_id: _builtins.str,
                 gateway_name: _builtins.str,
                 ingress_application_gateway_identities: Sequence['outputs.GetKubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityResult'],
                 subnet_cidr: _builtins.str,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str effective_gateway_id: The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
        :param _builtins.str gateway_id: The ID of the Application Gateway integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when gateway_id is specified when configuring the `ingress_application_gateway` addon.
        :param Sequence['GetKubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityArgs'] ingress_application_gateway_identities: An `ingress_application_gateway_identity` block as defined below.
        :param _builtins.str subnet_cidr: The subnet CIDR used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when `subnet_cidr` is specified when configuring the `ingress_application_gateway` addon.
        :param _builtins.str subnet_id: The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when `subnet_id` is specified when configuring the `ingress_application_gateway` addon.
        """
        pulumi.set(__self__, "effective_gateway_id", effective_gateway_id)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "gateway_name", gateway_name)
        pulumi.set(__self__, "ingress_application_gateway_identities", ingress_application_gateway_identities)
        pulumi.set(__self__, "subnet_cidr", subnet_cidr)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="effectiveGatewayId")
    def effective_gateway_id(self) -> _builtins.str:
        """
        The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
        """
        return pulumi.get(self, "effective_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        """
        The ID of the Application Gateway integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when gateway_id is specified when configuring the `ingress_application_gateway` addon.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayName")
    def gateway_name(self) -> _builtins.str:
        return pulumi.get(self, "gateway_name")

    @_builtins.property
    @pulumi.getter(name="ingressApplicationGatewayIdentities")
    def ingress_application_gateway_identities(self) -> Sequence['outputs.GetKubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityResult']:
        """
        An `ingress_application_gateway_identity` block as defined below.
        """
        return pulumi.get(self, "ingress_application_gateway_identities")

    @_builtins.property
    @pulumi.getter(name="subnetCidr")
    def subnet_cidr(self) -> _builtins.str:
        """
        The subnet CIDR used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when `subnet_cidr` is specified when configuring the `ingress_application_gateway` addon.
        """
        return pulumi.get(self, "subnet_cidr")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when `subnet_id` is specified when configuring the `ingress_application_gateway` addon.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetKubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentityResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 object_id: _builtins.str,
                 user_assigned_identity_id: _builtins.str):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> _builtins.str:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> _builtins.str:
        """
        The ID of the User Assigned Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class GetKubernetesClusterKeyManagementServiceResult(dict):
    def __init__(__self__, *,
                 key_vault_key_id: _builtins.str,
                 key_vault_network_access: _builtins.str):
        """
        :param _builtins.str key_vault_key_id: Identifier of Azure Key Vault key. See [key identifier format](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details.
        :param _builtins.str key_vault_network_access: Network access of the key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link.
        """
        pulumi.set(__self__, "key_vault_key_id", key_vault_key_id)
        pulumi.set(__self__, "key_vault_network_access", key_vault_network_access)

    @_builtins.property
    @pulumi.getter(name="keyVaultKeyId")
    def key_vault_key_id(self) -> _builtins.str:
        """
        Identifier of Azure Key Vault key. See [key identifier format](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details.
        """
        return pulumi.get(self, "key_vault_key_id")

    @_builtins.property
    @pulumi.getter(name="keyVaultNetworkAccess")
    def key_vault_network_access(self) -> _builtins.str:
        """
        Network access of the key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link.
        """
        return pulumi.get(self, "key_vault_network_access")


@pulumi.output_type
class GetKubernetesClusterKeyVaultSecretsProviderResult(dict):
    def __init__(__self__, *,
                 secret_identities: Sequence['outputs.GetKubernetesClusterKeyVaultSecretsProviderSecretIdentityResult'],
                 secret_rotation_enabled: _builtins.bool,
                 secret_rotation_interval: _builtins.str):
        """
        :param Sequence['GetKubernetesClusterKeyVaultSecretsProviderSecretIdentityArgs'] secret_identities: A `secret_identity` block as documented below.
        :param _builtins.bool secret_rotation_enabled: Is secret rotation enabled?
        :param _builtins.str secret_rotation_interval: The interval to poll for secret rotation.
        """
        pulumi.set(__self__, "secret_identities", secret_identities)
        pulumi.set(__self__, "secret_rotation_enabled", secret_rotation_enabled)
        pulumi.set(__self__, "secret_rotation_interval", secret_rotation_interval)

    @_builtins.property
    @pulumi.getter(name="secretIdentities")
    def secret_identities(self) -> Sequence['outputs.GetKubernetesClusterKeyVaultSecretsProviderSecretIdentityResult']:
        """
        A `secret_identity` block as documented below.
        """
        return pulumi.get(self, "secret_identities")

    @_builtins.property
    @pulumi.getter(name="secretRotationEnabled")
    def secret_rotation_enabled(self) -> _builtins.bool:
        """
        Is secret rotation enabled?
        """
        return pulumi.get(self, "secret_rotation_enabled")

    @_builtins.property
    @pulumi.getter(name="secretRotationInterval")
    def secret_rotation_interval(self) -> _builtins.str:
        """
        The interval to poll for secret rotation.
        """
        return pulumi.get(self, "secret_rotation_interval")


@pulumi.output_type
class GetKubernetesClusterKeyVaultSecretsProviderSecretIdentityResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 object_id: _builtins.str,
                 user_assigned_identity_id: _builtins.str):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> _builtins.str:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> _builtins.str:
        """
        The ID of the User Assigned Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class GetKubernetesClusterKubeAdminConfigResult(dict):
    def __init__(__self__, *,
                 client_certificate: _builtins.str,
                 client_key: _builtins.str,
                 cluster_ca_certificate: _builtins.str,
                 host: _builtins.str,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param _builtins.str client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param _builtins.str cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param _builtins.str host: The Kubernetes cluster server host.
        :param _builtins.str password: A password or token used to authenticate to the Kubernetes cluster.
        :param _builtins.str username: A username used to authenticate to the Kubernetes cluster.
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> _builtins.str:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> _builtins.str:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> _builtins.str:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetKubernetesClusterKubeConfigResult(dict):
    def __init__(__self__, *,
                 client_certificate: _builtins.str,
                 client_key: _builtins.str,
                 cluster_ca_certificate: _builtins.str,
                 host: _builtins.str,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str client_certificate: Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        :param _builtins.str client_key: Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        :param _builtins.str cluster_ca_certificate: Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        :param _builtins.str host: The Kubernetes cluster server host.
        :param _builtins.str password: A password or token used to authenticate to the Kubernetes cluster.
        :param _builtins.str username: A username used to authenticate to the Kubernetes cluster.
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> _builtins.str:
        """
        Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> _builtins.str:
        """
        Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> _builtins.str:
        """
        Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The Kubernetes cluster server host.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        A password or token used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        A username used to authenticate to the Kubernetes cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetKubernetesClusterKubeletIdentityResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 object_id: _builtins.str,
                 user_assigned_identity_id: _builtins.str):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> _builtins.str:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> _builtins.str:
        """
        The ID of the User Assigned Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class GetKubernetesClusterLinuxProfileResult(dict):
    def __init__(__self__, *,
                 admin_username: _builtins.str,
                 ssh_keys: Sequence['outputs.GetKubernetesClusterLinuxProfileSshKeyResult']):
        """
        :param _builtins.str admin_username: The username associated with the administrator account of the Windows VMs.
        :param Sequence['GetKubernetesClusterLinuxProfileSshKeyArgs'] ssh_keys: An `ssh_key` block as defined below.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "ssh_keys", ssh_keys)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> _builtins.str:
        """
        The username associated with the administrator account of the Windows VMs.
        """
        return pulumi.get(self, "admin_username")

    @_builtins.property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence['outputs.GetKubernetesClusterLinuxProfileSshKeyResult']:
        """
        An `ssh_key` block as defined below.
        """
        return pulumi.get(self, "ssh_keys")


@pulumi.output_type
class GetKubernetesClusterLinuxProfileSshKeyResult(dict):
    def __init__(__self__, *,
                 key_data: _builtins.str):
        """
        :param _builtins.str key_data: The Public SSH Key used to access the cluster.
        """
        pulumi.set(__self__, "key_data", key_data)

    @_builtins.property
    @pulumi.getter(name="keyData")
    def key_data(self) -> _builtins.str:
        """
        The Public SSH Key used to access the cluster.
        """
        return pulumi.get(self, "key_data")


@pulumi.output_type
class GetKubernetesClusterMicrosoftDefenderResult(dict):
    def __init__(__self__, *,
                 log_analytics_workspace_id: _builtins.str):
        """
        :param _builtins.str log_analytics_workspace_id: The ID of the Log Analytics Workspace to which the OMS Agent should send data.
        """
        pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> _builtins.str:
        """
        The ID of the Log Analytics Workspace to which the OMS Agent should send data.
        """
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class GetKubernetesClusterNetworkProfileResult(dict):
    def __init__(__self__, *,
                 dns_service_ip: _builtins.str,
                 docker_bridge_cidr: _builtins.str,
                 load_balancer_sku: _builtins.str,
                 network_plugin: _builtins.str,
                 network_policy: _builtins.str,
                 pod_cidr: _builtins.str,
                 service_cidr: _builtins.str):
        """
        :param _builtins.str dns_service_ip: IP address within the Kubernetes service address range used by cluster service discovery (kube-dns).
        :param _builtins.str docker_bridge_cidr: IP address (in CIDR notation) used as the Docker bridge IP address on nodes.
        :param _builtins.str network_plugin: Network plugin used such as `azure` or `kubenet`.
        :param _builtins.str network_policy: Network policy to be used with Azure CNI. e.g. `calico` or `azure`
        :param _builtins.str pod_cidr: The CIDR used for pod IP addresses.
        :param _builtins.str service_cidr: Network range used by the Kubernetes service.
        """
        pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        pulumi.set(__self__, "network_plugin", network_plugin)
        pulumi.set(__self__, "network_policy", network_policy)
        pulumi.set(__self__, "pod_cidr", pod_cidr)
        pulumi.set(__self__, "service_cidr", service_cidr)

    @_builtins.property
    @pulumi.getter(name="dnsServiceIp")
    def dns_service_ip(self) -> _builtins.str:
        """
        IP address within the Kubernetes service address range used by cluster service discovery (kube-dns).
        """
        return pulumi.get(self, "dns_service_ip")

    @_builtins.property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> _builtins.str:
        """
        IP address (in CIDR notation) used as the Docker bridge IP address on nodes.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> _builtins.str:
        return pulumi.get(self, "load_balancer_sku")

    @_builtins.property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> _builtins.str:
        """
        Network plugin used such as `azure` or `kubenet`.
        """
        return pulumi.get(self, "network_plugin")

    @_builtins.property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> _builtins.str:
        """
        Network policy to be used with Azure CNI. e.g. `calico` or `azure`
        """
        return pulumi.get(self, "network_policy")

    @_builtins.property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> _builtins.str:
        """
        The CIDR used for pod IP addresses.
        """
        return pulumi.get(self, "pod_cidr")

    @_builtins.property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> _builtins.str:
        """
        Network range used by the Kubernetes service.
        """
        return pulumi.get(self, "service_cidr")


@pulumi.output_type
class GetKubernetesClusterOmsAgentResult(dict):
    def __init__(__self__, *,
                 log_analytics_workspace_id: _builtins.str,
                 msi_auth_for_monitoring_enabled: _builtins.bool,
                 oms_agent_identities: Sequence['outputs.GetKubernetesClusterOmsAgentOmsAgentIdentityResult']):
        """
        :param _builtins.str log_analytics_workspace_id: The ID of the Log Analytics Workspace to which the OMS Agent should send data.
        :param _builtins.bool msi_auth_for_monitoring_enabled: Is managed identity authentication for monitoring enabled?
        :param Sequence['GetKubernetesClusterOmsAgentOmsAgentIdentityArgs'] oms_agent_identities: An `oms_agent_identity` block as defined below.
        """
        pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)
        pulumi.set(__self__, "msi_auth_for_monitoring_enabled", msi_auth_for_monitoring_enabled)
        pulumi.set(__self__, "oms_agent_identities", oms_agent_identities)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> _builtins.str:
        """
        The ID of the Log Analytics Workspace to which the OMS Agent should send data.
        """
        return pulumi.get(self, "log_analytics_workspace_id")

    @_builtins.property
    @pulumi.getter(name="msiAuthForMonitoringEnabled")
    def msi_auth_for_monitoring_enabled(self) -> _builtins.bool:
        """
        Is managed identity authentication for monitoring enabled?
        """
        return pulumi.get(self, "msi_auth_for_monitoring_enabled")

    @_builtins.property
    @pulumi.getter(name="omsAgentIdentities")
    def oms_agent_identities(self) -> Sequence['outputs.GetKubernetesClusterOmsAgentOmsAgentIdentityResult']:
        """
        An `oms_agent_identity` block as defined below.
        """
        return pulumi.get(self, "oms_agent_identities")


@pulumi.output_type
class GetKubernetesClusterOmsAgentOmsAgentIdentityResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 object_id: _builtins.str,
                 user_assigned_identity_id: _builtins.str):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        :param _builtins.str object_id: The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        :param _builtins.str user_assigned_identity_id: The ID of the User Assigned Identity assigned to the Kubelets.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "user_assigned_identity_id", user_assigned_identity_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> _builtins.str:
        """
        The Object ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityId")
    def user_assigned_identity_id(self) -> _builtins.str:
        """
        The ID of the User Assigned Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "user_assigned_identity_id")


@pulumi.output_type
class GetKubernetesClusterServiceMeshProfileResult(dict):
    def __init__(__self__, *,
                 certificate_authorities: Sequence['outputs.GetKubernetesClusterServiceMeshProfileCertificateAuthorityResult'],
                 external_ingress_gateway_enabled: _builtins.bool,
                 internal_ingress_gateway_enabled: _builtins.bool,
                 mode: _builtins.str,
                 revisions: Sequence[_builtins.str]):
        """
        :param Sequence['GetKubernetesClusterServiceMeshProfileCertificateAuthorityArgs'] certificate_authorities: A `certificate_authority` block as documented below.
        :param _builtins.bool external_ingress_gateway_enabled: Is Istio External Ingress Gateway enabled?
        :param _builtins.bool internal_ingress_gateway_enabled: Is Istio Internal Ingress Gateway enabled?
        :param _builtins.str mode: The mode of the service mesh.
        :param Sequence[_builtins.str] revisions: List of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary upgrade is in progress, this can only hold two consecutive values. Learn More.
        """
        pulumi.set(__self__, "certificate_authorities", certificate_authorities)
        pulumi.set(__self__, "external_ingress_gateway_enabled", external_ingress_gateway_enabled)
        pulumi.set(__self__, "internal_ingress_gateway_enabled", internal_ingress_gateway_enabled)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "revisions", revisions)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorities")
    def certificate_authorities(self) -> Sequence['outputs.GetKubernetesClusterServiceMeshProfileCertificateAuthorityResult']:
        """
        A `certificate_authority` block as documented below.
        """
        return pulumi.get(self, "certificate_authorities")

    @_builtins.property
    @pulumi.getter(name="externalIngressGatewayEnabled")
    def external_ingress_gateway_enabled(self) -> _builtins.bool:
        """
        Is Istio External Ingress Gateway enabled?
        """
        return pulumi.get(self, "external_ingress_gateway_enabled")

    @_builtins.property
    @pulumi.getter(name="internalIngressGatewayEnabled")
    def internal_ingress_gateway_enabled(self) -> _builtins.bool:
        """
        Is Istio Internal Ingress Gateway enabled?
        """
        return pulumi.get(self, "internal_ingress_gateway_enabled")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode of the service mesh.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def revisions(self) -> Sequence[_builtins.str]:
        """
        List of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary upgrade is in progress, this can only hold two consecutive values. Learn More.
        """
        return pulumi.get(self, "revisions")


@pulumi.output_type
class GetKubernetesClusterServiceMeshProfileCertificateAuthorityResult(dict):
    def __init__(__self__, *,
                 cert_chain_object_name: _builtins.str,
                 cert_object_name: _builtins.str,
                 key_object_name: _builtins.str,
                 key_vault_id: _builtins.str,
                 root_cert_object_name: _builtins.str):
        """
        :param _builtins.str cert_chain_object_name: The certificate chain object name in Azure Key Vault.
        :param _builtins.str cert_object_name: The intermediate certificate object name in Azure Key Vault.
        :param _builtins.str key_object_name: The intermediate certificate private key object name in Azure Key Vault.
        :param _builtins.str key_vault_id: The resource ID of the Key Vault.
        :param _builtins.str root_cert_object_name: The root certificate object name in Azure Key Vault.
        """
        pulumi.set(__self__, "cert_chain_object_name", cert_chain_object_name)
        pulumi.set(__self__, "cert_object_name", cert_object_name)
        pulumi.set(__self__, "key_object_name", key_object_name)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        pulumi.set(__self__, "root_cert_object_name", root_cert_object_name)

    @_builtins.property
    @pulumi.getter(name="certChainObjectName")
    def cert_chain_object_name(self) -> _builtins.str:
        """
        The certificate chain object name in Azure Key Vault.
        """
        return pulumi.get(self, "cert_chain_object_name")

    @_builtins.property
    @pulumi.getter(name="certObjectName")
    def cert_object_name(self) -> _builtins.str:
        """
        The intermediate certificate object name in Azure Key Vault.
        """
        return pulumi.get(self, "cert_object_name")

    @_builtins.property
    @pulumi.getter(name="keyObjectName")
    def key_object_name(self) -> _builtins.str:
        """
        The intermediate certificate private key object name in Azure Key Vault.
        """
        return pulumi.get(self, "key_object_name")

    @_builtins.property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> _builtins.str:
        """
        The resource ID of the Key Vault.
        """
        return pulumi.get(self, "key_vault_id")

    @_builtins.property
    @pulumi.getter(name="rootCertObjectName")
    def root_cert_object_name(self) -> _builtins.str:
        """
        The root certificate object name in Azure Key Vault.
        """
        return pulumi.get(self, "root_cert_object_name")


@pulumi.output_type
class GetKubernetesClusterServicePrincipalResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str):
        """
        :param _builtins.str client_id: The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        pulumi.set(__self__, "client_id", client_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID of the user-defined Managed Identity assigned to the Kubelets.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class GetKubernetesClusterStorageProfileResult(dict):
    def __init__(__self__, *,
                 blob_driver_enabled: _builtins.bool,
                 disk_driver_enabled: _builtins.bool,
                 file_driver_enabled: _builtins.bool,
                 snapshot_controller_enabled: _builtins.bool):
        """
        :param _builtins.bool blob_driver_enabled: Is the Blob CSI driver enabled?
        :param _builtins.bool disk_driver_enabled: Is the Disk CSI driver enabled?
        :param _builtins.bool file_driver_enabled: Is the File CSI driver enabled?
        :param _builtins.bool snapshot_controller_enabled: Is the Snapshot Controller enabled?
        """
        pulumi.set(__self__, "blob_driver_enabled", blob_driver_enabled)
        pulumi.set(__self__, "disk_driver_enabled", disk_driver_enabled)
        pulumi.set(__self__, "file_driver_enabled", file_driver_enabled)
        pulumi.set(__self__, "snapshot_controller_enabled", snapshot_controller_enabled)

    @_builtins.property
    @pulumi.getter(name="blobDriverEnabled")
    def blob_driver_enabled(self) -> _builtins.bool:
        """
        Is the Blob CSI driver enabled?
        """
        return pulumi.get(self, "blob_driver_enabled")

    @_builtins.property
    @pulumi.getter(name="diskDriverEnabled")
    def disk_driver_enabled(self) -> _builtins.bool:
        """
        Is the Disk CSI driver enabled?
        """
        return pulumi.get(self, "disk_driver_enabled")

    @_builtins.property
    @pulumi.getter(name="fileDriverEnabled")
    def file_driver_enabled(self) -> _builtins.bool:
        """
        Is the File CSI driver enabled?
        """
        return pulumi.get(self, "file_driver_enabled")

    @_builtins.property
    @pulumi.getter(name="snapshotControllerEnabled")
    def snapshot_controller_enabled(self) -> _builtins.bool:
        """
        Is the Snapshot Controller enabled?
        """
        return pulumi.get(self, "snapshot_controller_enabled")


@pulumi.output_type
class GetKubernetesClusterWindowsProfileResult(dict):
    def __init__(__self__, *,
                 admin_username: _builtins.str):
        """
        :param _builtins.str admin_username: The username associated with the administrator account of the Windows VMs.
        """
        pulumi.set(__self__, "admin_username", admin_username)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> _builtins.str:
        """
        The username associated with the administrator account of the Windows VMs.
        """
        return pulumi.get(self, "admin_username")


