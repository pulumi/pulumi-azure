# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AppConnectionAuthenticationArgs',
    'AppConnectionAuthenticationArgsDict',
    'AppConnectionSecretStoreArgs',
    'AppConnectionSecretStoreArgsDict',
    'AppServiceAuthSettingsArgs',
    'AppServiceAuthSettingsArgsDict',
    'AppServiceAuthSettingsActiveDirectoryArgs',
    'AppServiceAuthSettingsActiveDirectoryArgsDict',
    'AppServiceAuthSettingsFacebookArgs',
    'AppServiceAuthSettingsFacebookArgsDict',
    'AppServiceAuthSettingsGoogleArgs',
    'AppServiceAuthSettingsGoogleArgsDict',
    'AppServiceAuthSettingsMicrosoftArgs',
    'AppServiceAuthSettingsMicrosoftArgsDict',
    'AppServiceAuthSettingsTwitterArgs',
    'AppServiceAuthSettingsTwitterArgsDict',
    'AppServiceBackupArgs',
    'AppServiceBackupArgsDict',
    'AppServiceBackupScheduleArgs',
    'AppServiceBackupScheduleArgsDict',
    'AppServiceConnectionStringArgs',
    'AppServiceConnectionStringArgsDict',
    'AppServiceIdentityArgs',
    'AppServiceIdentityArgsDict',
    'AppServiceLogsArgs',
    'AppServiceLogsArgsDict',
    'AppServiceLogsApplicationLogsArgs',
    'AppServiceLogsApplicationLogsArgsDict',
    'AppServiceLogsApplicationLogsAzureBlobStorageArgs',
    'AppServiceLogsApplicationLogsAzureBlobStorageArgsDict',
    'AppServiceLogsHttpLogsArgs',
    'AppServiceLogsHttpLogsArgsDict',
    'AppServiceLogsHttpLogsAzureBlobStorageArgs',
    'AppServiceLogsHttpLogsAzureBlobStorageArgsDict',
    'AppServiceLogsHttpLogsFileSystemArgs',
    'AppServiceLogsHttpLogsFileSystemArgsDict',
    'AppServiceSiteConfigArgs',
    'AppServiceSiteConfigArgsDict',
    'AppServiceSiteConfigCorsArgs',
    'AppServiceSiteConfigCorsArgsDict',
    'AppServiceSiteConfigIpRestrictionArgs',
    'AppServiceSiteConfigIpRestrictionArgsDict',
    'AppServiceSiteConfigIpRestrictionHeadersArgs',
    'AppServiceSiteConfigIpRestrictionHeadersArgsDict',
    'AppServiceSiteConfigScmIpRestrictionArgs',
    'AppServiceSiteConfigScmIpRestrictionArgsDict',
    'AppServiceSiteConfigScmIpRestrictionHeadersArgs',
    'AppServiceSiteConfigScmIpRestrictionHeadersArgsDict',
    'AppServiceSiteCredentialArgs',
    'AppServiceSiteCredentialArgsDict',
    'AppServiceSourceControlArgs',
    'AppServiceSourceControlArgsDict',
    'AppServiceStorageAccountArgs',
    'AppServiceStorageAccountArgsDict',
    'CertificateOrderCertificateArgs',
    'CertificateOrderCertificateArgsDict',
    'ConnectionAuthenticationArgs',
    'ConnectionAuthenticationArgsDict',
    'ConnectionSecretStoreArgs',
    'ConnectionSecretStoreArgsDict',
    'EnvironmentV3ClusterSettingArgs',
    'EnvironmentV3ClusterSettingArgsDict',
    'EnvironmentV3InboundNetworkDependencyArgs',
    'EnvironmentV3InboundNetworkDependencyArgsDict',
    'FunctionAppAuthSettingsArgs',
    'FunctionAppAuthSettingsArgsDict',
    'FunctionAppAuthSettingsActiveDirectoryArgs',
    'FunctionAppAuthSettingsActiveDirectoryArgsDict',
    'FunctionAppAuthSettingsFacebookArgs',
    'FunctionAppAuthSettingsFacebookArgsDict',
    'FunctionAppAuthSettingsGoogleArgs',
    'FunctionAppAuthSettingsGoogleArgsDict',
    'FunctionAppAuthSettingsMicrosoftArgs',
    'FunctionAppAuthSettingsMicrosoftArgsDict',
    'FunctionAppAuthSettingsTwitterArgs',
    'FunctionAppAuthSettingsTwitterArgsDict',
    'FunctionAppConnectionStringArgs',
    'FunctionAppConnectionStringArgsDict',
    'FunctionAppFunctionFileArgs',
    'FunctionAppFunctionFileArgsDict',
    'FunctionAppIdentityArgs',
    'FunctionAppIdentityArgsDict',
    'FunctionAppSiteConfigArgs',
    'FunctionAppSiteConfigArgsDict',
    'FunctionAppSiteConfigCorsArgs',
    'FunctionAppSiteConfigCorsArgsDict',
    'FunctionAppSiteConfigIpRestrictionArgs',
    'FunctionAppSiteConfigIpRestrictionArgsDict',
    'FunctionAppSiteConfigIpRestrictionHeadersArgs',
    'FunctionAppSiteConfigIpRestrictionHeadersArgsDict',
    'FunctionAppSiteConfigScmIpRestrictionArgs',
    'FunctionAppSiteConfigScmIpRestrictionArgsDict',
    'FunctionAppSiteConfigScmIpRestrictionHeadersArgs',
    'FunctionAppSiteConfigScmIpRestrictionHeadersArgsDict',
    'FunctionAppSiteCredentialArgs',
    'FunctionAppSiteCredentialArgsDict',
    'FunctionAppSlotAuthSettingsArgs',
    'FunctionAppSlotAuthSettingsArgsDict',
    'FunctionAppSlotAuthSettingsActiveDirectoryArgs',
    'FunctionAppSlotAuthSettingsActiveDirectoryArgsDict',
    'FunctionAppSlotAuthSettingsFacebookArgs',
    'FunctionAppSlotAuthSettingsFacebookArgsDict',
    'FunctionAppSlotAuthSettingsGoogleArgs',
    'FunctionAppSlotAuthSettingsGoogleArgsDict',
    'FunctionAppSlotAuthSettingsMicrosoftArgs',
    'FunctionAppSlotAuthSettingsMicrosoftArgsDict',
    'FunctionAppSlotAuthSettingsTwitterArgs',
    'FunctionAppSlotAuthSettingsTwitterArgsDict',
    'FunctionAppSlotConnectionStringArgs',
    'FunctionAppSlotConnectionStringArgsDict',
    'FunctionAppSlotIdentityArgs',
    'FunctionAppSlotIdentityArgsDict',
    'FunctionAppSlotSiteConfigArgs',
    'FunctionAppSlotSiteConfigArgsDict',
    'FunctionAppSlotSiteConfigCorsArgs',
    'FunctionAppSlotSiteConfigCorsArgsDict',
    'FunctionAppSlotSiteConfigIpRestrictionArgs',
    'FunctionAppSlotSiteConfigIpRestrictionArgsDict',
    'FunctionAppSlotSiteConfigIpRestrictionHeadersArgs',
    'FunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict',
    'FunctionAppSlotSiteConfigScmIpRestrictionArgs',
    'FunctionAppSlotSiteConfigScmIpRestrictionArgsDict',
    'FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs',
    'FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict',
    'FunctionAppSlotSiteCredentialArgs',
    'FunctionAppSlotSiteCredentialArgsDict',
    'FunctionAppSourceControlArgs',
    'FunctionAppSourceControlArgsDict',
    'LinuxFunctionAppAuthSettingsArgs',
    'LinuxFunctionAppAuthSettingsArgsDict',
    'LinuxFunctionAppAuthSettingsActiveDirectoryArgs',
    'LinuxFunctionAppAuthSettingsActiveDirectoryArgsDict',
    'LinuxFunctionAppAuthSettingsFacebookArgs',
    'LinuxFunctionAppAuthSettingsFacebookArgsDict',
    'LinuxFunctionAppAuthSettingsGithubArgs',
    'LinuxFunctionAppAuthSettingsGithubArgsDict',
    'LinuxFunctionAppAuthSettingsGoogleArgs',
    'LinuxFunctionAppAuthSettingsGoogleArgsDict',
    'LinuxFunctionAppAuthSettingsMicrosoftArgs',
    'LinuxFunctionAppAuthSettingsMicrosoftArgsDict',
    'LinuxFunctionAppAuthSettingsTwitterArgs',
    'LinuxFunctionAppAuthSettingsTwitterArgsDict',
    'LinuxFunctionAppAuthSettingsV2Args',
    'LinuxFunctionAppAuthSettingsV2ArgsDict',
    'LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Args',
    'LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2ArgsDict',
    'LinuxFunctionAppAuthSettingsV2AppleV2Args',
    'LinuxFunctionAppAuthSettingsV2AppleV2ArgsDict',
    'LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Args',
    'LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2ArgsDict',
    'LinuxFunctionAppAuthSettingsV2CustomOidcV2Args',
    'LinuxFunctionAppAuthSettingsV2CustomOidcV2ArgsDict',
    'LinuxFunctionAppAuthSettingsV2FacebookV2Args',
    'LinuxFunctionAppAuthSettingsV2FacebookV2ArgsDict',
    'LinuxFunctionAppAuthSettingsV2GithubV2Args',
    'LinuxFunctionAppAuthSettingsV2GithubV2ArgsDict',
    'LinuxFunctionAppAuthSettingsV2GoogleV2Args',
    'LinuxFunctionAppAuthSettingsV2GoogleV2ArgsDict',
    'LinuxFunctionAppAuthSettingsV2LoginArgs',
    'LinuxFunctionAppAuthSettingsV2LoginArgsDict',
    'LinuxFunctionAppAuthSettingsV2MicrosoftV2Args',
    'LinuxFunctionAppAuthSettingsV2MicrosoftV2ArgsDict',
    'LinuxFunctionAppAuthSettingsV2TwitterV2Args',
    'LinuxFunctionAppAuthSettingsV2TwitterV2ArgsDict',
    'LinuxFunctionAppBackupArgs',
    'LinuxFunctionAppBackupArgsDict',
    'LinuxFunctionAppBackupScheduleArgs',
    'LinuxFunctionAppBackupScheduleArgsDict',
    'LinuxFunctionAppConnectionStringArgs',
    'LinuxFunctionAppConnectionStringArgsDict',
    'LinuxFunctionAppIdentityArgs',
    'LinuxFunctionAppIdentityArgsDict',
    'LinuxFunctionAppSiteConfigArgs',
    'LinuxFunctionAppSiteConfigArgsDict',
    'LinuxFunctionAppSiteConfigAppServiceLogsArgs',
    'LinuxFunctionAppSiteConfigAppServiceLogsArgsDict',
    'LinuxFunctionAppSiteConfigApplicationStackArgs',
    'LinuxFunctionAppSiteConfigApplicationStackArgsDict',
    'LinuxFunctionAppSiteConfigApplicationStackDockerArgs',
    'LinuxFunctionAppSiteConfigApplicationStackDockerArgsDict',
    'LinuxFunctionAppSiteConfigCorsArgs',
    'LinuxFunctionAppSiteConfigCorsArgsDict',
    'LinuxFunctionAppSiteConfigIpRestrictionArgs',
    'LinuxFunctionAppSiteConfigIpRestrictionArgsDict',
    'LinuxFunctionAppSiteConfigIpRestrictionHeadersArgs',
    'LinuxFunctionAppSiteConfigIpRestrictionHeadersArgsDict',
    'LinuxFunctionAppSiteConfigScmIpRestrictionArgs',
    'LinuxFunctionAppSiteConfigScmIpRestrictionArgsDict',
    'LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgs',
    'LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgsDict',
    'LinuxFunctionAppSiteCredentialArgs',
    'LinuxFunctionAppSiteCredentialArgsDict',
    'LinuxFunctionAppSlotAuthSettingsArgs',
    'LinuxFunctionAppSlotAuthSettingsArgsDict',
    'LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgs',
    'LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgsDict',
    'LinuxFunctionAppSlotAuthSettingsFacebookArgs',
    'LinuxFunctionAppSlotAuthSettingsFacebookArgsDict',
    'LinuxFunctionAppSlotAuthSettingsGithubArgs',
    'LinuxFunctionAppSlotAuthSettingsGithubArgsDict',
    'LinuxFunctionAppSlotAuthSettingsGoogleArgs',
    'LinuxFunctionAppSlotAuthSettingsGoogleArgsDict',
    'LinuxFunctionAppSlotAuthSettingsMicrosoftArgs',
    'LinuxFunctionAppSlotAuthSettingsMicrosoftArgsDict',
    'LinuxFunctionAppSlotAuthSettingsTwitterArgs',
    'LinuxFunctionAppSlotAuthSettingsTwitterArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2ArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2AppleV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2AppleV2ArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2ArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2FacebookV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2FacebookV2ArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2GithubV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2GithubV2ArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2GoogleV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2GoogleV2ArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2LoginArgs',
    'LinuxFunctionAppSlotAuthSettingsV2LoginArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2ArgsDict',
    'LinuxFunctionAppSlotAuthSettingsV2TwitterV2Args',
    'LinuxFunctionAppSlotAuthSettingsV2TwitterV2ArgsDict',
    'LinuxFunctionAppSlotBackupArgs',
    'LinuxFunctionAppSlotBackupArgsDict',
    'LinuxFunctionAppSlotBackupScheduleArgs',
    'LinuxFunctionAppSlotBackupScheduleArgsDict',
    'LinuxFunctionAppSlotConnectionStringArgs',
    'LinuxFunctionAppSlotConnectionStringArgsDict',
    'LinuxFunctionAppSlotIdentityArgs',
    'LinuxFunctionAppSlotIdentityArgsDict',
    'LinuxFunctionAppSlotSiteConfigArgs',
    'LinuxFunctionAppSlotSiteConfigArgsDict',
    'LinuxFunctionAppSlotSiteConfigAppServiceLogsArgs',
    'LinuxFunctionAppSlotSiteConfigAppServiceLogsArgsDict',
    'LinuxFunctionAppSlotSiteConfigApplicationStackArgs',
    'LinuxFunctionAppSlotSiteConfigApplicationStackArgsDict',
    'LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgs',
    'LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgsDict',
    'LinuxFunctionAppSlotSiteConfigCorsArgs',
    'LinuxFunctionAppSlotSiteConfigCorsArgsDict',
    'LinuxFunctionAppSlotSiteConfigIpRestrictionArgs',
    'LinuxFunctionAppSlotSiteConfigIpRestrictionArgsDict',
    'LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgs',
    'LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict',
    'LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgs',
    'LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgsDict',
    'LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs',
    'LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict',
    'LinuxFunctionAppSlotSiteCredentialArgs',
    'LinuxFunctionAppSlotSiteCredentialArgsDict',
    'LinuxFunctionAppSlotStorageAccountArgs',
    'LinuxFunctionAppSlotStorageAccountArgsDict',
    'LinuxFunctionAppStickySettingsArgs',
    'LinuxFunctionAppStickySettingsArgsDict',
    'LinuxFunctionAppStorageAccountArgs',
    'LinuxFunctionAppStorageAccountArgsDict',
    'LinuxWebAppAuthSettingsArgs',
    'LinuxWebAppAuthSettingsArgsDict',
    'LinuxWebAppAuthSettingsActiveDirectoryArgs',
    'LinuxWebAppAuthSettingsActiveDirectoryArgsDict',
    'LinuxWebAppAuthSettingsFacebookArgs',
    'LinuxWebAppAuthSettingsFacebookArgsDict',
    'LinuxWebAppAuthSettingsGithubArgs',
    'LinuxWebAppAuthSettingsGithubArgsDict',
    'LinuxWebAppAuthSettingsGoogleArgs',
    'LinuxWebAppAuthSettingsGoogleArgsDict',
    'LinuxWebAppAuthSettingsMicrosoftArgs',
    'LinuxWebAppAuthSettingsMicrosoftArgsDict',
    'LinuxWebAppAuthSettingsTwitterArgs',
    'LinuxWebAppAuthSettingsTwitterArgsDict',
    'LinuxWebAppAuthSettingsV2Args',
    'LinuxWebAppAuthSettingsV2ArgsDict',
    'LinuxWebAppAuthSettingsV2ActiveDirectoryV2Args',
    'LinuxWebAppAuthSettingsV2ActiveDirectoryV2ArgsDict',
    'LinuxWebAppAuthSettingsV2AppleV2Args',
    'LinuxWebAppAuthSettingsV2AppleV2ArgsDict',
    'LinuxWebAppAuthSettingsV2AzureStaticWebAppV2Args',
    'LinuxWebAppAuthSettingsV2AzureStaticWebAppV2ArgsDict',
    'LinuxWebAppAuthSettingsV2CustomOidcV2Args',
    'LinuxWebAppAuthSettingsV2CustomOidcV2ArgsDict',
    'LinuxWebAppAuthSettingsV2FacebookV2Args',
    'LinuxWebAppAuthSettingsV2FacebookV2ArgsDict',
    'LinuxWebAppAuthSettingsV2GithubV2Args',
    'LinuxWebAppAuthSettingsV2GithubV2ArgsDict',
    'LinuxWebAppAuthSettingsV2GoogleV2Args',
    'LinuxWebAppAuthSettingsV2GoogleV2ArgsDict',
    'LinuxWebAppAuthSettingsV2LoginArgs',
    'LinuxWebAppAuthSettingsV2LoginArgsDict',
    'LinuxWebAppAuthSettingsV2MicrosoftV2Args',
    'LinuxWebAppAuthSettingsV2MicrosoftV2ArgsDict',
    'LinuxWebAppAuthSettingsV2TwitterV2Args',
    'LinuxWebAppAuthSettingsV2TwitterV2ArgsDict',
    'LinuxWebAppBackupArgs',
    'LinuxWebAppBackupArgsDict',
    'LinuxWebAppBackupScheduleArgs',
    'LinuxWebAppBackupScheduleArgsDict',
    'LinuxWebAppConnectionStringArgs',
    'LinuxWebAppConnectionStringArgsDict',
    'LinuxWebAppIdentityArgs',
    'LinuxWebAppIdentityArgsDict',
    'LinuxWebAppLogsArgs',
    'LinuxWebAppLogsArgsDict',
    'LinuxWebAppLogsApplicationLogsArgs',
    'LinuxWebAppLogsApplicationLogsArgsDict',
    'LinuxWebAppLogsApplicationLogsAzureBlobStorageArgs',
    'LinuxWebAppLogsApplicationLogsAzureBlobStorageArgsDict',
    'LinuxWebAppLogsHttpLogsArgs',
    'LinuxWebAppLogsHttpLogsArgsDict',
    'LinuxWebAppLogsHttpLogsAzureBlobStorageArgs',
    'LinuxWebAppLogsHttpLogsAzureBlobStorageArgsDict',
    'LinuxWebAppLogsHttpLogsFileSystemArgs',
    'LinuxWebAppLogsHttpLogsFileSystemArgsDict',
    'LinuxWebAppSiteConfigArgs',
    'LinuxWebAppSiteConfigArgsDict',
    'LinuxWebAppSiteConfigApplicationStackArgs',
    'LinuxWebAppSiteConfigApplicationStackArgsDict',
    'LinuxWebAppSiteConfigAutoHealSettingArgs',
    'LinuxWebAppSiteConfigAutoHealSettingArgsDict',
    'LinuxWebAppSiteConfigAutoHealSettingActionArgs',
    'LinuxWebAppSiteConfigAutoHealSettingActionArgsDict',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerArgs',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerArgsDict',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgs',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgsDict',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgsDict',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs',
    'LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgsDict',
    'LinuxWebAppSiteConfigCorsArgs',
    'LinuxWebAppSiteConfigCorsArgsDict',
    'LinuxWebAppSiteConfigIpRestrictionArgs',
    'LinuxWebAppSiteConfigIpRestrictionArgsDict',
    'LinuxWebAppSiteConfigIpRestrictionHeadersArgs',
    'LinuxWebAppSiteConfigIpRestrictionHeadersArgsDict',
    'LinuxWebAppSiteConfigScmIpRestrictionArgs',
    'LinuxWebAppSiteConfigScmIpRestrictionArgsDict',
    'LinuxWebAppSiteConfigScmIpRestrictionHeadersArgs',
    'LinuxWebAppSiteConfigScmIpRestrictionHeadersArgsDict',
    'LinuxWebAppSiteCredentialArgs',
    'LinuxWebAppSiteCredentialArgsDict',
    'LinuxWebAppSlotAuthSettingsArgs',
    'LinuxWebAppSlotAuthSettingsArgsDict',
    'LinuxWebAppSlotAuthSettingsActiveDirectoryArgs',
    'LinuxWebAppSlotAuthSettingsActiveDirectoryArgsDict',
    'LinuxWebAppSlotAuthSettingsFacebookArgs',
    'LinuxWebAppSlotAuthSettingsFacebookArgsDict',
    'LinuxWebAppSlotAuthSettingsGithubArgs',
    'LinuxWebAppSlotAuthSettingsGithubArgsDict',
    'LinuxWebAppSlotAuthSettingsGoogleArgs',
    'LinuxWebAppSlotAuthSettingsGoogleArgsDict',
    'LinuxWebAppSlotAuthSettingsMicrosoftArgs',
    'LinuxWebAppSlotAuthSettingsMicrosoftArgsDict',
    'LinuxWebAppSlotAuthSettingsTwitterArgs',
    'LinuxWebAppSlotAuthSettingsTwitterArgsDict',
    'LinuxWebAppSlotAuthSettingsV2Args',
    'LinuxWebAppSlotAuthSettingsV2ArgsDict',
    'LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2Args',
    'LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict',
    'LinuxWebAppSlotAuthSettingsV2AppleV2Args',
    'LinuxWebAppSlotAuthSettingsV2AppleV2ArgsDict',
    'LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args',
    'LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict',
    'LinuxWebAppSlotAuthSettingsV2CustomOidcV2Args',
    'LinuxWebAppSlotAuthSettingsV2CustomOidcV2ArgsDict',
    'LinuxWebAppSlotAuthSettingsV2FacebookV2Args',
    'LinuxWebAppSlotAuthSettingsV2FacebookV2ArgsDict',
    'LinuxWebAppSlotAuthSettingsV2GithubV2Args',
    'LinuxWebAppSlotAuthSettingsV2GithubV2ArgsDict',
    'LinuxWebAppSlotAuthSettingsV2GoogleV2Args',
    'LinuxWebAppSlotAuthSettingsV2GoogleV2ArgsDict',
    'LinuxWebAppSlotAuthSettingsV2LoginArgs',
    'LinuxWebAppSlotAuthSettingsV2LoginArgsDict',
    'LinuxWebAppSlotAuthSettingsV2MicrosoftV2Args',
    'LinuxWebAppSlotAuthSettingsV2MicrosoftV2ArgsDict',
    'LinuxWebAppSlotAuthSettingsV2TwitterV2Args',
    'LinuxWebAppSlotAuthSettingsV2TwitterV2ArgsDict',
    'LinuxWebAppSlotBackupArgs',
    'LinuxWebAppSlotBackupArgsDict',
    'LinuxWebAppSlotBackupScheduleArgs',
    'LinuxWebAppSlotBackupScheduleArgsDict',
    'LinuxWebAppSlotConnectionStringArgs',
    'LinuxWebAppSlotConnectionStringArgsDict',
    'LinuxWebAppSlotIdentityArgs',
    'LinuxWebAppSlotIdentityArgsDict',
    'LinuxWebAppSlotLogsArgs',
    'LinuxWebAppSlotLogsArgsDict',
    'LinuxWebAppSlotLogsApplicationLogsArgs',
    'LinuxWebAppSlotLogsApplicationLogsArgsDict',
    'LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgs',
    'LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgsDict',
    'LinuxWebAppSlotLogsHttpLogsArgs',
    'LinuxWebAppSlotLogsHttpLogsArgsDict',
    'LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgs',
    'LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgsDict',
    'LinuxWebAppSlotLogsHttpLogsFileSystemArgs',
    'LinuxWebAppSlotLogsHttpLogsFileSystemArgsDict',
    'LinuxWebAppSlotSiteConfigArgs',
    'LinuxWebAppSlotSiteConfigArgsDict',
    'LinuxWebAppSlotSiteConfigApplicationStackArgs',
    'LinuxWebAppSlotSiteConfigApplicationStackArgsDict',
    'LinuxWebAppSlotSiteConfigAutoHealSettingArgs',
    'LinuxWebAppSlotSiteConfigAutoHealSettingArgsDict',
    'LinuxWebAppSlotSiteConfigAutoHealSettingActionArgs',
    'LinuxWebAppSlotSiteConfigAutoHealSettingActionArgsDict',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgs',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgsDict',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgsDict',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgsDict',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs',
    'LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgsDict',
    'LinuxWebAppSlotSiteConfigCorsArgs',
    'LinuxWebAppSlotSiteConfigCorsArgsDict',
    'LinuxWebAppSlotSiteConfigIpRestrictionArgs',
    'LinuxWebAppSlotSiteConfigIpRestrictionArgsDict',
    'LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgs',
    'LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgsDict',
    'LinuxWebAppSlotSiteConfigScmIpRestrictionArgs',
    'LinuxWebAppSlotSiteConfigScmIpRestrictionArgsDict',
    'LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgs',
    'LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgsDict',
    'LinuxWebAppSlotSiteCredentialArgs',
    'LinuxWebAppSlotSiteCredentialArgsDict',
    'LinuxWebAppSlotStorageAccountArgs',
    'LinuxWebAppSlotStorageAccountArgsDict',
    'LinuxWebAppStickySettingsArgs',
    'LinuxWebAppStickySettingsArgsDict',
    'LinuxWebAppStorageAccountArgs',
    'LinuxWebAppStorageAccountArgsDict',
    'PlanSkuArgs',
    'PlanSkuArgsDict',
    'SlotAuthSettingsArgs',
    'SlotAuthSettingsArgsDict',
    'SlotAuthSettingsActiveDirectoryArgs',
    'SlotAuthSettingsActiveDirectoryArgsDict',
    'SlotAuthSettingsFacebookArgs',
    'SlotAuthSettingsFacebookArgsDict',
    'SlotAuthSettingsGoogleArgs',
    'SlotAuthSettingsGoogleArgsDict',
    'SlotAuthSettingsMicrosoftArgs',
    'SlotAuthSettingsMicrosoftArgsDict',
    'SlotAuthSettingsTwitterArgs',
    'SlotAuthSettingsTwitterArgsDict',
    'SlotConnectionStringArgs',
    'SlotConnectionStringArgsDict',
    'SlotIdentityArgs',
    'SlotIdentityArgsDict',
    'SlotLogsArgs',
    'SlotLogsArgsDict',
    'SlotLogsApplicationLogsArgs',
    'SlotLogsApplicationLogsArgsDict',
    'SlotLogsApplicationLogsAzureBlobStorageArgs',
    'SlotLogsApplicationLogsAzureBlobStorageArgsDict',
    'SlotLogsHttpLogsArgs',
    'SlotLogsHttpLogsArgsDict',
    'SlotLogsHttpLogsAzureBlobStorageArgs',
    'SlotLogsHttpLogsAzureBlobStorageArgsDict',
    'SlotLogsHttpLogsFileSystemArgs',
    'SlotLogsHttpLogsFileSystemArgsDict',
    'SlotSiteConfigArgs',
    'SlotSiteConfigArgsDict',
    'SlotSiteConfigCorsArgs',
    'SlotSiteConfigCorsArgsDict',
    'SlotSiteConfigIpRestrictionArgs',
    'SlotSiteConfigIpRestrictionArgsDict',
    'SlotSiteConfigIpRestrictionHeadersArgs',
    'SlotSiteConfigIpRestrictionHeadersArgsDict',
    'SlotSiteConfigScmIpRestrictionArgs',
    'SlotSiteConfigScmIpRestrictionArgsDict',
    'SlotSiteConfigScmIpRestrictionHeadersArgs',
    'SlotSiteConfigScmIpRestrictionHeadersArgsDict',
    'SlotSiteCredentialArgs',
    'SlotSiteCredentialArgsDict',
    'SlotStorageAccountArgs',
    'SlotStorageAccountArgsDict',
    'SourceControlGithubActionConfigurationArgs',
    'SourceControlGithubActionConfigurationArgsDict',
    'SourceControlGithubActionConfigurationCodeConfigurationArgs',
    'SourceControlGithubActionConfigurationCodeConfigurationArgsDict',
    'SourceControlGithubActionConfigurationContainerConfigurationArgs',
    'SourceControlGithubActionConfigurationContainerConfigurationArgsDict',
    'SourceControlSlotGithubActionConfigurationArgs',
    'SourceControlSlotGithubActionConfigurationArgsDict',
    'SourceControlSlotGithubActionConfigurationCodeConfigurationArgs',
    'SourceControlSlotGithubActionConfigurationCodeConfigurationArgsDict',
    'SourceControlSlotGithubActionConfigurationContainerConfigurationArgs',
    'SourceControlSlotGithubActionConfigurationContainerConfigurationArgsDict',
    'StaticSiteIdentityArgs',
    'StaticSiteIdentityArgsDict',
    'StaticWebAppBasicAuthArgs',
    'StaticWebAppBasicAuthArgsDict',
    'StaticWebAppIdentityArgs',
    'StaticWebAppIdentityArgsDict',
    'WindowsFunctionAppAuthSettingsArgs',
    'WindowsFunctionAppAuthSettingsArgsDict',
    'WindowsFunctionAppAuthSettingsActiveDirectoryArgs',
    'WindowsFunctionAppAuthSettingsActiveDirectoryArgsDict',
    'WindowsFunctionAppAuthSettingsFacebookArgs',
    'WindowsFunctionAppAuthSettingsFacebookArgsDict',
    'WindowsFunctionAppAuthSettingsGithubArgs',
    'WindowsFunctionAppAuthSettingsGithubArgsDict',
    'WindowsFunctionAppAuthSettingsGoogleArgs',
    'WindowsFunctionAppAuthSettingsGoogleArgsDict',
    'WindowsFunctionAppAuthSettingsMicrosoftArgs',
    'WindowsFunctionAppAuthSettingsMicrosoftArgsDict',
    'WindowsFunctionAppAuthSettingsTwitterArgs',
    'WindowsFunctionAppAuthSettingsTwitterArgsDict',
    'WindowsFunctionAppAuthSettingsV2Args',
    'WindowsFunctionAppAuthSettingsV2ArgsDict',
    'WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Args',
    'WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2ArgsDict',
    'WindowsFunctionAppAuthSettingsV2AppleV2Args',
    'WindowsFunctionAppAuthSettingsV2AppleV2ArgsDict',
    'WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Args',
    'WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2ArgsDict',
    'WindowsFunctionAppAuthSettingsV2CustomOidcV2Args',
    'WindowsFunctionAppAuthSettingsV2CustomOidcV2ArgsDict',
    'WindowsFunctionAppAuthSettingsV2FacebookV2Args',
    'WindowsFunctionAppAuthSettingsV2FacebookV2ArgsDict',
    'WindowsFunctionAppAuthSettingsV2GithubV2Args',
    'WindowsFunctionAppAuthSettingsV2GithubV2ArgsDict',
    'WindowsFunctionAppAuthSettingsV2GoogleV2Args',
    'WindowsFunctionAppAuthSettingsV2GoogleV2ArgsDict',
    'WindowsFunctionAppAuthSettingsV2LoginArgs',
    'WindowsFunctionAppAuthSettingsV2LoginArgsDict',
    'WindowsFunctionAppAuthSettingsV2MicrosoftV2Args',
    'WindowsFunctionAppAuthSettingsV2MicrosoftV2ArgsDict',
    'WindowsFunctionAppAuthSettingsV2TwitterV2Args',
    'WindowsFunctionAppAuthSettingsV2TwitterV2ArgsDict',
    'WindowsFunctionAppBackupArgs',
    'WindowsFunctionAppBackupArgsDict',
    'WindowsFunctionAppBackupScheduleArgs',
    'WindowsFunctionAppBackupScheduleArgsDict',
    'WindowsFunctionAppConnectionStringArgs',
    'WindowsFunctionAppConnectionStringArgsDict',
    'WindowsFunctionAppIdentityArgs',
    'WindowsFunctionAppIdentityArgsDict',
    'WindowsFunctionAppSiteConfigArgs',
    'WindowsFunctionAppSiteConfigArgsDict',
    'WindowsFunctionAppSiteConfigAppServiceLogsArgs',
    'WindowsFunctionAppSiteConfigAppServiceLogsArgsDict',
    'WindowsFunctionAppSiteConfigApplicationStackArgs',
    'WindowsFunctionAppSiteConfigApplicationStackArgsDict',
    'WindowsFunctionAppSiteConfigCorsArgs',
    'WindowsFunctionAppSiteConfigCorsArgsDict',
    'WindowsFunctionAppSiteConfigIpRestrictionArgs',
    'WindowsFunctionAppSiteConfigIpRestrictionArgsDict',
    'WindowsFunctionAppSiteConfigIpRestrictionHeadersArgs',
    'WindowsFunctionAppSiteConfigIpRestrictionHeadersArgsDict',
    'WindowsFunctionAppSiteConfigScmIpRestrictionArgs',
    'WindowsFunctionAppSiteConfigScmIpRestrictionArgsDict',
    'WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgs',
    'WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgsDict',
    'WindowsFunctionAppSiteCredentialArgs',
    'WindowsFunctionAppSiteCredentialArgsDict',
    'WindowsFunctionAppSlotAuthSettingsArgs',
    'WindowsFunctionAppSlotAuthSettingsArgsDict',
    'WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgs',
    'WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgsDict',
    'WindowsFunctionAppSlotAuthSettingsFacebookArgs',
    'WindowsFunctionAppSlotAuthSettingsFacebookArgsDict',
    'WindowsFunctionAppSlotAuthSettingsGithubArgs',
    'WindowsFunctionAppSlotAuthSettingsGithubArgsDict',
    'WindowsFunctionAppSlotAuthSettingsGoogleArgs',
    'WindowsFunctionAppSlotAuthSettingsGoogleArgsDict',
    'WindowsFunctionAppSlotAuthSettingsMicrosoftArgs',
    'WindowsFunctionAppSlotAuthSettingsMicrosoftArgsDict',
    'WindowsFunctionAppSlotAuthSettingsTwitterArgs',
    'WindowsFunctionAppSlotAuthSettingsTwitterArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2ArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2AppleV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2AppleV2ArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2ArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2FacebookV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2FacebookV2ArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2GithubV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2GithubV2ArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2GoogleV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2GoogleV2ArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2LoginArgs',
    'WindowsFunctionAppSlotAuthSettingsV2LoginArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2ArgsDict',
    'WindowsFunctionAppSlotAuthSettingsV2TwitterV2Args',
    'WindowsFunctionAppSlotAuthSettingsV2TwitterV2ArgsDict',
    'WindowsFunctionAppSlotBackupArgs',
    'WindowsFunctionAppSlotBackupArgsDict',
    'WindowsFunctionAppSlotBackupScheduleArgs',
    'WindowsFunctionAppSlotBackupScheduleArgsDict',
    'WindowsFunctionAppSlotConnectionStringArgs',
    'WindowsFunctionAppSlotConnectionStringArgsDict',
    'WindowsFunctionAppSlotIdentityArgs',
    'WindowsFunctionAppSlotIdentityArgsDict',
    'WindowsFunctionAppSlotSiteConfigArgs',
    'WindowsFunctionAppSlotSiteConfigArgsDict',
    'WindowsFunctionAppSlotSiteConfigAppServiceLogsArgs',
    'WindowsFunctionAppSlotSiteConfigAppServiceLogsArgsDict',
    'WindowsFunctionAppSlotSiteConfigApplicationStackArgs',
    'WindowsFunctionAppSlotSiteConfigApplicationStackArgsDict',
    'WindowsFunctionAppSlotSiteConfigCorsArgs',
    'WindowsFunctionAppSlotSiteConfigCorsArgsDict',
    'WindowsFunctionAppSlotSiteConfigIpRestrictionArgs',
    'WindowsFunctionAppSlotSiteConfigIpRestrictionArgsDict',
    'WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgs',
    'WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict',
    'WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgs',
    'WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgsDict',
    'WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs',
    'WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict',
    'WindowsFunctionAppSlotSiteCredentialArgs',
    'WindowsFunctionAppSlotSiteCredentialArgsDict',
    'WindowsFunctionAppSlotStorageAccountArgs',
    'WindowsFunctionAppSlotStorageAccountArgsDict',
    'WindowsFunctionAppStickySettingsArgs',
    'WindowsFunctionAppStickySettingsArgsDict',
    'WindowsFunctionAppStorageAccountArgs',
    'WindowsFunctionAppStorageAccountArgsDict',
    'WindowsWebAppAuthSettingsArgs',
    'WindowsWebAppAuthSettingsArgsDict',
    'WindowsWebAppAuthSettingsActiveDirectoryArgs',
    'WindowsWebAppAuthSettingsActiveDirectoryArgsDict',
    'WindowsWebAppAuthSettingsFacebookArgs',
    'WindowsWebAppAuthSettingsFacebookArgsDict',
    'WindowsWebAppAuthSettingsGithubArgs',
    'WindowsWebAppAuthSettingsGithubArgsDict',
    'WindowsWebAppAuthSettingsGoogleArgs',
    'WindowsWebAppAuthSettingsGoogleArgsDict',
    'WindowsWebAppAuthSettingsMicrosoftArgs',
    'WindowsWebAppAuthSettingsMicrosoftArgsDict',
    'WindowsWebAppAuthSettingsTwitterArgs',
    'WindowsWebAppAuthSettingsTwitterArgsDict',
    'WindowsWebAppAuthSettingsV2Args',
    'WindowsWebAppAuthSettingsV2ArgsDict',
    'WindowsWebAppAuthSettingsV2ActiveDirectoryV2Args',
    'WindowsWebAppAuthSettingsV2ActiveDirectoryV2ArgsDict',
    'WindowsWebAppAuthSettingsV2AppleV2Args',
    'WindowsWebAppAuthSettingsV2AppleV2ArgsDict',
    'WindowsWebAppAuthSettingsV2AzureStaticWebAppV2Args',
    'WindowsWebAppAuthSettingsV2AzureStaticWebAppV2ArgsDict',
    'WindowsWebAppAuthSettingsV2CustomOidcV2Args',
    'WindowsWebAppAuthSettingsV2CustomOidcV2ArgsDict',
    'WindowsWebAppAuthSettingsV2FacebookV2Args',
    'WindowsWebAppAuthSettingsV2FacebookV2ArgsDict',
    'WindowsWebAppAuthSettingsV2GithubV2Args',
    'WindowsWebAppAuthSettingsV2GithubV2ArgsDict',
    'WindowsWebAppAuthSettingsV2GoogleV2Args',
    'WindowsWebAppAuthSettingsV2GoogleV2ArgsDict',
    'WindowsWebAppAuthSettingsV2LoginArgs',
    'WindowsWebAppAuthSettingsV2LoginArgsDict',
    'WindowsWebAppAuthSettingsV2MicrosoftV2Args',
    'WindowsWebAppAuthSettingsV2MicrosoftV2ArgsDict',
    'WindowsWebAppAuthSettingsV2TwitterV2Args',
    'WindowsWebAppAuthSettingsV2TwitterV2ArgsDict',
    'WindowsWebAppBackupArgs',
    'WindowsWebAppBackupArgsDict',
    'WindowsWebAppBackupScheduleArgs',
    'WindowsWebAppBackupScheduleArgsDict',
    'WindowsWebAppConnectionStringArgs',
    'WindowsWebAppConnectionStringArgsDict',
    'WindowsWebAppIdentityArgs',
    'WindowsWebAppIdentityArgsDict',
    'WindowsWebAppLogsArgs',
    'WindowsWebAppLogsArgsDict',
    'WindowsWebAppLogsApplicationLogsArgs',
    'WindowsWebAppLogsApplicationLogsArgsDict',
    'WindowsWebAppLogsApplicationLogsAzureBlobStorageArgs',
    'WindowsWebAppLogsApplicationLogsAzureBlobStorageArgsDict',
    'WindowsWebAppLogsHttpLogsArgs',
    'WindowsWebAppLogsHttpLogsArgsDict',
    'WindowsWebAppLogsHttpLogsAzureBlobStorageArgs',
    'WindowsWebAppLogsHttpLogsAzureBlobStorageArgsDict',
    'WindowsWebAppLogsHttpLogsFileSystemArgs',
    'WindowsWebAppLogsHttpLogsFileSystemArgsDict',
    'WindowsWebAppSiteConfigArgs',
    'WindowsWebAppSiteConfigArgsDict',
    'WindowsWebAppSiteConfigApplicationStackArgs',
    'WindowsWebAppSiteConfigApplicationStackArgsDict',
    'WindowsWebAppSiteConfigAutoHealSettingArgs',
    'WindowsWebAppSiteConfigAutoHealSettingArgsDict',
    'WindowsWebAppSiteConfigAutoHealSettingActionArgs',
    'WindowsWebAppSiteConfigAutoHealSettingActionArgsDict',
    'WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs',
    'WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgsDict',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerArgs',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerArgsDict',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgs',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgsDict',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgsDict',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs',
    'WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgsDict',
    'WindowsWebAppSiteConfigCorsArgs',
    'WindowsWebAppSiteConfigCorsArgsDict',
    'WindowsWebAppSiteConfigHandlerMappingArgs',
    'WindowsWebAppSiteConfigHandlerMappingArgsDict',
    'WindowsWebAppSiteConfigIpRestrictionArgs',
    'WindowsWebAppSiteConfigIpRestrictionArgsDict',
    'WindowsWebAppSiteConfigIpRestrictionHeadersArgs',
    'WindowsWebAppSiteConfigIpRestrictionHeadersArgsDict',
    'WindowsWebAppSiteConfigScmIpRestrictionArgs',
    'WindowsWebAppSiteConfigScmIpRestrictionArgsDict',
    'WindowsWebAppSiteConfigScmIpRestrictionHeadersArgs',
    'WindowsWebAppSiteConfigScmIpRestrictionHeadersArgsDict',
    'WindowsWebAppSiteConfigVirtualApplicationArgs',
    'WindowsWebAppSiteConfigVirtualApplicationArgsDict',
    'WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs',
    'WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgsDict',
    'WindowsWebAppSiteCredentialArgs',
    'WindowsWebAppSiteCredentialArgsDict',
    'WindowsWebAppSlotAuthSettingsArgs',
    'WindowsWebAppSlotAuthSettingsArgsDict',
    'WindowsWebAppSlotAuthSettingsActiveDirectoryArgs',
    'WindowsWebAppSlotAuthSettingsActiveDirectoryArgsDict',
    'WindowsWebAppSlotAuthSettingsFacebookArgs',
    'WindowsWebAppSlotAuthSettingsFacebookArgsDict',
    'WindowsWebAppSlotAuthSettingsGithubArgs',
    'WindowsWebAppSlotAuthSettingsGithubArgsDict',
    'WindowsWebAppSlotAuthSettingsGoogleArgs',
    'WindowsWebAppSlotAuthSettingsGoogleArgsDict',
    'WindowsWebAppSlotAuthSettingsMicrosoftArgs',
    'WindowsWebAppSlotAuthSettingsMicrosoftArgsDict',
    'WindowsWebAppSlotAuthSettingsTwitterArgs',
    'WindowsWebAppSlotAuthSettingsTwitterArgsDict',
    'WindowsWebAppSlotAuthSettingsV2Args',
    'WindowsWebAppSlotAuthSettingsV2ArgsDict',
    'WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2Args',
    'WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict',
    'WindowsWebAppSlotAuthSettingsV2AppleV2Args',
    'WindowsWebAppSlotAuthSettingsV2AppleV2ArgsDict',
    'WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args',
    'WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict',
    'WindowsWebAppSlotAuthSettingsV2CustomOidcV2Args',
    'WindowsWebAppSlotAuthSettingsV2CustomOidcV2ArgsDict',
    'WindowsWebAppSlotAuthSettingsV2FacebookV2Args',
    'WindowsWebAppSlotAuthSettingsV2FacebookV2ArgsDict',
    'WindowsWebAppSlotAuthSettingsV2GithubV2Args',
    'WindowsWebAppSlotAuthSettingsV2GithubV2ArgsDict',
    'WindowsWebAppSlotAuthSettingsV2GoogleV2Args',
    'WindowsWebAppSlotAuthSettingsV2GoogleV2ArgsDict',
    'WindowsWebAppSlotAuthSettingsV2LoginArgs',
    'WindowsWebAppSlotAuthSettingsV2LoginArgsDict',
    'WindowsWebAppSlotAuthSettingsV2MicrosoftV2Args',
    'WindowsWebAppSlotAuthSettingsV2MicrosoftV2ArgsDict',
    'WindowsWebAppSlotAuthSettingsV2TwitterV2Args',
    'WindowsWebAppSlotAuthSettingsV2TwitterV2ArgsDict',
    'WindowsWebAppSlotBackupArgs',
    'WindowsWebAppSlotBackupArgsDict',
    'WindowsWebAppSlotBackupScheduleArgs',
    'WindowsWebAppSlotBackupScheduleArgsDict',
    'WindowsWebAppSlotConnectionStringArgs',
    'WindowsWebAppSlotConnectionStringArgsDict',
    'WindowsWebAppSlotIdentityArgs',
    'WindowsWebAppSlotIdentityArgsDict',
    'WindowsWebAppSlotLogsArgs',
    'WindowsWebAppSlotLogsArgsDict',
    'WindowsWebAppSlotLogsApplicationLogsArgs',
    'WindowsWebAppSlotLogsApplicationLogsArgsDict',
    'WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgs',
    'WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgsDict',
    'WindowsWebAppSlotLogsHttpLogsArgs',
    'WindowsWebAppSlotLogsHttpLogsArgsDict',
    'WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgs',
    'WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgsDict',
    'WindowsWebAppSlotLogsHttpLogsFileSystemArgs',
    'WindowsWebAppSlotLogsHttpLogsFileSystemArgsDict',
    'WindowsWebAppSlotSiteConfigArgs',
    'WindowsWebAppSlotSiteConfigArgsDict',
    'WindowsWebAppSlotSiteConfigApplicationStackArgs',
    'WindowsWebAppSlotSiteConfigApplicationStackArgsDict',
    'WindowsWebAppSlotSiteConfigAutoHealSettingArgs',
    'WindowsWebAppSlotSiteConfigAutoHealSettingArgsDict',
    'WindowsWebAppSlotSiteConfigAutoHealSettingActionArgs',
    'WindowsWebAppSlotSiteConfigAutoHealSettingActionArgsDict',
    'WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgs',
    'WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgsDict',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgs',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgsDict',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgsDict',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgsDict',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs',
    'WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgsDict',
    'WindowsWebAppSlotSiteConfigCorsArgs',
    'WindowsWebAppSlotSiteConfigCorsArgsDict',
    'WindowsWebAppSlotSiteConfigHandlerMappingArgs',
    'WindowsWebAppSlotSiteConfigHandlerMappingArgsDict',
    'WindowsWebAppSlotSiteConfigIpRestrictionArgs',
    'WindowsWebAppSlotSiteConfigIpRestrictionArgsDict',
    'WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgs',
    'WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgsDict',
    'WindowsWebAppSlotSiteConfigScmIpRestrictionArgs',
    'WindowsWebAppSlotSiteConfigScmIpRestrictionArgsDict',
    'WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgs',
    'WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgsDict',
    'WindowsWebAppSlotSiteConfigVirtualApplicationArgs',
    'WindowsWebAppSlotSiteConfigVirtualApplicationArgsDict',
    'WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgs',
    'WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgsDict',
    'WindowsWebAppSlotSiteCredentialArgs',
    'WindowsWebAppSlotSiteCredentialArgsDict',
    'WindowsWebAppSlotStorageAccountArgs',
    'WindowsWebAppSlotStorageAccountArgsDict',
    'WindowsWebAppStickySettingsArgs',
    'WindowsWebAppStickySettingsArgsDict',
    'WindowsWebAppStorageAccountArgs',
    'WindowsWebAppStorageAccountArgsDict',
]

MYPY = False

if not MYPY:
    class AppConnectionAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        """
        certificate: NotRequired[pulumi.Input[str]]
        """
        Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        """
        subscription_id: NotRequired[pulumi.Input[str]]
        """
        Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
elif False:
    AppConnectionAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppConnectionAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 certificate: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] certificate: Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        :param pulumi.Input[str] client_id: Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        :param pulumi.Input[str] name: Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        :param pulumi.Input[str] principal_id: Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        :param pulumi.Input[str] secret: Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        :param pulumi.Input[str] subscription_id: Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)


if not MYPY:
    class AppConnectionSecretStoreArgsDict(TypedDict):
        key_vault_id: pulumi.Input[str]
        """
        The key vault id to store secret.
        """
elif False:
    AppConnectionSecretStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppConnectionSecretStoreArgs:
    def __init__(__self__, *,
                 key_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key_vault_id: The key vault id to store secret.
        """
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The key vault id to store secret.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)


if not MYPY:
    class AppServiceAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Is Authentication enabled?
        """
        active_directory: NotRequired[pulumi.Input['AppServiceAuthSettingsActiveDirectoryArgsDict']]
        """
        A `active_directory` block as defined below.
        """
        additional_login_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        facebook: NotRequired[pulumi.Input['AppServiceAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        google: NotRequired[pulumi.Input['AppServiceAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['AppServiceAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The runtime version of the Authentication/Authorization module.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['AppServiceAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
elif False:
    AppServiceAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['AppServiceAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['AppServiceAuthSettingsFacebookArgs']] = None,
                 google: Optional[pulumi.Input['AppServiceAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['AppServiceAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['AppServiceAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Is Authentication enabled?
        :param pulumi.Input['AppServiceAuthSettingsActiveDirectoryArgs'] active_directory: A `active_directory` block as defined below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_params: Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param pulumi.Input[str] default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
               
               > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        :param pulumi.Input['AppServiceAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['AppServiceAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['AppServiceAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The runtime version of the Authentication/Authorization module.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        :param pulumi.Input[bool] token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        :param pulumi.Input['AppServiceAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['AppServiceAuthSettingsActiveDirectoryArgs']]:
        """
        A `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['AppServiceAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @additional_login_params.setter
    def additional_login_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_params", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['AppServiceAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['AppServiceAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['AppServiceAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['AppServiceAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['AppServiceAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['AppServiceAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['AppServiceAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['AppServiceAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class AppServiceAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
elif False:
    AppServiceAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param pulumi.Input[str] client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


if not MYPY:
    class AppServiceAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login
        """
        app_secret: pulumi.Input[str]
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
elif False:
    AppServiceAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> pulumi.Input[str]:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class AppServiceAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: pulumi.Input[str]
        """
        The client secret associated with the Google web application.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
elif False:
    AppServiceAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class AppServiceAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: pulumi.Input[str]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
elif False:
    AppServiceAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class AppServiceAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The consumer key of the Twitter app used for login
        """
        consumer_secret: pulumi.Input[str]
        """
        The consumer secret of the Twitter app used for login.
        """
elif False:
    AppServiceAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The consumer key of the Twitter app used for login
        :param pulumi.Input[str] consumer_secret: The consumer secret of the Twitter app used for login.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The consumer key of the Twitter app used for login
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> pulumi.Input[str]:
        """
        The consumer secret of the Twitter app used for login.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret", value)


if not MYPY:
    class AppServiceBackupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Specifies the name for this Backup.
        """
        schedule: pulumi.Input['AppServiceBackupScheduleArgsDict']
        """
        A `schedule` block as defined below.
        """
        storage_account_url: pulumi.Input[str]
        """
        The SAS URL to a Storage Container where Backups should be saved.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Is this Backup enabled? Defaults to `true`.
        """
elif False:
    AppServiceBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceBackupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['AppServiceBackupScheduleArgs'],
                 storage_account_url: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: Specifies the name for this Backup.
        :param pulumi.Input['AppServiceBackupScheduleArgs'] schedule: A `schedule` block as defined below.
        :param pulumi.Input[str] storage_account_url: The SAS URL to a Storage Container where Backups should be saved.
        :param pulumi.Input[bool] enabled: Is this Backup enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name for this Backup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['AppServiceBackupScheduleArgs']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['AppServiceBackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> pulumi.Input[str]:
        """
        The SAS URL to a Storage Container where Backups should be saved.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this Backup enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AppServiceBackupScheduleArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Sets how often the backup should be executed.
        """
        frequency_unit: pulumi.Input[str]
        """
        Sets the unit of time for how often the backup should be executed. Possible values are `Day` or `Hour`.
        """
        keep_at_least_one_backup: NotRequired[pulumi.Input[bool]]
        """
        Should at least one backup always be kept in the Storage Account by the Retention Policy, regardless of how old it is?
        """
        retention_period_in_days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days after which Backups should be deleted. Defaults to `30`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Sets when the schedule should start working.
        """
elif False:
    AppServiceBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceBackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_unit: pulumi.Input[str],
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 retention_period_in_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Sets how often the backup should be executed.
        :param pulumi.Input[str] frequency_unit: Sets the unit of time for how often the backup should be executed. Possible values are `Day` or `Hour`.
        :param pulumi.Input[bool] keep_at_least_one_backup: Should at least one backup always be kept in the Storage Account by the Retention Policy, regardless of how old it is?
        :param pulumi.Input[int] retention_period_in_days: Specifies the number of days after which Backups should be deleted. Defaults to `30`.
        :param pulumi.Input[str] start_time: Sets when the schedule should start working.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if retention_period_in_days is not None:
            pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Sets how often the backup should be executed.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input[str]:
        """
        Sets the unit of time for how often the backup should be executed. Possible values are `Day` or `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Should at least one backup always be kept in the Storage Account by the Retention Policy, regardless of how old it is?
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after which Backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_in_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Sets when the schedule should start working.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class AppServiceConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Connection String.
        """
        type: pulumi.Input[str]
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The value for the Connection String.
        """
elif False:
    AppServiceConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Connection String.
        :param pulumi.Input[str] type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        :param pulumi.Input[str] value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppServiceIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
elif False:
    AppServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        :param pulumi.Input[str] tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class AppServiceLogsArgsDict(TypedDict):
        application_logs: NotRequired[pulumi.Input['AppServiceLogsApplicationLogsArgsDict']]
        """
        An `application_logs` block as defined below.
        """
        detailed_error_messages_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should `Detailed error messages` be enabled on this App Service? Defaults to `false`.
        """
        failed_request_tracing_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should `Failed request tracing` be enabled on this App Service? Defaults to `false`.
        """
        http_logs: NotRequired[pulumi.Input['AppServiceLogsHttpLogsArgsDict']]
        """
        An `http_logs` block as defined below.
        """
elif False:
    AppServiceLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceLogsArgs:
    def __init__(__self__, *,
                 application_logs: Optional[pulumi.Input['AppServiceLogsApplicationLogsArgs']] = None,
                 detailed_error_messages_enabled: Optional[pulumi.Input[bool]] = None,
                 failed_request_tracing_enabled: Optional[pulumi.Input[bool]] = None,
                 http_logs: Optional[pulumi.Input['AppServiceLogsHttpLogsArgs']] = None):
        """
        :param pulumi.Input['AppServiceLogsApplicationLogsArgs'] application_logs: An `application_logs` block as defined below.
        :param pulumi.Input[bool] detailed_error_messages_enabled: Should `Detailed error messages` be enabled on this App Service? Defaults to `false`.
        :param pulumi.Input[bool] failed_request_tracing_enabled: Should `Failed request tracing` be enabled on this App Service? Defaults to `false`.
        :param pulumi.Input['AppServiceLogsHttpLogsArgs'] http_logs: An `http_logs` block as defined below.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages_enabled is not None:
            pulumi.set(__self__, "detailed_error_messages_enabled", detailed_error_messages_enabled)
        if failed_request_tracing_enabled is not None:
            pulumi.set(__self__, "failed_request_tracing_enabled", failed_request_tracing_enabled)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional[pulumi.Input['AppServiceLogsApplicationLogsArgs']]:
        """
        An `application_logs` block as defined below.
        """
        return pulumi.get(self, "application_logs")

    @application_logs.setter
    def application_logs(self, value: Optional[pulumi.Input['AppServiceLogsApplicationLogsArgs']]):
        pulumi.set(self, "application_logs", value)

    @property
    @pulumi.getter(name="detailedErrorMessagesEnabled")
    def detailed_error_messages_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should `Detailed error messages` be enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "detailed_error_messages_enabled")

    @detailed_error_messages_enabled.setter
    def detailed_error_messages_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_messages_enabled", value)

    @property
    @pulumi.getter(name="failedRequestTracingEnabled")
    def failed_request_tracing_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should `Failed request tracing` be enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "failed_request_tracing_enabled")

    @failed_request_tracing_enabled.setter
    def failed_request_tracing_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failed_request_tracing_enabled", value)

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional[pulumi.Input['AppServiceLogsHttpLogsArgs']]:
        """
        An `http_logs` block as defined below.
        """
        return pulumi.get(self, "http_logs")

    @http_logs.setter
    def http_logs(self, value: Optional[pulumi.Input['AppServiceLogsHttpLogsArgs']]):
        pulumi.set(self, "http_logs", value)


if not MYPY:
    class AppServiceLogsApplicationLogsArgsDict(TypedDict):
        azure_blob_storage: NotRequired[pulumi.Input['AppServiceLogsApplicationLogsAzureBlobStorageArgsDict']]
        """
        An `azure_blob_storage` block as defined below.
        """
        file_system_level: NotRequired[pulumi.Input[str]]
        """
        Log level for filesystem based logging. Supported values are `Error`, `Information`, `Verbose`, `Warning` and `Off`. Defaults to `Off`.
        """
elif False:
    AppServiceLogsApplicationLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceLogsApplicationLogsArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['AppServiceLogsApplicationLogsAzureBlobStorageArgs']] = None,
                 file_system_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AppServiceLogsApplicationLogsAzureBlobStorageArgs'] azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param pulumi.Input[str] file_system_level: Log level for filesystem based logging. Supported values are `Error`, `Information`, `Verbose`, `Warning` and `Off`. Defaults to `Off`.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system_level is not None:
            pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['AppServiceLogsApplicationLogsAzureBlobStorageArgs']]:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['AppServiceLogsApplicationLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> Optional[pulumi.Input[str]]:
        """
        Log level for filesystem based logging. Supported values are `Error`, `Information`, `Verbose`, `Warning` and `Off`. Defaults to `Off`.
        """
        return pulumi.get(self, "file_system_level")

    @file_system_level.setter
    def file_system_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_system_level", value)


if not MYPY:
    class AppServiceLogsApplicationLogsAzureBlobStorageArgsDict(TypedDict):
        level: pulumi.Input[str]
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        retention_in_days: pulumi.Input[int]
        """
        The number of days to retain logs for.
        """
        sas_url: pulumi.Input[str]
        """
        The URL to the storage container with a shared access signature token appended.
        """
elif False:
    AppServiceLogsApplicationLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceLogsApplicationLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[str],
                 retention_in_days: pulumi.Input[int],
                 sas_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param pulumi.Input[int] retention_in_days: The number of days to retain logs for.
        :param pulumi.Input[str] sas_url: The URL to the storage container with a shared access signature token appended.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input[str]:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[str]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        The URL to the storage container with a shared access signature token appended.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class AppServiceLogsHttpLogsArgsDict(TypedDict):
        azure_blob_storage: NotRequired[pulumi.Input['AppServiceLogsHttpLogsAzureBlobStorageArgsDict']]
        """
        An `azure_blob_storage` block as defined below.
        """
        file_system: NotRequired[pulumi.Input['AppServiceLogsHttpLogsFileSystemArgsDict']]
        """
        A `file_system` block as defined below.
        """
elif False:
    AppServiceLogsHttpLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceLogsHttpLogsArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['AppServiceLogsHttpLogsAzureBlobStorageArgs']] = None,
                 file_system: Optional[pulumi.Input['AppServiceLogsHttpLogsFileSystemArgs']] = None):
        """
        :param pulumi.Input['AppServiceLogsHttpLogsAzureBlobStorageArgs'] azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param pulumi.Input['AppServiceLogsHttpLogsFileSystemArgs'] file_system: A `file_system` block as defined below.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['AppServiceLogsHttpLogsAzureBlobStorageArgs']]:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['AppServiceLogsHttpLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['AppServiceLogsHttpLogsFileSystemArgs']]:
        """
        A `file_system` block as defined below.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['AppServiceLogsHttpLogsFileSystemArgs']]):
        pulumi.set(self, "file_system", value)


if not MYPY:
    class AppServiceLogsHttpLogsAzureBlobStorageArgsDict(TypedDict):
        retention_in_days: pulumi.Input[int]
        """
        The number of days to retain logs for.
        """
        sas_url: pulumi.Input[str]
        """
        The URL to the storage container with a shared access signature token appended.
        """
elif False:
    AppServiceLogsHttpLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceLogsHttpLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 retention_in_days: pulumi.Input[int],
                 sas_url: pulumi.Input[str]):
        """
        :param pulumi.Input[int] retention_in_days: The number of days to retain logs for.
        :param pulumi.Input[str] sas_url: The URL to the storage container with a shared access signature token appended.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        The URL to the storage container with a shared access signature token appended.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class AppServiceLogsHttpLogsFileSystemArgsDict(TypedDict):
        retention_in_days: pulumi.Input[int]
        """
        The number of days to retain logs for.
        """
        retention_in_mb: pulumi.Input[int]
        """
        The maximum size in megabytes that HTTP log files can use before being removed.
        """
elif False:
    AppServiceLogsHttpLogsFileSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceLogsHttpLogsFileSystemArgs:
    def __init__(__self__, *,
                 retention_in_days: pulumi.Input[int],
                 retention_in_mb: pulumi.Input[int]):
        """
        :param pulumi.Input[int] retention_in_days: The number of days to retain logs for.
        :param pulumi.Input[int] retention_in_mb: The maximum size in megabytes that HTTP log files can use before being removed.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> pulumi.Input[int]:
        """
        The maximum size in megabytes that HTTP log files can use before being removed.
        """
        return pulumi.get(self, "retention_in_mb")

    @retention_in_mb.setter
    def retention_in_mb(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_mb", value)


if not MYPY:
    class AppServiceSiteConfigArgsDict(TypedDict):
        acr_use_managed_identity_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are Managed Identity Credentials used for Azure Container Registry pull
        """
        acr_user_managed_identity_client_id: NotRequired[pulumi.Input[str]]
        """
        If using User Managed Identity, the User Managed Identity Client Id

        > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        """
        always_on: NotRequired[pulumi.Input[bool]]
        """
        Should the app be loaded at all times? Defaults to `false`.

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        """
        auto_swap_slot_name: NotRequired[pulumi.Input[str]]
        """
        The name of the slot to automatically swap to during deployment
        """
        cors: NotRequired[pulumi.Input['AppServiceSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined below.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        dotnet_framework_version: NotRequired[pulumi.Input[str]]
        """
        The version of the .NET framework's CLR used in this App Service. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        """
        ftps_state: NotRequired[pulumi.Input[str]]
        """
        State of FTP / FTPS service for this App Service. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The health check path to be pinged by App Service. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is HTTP2 Enabled on this App Service? Defaults to `false`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigIpRestrictionArgsDict']]]]
        """
        A list of objects representing ip restrictions as defined below.

        > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        """
        java_container: NotRequired[pulumi.Input[str]]
        """
        The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        """
        java_container_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8` and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        """
        linux_fx_version: NotRequired[pulumi.Input[str]]
        """
        Linux App Framework and version for the App Service. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).

        > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        """
        local_mysql_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.

        > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        """
        min_tls_version: NotRequired[pulumi.Input[str]]
        """
        The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        """
        number_of_workers: NotRequired[pulumi.Input[int]]
        """
        The scaled number of workers (for per site scaling) of this App Service. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        """
        php_version: NotRequired[pulumi.Input[str]]
        """
        The version of PHP to use in this App Service. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3` and `7.4`.
        """
        python_version: NotRequired[pulumi.Input[str]]
        """
        The version of Python to use in this App Service. Possible values are `2.7` and `3.4`.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Remote Debugging Enabled? Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017`, `VS2019`, `VS2022`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigScmIpRestrictionArgsDict']]]]
        """
        A list of `scm_ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        """
        The type of Source Control enabled for this App Service. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        """
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        IP security restrictions for scm to use main. Defaults to `false`. 

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        use32_bit_worker_process: NotRequired[pulumi.Input[bool]]
        """
        Should the App Service run in 32 bit mode, rather than 64 bit mode?

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should WebSockets be enabled?
        """
        windows_fx_version: NotRequired[pulumi.Input[str]]
        """
        The Windows Docker container image (`DOCKER|<user/image:tag>`)
        """
elif False:
    AppServiceSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceSiteConfigArgs:
    def __init__(__self__, *,
                 acr_use_managed_identity_credentials: Optional[pulumi.Input[bool]] = None,
                 acr_user_managed_identity_client_id: Optional[pulumi.Input[str]] = None,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
                 cors: Optional[pulumi.Input['AppServiceSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dotnet_framework_version: Optional[pulumi.Input[str]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigIpRestrictionArgs']]]] = None,
                 java_container: Optional[pulumi.Input[str]] = None,
                 java_container_version: Optional[pulumi.Input[str]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 local_mysql_enabled: Optional[pulumi.Input[bool]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 number_of_workers: Optional[pulumi.Input[int]] = None,
                 php_version: Optional[pulumi.Input[str]] = None,
                 python_version: Optional[pulumi.Input[str]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker_process: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 windows_fx_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] acr_use_managed_identity_credentials: Are Managed Identity Credentials used for Azure Container Registry pull
        :param pulumi.Input[str] acr_user_managed_identity_client_id: If using User Managed Identity, the User Managed Identity Client Id
               
               > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        :param pulumi.Input[bool] always_on: Should the app be loaded at all times? Defaults to `false`.
               
               > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        :param pulumi.Input[str] app_command_line: App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        :param pulumi.Input[str] auto_swap_slot_name: The name of the slot to automatically swap to during deployment
        :param pulumi.Input['AppServiceSiteConfigCorsArgs'] cors: A `cors` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: The ordering of default documents to load, if an address isn't specified.
        :param pulumi.Input[str] dotnet_framework_version: The version of the .NET framework's CLR used in this App Service. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        :param pulumi.Input[str] ftps_state: State of FTP / FTPS service for this App Service. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        :param pulumi.Input[str] health_check_path: The health check path to be pinged by App Service. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        :param pulumi.Input[bool] http2_enabled: Is HTTP2 Enabled on this App Service? Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigIpRestrictionArgs']]] ip_restrictions: A list of objects representing ip restrictions as defined below.
               
               > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        :param pulumi.Input[str] java_container: The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        :param pulumi.Input[str] java_container_version: The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        :param pulumi.Input[str] java_version: The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8` and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        :param pulumi.Input[str] linux_fx_version: Linux App Framework and version for the App Service. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
               
               > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        :param pulumi.Input[bool] local_mysql_enabled: Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
               
               > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        :param pulumi.Input[str] managed_pipeline_mode: The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] min_tls_version: The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        :param pulumi.Input[int] number_of_workers: The scaled number of workers (for per site scaling) of this App Service. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        :param pulumi.Input[str] php_version: The version of PHP to use in this App Service. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3` and `7.4`.
        :param pulumi.Input[str] python_version: The version of Python to use in this App Service. Possible values are `2.7` and `3.4`.
        :param pulumi.Input[bool] remote_debugging_enabled: Is Remote Debugging Enabled? Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017`, `VS2019`, `VS2022`.
        :param pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: A list of `scm_ip_restriction` objects representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        :param pulumi.Input[str] scm_type: The type of Source Control enabled for this App Service. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        :param pulumi.Input[bool] scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to `false`. 
               
               > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        :param pulumi.Input[bool] use32_bit_worker_process: Should the App Service run in 32 bit mode, rather than 64 bit mode?
               
               > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        :param pulumi.Input[bool] websockets_enabled: Should WebSockets be enabled?
        :param pulumi.Input[str] windows_fx_version: The Windows Docker container image (`DOCKER|<user/image:tag>`)
        """
        if acr_use_managed_identity_credentials is not None:
            pulumi.set(__self__, "acr_use_managed_identity_credentials", acr_use_managed_identity_credentials)
        if acr_user_managed_identity_client_id is not None:
            pulumi.set(__self__, "acr_user_managed_identity_client_id", acr_user_managed_identity_client_id)
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCredentials")
    def acr_use_managed_identity_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are Managed Identity Credentials used for Azure Container Registry pull
        """
        return pulumi.get(self, "acr_use_managed_identity_credentials")

    @acr_use_managed_identity_credentials.setter
    def acr_use_managed_identity_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "acr_use_managed_identity_credentials", value)

    @property
    @pulumi.getter(name="acrUserManagedIdentityClientId")
    def acr_user_managed_identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        If using User Managed Identity, the User Managed Identity Client Id

        > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        """
        return pulumi.get(self, "acr_user_managed_identity_client_id")

    @acr_user_managed_identity_client_id.setter
    def acr_user_managed_identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acr_user_managed_identity_client_id", value)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the app be loaded at all times? Defaults to `false`.

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the slot to automatically swap to during deployment
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['AppServiceSiteConfigCorsArgs']]:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['AppServiceSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the .NET framework's CLR used in this App Service. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @dotnet_framework_version.setter
    def dotnet_framework_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_framework_version", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        """
        State of FTP / FTPS service for this App Service. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The health check path to be pinged by App Service. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is HTTP2 Enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigIpRestrictionArgs']]]]:
        """
        A list of objects representing ip restrictions as defined below.

        > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[pulumi.Input[str]]:
        """
        The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        """
        return pulumi.get(self, "java_container")

    @java_container.setter
    def java_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container", value)

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        """
        return pulumi.get(self, "java_container_version")

    @java_container_version.setter
    def java_container_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8` and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        Linux App Framework and version for the App Service. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).

        > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        """
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.

        > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @local_mysql_enabled.setter
    def local_mysql_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local_mysql_enabled", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[pulumi.Input[int]]:
        """
        The scaled number of workers (for per site scaling) of this App Service. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        """
        return pulumi.get(self, "number_of_workers")

    @number_of_workers.setter
    def number_of_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_workers", value)

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of PHP to use in this App Service. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3` and `7.4`.
        """
        return pulumi.get(self, "php_version")

    @php_version.setter
    def php_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "php_version", value)

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Python to use in this App Service. Possible values are `2.7` and `3.4`.
        """
        return pulumi.get(self, "python_version")

    @python_version.setter
    def python_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "python_version", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Remote Debugging Enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017`, `VS2019`, `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigScmIpRestrictionArgs']]]]:
        """
        A list of `scm_ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppServiceSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of Source Control enabled for this App Service. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        IP security restrictions for scm to use main. Defaults to `false`. 

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the App Service run in 32 bit mode, rather than 64 bit mode?

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @use32_bit_worker_process.setter
    def use32_bit_worker_process(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker_process", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Windows Docker container image (`DOCKER|<user/image:tag>`)
        """
        return pulumi.get(self, "windows_fx_version")

    @windows_fx_version.setter
    def windows_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_fx_version", value)


if not MYPY:
    class AppServiceSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are credentials supported?
        """
elif False:
    AppServiceSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param pulumi.Input[bool] support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class AppServiceSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        headers: NotRequired[pulumi.Input['AppServiceSiteConfigIpRestrictionHeadersArgsDict']]
        """
        The `headers` block for this specific `ip_restriction` as defined below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for this IP Restriction.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
elif False:
    AppServiceSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['AppServiceSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param pulumi.Input['AppServiceSiteConfigIpRestrictionHeadersArgs'] headers: The `headers` block for this specific `ip_restriction` as defined below.
        :param pulumi.Input[str] ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param pulumi.Input[str] name: The name for this IP Restriction.
        :param pulumi.Input[int] priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['AppServiceSiteConfigIpRestrictionHeadersArgs']]:
        """
        The `headers` block for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['AppServiceSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class AppServiceSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
elif False:
    AppServiceSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param pulumi.Input[str] x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class AppServiceSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        headers: NotRequired[pulumi.Input['AppServiceSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        The `headers` block for this specific `scm_ip_restriction` as defined below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for this IP Restriction.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
elif False:
    AppServiceSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['AppServiceSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Allow or Deny access for this IP range. Defaults to `Allow`.
        :param pulumi.Input['AppServiceSiteConfigScmIpRestrictionHeadersArgs'] headers: The `headers` block for this specific `scm_ip_restriction` as defined below.
        :param pulumi.Input[str] ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param pulumi.Input[str] name: The name for this IP Restriction.
        :param pulumi.Input[int] priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['AppServiceSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        The `headers` block for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['AppServiceSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class AppServiceSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
elif False:
    AppServiceSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param pulumi.Input[str] x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class AppServiceSiteCredentialArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username which can be used to publish to this App Service
        """
elif False:
    AppServiceSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceSiteCredentialArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: The password associated with the username, which can be used to publish to this App Service.
        :param pulumi.Input[str] username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class AppServiceSourceControlArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The branch of the remote repository to use. Defaults to 'master'.
        """
        manual_integration: NotRequired[pulumi.Input[bool]]
        """
        Limits to manual integration. Defaults to `false` if not specified.
        """
        repo_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the source code repository.
        """
        rollback_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable roll-back for the repository. Defaults to `false` if not specified.
        """
        use_mercurial: NotRequired[pulumi.Input[bool]]
        """
        Use Mercurial if `true`, otherwise uses Git.
        """
elif False:
    AppServiceSourceControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceSourceControlArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 manual_integration: Optional[pulumi.Input[bool]] = None,
                 repo_url: Optional[pulumi.Input[str]] = None,
                 rollback_enabled: Optional[pulumi.Input[bool]] = None,
                 use_mercurial: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] branch: The branch of the remote repository to use. Defaults to 'master'.
        :param pulumi.Input[bool] manual_integration: Limits to manual integration. Defaults to `false` if not specified.
        :param pulumi.Input[str] repo_url: The URL of the source code repository.
        :param pulumi.Input[bool] rollback_enabled: Enable roll-back for the repository. Defaults to `false` if not specified.
        :param pulumi.Input[bool] use_mercurial: Use Mercurial if `true`, otherwise uses Git.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if manual_integration is not None:
            pulumi.set(__self__, "manual_integration", manual_integration)
        if repo_url is not None:
            pulumi.set(__self__, "repo_url", repo_url)
        if rollback_enabled is not None:
            pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        if use_mercurial is not None:
            pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The branch of the remote repository to use. Defaults to 'master'.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> Optional[pulumi.Input[bool]]:
        """
        Limits to manual integration. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "manual_integration")

    @manual_integration.setter
    def manual_integration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manual_integration", value)

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @repo_url.setter
    def repo_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_url", value)

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable roll-back for the repository. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "rollback_enabled")

    @rollback_enabled.setter
    def rollback_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rollback_enabled", value)

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> Optional[pulumi.Input[bool]]:
        """
        Use Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")

    @use_mercurial.setter
    def use_mercurial(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mercurial", value)


if not MYPY:
    class AppServiceStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The name of the storage account.
        """
        name: pulumi.Input[str]
        """
        The name of the storage account identifier.
        """
        share_name: pulumi.Input[str]
        """
        The name of the file share (container name, for Blob storage).
        """
        type: pulumi.Input[str]
        """
        The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path to mount the storage within the site's runtime environment.
        """
elif False:
    AppServiceStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServiceStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The access key for the storage account.
        :param pulumi.Input[str] account_name: The name of the storage account.
        :param pulumi.Input[str] name: The name of the storage account identifier.
        :param pulumi.Input[str] share_name: The name of the file share (container name, for Blob storage).
        :param pulumi.Input[str] type: The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        :param pulumi.Input[str] mount_path: The path to mount the storage within the site's runtime environment.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the storage account identifier.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class CertificateOrderCertificateArgsDict(TypedDict):
        certificate_name: NotRequired[pulumi.Input[str]]
        """
        The name of the App Service Certificate.
        """
        key_vault_id: NotRequired[pulumi.Input[str]]
        """
        Key Vault resource Id.
        """
        key_vault_secret_name: NotRequired[pulumi.Input[str]]
        """
        Key Vault secret name.
        """
        provisioning_state: NotRequired[pulumi.Input[str]]
        """
        Status of the Key Vault secret.
        """
elif False:
    CertificateOrderCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateOrderCertificateArgs:
    def __init__(__self__, *,
                 certificate_name: Optional[pulumi.Input[str]] = None,
                 key_vault_id: Optional[pulumi.Input[str]] = None,
                 key_vault_secret_name: Optional[pulumi.Input[str]] = None,
                 provisioning_state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate_name: The name of the App Service Certificate.
        :param pulumi.Input[str] key_vault_id: Key Vault resource Id.
        :param pulumi.Input[str] key_vault_secret_name: Key Vault secret name.
        :param pulumi.Input[str] provisioning_state: Status of the Key Vault secret.
        """
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if key_vault_id is not None:
            pulumi.set(__self__, "key_vault_id", key_vault_id)
        if key_vault_secret_name is not None:
            pulumi.set(__self__, "key_vault_secret_name", key_vault_secret_name)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the App Service Certificate.
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_name", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        Key Vault resource Id.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_id", value)

    @property
    @pulumi.getter(name="keyVaultSecretName")
    def key_vault_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Key Vault secret name.
        """
        return pulumi.get(self, "key_vault_secret_name")

    @key_vault_secret_name.setter
    def key_vault_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_secret_name", value)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[pulumi.Input[str]]:
        """
        Status of the Key Vault secret.
        """
        return pulumi.get(self, "provisioning_state")

    @provisioning_state.setter
    def provisioning_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provisioning_state", value)


if not MYPY:
    class ConnectionAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        """
        certificate: NotRequired[pulumi.Input[str]]
        """
        Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        """
        subscription_id: NotRequired[pulumi.Input[str]]
        """
        Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
elif False:
    ConnectionAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 certificate: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] certificate: Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        :param pulumi.Input[str] client_id: Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        :param pulumi.Input[str] name: Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        :param pulumi.Input[str] principal_id: Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        :param pulumi.Input[str] secret: Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        :param pulumi.Input[str] subscription_id: Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `client_id` and `subscription_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subscription ID for `userAssignedIdentity`. `subscription_id` and `client_id` should be either both specified or both not specified.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)


if not MYPY:
    class ConnectionSecretStoreArgsDict(TypedDict):
        key_vault_id: pulumi.Input[str]
        """
        The key vault id to store secret.
        """
elif False:
    ConnectionSecretStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSecretStoreArgs:
    def __init__(__self__, *,
                 key_vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key_vault_id: The key vault id to store secret.
        """
        pulumi.set(__self__, "key_vault_id", key_vault_id)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The key vault id to store secret.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)


if not MYPY:
    class EnvironmentV3ClusterSettingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Cluster Setting.
        """
        value: pulumi.Input[str]
        """
        The value for the Cluster Setting.
        """
elif False:
    EnvironmentV3ClusterSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentV3ClusterSettingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Cluster Setting.
        :param pulumi.Input[str] value: The value for the Cluster Setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Cluster Setting.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value for the Cluster Setting.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EnvironmentV3InboundNetworkDependencyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        A short description of the purpose of the network traffic.
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IP addresses that network traffic will originate from in CIDR notation.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ports that network traffic will arrive to the App Service Environment V3 on.
        """
elif False:
    EnvironmentV3InboundNetworkDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentV3InboundNetworkDependencyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] description: A short description of the purpose of the network traffic.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_addresses: A list of IP addresses that network traffic will originate from in CIDR notation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ports: The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of the purpose of the network traffic.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP addresses that network traffic will originate from in CIDR notation.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ports that network traffic will arrive to the App Service Environment V3 on.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class FunctionAppAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Is Authentication enabled?
        """
        active_directory: NotRequired[pulumi.Input['FunctionAppAuthSettingsActiveDirectoryArgsDict']]
        """
        A `active_directory` block as defined below.
        """
        additional_login_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        facebook: NotRequired[pulumi.Input['FunctionAppAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        google: NotRequired[pulumi.Input['FunctionAppAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['FunctionAppAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The runtime version of the Authentication/Authorization module.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['FunctionAppAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
elif False:
    FunctionAppAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['FunctionAppAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['FunctionAppAuthSettingsFacebookArgs']] = None,
                 google: Optional[pulumi.Input['FunctionAppAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['FunctionAppAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['FunctionAppAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Is Authentication enabled?
        :param pulumi.Input['FunctionAppAuthSettingsActiveDirectoryArgs'] active_directory: A `active_directory` block as defined below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_params: Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param pulumi.Input[str] default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
               
               > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        :param pulumi.Input['FunctionAppAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['FunctionAppAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['FunctionAppAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The runtime version of the Authentication/Authorization module.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        :param pulumi.Input[bool] token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        :param pulumi.Input['FunctionAppAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['FunctionAppAuthSettingsActiveDirectoryArgs']]:
        """
        A `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['FunctionAppAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @additional_login_params.setter
    def additional_login_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_params", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['FunctionAppAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['FunctionAppAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['FunctionAppAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['FunctionAppAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['FunctionAppAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['FunctionAppAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['FunctionAppAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['FunctionAppAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class FunctionAppAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
elif False:
    FunctionAppAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param pulumi.Input[str] client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


if not MYPY:
    class FunctionAppAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login
        """
        app_secret: pulumi.Input[str]
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
elif False:
    FunctionAppAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> pulumi.Input[str]:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class FunctionAppAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: pulumi.Input[str]
        """
        The client secret associated with the Google web application.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
elif False:
    FunctionAppAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class FunctionAppAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: pulumi.Input[str]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
elif False:
    FunctionAppAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class FunctionAppAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: pulumi.Input[str]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
elif False:
    FunctionAppAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret", value)


if not MYPY:
    class FunctionAppConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Connection String.
        """
        type: pulumi.Input[str]
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The value for the Connection String.
        """
elif False:
    FunctionAppConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Connection String.
        :param pulumi.Input[str] type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        :param pulumi.Input[str] value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FunctionAppFunctionFileArgsDict(TypedDict):
        content: pulumi.Input[str]
        """
        The content of the file. Changing this forces a new resource to be created.
        """
        name: pulumi.Input[str]
        """
        The filename of the file to be uploaded. Changing this forces a new resource to be created.
        """
elif False:
    FunctionAppFunctionFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppFunctionFileArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The content of the file. Changing this forces a new resource to be created.
        :param pulumi.Input[str] name: The filename of the file to be uploaded. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the file. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The filename of the file to be uploaded. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FunctionAppIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
elif False:
    FunctionAppIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        :param pulumi.Input[str] tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class FunctionAppSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        Should the Function App be loaded at all times? Defaults to `false`.
        """
        app_scale_limit: NotRequired[pulumi.Input[int]]
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        auto_swap_slot_name: NotRequired[pulumi.Input[str]]
        """
        The name of the slot to automatically swap to during deployment

        > **NOTE:** This attribute is only used for slots.
        """
        cors: NotRequired[pulumi.Input['FunctionAppSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined below.
        """
        dotnet_framework_version: NotRequired[pulumi.Input[str]]
        """
        The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        """
        elastic_instance_minimum: NotRequired[pulumi.Input[int]]
        """
        The number of minimum instances for this function app. Only affects apps on the Premium plan. Possible values are between `1` and `20`.
        """
        ftps_state: NotRequired[pulumi.Input[str]]
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        Path which will be checked for this function app health.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigIpRestrictionArgsDict']]]]
        """
        A list of `ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        """
        linux_fx_version: NotRequired[pulumi.Input[str]]
        """
        Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        """
        min_tls_version: NotRequired[pulumi.Input[str]]
        """
        The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        """
        pre_warmed_instance_count: NotRequired[pulumi.Input[int]]
        """
        The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        """
        runtime_scale_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigScmIpRestrictionArgsDict']]]]
        """
        A list of `scm_ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        """
        The type of Source Control used by the Function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.

        > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        """
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        IP security restrictions for scm to use main. Defaults to `false`. 

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        use32_bit_worker_process: NotRequired[pulumi.Input[bool]]
        """
        Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.

        > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should WebSockets be enabled?
        """
elif False:
    FunctionAppSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 app_scale_limit: Optional[pulumi.Input[int]] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
                 cors: Optional[pulumi.Input['FunctionAppSiteConfigCorsArgs']] = None,
                 dotnet_framework_version: Optional[pulumi.Input[str]] = None,
                 elastic_instance_minimum: Optional[pulumi.Input[int]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigIpRestrictionArgs']]]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 pre_warmed_instance_count: Optional[pulumi.Input[int]] = None,
                 runtime_scale_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker_process: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] always_on: Should the Function App be loaded at all times? Defaults to `false`.
        :param pulumi.Input[int] app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param pulumi.Input[str] auto_swap_slot_name: The name of the slot to automatically swap to during deployment
               
               > **NOTE:** This attribute is only used for slots.
        :param pulumi.Input['FunctionAppSiteConfigCorsArgs'] cors: A `cors` block as defined below.
        :param pulumi.Input[str] dotnet_framework_version: The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        :param pulumi.Input[int] elastic_instance_minimum: The number of minimum instances for this function app. Only affects apps on the Premium plan. Possible values are between `1` and `20`.
        :param pulumi.Input[str] ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
        :param pulumi.Input[str] health_check_path: Path which will be checked for this function app health.
        :param pulumi.Input[bool] http2_enabled: Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigIpRestrictionArgs']]] ip_restrictions: A list of `ip_restriction` objects representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        :param pulumi.Input[str] java_version: Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        :param pulumi.Input[str] linux_fx_version: Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        :param pulumi.Input[str] min_tls_version: The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        :param pulumi.Input[int] pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        :param pulumi.Input[bool] runtime_scale_monitoring_enabled: Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: A list of `scm_ip_restriction` objects representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        :param pulumi.Input[str] scm_type: The type of Source Control used by the Function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.
               
               > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to `false`. 
               
               > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        :param pulumi.Input[bool] use32_bit_worker_process: Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
               
               > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        :param pulumi.Input[bool] websockets_enabled: Should WebSockets be enabled?
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Function App be loaded at all times? Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @app_scale_limit.setter
    def app_scale_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "app_scale_limit", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the slot to automatically swap to during deployment

        > **NOTE:** This attribute is only used for slots.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['FunctionAppSiteConfigCorsArgs']]:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['FunctionAppSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @dotnet_framework_version.setter
    def dotnet_framework_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_framework_version", value)

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minimum instances for this function app. Only affects apps on the Premium plan. Possible values are between `1` and `20`.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @elastic_instance_minimum.setter
    def elastic_instance_minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "elastic_instance_minimum", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path which will be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigIpRestrictionArgs']]]]:
        """
        A list of `ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        """
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @pre_warmed_instance_count.setter
    def pre_warmed_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pre_warmed_instance_count", value)

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @runtime_scale_monitoring_enabled.setter
    def runtime_scale_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "runtime_scale_monitoring_enabled", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigScmIpRestrictionArgs']]]]:
        """
        A list of `scm_ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of Source Control used by the Function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.

        > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        IP security restrictions for scm to use main. Defaults to `false`. 

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.

        > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @use32_bit_worker_process.setter
    def use32_bit_worker_process(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker_process", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)


if not MYPY:
    class FunctionAppSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are credentials supported?
        """
elif False:
    FunctionAppSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param pulumi.Input[bool] support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class FunctionAppSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        headers: NotRequired[pulumi.Input['FunctionAppSiteConfigIpRestrictionHeadersArgsDict']]
        """
        The `headers` block for this specific `ip_restriction` as defined below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for this IP Restriction.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
elif False:
    FunctionAppSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['FunctionAppSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param pulumi.Input['FunctionAppSiteConfigIpRestrictionHeadersArgs'] headers: The `headers` block for this specific `ip_restriction` as defined below.
        :param pulumi.Input[str] ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param pulumi.Input[str] name: The name for this IP Restriction.
        :param pulumi.Input[int] priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['FunctionAppSiteConfigIpRestrictionHeadersArgs']]:
        """
        The `headers` block for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['FunctionAppSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class FunctionAppSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
elif False:
    FunctionAppSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param pulumi.Input[str] x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class FunctionAppSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        headers: NotRequired[pulumi.Input['FunctionAppSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        The `headers` block for this specific `scm_ip_restriction` as defined below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for this IP Restriction.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
elif False:
    FunctionAppSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['FunctionAppSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Allow or Deny access for this IP range. Defaults to `Allow`.
        :param pulumi.Input['FunctionAppSiteConfigScmIpRestrictionHeadersArgs'] headers: The `headers` block for this specific `scm_ip_restriction` as defined below.
        :param pulumi.Input[str] ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param pulumi.Input[str] name: The name for this IP Restriction.
        :param pulumi.Input[int] priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['FunctionAppSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        The `headers` block for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['FunctionAppSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class FunctionAppSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
elif False:
    FunctionAppSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param pulumi.Input[str] x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class FunctionAppSiteCredentialArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username which can be used to publish to this App Service
        """
elif False:
    FunctionAppSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSiteCredentialArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: The password associated with the username, which can be used to publish to this App Service.
        :param pulumi.Input[str] username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class FunctionAppSlotAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Is Authentication enabled?
        """
        active_directory: NotRequired[pulumi.Input['FunctionAppSlotAuthSettingsActiveDirectoryArgsDict']]
        """
        An `active_directory` block as defined below.
        """
        additional_login_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        facebook: NotRequired[pulumi.Input['FunctionAppSlotAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        google: NotRequired[pulumi.Input['FunctionAppSlotAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['FunctionAppSlotAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The runtime version of the Authentication/Authorization module.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['FunctionAppSlotAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
elif False:
    FunctionAppSlotAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['FunctionAppSlotAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['FunctionAppSlotAuthSettingsFacebookArgs']] = None,
                 google: Optional[pulumi.Input['FunctionAppSlotAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['FunctionAppSlotAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['FunctionAppSlotAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Is Authentication enabled?
        :param pulumi.Input['FunctionAppSlotAuthSettingsActiveDirectoryArgs'] active_directory: An `active_directory` block as defined below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_params: login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param pulumi.Input[str] default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
               
               > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        :param pulumi.Input['FunctionAppSlotAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['FunctionAppSlotAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['FunctionAppSlotAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The runtime version of the Authentication/Authorization module.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        :param pulumi.Input[bool] token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        :param pulumi.Input['FunctionAppSlotAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['FunctionAppSlotAuthSettingsActiveDirectoryArgs']]:
        """
        An `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['FunctionAppSlotAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @additional_login_params.setter
    def additional_login_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_params", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['FunctionAppSlotAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['FunctionAppSlotAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['FunctionAppSlotAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['FunctionAppSlotAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['FunctionAppSlotAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['FunctionAppSlotAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['FunctionAppSlotAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['FunctionAppSlotAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class FunctionAppSlotAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
elif False:
    FunctionAppSlotAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param pulumi.Input[str] client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


if not MYPY:
    class FunctionAppSlotAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login
        """
        app_secret: pulumi.Input[str]
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
elif False:
    FunctionAppSlotAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> pulumi.Input[str]:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class FunctionAppSlotAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: pulumi.Input[str]
        """
        The client secret associated with the Google web application.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
elif False:
    FunctionAppSlotAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class FunctionAppSlotAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: pulumi.Input[str]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
elif False:
    FunctionAppSlotAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class FunctionAppSlotAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: pulumi.Input[str]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
elif False:
    FunctionAppSlotAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret", value)


if not MYPY:
    class FunctionAppSlotConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Connection String.
        """
        type: pulumi.Input[str]
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The value for the Connection String.
        """
elif False:
    FunctionAppSlotConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Connection String.
        :param pulumi.Input[str] type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        :param pulumi.Input[str] value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FunctionAppSlotIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
elif False:
    FunctionAppSlotIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        :param pulumi.Input[str] tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the Function App has been created. More details are available below.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class FunctionAppSlotSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        Should the Function App be loaded at all times? Defaults to `false`.
        """
        app_scale_limit: NotRequired[pulumi.Input[int]]
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        auto_swap_slot_name: NotRequired[pulumi.Input[str]]
        """
        The name of the slot to automatically swap to during deployment
        """
        cors: NotRequired[pulumi.Input['FunctionAppSlotSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined below.
        """
        dotnet_framework_version: NotRequired[pulumi.Input[str]]
        """
        The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        """
        elastic_instance_minimum: NotRequired[pulumi.Input[int]]
        """
        The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        """
        ftps_state: NotRequired[pulumi.Input[str]]
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        Path which will be checked for this function app health.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionArgsDict']]]]
        """
        A list of `ip_restriction` objects representing IP restrictions as defined below.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        """
        linux_fx_version: NotRequired[pulumi.Input[str]]
        """
        Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        """
        min_tls_version: NotRequired[pulumi.Input[str]]
        """
        The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        """
        pre_warmed_instance_count: NotRequired[pulumi.Input[int]]
        """
        The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        """
        runtime_scale_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionArgsDict']]]]
        """
        A list of `scm_ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        """
        The type of Source Control used by this function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.

        > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        """
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        IP security restrictions for scm to use main. Defaults to `false`.

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        use32_bit_worker_process: NotRequired[pulumi.Input[bool]]
        """
        Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.

        > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should WebSockets be enabled?
        """
elif False:
    FunctionAppSlotSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 app_scale_limit: Optional[pulumi.Input[int]] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
                 cors: Optional[pulumi.Input['FunctionAppSlotSiteConfigCorsArgs']] = None,
                 dotnet_framework_version: Optional[pulumi.Input[str]] = None,
                 elastic_instance_minimum: Optional[pulumi.Input[int]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionArgs']]]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 pre_warmed_instance_count: Optional[pulumi.Input[int]] = None,
                 runtime_scale_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker_process: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] always_on: Should the Function App be loaded at all times? Defaults to `false`.
        :param pulumi.Input[int] app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param pulumi.Input[str] auto_swap_slot_name: The name of the slot to automatically swap to during deployment
        :param pulumi.Input['FunctionAppSlotSiteConfigCorsArgs'] cors: A `cors` block as defined below.
        :param pulumi.Input[str] dotnet_framework_version: The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        :param pulumi.Input[int] elastic_instance_minimum: The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        :param pulumi.Input[str] ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        :param pulumi.Input[str] health_check_path: Path which will be checked for this function app health.
        :param pulumi.Input[bool] http2_enabled: Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionArgs']]] ip_restrictions: A list of `ip_restriction` objects representing IP restrictions as defined below.
        :param pulumi.Input[str] java_version: Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        :param pulumi.Input[str] linux_fx_version: Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        :param pulumi.Input[str] min_tls_version: The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        :param pulumi.Input[int] pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        :param pulumi.Input[bool] runtime_scale_monitoring_enabled: Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: A list of `scm_ip_restriction` objects representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        :param pulumi.Input[str] scm_type: The type of Source Control used by this function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.
               
               > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to `false`.
               
               > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        :param pulumi.Input[bool] use32_bit_worker_process: Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
               
               > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        :param pulumi.Input[bool] websockets_enabled: Should WebSockets be enabled?
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Function App be loaded at all times? Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @app_scale_limit.setter
    def app_scale_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "app_scale_limit", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the slot to automatically swap to during deployment
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['FunctionAppSlotSiteConfigCorsArgs']]:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['FunctionAppSlotSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @dotnet_framework_version.setter
    def dotnet_framework_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_framework_version", value)

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @elastic_instance_minimum.setter
    def elastic_instance_minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "elastic_instance_minimum", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path which will be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionArgs']]]]:
        """
        A list of `ip_restriction` objects representing IP restrictions as defined below.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
        """
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @pre_warmed_instance_count.setter
    def pre_warmed_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pre_warmed_instance_count", value)

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @runtime_scale_monitoring_enabled.setter
    def runtime_scale_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "runtime_scale_monitoring_enabled", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionArgs']]]]:
        """
        A list of `scm_ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of Source Control used by this function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.

        > **NOTE:** This setting is incompatible with the `source_control` block which updates this value based on the setting provided.
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        IP security restrictions for scm to use main. Defaults to `false`.

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.

        > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @use32_bit_worker_process.setter
    def use32_bit_worker_process(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker_process", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)


if not MYPY:
    class FunctionAppSlotSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are credentials supported?
        """
elif False:
    FunctionAppSlotSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param pulumi.Input[bool] support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class FunctionAppSlotSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        headers: NotRequired[pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict']]
        """
        The `headers` block for this specific `ip_restriction` as defined below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for this IP Restriction.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
elif False:
    FunctionAppSlotSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionHeadersArgs'] headers: The `headers` block for this specific `ip_restriction` as defined below.
        :param pulumi.Input[str] ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param pulumi.Input[str] name: The name for this IP Restriction.
        :param pulumi.Input[int] priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionHeadersArgs']]:
        """
        The `headers` block for this specific `ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['FunctionAppSlotSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class FunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
elif False:
    FunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param pulumi.Input[str] x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class FunctionAppSlotSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        headers: NotRequired[pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        The `headers` block for this specific `scm_ip_restriction` as defined below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for this IP Restriction.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
elif False:
    FunctionAppSlotSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Allow or Deny access for this IP range. Defaults to `Allow`.
        :param pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs'] headers: The `headers` block for this specific `scm_ip_restriction` as defined below.
        :param pulumi.Input[str] ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param pulumi.Input[str] name: The name for this IP Restriction.
        :param pulumi.Input[int] priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        The `headers` block for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
elif False:
    FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param pulumi.Input[str] x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class FunctionAppSlotSiteCredentialArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username which can be used to publish to this App Service
        """
elif False:
    FunctionAppSlotSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSlotSiteCredentialArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: The password associated with the username, which can be used to publish to this App Service.
        :param pulumi.Input[str] username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class FunctionAppSourceControlArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The branch of the remote repository to use. Defaults to 'master'.
        """
        manual_integration: NotRequired[pulumi.Input[bool]]
        """
        Limits to manual integration. Defaults to `false` if not specified.
        """
        repo_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the source code repository.
        """
        rollback_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable roll-back for the repository. Defaults to `false` if not specified.
        """
        use_mercurial: NotRequired[pulumi.Input[bool]]
        """
        Use Mercurial if `true`, otherwise uses Git.
        """
elif False:
    FunctionAppSourceControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppSourceControlArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 manual_integration: Optional[pulumi.Input[bool]] = None,
                 repo_url: Optional[pulumi.Input[str]] = None,
                 rollback_enabled: Optional[pulumi.Input[bool]] = None,
                 use_mercurial: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] branch: The branch of the remote repository to use. Defaults to 'master'.
        :param pulumi.Input[bool] manual_integration: Limits to manual integration. Defaults to `false` if not specified.
        :param pulumi.Input[str] repo_url: The URL of the source code repository.
        :param pulumi.Input[bool] rollback_enabled: Enable roll-back for the repository. Defaults to `false` if not specified.
        :param pulumi.Input[bool] use_mercurial: Use Mercurial if `true`, otherwise uses Git.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if manual_integration is not None:
            pulumi.set(__self__, "manual_integration", manual_integration)
        if repo_url is not None:
            pulumi.set(__self__, "repo_url", repo_url)
        if rollback_enabled is not None:
            pulumi.set(__self__, "rollback_enabled", rollback_enabled)
        if use_mercurial is not None:
            pulumi.set(__self__, "use_mercurial", use_mercurial)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The branch of the remote repository to use. Defaults to 'master'.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="manualIntegration")
    def manual_integration(self) -> Optional[pulumi.Input[bool]]:
        """
        Limits to manual integration. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "manual_integration")

    @manual_integration.setter
    def manual_integration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manual_integration", value)

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the source code repository.
        """
        return pulumi.get(self, "repo_url")

    @repo_url.setter
    def repo_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_url", value)

    @property
    @pulumi.getter(name="rollbackEnabled")
    def rollback_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable roll-back for the repository. Defaults to `false` if not specified.
        """
        return pulumi.get(self, "rollback_enabled")

    @rollback_enabled.setter
    def rollback_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rollback_enabled", value)

    @property
    @pulumi.getter(name="useMercurial")
    def use_mercurial(self) -> Optional[pulumi.Input[bool]]:
        """
        Use Mercurial if `true`, otherwise uses Git.
        """
        return pulumi.get(self, "use_mercurial")

    @use_mercurial.setter
    def use_mercurial(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mercurial", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        active_directory: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsActiveDirectoryArgsDict']]
        """
        An `active_directory` block as defined above.
        """
        additional_login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        facebook: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        github: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsGithubArgsDict']]
        """
        A `github` block as defined below.
        """
        google: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
elif False:
    LinuxFunctionAppAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsFacebookArgs']] = None,
                 github: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsGithubArgs']] = None,
                 google: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Authentication / Authorization feature be enabled for the Linux Web App?
        :param pulumi.Input['LinuxFunctionAppAuthSettingsActiveDirectoryArgs'] active_directory: An `active_directory` block as defined above.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param pulumi.Input[str] default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
               
               > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        :param pulumi.Input['LinuxFunctionAppAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsGithubArgs'] github: A `github` block as defined below.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsActiveDirectoryArgs']]:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @additional_login_parameters.setter
    def additional_login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_parameters", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsGithubArgs']]:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
elif False:
    LinuxFunctionAppAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param pulumi.Input[str] client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret: NotRequired[pulumi.Input[str]]
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
elif False:
    LinuxFunctionAppAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsGithubArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
elif False:
    LinuxFunctionAppAuthSettingsGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsGithubArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login.
        :param pulumi.Input[str] client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
elif False:
    LinuxFunctionAppAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
elif False:
    LinuxFunctionAppAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
elif False:
    LinuxFunctionAppAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2ArgsDict(TypedDict):
        login: pulumi.Input['LinuxFunctionAppAuthSettingsV2LoginArgsDict']
        """
        A `login` block as defined below.
        """
        active_directory_v2: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2ArgsDict']]
        """
        An `active_directory_v2` block as defined below.
        """
        apple_v2: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsV2AppleV2ArgsDict']]
        """
        An `apple_v2` block as defined below.
        """
        auth_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        azure_static_web_app_v2: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2ArgsDict']]
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        config_file_path: NotRequired[pulumi.Input[str]]
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        custom_oidc_v2s: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppAuthSettingsV2CustomOidcV2ArgsDict']]]]
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        facebook_v2: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsV2FacebookV2ArgsDict']]
        """
        A `facebook_v2` block as defined below.
        """
        forward_proxy_convention: NotRequired[pulumi.Input[str]]
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        forward_proxy_custom_host_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the host of the request.
        """
        forward_proxy_custom_scheme_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the scheme of the request.
        """
        github_v2: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsV2GithubV2ArgsDict']]
        """
        A `github_v2` block as defined below.
        """
        google_v2: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsV2GoogleV2ArgsDict']]
        """
        A `google_v2` block as defined below.
        """
        http_route_api_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        microsoft_v2: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsV2MicrosoftV2ArgsDict']]
        """
        A `microsoft_v2` block as defined below.
        """
        require_authentication: NotRequired[pulumi.Input[bool]]
        """
        Should the authentication flow be used for all requests.
        """
        require_https: NotRequired[pulumi.Input[bool]]
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        twitter_v2: NotRequired[pulumi.Input['LinuxFunctionAppAuthSettingsV2TwitterV2ArgsDict']]
        """
        A `twitter_v2` block as defined below.
        """
        unauthenticated_action: NotRequired[pulumi.Input[str]]
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2Args:
    def __init__(__self__, *,
                 login: pulumi.Input['LinuxFunctionAppAuthSettingsV2LoginArgs'],
                 active_directory_v2: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Args']] = None,
                 apple_v2: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2AppleV2Args']] = None,
                 auth_enabled: Optional[pulumi.Input[bool]] = None,
                 azure_static_web_app_v2: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Args']] = None,
                 config_file_path: Optional[pulumi.Input[str]] = None,
                 custom_oidc_v2s: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppAuthSettingsV2CustomOidcV2Args']]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 facebook_v2: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2FacebookV2Args']] = None,
                 forward_proxy_convention: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_scheme_header_name: Optional[pulumi.Input[str]] = None,
                 github_v2: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2GithubV2Args']] = None,
                 google_v2: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2GoogleV2Args']] = None,
                 http_route_api_prefix: Optional[pulumi.Input[str]] = None,
                 microsoft_v2: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2MicrosoftV2Args']] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 twitter_v2: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2TwitterV2Args']] = None,
                 unauthenticated_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['LinuxFunctionAppAuthSettingsV2LoginArgs'] login: A `login` block as defined below.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2: An `active_directory_v2` block as defined below.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsV2AppleV2Args'] apple_v2: An `apple_v2` block as defined below.
        :param pulumi.Input[bool] auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param pulumi.Input[str] config_file_path: The path to the App Auth settings.
               
               > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppAuthSettingsV2CustomOidcV2Args']]] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param pulumi.Input[str] default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsV2FacebookV2Args'] facebook_v2: A `facebook_v2` block as defined below.
        :param pulumi.Input[str] forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param pulumi.Input[str] forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param pulumi.Input[str] forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsV2GithubV2Args'] github_v2: A `github_v2` block as defined below.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsV2GoogleV2Args'] google_v2: A `google_v2` block as defined below.
        :param pulumi.Input[str] http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsV2MicrosoftV2Args'] microsoft_v2: A `microsoft_v2` block as defined below.
        :param pulumi.Input[bool] require_authentication: Should the authentication flow be used for all requests.
        :param pulumi.Input[bool] require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param pulumi.Input[str] runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param pulumi.Input['LinuxFunctionAppAuthSettingsV2TwitterV2Args'] twitter_v2: A `twitter_v2` block as defined below.
        :param pulumi.Input[str] unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> pulumi.Input['LinuxFunctionAppAuthSettingsV2LoginArgs']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: pulumi.Input['LinuxFunctionAppAuthSettingsV2LoginArgs']):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Args']]:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @active_directory_v2.setter
    def active_directory_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Args']]):
        pulumi.set(self, "active_directory_v2", value)

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2AppleV2Args']]:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @apple_v2.setter
    def apple_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2AppleV2Args']]):
        pulumi.set(self, "apple_v2", value)

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @auth_enabled.setter
    def auth_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auth_enabled", value)

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Args']]:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @azure_static_web_app_v2.setter
    def azure_static_web_app_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Args']]):
        pulumi.set(self, "azure_static_web_app_v2", value)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppAuthSettingsV2CustomOidcV2Args']]]]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @custom_oidc_v2s.setter
    def custom_oidc_v2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppAuthSettingsV2CustomOidcV2Args']]]]):
        pulumi.set(self, "custom_oidc_v2s", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2FacebookV2Args']]:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @facebook_v2.setter
    def facebook_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2FacebookV2Args']]):
        pulumi.set(self, "facebook_v2", value)

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @forward_proxy_convention.setter
    def forward_proxy_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_convention", value)

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @forward_proxy_custom_host_header_name.setter
    def forward_proxy_custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_host_header_name", value)

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @forward_proxy_custom_scheme_header_name.setter
    def forward_proxy_custom_scheme_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_scheme_header_name", value)

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2GithubV2Args']]:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @github_v2.setter
    def github_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2GithubV2Args']]):
        pulumi.set(self, "github_v2", value)

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2GoogleV2Args']]:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @google_v2.setter
    def google_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2GoogleV2Args']]):
        pulumi.set(self, "google_v2", value)

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @http_route_api_prefix.setter
    def http_route_api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_route_api_prefix", value)

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2MicrosoftV2Args']]:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @microsoft_v2.setter
    def microsoft_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2MicrosoftV2Args']]):
        pulumi.set(self, "microsoft_v2", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2TwitterV2Args']]:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @twitter_v2.setter
    def twitter_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppAuthSettingsV2TwitterV2Args']]):
        pulumi.set(self, "twitter_v2", value)

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")

    @unauthenticated_action.setter
    def unauthenticated_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_action", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        tenant_auth_endpoint: pulumi.Input[str]
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        allowed_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the certificate used for signing purposes.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        jwt_allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        jwt_allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Groups in the JWT Claim.
        """
        login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        www_authentication_disabled: NotRequired[pulumi.Input[bool]]
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 tenant_auth_endpoint: pulumi.Input[str],
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 jwt_allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jwt_allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 www_authentication_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[str] tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`
               
               > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param pulumi.Input[str] client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param pulumi.Input[bool] www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> pulumi.Input[str]:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @tenant_auth_endpoint.setter
    def tenant_auth_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_auth_endpoint", value)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @allowed_identities.setter
    def allowed_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_identities", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @jwt_allowed_client_applications.setter
    def jwt_allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_client_applications", value)

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @jwt_allowed_groups.setter
    def jwt_allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_groups", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        return pulumi.get(self, "www_authentication_disabled")

    @www_authentication_disabled.setter
    def www_authentication_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "www_authentication_disabled", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2AppleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2AppleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2AppleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Apple web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Apple Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: A list of Login Scopes provided by this Authentication Provider.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2CustomOidcV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        name: pulumi.Input[str]
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        openid_configuration_endpoint: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        authorisation_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        certification_uri: NotRequired[pulumi.Input[str]]
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        client_credential_method: NotRequired[pulumi.Input[str]]
        """
        The Client Credential Method used.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        issuer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        name_claim_type: NotRequired[pulumi.Input[str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of the scopes that should be requested while authenticating.
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2CustomOidcV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2CustomOidcV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 openid_configuration_endpoint: pulumi.Input[str],
                 authorisation_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 client_credential_method: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 issuer_endpoint: Optional[pulumi.Input[str]] = None,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with the Custom OIDC.
        :param pulumi.Input[str] name: The name of the Custom OIDC Authentication Provider.
               
               > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        :param pulumi.Input[str] openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param pulumi.Input[str] authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] client_credential_method: The Client Credential Method used.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        :param pulumi.Input[str] issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of the scopes that should be requested while authenticating.
        :param pulumi.Input[str] token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @openid_configuration_endpoint.setter
    def openid_configuration_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "openid_configuration_endpoint", value)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @authorisation_endpoint.setter
    def authorisation_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorisation_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @client_credential_method.setter
    def client_credential_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_credential_method", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @issuer_endpoint.setter
    def issuer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_endpoint", value)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2FacebookV2ArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        graph_api_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Facebook API to be used while logging in.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2FacebookV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2FacebookV2Args:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret_setting_name: pulumi.Input[str],
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[str] graph_api_version: The version of the Facebook API to be used while logging in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of scopes that should be requested as part of Facebook Login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2GithubV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login..
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2GithubV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2GithubV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login..
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login..
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2GoogleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2GoogleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2GoogleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2LoginArgsDict(TypedDict):
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration_convention: NotRequired[pulumi.Input[str]]
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        cookie_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        logout_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to which logout requests should be made.
        """
        nonce_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[bool]]
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        token_refresh_extension_time: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        token_store_path: NotRequired[pulumi.Input[str]]
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        token_store_sas_setting_name: NotRequired[pulumi.Input[str]]
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        validate_nonce: NotRequired[pulumi.Input[bool]]
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration_convention: Optional[pulumi.Input[str]] = None,
                 cookie_expiration_time: Optional[pulumi.Input[str]] = None,
                 logout_endpoint: Optional[pulumi.Input[str]] = None,
                 nonce_expiration_time: Optional[pulumi.Input[str]] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 token_refresh_extension_time: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 token_store_path: Optional[pulumi.Input[str]] = None,
                 token_store_sas_setting_name: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param pulumi.Input[str] cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param pulumi.Input[str] cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param pulumi.Input[str] logout_endpoint: The endpoint to which logout requests should be made.
        :param pulumi.Input[str] nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param pulumi.Input[bool] preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param pulumi.Input[float] token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param pulumi.Input[str] token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param pulumi.Input[str] token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param pulumi.Input[bool] validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @cookie_expiration_convention.setter
    def cookie_expiration_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_convention", value)

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @cookie_expiration_time.setter
    def cookie_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_time", value)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @nonce_expiration_time.setter
    def nonce_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_time", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @token_refresh_extension_time.setter
    def token_refresh_extension_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_time", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @token_store_path.setter
    def token_store_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_path", value)

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @token_store_sas_setting_name.setter
    def token_store_sas_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_sas_setting_name", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2MicrosoftV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2MicrosoftV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2MicrosoftV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppAuthSettingsV2TwitterV2ArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
elif False:
    LinuxFunctionAppAuthSettingsV2TwitterV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppAuthSettingsV2TwitterV2Args:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret_setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class LinuxFunctionAppBackupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Backup.
        """
        schedule: pulumi.Input['LinuxFunctionAppBackupScheduleArgsDict']
        """
        A `schedule` block as defined below.
        """
        storage_account_url: pulumi.Input[str]
        """
        The SAS URL to the container.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Should this backup job be enabled? Defaults to `true`.
        """
elif False:
    LinuxFunctionAppBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppBackupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['LinuxFunctionAppBackupScheduleArgs'],
                 storage_account_url: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Backup.
        :param pulumi.Input['LinuxFunctionAppBackupScheduleArgs'] schedule: A `schedule` block as defined below.
        :param pulumi.Input[str] storage_account_url: The SAS URL to the container.
        :param pulumi.Input[bool] enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['LinuxFunctionAppBackupScheduleArgs']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['LinuxFunctionAppBackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> pulumi.Input[str]:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LinuxFunctionAppBackupScheduleArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        """
        frequency_unit: pulumi.Input[str]
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        keep_at_least_one_backup: NotRequired[pulumi.Input[bool]]
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        last_execution_time: NotRequired[pulumi.Input[str]]
        """
        The time the backup was last attempted.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        When the schedule should start working in RFC-3339 format.
        """
elif False:
    LinuxFunctionAppBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppBackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_unit: pulumi.Input[str],
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 last_execution_time: Optional[pulumi.Input[str]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        :param pulumi.Input[str] frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param pulumi.Input[bool] keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param pulumi.Input[str] last_execution_time: The time the backup was last attempted.
        :param pulumi.Input[int] retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param pulumi.Input[str] start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input[str]:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @last_execution_time.setter
    def last_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_execution_time", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class LinuxFunctionAppConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Connection.
        """
        type: pulumi.Input[str]
        """
        Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        """
        value: pulumi.Input[str]
        """
        The connection string value.
        """
elif False:
    LinuxFunctionAppConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name which should be used for this Connection.
        :param pulumi.Input[str] type: Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        :param pulumi.Input[str] value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LinuxFunctionAppIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    LinuxFunctionAppIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Linux Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class LinuxFunctionAppSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        If this Linux Web App is Always On enabled. Defaults to `false`.

        > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        """
        api_definition_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the API definition that describes this Linux Function App.
        """
        api_management_api_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the API Management API for this Linux Function App.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        The App command line to launch.
        """
        app_scale_limit: NotRequired[pulumi.Input[int]]
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        app_service_logs: NotRequired[pulumi.Input['LinuxFunctionAppSiteConfigAppServiceLogsArgsDict']]
        """
        An `app_service_logs` block as defined above.
        """
        application_insights_connection_string: NotRequired[pulumi.Input[str]]
        """
        The Connection String for linking the Linux Function App to Application Insights.
        """
        application_insights_key: NotRequired[pulumi.Input[str]]
        """
        The Instrumentation Key for connecting the Linux Function App to Application Insights.
        """
        application_stack: NotRequired[pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackArgsDict']]
        """
        An `application_stack` block as defined above.

        > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        """
        container_registry_managed_identity_client_id: NotRequired[pulumi.Input[str]]
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        container_registry_use_managed_identity: NotRequired[pulumi.Input[bool]]
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        cors: NotRequired[pulumi.Input['LinuxFunctionAppSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined above.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        detailed_error_logging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is detailed error logging enabled
        """
        elastic_instance_minimum: NotRequired[pulumi.Input[int]]
        """
        The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        """
        ftps_state: NotRequired[pulumi.Input[str]]
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        health_check_eviction_time_in_min: NotRequired[pulumi.Input[int]]
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The path to be checked for this function app health.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionArgsDict']]]]
        """
        One or more `ip_restriction` blocks as defined above.
        """
        linux_fx_version: NotRequired[pulumi.Input[str]]
        """
        The Linux FX Version
        """
        load_balancing_mode: NotRequired[pulumi.Input[str]]
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        """
        pre_warmed_instance_count: NotRequired[pulumi.Input[int]]
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        """
        runtime_scale_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Scale Monitoring of the Functions Runtime be enabled?

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        scm_ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionArgsDict']]]]
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        scm_minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        """
        The SCM Type in use by the Linux Function App.
        """
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        """
        use32_bit_worker: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App use a 32-bit worker process. Defaults to `false`.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        worker_count: NotRequired[pulumi.Input[int]]
        """
        The number of Workers for this Linux Function App.
        """
elif False:
    LinuxFunctionAppSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 api_definition_url: Optional[pulumi.Input[str]] = None,
                 api_management_api_id: Optional[pulumi.Input[str]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 app_scale_limit: Optional[pulumi.Input[int]] = None,
                 app_service_logs: Optional[pulumi.Input['LinuxFunctionAppSiteConfigAppServiceLogsArgs']] = None,
                 application_insights_connection_string: Optional[pulumi.Input[str]] = None,
                 application_insights_key: Optional[pulumi.Input[str]] = None,
                 application_stack: Optional[pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackArgs']] = None,
                 container_registry_managed_identity_client_id: Optional[pulumi.Input[str]] = None,
                 container_registry_use_managed_identity: Optional[pulumi.Input[bool]] = None,
                 cors: Optional[pulumi.Input['LinuxFunctionAppSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 elastic_instance_minimum: Optional[pulumi.Input[int]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_eviction_time_in_min: Optional[pulumi.Input[int]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionArgs']]]] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 load_balancing_mode: Optional[pulumi.Input[str]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 pre_warmed_instance_count: Optional[pulumi.Input[int]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 runtime_scale_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 scm_ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 worker_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] always_on: If this Linux Web App is Always On enabled. Defaults to `false`.
               
               > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        :param pulumi.Input[str] api_definition_url: The URL of the API definition that describes this Linux Function App.
        :param pulumi.Input[str] api_management_api_id: The ID of the API Management API for this Linux Function App.
        :param pulumi.Input[str] app_command_line: The App command line to launch.
        :param pulumi.Input[int] app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param pulumi.Input['LinuxFunctionAppSiteConfigAppServiceLogsArgs'] app_service_logs: An `app_service_logs` block as defined above.
        :param pulumi.Input[str] application_insights_connection_string: The Connection String for linking the Linux Function App to Application Insights.
        :param pulumi.Input[str] application_insights_key: The Instrumentation Key for connecting the Linux Function App to Application Insights.
        :param pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackArgs'] application_stack: An `application_stack` block as defined above.
               
               > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        :param pulumi.Input[str] container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param pulumi.Input[bool] container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param pulumi.Input['LinuxFunctionAppSiteConfigCorsArgs'] cors: A `cors` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param pulumi.Input[bool] detailed_error_logging_enabled: Is detailed error logging enabled
        :param pulumi.Input[int] elastic_instance_minimum: The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        :param pulumi.Input[str] ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param pulumi.Input[int] health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param pulumi.Input[str] health_check_path: The path to be checked for this function app health.
        :param pulumi.Input[bool] http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param pulumi.Input[str] ip_restriction_default_action: The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionArgs']]] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param pulumi.Input[str] linux_fx_version: The Linux FX Version
        :param pulumi.Input[str] load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param pulumi.Input[str] managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        :param pulumi.Input[int] pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        :param pulumi.Input[bool] remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        :param pulumi.Input[bool] runtime_scale_monitoring_enabled: Should Scale Monitoring of the Functions Runtime be enabled?
               
               > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        :param pulumi.Input[str] scm_ip_restriction_default_action: The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param pulumi.Input[str] scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[str] scm_type: The SCM Type in use by the Linux Function App.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        :param pulumi.Input[bool] use32_bit_worker: Should the Linux Web App use a 32-bit worker process. Defaults to `false`.
        :param pulumi.Input[bool] vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param pulumi.Input[bool] websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param pulumi.Input[int] worker_count: The number of Workers for this Linux Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restriction_default_action is not None:
            pulumi.set(__self__, "ip_restriction_default_action", ip_restriction_default_action)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restriction_default_action is not None:
            pulumi.set(__self__, "scm_ip_restriction_default_action", scm_ip_restriction_default_action)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        If this Linux Web App is Always On enabled. Defaults to `false`.

        > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the API definition that describes this Linux Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @api_definition_url.setter
    def api_definition_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_definition_url", value)

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the API Management API for this Linux Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @api_management_api_id.setter
    def api_management_api_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_management_api_id", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @app_scale_limit.setter
    def app_scale_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "app_scale_limit", value)

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional[pulumi.Input['LinuxFunctionAppSiteConfigAppServiceLogsArgs']]:
        """
        An `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @app_service_logs.setter
    def app_service_logs(self, value: Optional[pulumi.Input['LinuxFunctionAppSiteConfigAppServiceLogsArgs']]):
        pulumi.set(self, "app_service_logs", value)

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        The Connection String for linking the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @application_insights_connection_string.setter
    def application_insights_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_insights_connection_string", value)

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Instrumentation Key for connecting the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @application_insights_key.setter
    def application_insights_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_insights_key", value)

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional[pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackArgs']]:
        """
        An `application_stack` block as defined above.

        > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        """
        return pulumi.get(self, "application_stack")

    @application_stack.setter
    def application_stack(self, value: Optional[pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackArgs']]):
        pulumi.set(self, "application_stack", value)

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @container_registry_managed_identity_client_id.setter
    def container_registry_managed_identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_registry_managed_identity_client_id", value)

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[pulumi.Input[bool]]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @container_registry_use_managed_identity.setter
    def container_registry_use_managed_identity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_registry_use_managed_identity", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['LinuxFunctionAppSiteConfigCorsArgs']]:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['LinuxFunctionAppSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is detailed error logging enabled
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @elastic_instance_minimum.setter
    def elastic_instance_minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "elastic_instance_minimum", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @health_check_eviction_time_in_min.setter
    def health_check_eviction_time_in_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_eviction_time_in_min", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictionDefaultAction")
    def ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "ip_restriction_default_action")

    @ip_restriction_default_action.setter
    def ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionArgs']]]]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Linux FX Version
        """
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @load_balancing_mode.setter
    def load_balancing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancing_mode", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @pre_warmed_instance_count.setter
    def pre_warmed_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pre_warmed_instance_count", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Scale Monitoring of the Functions Runtime be enabled?

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @runtime_scale_monitoring_enabled.setter
    def runtime_scale_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "runtime_scale_monitoring_enabled", value)

    @property
    @pulumi.getter(name="scmIpRestrictionDefaultAction")
    def scm_ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "scm_ip_restriction_default_action")

    @scm_ip_restriction_default_action.setter
    def scm_ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionArgs']]]]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @scm_minimum_tls_version.setter
    def scm_minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_minimum_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        """
        The SCM Type in use by the Linux Function App.
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App use a 32-bit worker process. Defaults to `false`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @use32_bit_worker.setter
    def use32_bit_worker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Workers for this Linux Function App.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class LinuxFunctionAppSiteConfigAppServiceLogsArgsDict(TypedDict):
        disk_quota_mb: NotRequired[pulumi.Input[int]]
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
elif False:
    LinuxFunctionAppSiteConfigAppServiceLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteConfigAppServiceLogsArgs:
    def __init__(__self__, *,
                 disk_quota_mb: Optional[pulumi.Input[int]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        :param pulumi.Input[int] retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
               
               > **NOTE:** This block is not supported on Consumption plans.
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @disk_quota_mb.setter
    def disk_quota_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_quota_mb", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)


if not MYPY:
    class LinuxFunctionAppSiteConfigApplicationStackArgsDict(TypedDict):
        dockers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackDockerArgsDict']]]]
        """
        One or more `docker` blocks as defined below.
        """
        dotnet_version: NotRequired[pulumi.Input[str]]
        """
        The version of .NET to use. Possible values include `3.1`, `6.0`, `7.0` and `8.0`.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The Version of Java to use. Supported versions include `8`, `11` & `17`.
        """
        node_version: NotRequired[pulumi.Input[str]]
        """
        The version of Node to run. Possible values include `12`, `14`, `16`, `18` and `20`.
        """
        powershell_core_version: NotRequired[pulumi.Input[str]]
        """
        The version of PowerShell Core to run. Possible values are `7`, `7.2`, and `7.4`.
        """
        python_version: NotRequired[pulumi.Input[str]]
        """
        The version of Python to run. Possible values are `3.12`, `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        """
        use_custom_runtime: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Function App use a custom runtime?
        """
        use_dotnet_isolated_runtime: NotRequired[pulumi.Input[bool]]
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
elif False:
    LinuxFunctionAppSiteConfigApplicationStackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteConfigApplicationStackArgs:
    def __init__(__self__, *,
                 dockers: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackDockerArgs']]]] = None,
                 dotnet_version: Optional[pulumi.Input[str]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 node_version: Optional[pulumi.Input[str]] = None,
                 powershell_core_version: Optional[pulumi.Input[str]] = None,
                 python_version: Optional[pulumi.Input[str]] = None,
                 use_custom_runtime: Optional[pulumi.Input[bool]] = None,
                 use_dotnet_isolated_runtime: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackDockerArgs']]] dockers: One or more `docker` blocks as defined below.
        :param pulumi.Input[str] dotnet_version: The version of .NET to use. Possible values include `3.1`, `6.0`, `7.0` and `8.0`.
        :param pulumi.Input[str] java_version: The Version of Java to use. Supported versions include `8`, `11` & `17`.
        :param pulumi.Input[str] node_version: The version of Node to run. Possible values include `12`, `14`, `16`, `18` and `20`.
        :param pulumi.Input[str] powershell_core_version: The version of PowerShell Core to run. Possible values are `7`, `7.2`, and `7.4`.
        :param pulumi.Input[str] python_version: The version of Python to run. Possible values are `3.12`, `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        :param pulumi.Input[bool] use_custom_runtime: Should the Linux Function App use a custom runtime?
        :param pulumi.Input[bool] use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dockers is not None:
            pulumi.set(__self__, "dockers", dockers)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter
    def dockers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackDockerArgs']]]]:
        """
        One or more `docker` blocks as defined below.
        """
        return pulumi.get(self, "dockers")

    @dockers.setter
    def dockers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSiteConfigApplicationStackDockerArgs']]]]):
        pulumi.set(self, "dockers", value)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .NET to use. Possible values include `3.1`, `6.0`, `7.0` and `8.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @dotnet_version.setter
    def dotnet_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Version of Java to use. Supported versions include `8`, `11` & `17`.
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Node to run. Possible values include `12`, `14`, `16`, `18` and `20`.
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of PowerShell Core to run. Possible values are `7`, `7.2`, and `7.4`.
        """
        return pulumi.get(self, "powershell_core_version")

    @powershell_core_version.setter
    def powershell_core_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "powershell_core_version", value)

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Python to run. Possible values are `3.12`, `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        """
        return pulumi.get(self, "python_version")

    @python_version.setter
    def python_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "python_version", value)

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @use_custom_runtime.setter
    def use_custom_runtime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_custom_runtime", value)

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")

    @use_dotnet_isolated_runtime.setter
    def use_dotnet_isolated_runtime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_dotnet_isolated_runtime", value)


if not MYPY:
    class LinuxFunctionAppSiteConfigApplicationStackDockerArgsDict(TypedDict):
        image_name: pulumi.Input[str]
        """
        The name of the Docker image to use.
        """
        image_tag: pulumi.Input[str]
        """
        The image tag of the image to use.
        """
        registry_url: pulumi.Input[str]
        """
        The URL of the docker registry.
        """
        registry_password: NotRequired[pulumi.Input[str]]
        """
        The password for the account to use to connect to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        registry_username: NotRequired[pulumi.Input[str]]
        """
        The username to use for connections to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
elif False:
    LinuxFunctionAppSiteConfigApplicationStackDockerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteConfigApplicationStackDockerArgs:
    def __init__(__self__, *,
                 image_name: pulumi.Input[str],
                 image_tag: pulumi.Input[str],
                 registry_url: pulumi.Input[str],
                 registry_password: Optional[pulumi.Input[str]] = None,
                 registry_username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_name: The name of the Docker image to use.
        :param pulumi.Input[str] image_tag: The image tag of the image to use.
        :param pulumi.Input[str] registry_url: The URL of the docker registry.
        :param pulumi.Input[str] registry_password: The password for the account to use to connect to the registry.
               
               > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        :param pulumi.Input[str] registry_username: The username to use for connections to the registry.
               
               > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_tag", image_tag)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        """
        The name of the Docker image to use.
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="imageTag")
    def image_tag(self) -> pulumi.Input[str]:
        """
        The image tag of the image to use.
        """
        return pulumi.get(self, "image_tag")

    @image_tag.setter
    def image_tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_tag", value)

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> pulumi.Input[str]:
        """
        The URL of the docker registry.
        """
        return pulumi.get(self, "registry_url")

    @registry_url.setter
    def registry_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_url", value)

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password for the account to use to connect to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        return pulumi.get(self, "registry_password")

    @registry_password.setter
    def registry_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_password", value)

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use for connections to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        return pulumi.get(self, "registry_username")

    @registry_username.setter
    def registry_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_username", value)


if not MYPY:
    class LinuxFunctionAppSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
elif False:
    LinuxFunctionAppSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param pulumi.Input[bool] support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class LinuxFunctionAppSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    LinuxFunctionAppSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['LinuxFunctionAppSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class LinuxFunctionAppSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    LinuxFunctionAppSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class LinuxFunctionAppSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    LinuxFunctionAppSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class LinuxFunctionAppSiteCredentialArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Password used for publishing.
        """
elif False:
    LinuxFunctionAppSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSiteCredentialArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        :param pulumi.Input[str] password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Should the Authentication / Authorization feature be enabled?
        """
        active_directory: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgsDict']]
        """
        an `active_directory` block as detailed below.
        """
        additional_login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        facebook: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsFacebookArgsDict']]
        """
        a `facebook` block as detailed below.
        """
        github: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsGithubArgsDict']]
        """
        a `github` block as detailed below.
        """
        google: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsGoogleArgsDict']]
        """
        a `google` block as detailed below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsMicrosoftArgsDict']]
        """
        a `microsoft` block as detailed below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The RuntimeVersion of the Authentication / Authorization feature in use.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsTwitterArgsDict']]
        """
        a `twitter` block as detailed below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsFacebookArgs']] = None,
                 github: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsGithubArgs']] = None,
                 google: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Authentication / Authorization feature be enabled?
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgs'] active_directory: an `active_directory` block as detailed below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        :param pulumi.Input[str] default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
               
               > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsFacebookArgs'] facebook: a `facebook` block as detailed below.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsGithubArgs'] github: a `github` block as detailed below.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsGoogleArgs'] google: a `google` block as detailed below.
        :param pulumi.Input[str] issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsMicrosoftArgs'] microsoft: a `microsoft` block as detailed below.
        :param pulumi.Input[str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsTwitterArgs'] twitter: a `twitter` block as detailed below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the Authentication / Authorization feature be enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgs']]:
        """
        an `active_directory` block as detailed below.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @additional_login_parameters.setter
    def additional_login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_parameters", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsFacebookArgs']]:
        """
        a `facebook` block as detailed below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsGithubArgs']]:
        """
        a `github` block as detailed below.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsGoogleArgs']]:
        """
        a `google` block as detailed below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsMicrosoftArgs']]:
        """
        a `microsoft` block as detailed below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsTwitterArgs']]:
        """
        a `twitter` block as detailed below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param pulumi.Input[str] client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret: NotRequired[pulumi.Input[str]]
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsGithubArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsGithubArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login.
        :param pulumi.Input[str] client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2ArgsDict(TypedDict):
        login: pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2LoginArgsDict']
        """
        A `login` block as defined below.
        """
        active_directory_v2: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict']]
        """
        An `active_directory_v2` block as defined below.
        """
        apple_v2: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AppleV2ArgsDict']]
        """
        An `apple_v2` block as defined below.
        """
        auth_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        azure_static_web_app_v2: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict']]
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        config_file_path: NotRequired[pulumi.Input[str]]
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        custom_oidc_v2s: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2ArgsDict']]]]
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        facebook_v2: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2FacebookV2ArgsDict']]
        """
        A `facebook_v2` block as defined below.
        """
        forward_proxy_convention: NotRequired[pulumi.Input[str]]
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        forward_proxy_custom_host_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the host of the request.
        """
        forward_proxy_custom_scheme_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the scheme of the request.
        """
        github_v2: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GithubV2ArgsDict']]
        """
        A `github_v2` block as defined below.
        """
        google_v2: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GoogleV2ArgsDict']]
        """
        A `google_v2` block as defined below.
        """
        http_route_api_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        microsoft_v2: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2ArgsDict']]
        """
        A `microsoft_v2` block as defined below.
        """
        require_authentication: NotRequired[pulumi.Input[bool]]
        """
        Should the authentication flow be used for all requests.
        """
        require_https: NotRequired[pulumi.Input[bool]]
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        twitter_v2: NotRequired[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2TwitterV2ArgsDict']]
        """
        A `twitter_v2` block as defined below.
        """
        unauthenticated_action: NotRequired[pulumi.Input[str]]
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2Args:
    def __init__(__self__, *,
                 login: pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2LoginArgs'],
                 active_directory_v2: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args']] = None,
                 apple_v2: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AppleV2Args']] = None,
                 auth_enabled: Optional[pulumi.Input[bool]] = None,
                 azure_static_web_app_v2: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args']] = None,
                 config_file_path: Optional[pulumi.Input[str]] = None,
                 custom_oidc_v2s: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2Args']]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 facebook_v2: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2FacebookV2Args']] = None,
                 forward_proxy_convention: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_scheme_header_name: Optional[pulumi.Input[str]] = None,
                 github_v2: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GithubV2Args']] = None,
                 google_v2: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GoogleV2Args']] = None,
                 http_route_api_prefix: Optional[pulumi.Input[str]] = None,
                 microsoft_v2: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2Args']] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 twitter_v2: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2TwitterV2Args']] = None,
                 unauthenticated_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2LoginArgs'] login: A `login` block as defined below.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2: An `active_directory_v2` block as defined below.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AppleV2Args'] apple_v2: An `apple_v2` block as defined below.
        :param pulumi.Input[bool] auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param pulumi.Input[str] config_file_path: The path to the App Auth settings.
               
               > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2Args']]] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param pulumi.Input[str] default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2FacebookV2Args'] facebook_v2: A `facebook_v2` block as defined below.
        :param pulumi.Input[str] forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param pulumi.Input[str] forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param pulumi.Input[str] forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GithubV2Args'] github_v2: A `github_v2` block as defined below.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GoogleV2Args'] google_v2: A `google_v2` block as defined below.
        :param pulumi.Input[str] http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2Args'] microsoft_v2: A `microsoft_v2` block as defined below.
        :param pulumi.Input[bool] require_authentication: Should the authentication flow be used for all requests.
        :param pulumi.Input[bool] require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param pulumi.Input[str] runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2TwitterV2Args'] twitter_v2: A `twitter_v2` block as defined below.
        :param pulumi.Input[str] unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2LoginArgs']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2LoginArgs']):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args']]:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @active_directory_v2.setter
    def active_directory_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args']]):
        pulumi.set(self, "active_directory_v2", value)

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AppleV2Args']]:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @apple_v2.setter
    def apple_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AppleV2Args']]):
        pulumi.set(self, "apple_v2", value)

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @auth_enabled.setter
    def auth_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auth_enabled", value)

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args']]:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @azure_static_web_app_v2.setter
    def azure_static_web_app_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args']]):
        pulumi.set(self, "azure_static_web_app_v2", value)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2Args']]]]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @custom_oidc_v2s.setter
    def custom_oidc_v2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2Args']]]]):
        pulumi.set(self, "custom_oidc_v2s", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2FacebookV2Args']]:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @facebook_v2.setter
    def facebook_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2FacebookV2Args']]):
        pulumi.set(self, "facebook_v2", value)

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @forward_proxy_convention.setter
    def forward_proxy_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_convention", value)

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @forward_proxy_custom_host_header_name.setter
    def forward_proxy_custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_host_header_name", value)

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @forward_proxy_custom_scheme_header_name.setter
    def forward_proxy_custom_scheme_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_scheme_header_name", value)

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GithubV2Args']]:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @github_v2.setter
    def github_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GithubV2Args']]):
        pulumi.set(self, "github_v2", value)

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GoogleV2Args']]:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @google_v2.setter
    def google_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2GoogleV2Args']]):
        pulumi.set(self, "google_v2", value)

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @http_route_api_prefix.setter
    def http_route_api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_route_api_prefix", value)

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2Args']]:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @microsoft_v2.setter
    def microsoft_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2Args']]):
        pulumi.set(self, "microsoft_v2", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2TwitterV2Args']]:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @twitter_v2.setter
    def twitter_v2(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotAuthSettingsV2TwitterV2Args']]):
        pulumi.set(self, "twitter_v2", value)

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")

    @unauthenticated_action.setter
    def unauthenticated_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_action", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        tenant_auth_endpoint: pulumi.Input[str]
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        allowed_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the certificate used for signing purposes.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        jwt_allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        jwt_allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Groups in the JWT Claim.
        """
        login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        www_authentication_disabled: NotRequired[pulumi.Input[bool]]
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 tenant_auth_endpoint: pulumi.Input[str],
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 jwt_allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jwt_allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 www_authentication_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[str] tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`
               
               > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param pulumi.Input[str] client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param pulumi.Input[bool] www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> pulumi.Input[str]:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @tenant_auth_endpoint.setter
    def tenant_auth_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_auth_endpoint", value)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @allowed_identities.setter
    def allowed_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_identities", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @jwt_allowed_client_applications.setter
    def jwt_allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_client_applications", value)

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @jwt_allowed_groups.setter
    def jwt_allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_groups", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        return pulumi.get(self, "www_authentication_disabled")

    @www_authentication_disabled.setter
    def www_authentication_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "www_authentication_disabled", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2AppleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2AppleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2AppleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Apple web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Apple Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: A list of Login Scopes provided by this Authentication Provider.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        name: pulumi.Input[str]
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        openid_configuration_endpoint: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        authorisation_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        certification_uri: NotRequired[pulumi.Input[str]]
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        client_credential_method: NotRequired[pulumi.Input[str]]
        """
        The Client Credential Method used.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        issuer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        name_claim_type: NotRequired[pulumi.Input[str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of the scopes that should be requested while authenticating.
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 openid_configuration_endpoint: pulumi.Input[str],
                 authorisation_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 client_credential_method: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 issuer_endpoint: Optional[pulumi.Input[str]] = None,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with the Custom OIDC.
        :param pulumi.Input[str] name: The name of the Custom OIDC Authentication Provider.
               
               > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        :param pulumi.Input[str] openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param pulumi.Input[str] authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] client_credential_method: The Client Credential Method used.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        :param pulumi.Input[str] issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of the scopes that should be requested while authenticating.
        :param pulumi.Input[str] token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @openid_configuration_endpoint.setter
    def openid_configuration_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "openid_configuration_endpoint", value)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @authorisation_endpoint.setter
    def authorisation_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorisation_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @client_credential_method.setter
    def client_credential_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_credential_method", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @issuer_endpoint.setter
    def issuer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_endpoint", value)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2FacebookV2ArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        graph_api_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Facebook API to be used while logging in.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2FacebookV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2FacebookV2Args:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret_setting_name: pulumi.Input[str],
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[str] graph_api_version: The version of the Facebook API to be used while logging in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of scopes that should be requested as part of Facebook Login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2GithubV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login..
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2GithubV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2GithubV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login..
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login..
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2GoogleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2GoogleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2GoogleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2LoginArgsDict(TypedDict):
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration_convention: NotRequired[pulumi.Input[str]]
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        cookie_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        logout_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to which logout requests should be made.
        """
        nonce_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[bool]]
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        token_refresh_extension_time: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        token_store_path: NotRequired[pulumi.Input[str]]
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        token_store_sas_setting_name: NotRequired[pulumi.Input[str]]
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        validate_nonce: NotRequired[pulumi.Input[bool]]
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration_convention: Optional[pulumi.Input[str]] = None,
                 cookie_expiration_time: Optional[pulumi.Input[str]] = None,
                 logout_endpoint: Optional[pulumi.Input[str]] = None,
                 nonce_expiration_time: Optional[pulumi.Input[str]] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 token_refresh_extension_time: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 token_store_path: Optional[pulumi.Input[str]] = None,
                 token_store_sas_setting_name: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param pulumi.Input[str] cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param pulumi.Input[str] cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param pulumi.Input[str] logout_endpoint: The endpoint to which logout requests should be made.
        :param pulumi.Input[str] nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param pulumi.Input[bool] preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param pulumi.Input[float] token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param pulumi.Input[str] token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param pulumi.Input[str] token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param pulumi.Input[bool] validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @cookie_expiration_convention.setter
    def cookie_expiration_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_convention", value)

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @cookie_expiration_time.setter
    def cookie_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_time", value)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @nonce_expiration_time.setter
    def nonce_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_time", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @token_refresh_extension_time.setter
    def token_refresh_extension_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_time", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @token_store_path.setter
    def token_store_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_path", value)

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @token_store_sas_setting_name.setter
    def token_store_sas_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_sas_setting_name", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxFunctionAppSlotAuthSettingsV2TwitterV2ArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
elif False:
    LinuxFunctionAppSlotAuthSettingsV2TwitterV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotAuthSettingsV2TwitterV2Args:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret_setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class LinuxFunctionAppSlotBackupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Backup.
        """
        schedule: pulumi.Input['LinuxFunctionAppSlotBackupScheduleArgsDict']
        """
        a `schedule` block as detailed below.
        """
        storage_account_url: pulumi.Input[str]
        """
        The SAS URL to the container.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Should this backup job be enabled? Defaults to `true`.
        """
elif False:
    LinuxFunctionAppSlotBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotBackupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['LinuxFunctionAppSlotBackupScheduleArgs'],
                 storage_account_url: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Backup.
        :param pulumi.Input['LinuxFunctionAppSlotBackupScheduleArgs'] schedule: a `schedule` block as detailed below.
        :param pulumi.Input[str] storage_account_url: The SAS URL to the container.
        :param pulumi.Input[bool] enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['LinuxFunctionAppSlotBackupScheduleArgs']:
        """
        a `schedule` block as detailed below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['LinuxFunctionAppSlotBackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> pulumi.Input[str]:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LinuxFunctionAppSlotBackupScheduleArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        """
        frequency_unit: pulumi.Input[str]
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        keep_at_least_one_backup: NotRequired[pulumi.Input[bool]]
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        last_execution_time: NotRequired[pulumi.Input[str]]
        """
        The time the backup was last attempted.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        When the schedule should start working in RFC-3339 format.
        """
elif False:
    LinuxFunctionAppSlotBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotBackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_unit: pulumi.Input[str],
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 last_execution_time: Optional[pulumi.Input[str]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        :param pulumi.Input[str] frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param pulumi.Input[bool] keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param pulumi.Input[str] last_execution_time: The time the backup was last attempted.
        :param pulumi.Input[int] retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param pulumi.Input[str] start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input[str]:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @last_execution_time.setter
    def last_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_execution_time", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class LinuxFunctionAppSlotConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Connection.
        """
        type: pulumi.Input[str]
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The connection string value.
        """
elif False:
    LinuxFunctionAppSlotConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name which should be used for this Connection.
        :param pulumi.Input[str] type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param pulumi.Input[str] value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LinuxFunctionAppSlotIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    LinuxFunctionAppSlotIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Linux Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App Slot.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        If this Linux Web App is Always On enabled. Defaults to `false`.
        """
        api_definition_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the API definition that describes this Linux Function App.
        """
        api_management_api_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the API Management API for this Linux Function App.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        """
        app_scale_limit: NotRequired[pulumi.Input[int]]
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        app_service_logs: NotRequired[pulumi.Input['LinuxFunctionAppSlotSiteConfigAppServiceLogsArgsDict']]
        """
        an `app_service_logs` block as detailed below.
        """
        application_insights_connection_string: NotRequired[pulumi.Input[str]]
        """
        The Connection String for linking the Linux Function App to Application Insights.
        """
        application_insights_key: NotRequired[pulumi.Input[str]]
        """
        The Instrumentation Key for connecting the Linux Function App to Application Insights.
        """
        application_stack: NotRequired[pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackArgsDict']]
        """
        an `application_stack` block as detailed below.
        """
        auto_swap_slot_name: NotRequired[pulumi.Input[str]]
        """
        The name of the slot to automatically swap with when this slot is successfully deployed.
        """
        container_registry_managed_identity_client_id: NotRequired[pulumi.Input[str]]
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        container_registry_use_managed_identity: NotRequired[pulumi.Input[bool]]
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        cors: NotRequired[pulumi.Input['LinuxFunctionAppSlotSiteConfigCorsArgsDict']]
        """
        a `cors` block as detailed below.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        detailed_error_logging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is detailed error logging enabled
        """
        elastic_instance_minimum: NotRequired[pulumi.Input[int]]
        """
        The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        """
        ftps_state: NotRequired[pulumi.Input[str]]
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        health_check_eviction_time_in_min: NotRequired[pulumi.Input[int]]
        """
        The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `0`. Only valid in conjunction with `health_check_path`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The path to be checked for this function app health.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionArgsDict']]]]
        """
        an `ip_restriction` block as detailed below.
        """
        linux_fx_version: NotRequired[pulumi.Input[str]]
        """
        The Linux FX Version
        """
        load_balancing_mode: NotRequired[pulumi.Input[str]]
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        pre_warmed_instance_count: NotRequired[pulumi.Input[int]]
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        """
        runtime_scale_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Functions Runtime Scale Monitoring be enabled.

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        scm_ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgsDict']]]]
        """
        a `scm_ip_restriction` block as detailed below.
        """
        scm_minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        """
        The SCM Type in use by the Linux Function App.
        """
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        """
        use32_bit_worker: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App use a 32-bit worker.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        worker_count: NotRequired[pulumi.Input[int]]
        """
        The number of Workers for this Linux Function App.
        """
elif False:
    LinuxFunctionAppSlotSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 api_definition_url: Optional[pulumi.Input[str]] = None,
                 api_management_api_id: Optional[pulumi.Input[str]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 app_scale_limit: Optional[pulumi.Input[int]] = None,
                 app_service_logs: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigAppServiceLogsArgs']] = None,
                 application_insights_connection_string: Optional[pulumi.Input[str]] = None,
                 application_insights_key: Optional[pulumi.Input[str]] = None,
                 application_stack: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackArgs']] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
                 container_registry_managed_identity_client_id: Optional[pulumi.Input[str]] = None,
                 container_registry_use_managed_identity: Optional[pulumi.Input[bool]] = None,
                 cors: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 elastic_instance_minimum: Optional[pulumi.Input[int]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_eviction_time_in_min: Optional[pulumi.Input[int]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionArgs']]]] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 load_balancing_mode: Optional[pulumi.Input[str]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 pre_warmed_instance_count: Optional[pulumi.Input[int]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 runtime_scale_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 scm_ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 worker_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] always_on: If this Linux Web App is Always On enabled. Defaults to `false`.
        :param pulumi.Input[str] api_definition_url: The URL of the API definition that describes this Linux Function App.
        :param pulumi.Input[str] api_management_api_id: The ID of the API Management API for this Linux Function App.
        :param pulumi.Input[str] app_command_line: The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        :param pulumi.Input[int] app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param pulumi.Input['LinuxFunctionAppSlotSiteConfigAppServiceLogsArgs'] app_service_logs: an `app_service_logs` block as detailed below.
        :param pulumi.Input[str] application_insights_connection_string: The Connection String for linking the Linux Function App to Application Insights.
        :param pulumi.Input[str] application_insights_key: The Instrumentation Key for connecting the Linux Function App to Application Insights.
        :param pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackArgs'] application_stack: an `application_stack` block as detailed below.
        :param pulumi.Input[str] auto_swap_slot_name: The name of the slot to automatically swap with when this slot is successfully deployed.
        :param pulumi.Input[str] container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param pulumi.Input[bool] container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param pulumi.Input['LinuxFunctionAppSlotSiteConfigCorsArgs'] cors: a `cors` block as detailed below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param pulumi.Input[bool] detailed_error_logging_enabled: Is detailed error logging enabled
        :param pulumi.Input[int] elastic_instance_minimum: The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        :param pulumi.Input[str] ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param pulumi.Input[int] health_check_eviction_time_in_min: The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `0`. Only valid in conjunction with `health_check_path`.
        :param pulumi.Input[str] health_check_path: The path to be checked for this function app health.
        :param pulumi.Input[bool] http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param pulumi.Input[str] ip_restriction_default_action: The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionArgs']]] ip_restrictions: an `ip_restriction` block as detailed below.
        :param pulumi.Input[str] linux_fx_version: The Linux FX Version
        :param pulumi.Input[str] load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param pulumi.Input[str] managed_pipeline_mode: The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[int] pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        :param pulumi.Input[bool] remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        :param pulumi.Input[bool] runtime_scale_monitoring_enabled: Should Functions Runtime Scale Monitoring be enabled.
               
               > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        :param pulumi.Input[str] scm_ip_restriction_default_action: The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: a `scm_ip_restriction` block as detailed below.
        :param pulumi.Input[str] scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[str] scm_type: The SCM Type in use by the Linux Function App.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        :param pulumi.Input[bool] use32_bit_worker: Should the Linux Web App use a 32-bit worker.
        :param pulumi.Input[bool] vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param pulumi.Input[bool] websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param pulumi.Input[int] worker_count: The number of Workers for this Linux Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restriction_default_action is not None:
            pulumi.set(__self__, "ip_restriction_default_action", ip_restriction_default_action)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restriction_default_action is not None:
            pulumi.set(__self__, "scm_ip_restriction_default_action", scm_ip_restriction_default_action)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        If this Linux Web App is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the API definition that describes this Linux Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @api_definition_url.setter
    def api_definition_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_definition_url", value)

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the API Management API for this Linux Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @api_management_api_id.setter
    def api_management_api_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_management_api_id", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @app_scale_limit.setter
    def app_scale_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "app_scale_limit", value)

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigAppServiceLogsArgs']]:
        """
        an `app_service_logs` block as detailed below.
        """
        return pulumi.get(self, "app_service_logs")

    @app_service_logs.setter
    def app_service_logs(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigAppServiceLogsArgs']]):
        pulumi.set(self, "app_service_logs", value)

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        The Connection String for linking the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @application_insights_connection_string.setter
    def application_insights_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_insights_connection_string", value)

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Instrumentation Key for connecting the Linux Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @application_insights_key.setter
    def application_insights_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_insights_key", value)

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackArgs']]:
        """
        an `application_stack` block as detailed below.
        """
        return pulumi.get(self, "application_stack")

    @application_stack.setter
    def application_stack(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackArgs']]):
        pulumi.set(self, "application_stack", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the slot to automatically swap with when this slot is successfully deployed.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @container_registry_managed_identity_client_id.setter
    def container_registry_managed_identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_registry_managed_identity_client_id", value)

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[pulumi.Input[bool]]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @container_registry_use_managed_identity.setter
    def container_registry_use_managed_identity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_registry_use_managed_identity", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigCorsArgs']]:
        """
        a `cors` block as detailed below.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is detailed error logging enabled
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @elastic_instance_minimum.setter
    def elastic_instance_minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "elastic_instance_minimum", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `0`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @health_check_eviction_time_in_min.setter
    def health_check_eviction_time_in_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_eviction_time_in_min", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictionDefaultAction")
    def ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "ip_restriction_default_action")

    @ip_restriction_default_action.setter
    def ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionArgs']]]]:
        """
        an `ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Linux FX Version
        """
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @load_balancing_mode.setter
    def load_balancing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancing_mode", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @pre_warmed_instance_count.setter
    def pre_warmed_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pre_warmed_instance_count", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Functions Runtime Scale Monitoring be enabled.

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @runtime_scale_monitoring_enabled.setter
    def runtime_scale_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "runtime_scale_monitoring_enabled", value)

    @property
    @pulumi.getter(name="scmIpRestrictionDefaultAction")
    def scm_ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "scm_ip_restriction_default_action")

    @scm_ip_restriction_default_action.setter
    def scm_ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgs']]]]:
        """
        a `scm_ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @scm_minimum_tls_version.setter
    def scm_minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_minimum_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        """
        The SCM Type in use by the Linux Function App.
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App use a 32-bit worker.
        """
        return pulumi.get(self, "use32_bit_worker")

    @use32_bit_worker.setter
    def use32_bit_worker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Workers for this Linux Function App.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteConfigAppServiceLogsArgsDict(TypedDict):
        disk_quota_mb: NotRequired[pulumi.Input[int]]
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
elif False:
    LinuxFunctionAppSlotSiteConfigAppServiceLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteConfigAppServiceLogsArgs:
    def __init__(__self__, *,
                 disk_quota_mb: Optional[pulumi.Input[int]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        :param pulumi.Input[int] retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
               
               > **NOTE:** This block is not supported on Consumption plans.
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @disk_quota_mb.setter
    def disk_quota_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_quota_mb", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteConfigApplicationStackArgsDict(TypedDict):
        dockers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgsDict']]]]
        """
        a `docker` block as detailed below.
        """
        dotnet_version: NotRequired[pulumi.Input[str]]
        """
        The version of .Net. Possible values are `3.1`, `6.0`, `7.0` and `8.0`.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
        """
        node_version: NotRequired[pulumi.Input[str]]
        """
        The version of Node to use. Possible values include `12`, `14`, `16`, `18` and `20`
        """
        powershell_core_version: NotRequired[pulumi.Input[str]]
        """
        The version of PowerShell Core to use. Possibles values are `7` , `7.2`, and `7.4`.
        """
        python_version: NotRequired[pulumi.Input[str]]
        """
        The version of Python to use. Possible values are `3.12`, `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        """
        use_custom_runtime: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Function App use a custom runtime?
        """
        use_dotnet_isolated_runtime: NotRequired[pulumi.Input[bool]]
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
elif False:
    LinuxFunctionAppSlotSiteConfigApplicationStackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteConfigApplicationStackArgs:
    def __init__(__self__, *,
                 dockers: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgs']]]] = None,
                 dotnet_version: Optional[pulumi.Input[str]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 node_version: Optional[pulumi.Input[str]] = None,
                 powershell_core_version: Optional[pulumi.Input[str]] = None,
                 python_version: Optional[pulumi.Input[str]] = None,
                 use_custom_runtime: Optional[pulumi.Input[bool]] = None,
                 use_dotnet_isolated_runtime: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgs']]] dockers: a `docker` block as detailed below.
        :param pulumi.Input[str] dotnet_version: The version of .Net. Possible values are `3.1`, `6.0`, `7.0` and `8.0`.
        :param pulumi.Input[str] java_version: The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
        :param pulumi.Input[str] node_version: The version of Node to use. Possible values include `12`, `14`, `16`, `18` and `20`
        :param pulumi.Input[str] powershell_core_version: The version of PowerShell Core to use. Possibles values are `7` , `7.2`, and `7.4`.
        :param pulumi.Input[str] python_version: The version of Python to use. Possible values are `3.12`, `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        :param pulumi.Input[bool] use_custom_runtime: Should the Linux Function App use a custom runtime?
        :param pulumi.Input[bool] use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dockers is not None:
            pulumi.set(__self__, "dockers", dockers)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter
    def dockers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgs']]]]:
        """
        a `docker` block as detailed below.
        """
        return pulumi.get(self, "dockers")

    @dockers.setter
    def dockers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgs']]]]):
        pulumi.set(self, "dockers", value)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .Net. Possible values are `3.1`, `6.0`, `7.0` and `8.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @dotnet_version.setter
    def dotnet_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Node to use. Possible values include `12`, `14`, `16`, `18` and `20`
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of PowerShell Core to use. Possibles values are `7` , `7.2`, and `7.4`.
        """
        return pulumi.get(self, "powershell_core_version")

    @powershell_core_version.setter
    def powershell_core_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "powershell_core_version", value)

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Python to use. Possible values are `3.12`, `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
        """
        return pulumi.get(self, "python_version")

    @python_version.setter
    def python_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "python_version", value)

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @use_custom_runtime.setter
    def use_custom_runtime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_custom_runtime", value)

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")

    @use_dotnet_isolated_runtime.setter
    def use_dotnet_isolated_runtime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_dotnet_isolated_runtime", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgsDict(TypedDict):
        image_name: pulumi.Input[str]
        """
        The name of the Docker image to use.
        """
        image_tag: pulumi.Input[str]
        """
        The image tag of the image to use.
        """
        registry_url: pulumi.Input[str]
        """
        The URL of the docker registry.
        """
        registry_password: NotRequired[pulumi.Input[str]]
        """
        The password for the account to use to connect to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        registry_username: NotRequired[pulumi.Input[str]]
        """
        The username to use for connections to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
elif False:
    LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteConfigApplicationStackDockerArgs:
    def __init__(__self__, *,
                 image_name: pulumi.Input[str],
                 image_tag: pulumi.Input[str],
                 registry_url: pulumi.Input[str],
                 registry_password: Optional[pulumi.Input[str]] = None,
                 registry_username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_name: The name of the Docker image to use.
        :param pulumi.Input[str] image_tag: The image tag of the image to use.
        :param pulumi.Input[str] registry_url: The URL of the docker registry.
        :param pulumi.Input[str] registry_password: The password for the account to use to connect to the registry.
               
               > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        :param pulumi.Input[str] registry_username: The username to use for connections to the registry.
               
               > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_tag", image_tag)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        """
        The name of the Docker image to use.
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="imageTag")
    def image_tag(self) -> pulumi.Input[str]:
        """
        The image tag of the image to use.
        """
        return pulumi.get(self, "image_tag")

    @image_tag.setter
    def image_tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_tag", value)

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> pulumi.Input[str]:
        """
        The URL of the docker registry.
        """
        return pulumi.get(self, "registry_url")

    @registry_url.setter
    def registry_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_url", value)

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password for the account to use to connect to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        return pulumi.get(self, "registry_password")

    @registry_password.setter
    def registry_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_password", value)

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use for connections to the registry.

        > **NOTE:** This value is required if `container_registry_use_managed_identity` is not set to `true`.
        """
        return pulumi.get(self, "registry_username")

    @registry_username.setter
    def registry_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_username", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
elif False:
    LinuxFunctionAppSlotSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param pulumi.Input[bool] support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict']]
        """
        a `headers` block as detailed below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    LinuxFunctionAppSlotSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgs'] headers: a `headers` block as detailed below.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgs']]:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        a `headers` block as detailed below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs'] headers: a `headers` block as detailed below.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class LinuxFunctionAppSlotSiteCredentialArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Username used for publishing.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Password used for publishing.
        """
elif False:
    LinuxFunctionAppSlotSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotSiteCredentialArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Site Credentials Username used for publishing.
        :param pulumi.Input[str] password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Username used for publishing.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class LinuxFunctionAppSlotStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The Access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The Name of the Storage Account.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this Storage Account.
        """
        share_name: pulumi.Input[str]
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        type: pulumi.Input[str]
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path at which to mount the storage share.
        """
elif False:
    LinuxFunctionAppSlotStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppSlotStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The Access key for the storage account.
        :param pulumi.Input[str] account_name: The Name of the Storage Account.
        :param pulumi.Input[str] name: The name which should be used for this Storage Account.
        :param pulumi.Input[str] share_name: The Name of the File Share or Container Name for Blob storage.
        :param pulumi.Input[str] type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        :param pulumi.Input[str] mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class LinuxFunctionAppStickySettingsArgsDict(TypedDict):
        app_setting_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        connection_string_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
elif False:
    LinuxFunctionAppStickySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppStickySettingsArgs:
    def __init__(__self__, *,
                 app_setting_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 connection_string_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_setting_names: A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] connection_string_names: A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of `app_setting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @app_setting_names.setter
    def app_setting_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_setting_names", value)

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of `connection_string` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")

    @connection_string_names.setter
    def connection_string_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "connection_string_names", value)


if not MYPY:
    class LinuxFunctionAppStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The Access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The Name of the Storage Account.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this Storage Account.
        """
        share_name: pulumi.Input[str]
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        type: pulumi.Input[str]
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path at which to mount the storage share.
        """
elif False:
    LinuxFunctionAppStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxFunctionAppStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The Access key for the storage account.
        :param pulumi.Input[str] account_name: The Name of the Storage Account.
        :param pulumi.Input[str] name: The name which should be used for this Storage Account.
        :param pulumi.Input[str] share_name: The Name of the File Share or Container Name for Blob storage.
        :param pulumi.Input[str] type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        :param pulumi.Input[str] mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class LinuxWebAppAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        active_directory: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsActiveDirectoryArgsDict']]
        """
        An `active_directory` block as defined above.
        """
        additional_login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        facebook: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        github: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsGithubArgsDict']]
        """
        A `github` block as defined below.
        """
        google: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
elif False:
    LinuxWebAppAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['LinuxWebAppAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['LinuxWebAppAuthSettingsFacebookArgs']] = None,
                 github: Optional[pulumi.Input['LinuxWebAppAuthSettingsGithubArgs']] = None,
                 google: Optional[pulumi.Input['LinuxWebAppAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['LinuxWebAppAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['LinuxWebAppAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Authentication / Authorization feature be enabled for the Linux Web App?
        :param pulumi.Input['LinuxWebAppAuthSettingsActiveDirectoryArgs'] active_directory: An `active_directory` block as defined above.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param pulumi.Input[str] default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`
               
               > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        :param pulumi.Input['LinuxWebAppAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['LinuxWebAppAuthSettingsGithubArgs'] github: A `github` block as defined below.
        :param pulumi.Input['LinuxWebAppAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['LinuxWebAppAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param pulumi.Input['LinuxWebAppAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsActiveDirectoryArgs']]:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @additional_login_parameters.setter
    def additional_login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_parameters", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsGithubArgs']]:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class LinuxWebAppAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
elif False:
    LinuxWebAppAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param pulumi.Input[str] client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class LinuxWebAppAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret: NotRequired[pulumi.Input[str]]
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
elif False:
    LinuxWebAppAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxWebAppAuthSettingsGithubArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
elif False:
    LinuxWebAppAuthSettingsGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsGithubArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login.
        :param pulumi.Input[str] client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxWebAppAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
elif False:
    LinuxWebAppAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxWebAppAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
elif False:
    LinuxWebAppAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxWebAppAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
elif False:
    LinuxWebAppAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2ArgsDict(TypedDict):
        login: pulumi.Input['LinuxWebAppAuthSettingsV2LoginArgsDict']
        """
        A `login` block as defined below.
        """
        active_directory_v2: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsV2ActiveDirectoryV2ArgsDict']]
        """
        An `active_directory_v2` block as defined below.
        """
        apple_v2: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsV2AppleV2ArgsDict']]
        """
        An `apple_v2` block as defined below.
        """
        auth_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        azure_static_web_app_v2: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsV2AzureStaticWebAppV2ArgsDict']]
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        config_file_path: NotRequired[pulumi.Input[str]]
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        custom_oidc_v2s: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppAuthSettingsV2CustomOidcV2ArgsDict']]]]
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        facebook_v2: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsV2FacebookV2ArgsDict']]
        """
        A `facebook_v2` block as defined below.
        """
        forward_proxy_convention: NotRequired[pulumi.Input[str]]
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        forward_proxy_custom_host_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the host of the request.
        """
        forward_proxy_custom_scheme_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the scheme of the request.
        """
        github_v2: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsV2GithubV2ArgsDict']]
        """
        A `github_v2` block as defined below.
        """
        google_v2: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsV2GoogleV2ArgsDict']]
        """
        A `google_v2` block as defined below.
        """
        http_route_api_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        microsoft_v2: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsV2MicrosoftV2ArgsDict']]
        """
        A `microsoft_v2` block as defined below.
        """
        require_authentication: NotRequired[pulumi.Input[bool]]
        """
        Should the authentication flow be used for all requests.
        """
        require_https: NotRequired[pulumi.Input[bool]]
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        twitter_v2: NotRequired[pulumi.Input['LinuxWebAppAuthSettingsV2TwitterV2ArgsDict']]
        """
        A `twitter_v2` block as defined below.
        """
        unauthenticated_action: NotRequired[pulumi.Input[str]]
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
elif False:
    LinuxWebAppAuthSettingsV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2Args:
    def __init__(__self__, *,
                 login: pulumi.Input['LinuxWebAppAuthSettingsV2LoginArgs'],
                 active_directory_v2: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2ActiveDirectoryV2Args']] = None,
                 apple_v2: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2AppleV2Args']] = None,
                 auth_enabled: Optional[pulumi.Input[bool]] = None,
                 azure_static_web_app_v2: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2AzureStaticWebAppV2Args']] = None,
                 config_file_path: Optional[pulumi.Input[str]] = None,
                 custom_oidc_v2s: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppAuthSettingsV2CustomOidcV2Args']]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 facebook_v2: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2FacebookV2Args']] = None,
                 forward_proxy_convention: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_scheme_header_name: Optional[pulumi.Input[str]] = None,
                 github_v2: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2GithubV2Args']] = None,
                 google_v2: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2GoogleV2Args']] = None,
                 http_route_api_prefix: Optional[pulumi.Input[str]] = None,
                 microsoft_v2: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2MicrosoftV2Args']] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 twitter_v2: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2TwitterV2Args']] = None,
                 unauthenticated_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['LinuxWebAppAuthSettingsV2LoginArgs'] login: A `login` block as defined below.
        :param pulumi.Input['LinuxWebAppAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2: An `active_directory_v2` block as defined below.
        :param pulumi.Input['LinuxWebAppAuthSettingsV2AppleV2Args'] apple_v2: An `apple_v2` block as defined below.
        :param pulumi.Input[bool] auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param pulumi.Input['LinuxWebAppAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param pulumi.Input[str] config_file_path: The path to the App Auth settings.
               
               > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppAuthSettingsV2CustomOidcV2Args']]] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param pulumi.Input[str] default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param pulumi.Input['LinuxWebAppAuthSettingsV2FacebookV2Args'] facebook_v2: A `facebook_v2` block as defined below.
        :param pulumi.Input[str] forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param pulumi.Input[str] forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param pulumi.Input[str] forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param pulumi.Input['LinuxWebAppAuthSettingsV2GithubV2Args'] github_v2: A `github_v2` block as defined below.
        :param pulumi.Input['LinuxWebAppAuthSettingsV2GoogleV2Args'] google_v2: A `google_v2` block as defined below.
        :param pulumi.Input[str] http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param pulumi.Input['LinuxWebAppAuthSettingsV2MicrosoftV2Args'] microsoft_v2: A `microsoft_v2` block as defined below.
        :param pulumi.Input[bool] require_authentication: Should the authentication flow be used for all requests.
        :param pulumi.Input[bool] require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param pulumi.Input[str] runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param pulumi.Input['LinuxWebAppAuthSettingsV2TwitterV2Args'] twitter_v2: A `twitter_v2` block as defined below.
        :param pulumi.Input[str] unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> pulumi.Input['LinuxWebAppAuthSettingsV2LoginArgs']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: pulumi.Input['LinuxWebAppAuthSettingsV2LoginArgs']):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsV2ActiveDirectoryV2Args']]:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @active_directory_v2.setter
    def active_directory_v2(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2ActiveDirectoryV2Args']]):
        pulumi.set(self, "active_directory_v2", value)

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsV2AppleV2Args']]:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @apple_v2.setter
    def apple_v2(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2AppleV2Args']]):
        pulumi.set(self, "apple_v2", value)

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @auth_enabled.setter
    def auth_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auth_enabled", value)

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsV2AzureStaticWebAppV2Args']]:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @azure_static_web_app_v2.setter
    def azure_static_web_app_v2(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2AzureStaticWebAppV2Args']]):
        pulumi.set(self, "azure_static_web_app_v2", value)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppAuthSettingsV2CustomOidcV2Args']]]]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @custom_oidc_v2s.setter
    def custom_oidc_v2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppAuthSettingsV2CustomOidcV2Args']]]]):
        pulumi.set(self, "custom_oidc_v2s", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsV2FacebookV2Args']]:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @facebook_v2.setter
    def facebook_v2(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2FacebookV2Args']]):
        pulumi.set(self, "facebook_v2", value)

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @forward_proxy_convention.setter
    def forward_proxy_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_convention", value)

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @forward_proxy_custom_host_header_name.setter
    def forward_proxy_custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_host_header_name", value)

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @forward_proxy_custom_scheme_header_name.setter
    def forward_proxy_custom_scheme_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_scheme_header_name", value)

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsV2GithubV2Args']]:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @github_v2.setter
    def github_v2(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2GithubV2Args']]):
        pulumi.set(self, "github_v2", value)

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsV2GoogleV2Args']]:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @google_v2.setter
    def google_v2(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2GoogleV2Args']]):
        pulumi.set(self, "google_v2", value)

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @http_route_api_prefix.setter
    def http_route_api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_route_api_prefix", value)

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsV2MicrosoftV2Args']]:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @microsoft_v2.setter
    def microsoft_v2(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2MicrosoftV2Args']]):
        pulumi.set(self, "microsoft_v2", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional[pulumi.Input['LinuxWebAppAuthSettingsV2TwitterV2Args']]:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @twitter_v2.setter
    def twitter_v2(self, value: Optional[pulumi.Input['LinuxWebAppAuthSettingsV2TwitterV2Args']]):
        pulumi.set(self, "twitter_v2", value)

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")

    @unauthenticated_action.setter
    def unauthenticated_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_action", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2ActiveDirectoryV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        tenant_auth_endpoint: pulumi.Input[str]
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        allowed_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the certificate used for signing purposes.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        jwt_allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        jwt_allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Groups in the JWT Claim.
        """
        login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        www_authentication_disabled: NotRequired[pulumi.Input[bool]]
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
elif False:
    LinuxWebAppAuthSettingsV2ActiveDirectoryV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2ActiveDirectoryV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 tenant_auth_endpoint: pulumi.Input[str],
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 jwt_allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jwt_allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 www_authentication_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[str] tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`
               
               > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param pulumi.Input[str] client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param pulumi.Input[bool] www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> pulumi.Input[str]:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @tenant_auth_endpoint.setter
    def tenant_auth_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_auth_endpoint", value)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @allowed_identities.setter
    def allowed_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_identities", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @jwt_allowed_client_applications.setter
    def jwt_allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_client_applications", value)

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @jwt_allowed_groups.setter
    def jwt_allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_groups", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        return pulumi.get(self, "www_authentication_disabled")

    @www_authentication_disabled.setter
    def www_authentication_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "www_authentication_disabled", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2AppleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
elif False:
    LinuxWebAppAuthSettingsV2AppleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2AppleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Apple web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Apple Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: A list of Login Scopes provided by this Authentication Provider.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2AzureStaticWebAppV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
elif False:
    LinuxWebAppAuthSettingsV2AzureStaticWebAppV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2AzureStaticWebAppV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2CustomOidcV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        name: pulumi.Input[str]
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        openid_configuration_endpoint: pulumi.Input[str]
        """
        Specifies the endpoint used for OpenID Connect Discovery. For example `https://example.com/.well-known/openid-configuration`.
        """
        authorisation_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        certification_uri: NotRequired[pulumi.Input[str]]
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        client_credential_method: NotRequired[pulumi.Input[str]]
        """
        The Client Credential Method used.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        issuer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        name_claim_type: NotRequired[pulumi.Input[str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of the scopes that should be requested while authenticating.
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
elif False:
    LinuxWebAppAuthSettingsV2CustomOidcV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2CustomOidcV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 openid_configuration_endpoint: pulumi.Input[str],
                 authorisation_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 client_credential_method: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 issuer_endpoint: Optional[pulumi.Input[str]] = None,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with the Custom OIDC.
        :param pulumi.Input[str] name: The name of the Custom OIDC Authentication Provider.
               
               > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        :param pulumi.Input[str] openid_configuration_endpoint: Specifies the endpoint used for OpenID Connect Discovery. For example `https://example.com/.well-known/openid-configuration`.
        :param pulumi.Input[str] authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] client_credential_method: The Client Credential Method used.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        :param pulumi.Input[str] issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of the scopes that should be requested while authenticating.
        :param pulumi.Input[str] token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> pulumi.Input[str]:
        """
        Specifies the endpoint used for OpenID Connect Discovery. For example `https://example.com/.well-known/openid-configuration`.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @openid_configuration_endpoint.setter
    def openid_configuration_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "openid_configuration_endpoint", value)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @authorisation_endpoint.setter
    def authorisation_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorisation_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @client_credential_method.setter
    def client_credential_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_credential_method", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @issuer_endpoint.setter
    def issuer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_endpoint", value)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2FacebookV2ArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        graph_api_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Facebook API to be used while logging in.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
elif False:
    LinuxWebAppAuthSettingsV2FacebookV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2FacebookV2Args:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret_setting_name: pulumi.Input[str],
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[str] graph_api_version: The version of the Facebook API to be used while logging in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of scopes that should be requested as part of Facebook Login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2GithubV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login..
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
elif False:
    LinuxWebAppAuthSettingsV2GithubV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2GithubV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login..
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login..
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2GoogleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
elif False:
    LinuxWebAppAuthSettingsV2GoogleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2GoogleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2LoginArgsDict(TypedDict):
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration_convention: NotRequired[pulumi.Input[str]]
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        cookie_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        logout_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to which logout requests should be made.
        """
        nonce_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[bool]]
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        token_refresh_extension_time: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        token_store_path: NotRequired[pulumi.Input[str]]
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        token_store_sas_setting_name: NotRequired[pulumi.Input[str]]
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        validate_nonce: NotRequired[pulumi.Input[bool]]
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
elif False:
    LinuxWebAppAuthSettingsV2LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration_convention: Optional[pulumi.Input[str]] = None,
                 cookie_expiration_time: Optional[pulumi.Input[str]] = None,
                 logout_endpoint: Optional[pulumi.Input[str]] = None,
                 nonce_expiration_time: Optional[pulumi.Input[str]] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 token_refresh_extension_time: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 token_store_path: Optional[pulumi.Input[str]] = None,
                 token_store_sas_setting_name: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param pulumi.Input[str] cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param pulumi.Input[str] cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param pulumi.Input[str] logout_endpoint: The endpoint to which logout requests should be made.
        :param pulumi.Input[str] nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param pulumi.Input[bool] preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param pulumi.Input[float] token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param pulumi.Input[str] token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param pulumi.Input[str] token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param pulumi.Input[bool] validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @cookie_expiration_convention.setter
    def cookie_expiration_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_convention", value)

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @cookie_expiration_time.setter
    def cookie_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_time", value)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @nonce_expiration_time.setter
    def nonce_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_time", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @token_refresh_extension_time.setter
    def token_refresh_extension_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_time", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @token_store_path.setter
    def token_store_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_path", value)

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @token_store_sas_setting_name.setter
    def token_store_sas_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_sas_setting_name", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2MicrosoftV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
elif False:
    LinuxWebAppAuthSettingsV2MicrosoftV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2MicrosoftV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppAuthSettingsV2TwitterV2ArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
elif False:
    LinuxWebAppAuthSettingsV2TwitterV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppAuthSettingsV2TwitterV2Args:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret_setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class LinuxWebAppBackupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Backup.
        """
        schedule: pulumi.Input['LinuxWebAppBackupScheduleArgsDict']
        """
        A `schedule` block as defined below.
        """
        storage_account_url: pulumi.Input[str]
        """
        The SAS URL to the container.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Should this backup job be enabled? Defaults to `true`.
        """
elif False:
    LinuxWebAppBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppBackupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['LinuxWebAppBackupScheduleArgs'],
                 storage_account_url: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Backup.
        :param pulumi.Input['LinuxWebAppBackupScheduleArgs'] schedule: A `schedule` block as defined below.
        :param pulumi.Input[str] storage_account_url: The SAS URL to the container.
        :param pulumi.Input[bool] enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['LinuxWebAppBackupScheduleArgs']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['LinuxWebAppBackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> pulumi.Input[str]:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LinuxWebAppBackupScheduleArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        frequency_unit: pulumi.Input[str]
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        keep_at_least_one_backup: NotRequired[pulumi.Input[bool]]
        """
        Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        """
        last_execution_time: NotRequired[pulumi.Input[str]]
        """
        The time the backup was last attempted.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        When the schedule should start working in RFC-3339 format.
        """
elif False:
    LinuxWebAppBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppBackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_unit: pulumi.Input[str],
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 last_execution_time: Optional[pulumi.Input[str]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        :param pulumi.Input[str] frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param pulumi.Input[bool] keep_at_least_one_backup: Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        :param pulumi.Input[str] last_execution_time: The time the backup was last attempted.
        :param pulumi.Input[int] retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param pulumi.Input[str] start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input[str]:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @last_execution_time.setter
    def last_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_execution_time", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class LinuxWebAppConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Connection String.
        """
        type: pulumi.Input[str]
        """
        Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        """
        value: pulumi.Input[str]
        """
        The connection string value.
        """
elif False:
    LinuxWebAppConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Connection String.
        :param pulumi.Input[str] type: Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        :param pulumi.Input[str] value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LinuxWebAppIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Web App. Possible values are `SystemAssigned`, `UserAssigned`, and `SystemAssigned, UserAssigned` (to enable both).
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    LinuxWebAppIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Linux Web App. Possible values are `SystemAssigned`, `UserAssigned`, and `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Web App. Possible values are `SystemAssigned`, `UserAssigned`, and `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class LinuxWebAppLogsArgsDict(TypedDict):
        application_logs: NotRequired[pulumi.Input['LinuxWebAppLogsApplicationLogsArgsDict']]
        """
        A `application_logs` block as defined above.
        """
        detailed_error_messages: NotRequired[pulumi.Input[bool]]
        """
        Should detailed error messages be enabled?
        """
        failed_request_tracing: NotRequired[pulumi.Input[bool]]
        """
        Should the failed request tracing be enabled?
        """
        http_logs: NotRequired[pulumi.Input['LinuxWebAppLogsHttpLogsArgsDict']]
        """
        An `http_logs` block as defined above.
        """
elif False:
    LinuxWebAppLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppLogsArgs:
    def __init__(__self__, *,
                 application_logs: Optional[pulumi.Input['LinuxWebAppLogsApplicationLogsArgs']] = None,
                 detailed_error_messages: Optional[pulumi.Input[bool]] = None,
                 failed_request_tracing: Optional[pulumi.Input[bool]] = None,
                 http_logs: Optional[pulumi.Input['LinuxWebAppLogsHttpLogsArgs']] = None):
        """
        :param pulumi.Input['LinuxWebAppLogsApplicationLogsArgs'] application_logs: A `application_logs` block as defined above.
        :param pulumi.Input[bool] detailed_error_messages: Should detailed error messages be enabled?
        :param pulumi.Input[bool] failed_request_tracing: Should the failed request tracing be enabled?
        :param pulumi.Input['LinuxWebAppLogsHttpLogsArgs'] http_logs: An `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional[pulumi.Input['LinuxWebAppLogsApplicationLogsArgs']]:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @application_logs.setter
    def application_logs(self, value: Optional[pulumi.Input['LinuxWebAppLogsApplicationLogsArgs']]):
        pulumi.set(self, "application_logs", value)

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[pulumi.Input[bool]]:
        """
        Should detailed error messages be enabled?
        """
        return pulumi.get(self, "detailed_error_messages")

    @detailed_error_messages.setter
    def detailed_error_messages(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_messages", value)

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the failed request tracing be enabled?
        """
        return pulumi.get(self, "failed_request_tracing")

    @failed_request_tracing.setter
    def failed_request_tracing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failed_request_tracing", value)

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional[pulumi.Input['LinuxWebAppLogsHttpLogsArgs']]:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")

    @http_logs.setter
    def http_logs(self, value: Optional[pulumi.Input['LinuxWebAppLogsHttpLogsArgs']]):
        pulumi.set(self, "http_logs", value)


if not MYPY:
    class LinuxWebAppLogsApplicationLogsArgsDict(TypedDict):
        file_system_level: pulumi.Input[str]
        """
        Log level. Possible values include: `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        """
        azure_blob_storage: NotRequired[pulumi.Input['LinuxWebAppLogsApplicationLogsAzureBlobStorageArgsDict']]
        """
        An `azure_blob_storage` block as defined below.
        """
elif False:
    LinuxWebAppLogsApplicationLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppLogsApplicationLogsArgs:
    def __init__(__self__, *,
                 file_system_level: pulumi.Input[str],
                 azure_blob_storage: Optional[pulumi.Input['LinuxWebAppLogsApplicationLogsAzureBlobStorageArgs']] = None):
        """
        :param pulumi.Input[str] file_system_level: Log level. Possible values include: `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        :param pulumi.Input['LinuxWebAppLogsApplicationLogsAzureBlobStorageArgs'] azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> pulumi.Input[str]:
        """
        Log level. Possible values include: `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @file_system_level.setter
    def file_system_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_system_level", value)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['LinuxWebAppLogsApplicationLogsAzureBlobStorageArgs']]:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['LinuxWebAppLogsApplicationLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)


if not MYPY:
    class LinuxWebAppLogsApplicationLogsAzureBlobStorageArgsDict(TypedDict):
        level: pulumi.Input[str]
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        retention_in_days: pulumi.Input[int]
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        sas_url: pulumi.Input[str]
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
elif False:
    LinuxWebAppLogsApplicationLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppLogsApplicationLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[str],
                 retention_in_days: pulumi.Input[int],
                 sas_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param pulumi.Input[int] retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param pulumi.Input[str] sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input[str]:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[str]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class LinuxWebAppLogsHttpLogsArgsDict(TypedDict):
        azure_blob_storage: NotRequired[pulumi.Input['LinuxWebAppLogsHttpLogsAzureBlobStorageArgsDict']]
        """
        A `azure_blob_storage_http` block as defined above.
        """
        file_system: NotRequired[pulumi.Input['LinuxWebAppLogsHttpLogsFileSystemArgsDict']]
        """
        A `file_system` block as defined above.
        """
elif False:
    LinuxWebAppLogsHttpLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppLogsHttpLogsArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['LinuxWebAppLogsHttpLogsAzureBlobStorageArgs']] = None,
                 file_system: Optional[pulumi.Input['LinuxWebAppLogsHttpLogsFileSystemArgs']] = None):
        """
        :param pulumi.Input['LinuxWebAppLogsHttpLogsAzureBlobStorageArgs'] azure_blob_storage: A `azure_blob_storage_http` block as defined above.
        :param pulumi.Input['LinuxWebAppLogsHttpLogsFileSystemArgs'] file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['LinuxWebAppLogsHttpLogsAzureBlobStorageArgs']]:
        """
        A `azure_blob_storage_http` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['LinuxWebAppLogsHttpLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['LinuxWebAppLogsHttpLogsFileSystemArgs']]:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['LinuxWebAppLogsHttpLogsFileSystemArgs']]):
        pulumi.set(self, "file_system", value)


if not MYPY:
    class LinuxWebAppLogsHttpLogsAzureBlobStorageArgsDict(TypedDict):
        sas_url: pulumi.Input[str]
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        retention_in_days: NotRequired[pulumi.Input[int]]
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
elif False:
    LinuxWebAppLogsHttpLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppLogsHttpLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 sas_url: pulumi.Input[str],
                 retention_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        :param pulumi.Input[int] retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)


if not MYPY:
    class LinuxWebAppLogsHttpLogsFileSystemArgsDict(TypedDict):
        retention_in_days: pulumi.Input[int]
        """
        The retention period in days. A value of `0` means no retention.
        """
        retention_in_mb: pulumi.Input[int]
        """
        The maximum size in megabytes that log files can use.
        """
elif False:
    LinuxWebAppLogsHttpLogsFileSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppLogsHttpLogsFileSystemArgs:
    def __init__(__self__, *,
                 retention_in_days: pulumi.Input[int],
                 retention_in_mb: pulumi.Input[int]):
        """
        :param pulumi.Input[int] retention_in_days: The retention period in days. A value of `0` means no retention.
        :param pulumi.Input[int] retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The retention period in days. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> pulumi.Input[int]:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")

    @retention_in_mb.setter
    def retention_in_mb(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_mb", value)


if not MYPY:
    class LinuxWebAppSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        If this Linux Web App is Always On enabled. Defaults to `true`.

        > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        """
        api_definition_url: NotRequired[pulumi.Input[str]]
        """
        The URL to the API Definition for this Linux Web App.
        """
        api_management_api_id: NotRequired[pulumi.Input[str]]
        """
        The API Management API ID this Linux Web App is associated with.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        The App command line to launch.
        """
        application_stack: NotRequired[pulumi.Input['LinuxWebAppSiteConfigApplicationStackArgsDict']]
        """
        A `application_stack` block as defined above.
        """
        auto_heal_setting: NotRequired[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingArgsDict']]
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        container_registry_managed_identity_client_id: NotRequired[pulumi.Input[str]]
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        container_registry_use_managed_identity: NotRequired[pulumi.Input[bool]]
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        cors: NotRequired[pulumi.Input['LinuxWebAppSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined above.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        detailed_error_logging_enabled: NotRequired[pulumi.Input[bool]]
        ftps_state: NotRequired[pulumi.Input[str]]
        health_check_eviction_time_in_min: NotRequired[pulumi.Input[int]]
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The path to the Health Check.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the HTTP2 be enabled?
        """
        ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigIpRestrictionArgsDict']]]]
        """
        One or more `ip_restriction` blocks as defined above.
        """
        linux_fx_version: NotRequired[pulumi.Input[str]]
        load_balancing_mode: NotRequired[pulumi.Input[str]]
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        local_mysql_enabled: NotRequired[pulumi.Input[bool]]
        """
        Use Local MySQL. Defaults to `false`.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        Managed pipeline mode. Possible values include `Integrated`, and `Classic`. Defaults to `Integrated`.
        """
        minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Remote Debugging be enabled? Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`.
        """
        scm_ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionArgsDict']]]]
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        scm_minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        """
        use32_bit_worker: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Web Sockets be enabled? Defaults to `false`.
        """
        worker_count: NotRequired[pulumi.Input[int]]
        """
        The number of Workers for this Linux App Service.
        """
elif False:
    LinuxWebAppSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 api_definition_url: Optional[pulumi.Input[str]] = None,
                 api_management_api_id: Optional[pulumi.Input[str]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 application_stack: Optional[pulumi.Input['LinuxWebAppSiteConfigApplicationStackArgs']] = None,
                 auto_heal_setting: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingArgs']] = None,
                 container_registry_managed_identity_client_id: Optional[pulumi.Input[str]] = None,
                 container_registry_use_managed_identity: Optional[pulumi.Input[bool]] = None,
                 cors: Optional[pulumi.Input['LinuxWebAppSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_eviction_time_in_min: Optional[pulumi.Input[int]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigIpRestrictionArgs']]]] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 load_balancing_mode: Optional[pulumi.Input[str]] = None,
                 local_mysql_enabled: Optional[pulumi.Input[bool]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 scm_ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 worker_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] always_on: If this Linux Web App is Always On enabled. Defaults to `true`.
               
               > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        :param pulumi.Input[str] api_definition_url: The URL to the API Definition for this Linux Web App.
        :param pulumi.Input[str] api_management_api_id: The API Management API ID this Linux Web App is associated with.
        :param pulumi.Input[str] app_command_line: The App command line to launch.
        :param pulumi.Input['LinuxWebAppSiteConfigApplicationStackArgs'] application_stack: A `application_stack` block as defined above.
        :param pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingArgs'] auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param pulumi.Input[str] container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param pulumi.Input[bool] container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param pulumi.Input['LinuxWebAppSiteConfigCorsArgs'] cors: A `cors` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param pulumi.Input[int] health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param pulumi.Input[str] health_check_path: The path to the Health Check.
        :param pulumi.Input[bool] http2_enabled: Should the HTTP2 be enabled?
        :param pulumi.Input[str] ip_restriction_default_action: The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigIpRestrictionArgs']]] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param pulumi.Input[str] load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param pulumi.Input[bool] local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param pulumi.Input[str] managed_pipeline_mode: Managed pipeline mode. Possible values include `Integrated`, and `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        :param pulumi.Input[bool] remote_debugging_enabled: Should Remote Debugging be enabled? Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`.
        :param pulumi.Input[str] scm_ip_restriction_default_action: The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param pulumi.Input[str] scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        :param pulumi.Input[bool] use32_bit_worker: Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        :param pulumi.Input[bool] vnet_route_all_enabled: Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param pulumi.Input[bool] websockets_enabled: Should Web Sockets be enabled? Defaults to `false`.
        :param pulumi.Input[int] worker_count: The number of Workers for this Linux App Service.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restriction_default_action is not None:
            pulumi.set(__self__, "ip_restriction_default_action", ip_restriction_default_action)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restriction_default_action is not None:
            pulumi.set(__self__, "scm_ip_restriction_default_action", scm_ip_restriction_default_action)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        If this Linux Web App is Always On enabled. Defaults to `true`.

        > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to the API Definition for this Linux Web App.
        """
        return pulumi.get(self, "api_definition_url")

    @api_definition_url.setter
    def api_definition_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_definition_url", value)

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[pulumi.Input[str]]:
        """
        The API Management API ID this Linux Web App is associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @api_management_api_id.setter
    def api_management_api_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_management_api_id", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional[pulumi.Input['LinuxWebAppSiteConfigApplicationStackArgs']]:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @application_stack.setter
    def application_stack(self, value: Optional[pulumi.Input['LinuxWebAppSiteConfigApplicationStackArgs']]):
        pulumi.set(self, "application_stack", value)

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingArgs']]:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @auto_heal_setting.setter
    def auto_heal_setting(self, value: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingArgs']]):
        pulumi.set(self, "auto_heal_setting", value)

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @container_registry_managed_identity_client_id.setter
    def container_registry_managed_identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_registry_managed_identity_client_id", value)

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[pulumi.Input[bool]]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @container_registry_use_managed_identity.setter
    def container_registry_use_managed_identity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_registry_use_managed_identity", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['LinuxWebAppSiteConfigCorsArgs']]:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['LinuxWebAppSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @health_check_eviction_time_in_min.setter
    def health_check_eviction_time_in_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_eviction_time_in_min", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictionDefaultAction")
    def ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "ip_restriction_default_action")

    @ip_restriction_default_action.setter
    def ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigIpRestrictionArgs']]]]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @load_balancing_mode.setter
    def load_balancing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancing_mode", value)

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @local_mysql_enabled.setter
    def local_mysql_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local_mysql_enabled", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Managed pipeline mode. Possible values include `Integrated`, and `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Remote Debugging be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="scmIpRestrictionDefaultAction")
    def scm_ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "scm_ip_restriction_default_action")

    @scm_ip_restriction_default_action.setter
    def scm_ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionArgs']]]]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @scm_minimum_tls_version.setter
    def scm_minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_minimum_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @use32_bit_worker.setter
    def use32_bit_worker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Web Sockets be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Workers for this Linux App Service.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class LinuxWebAppSiteConfigApplicationStackArgsDict(TypedDict):
        docker_image_name: NotRequired[pulumi.Input[str]]
        """
        The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        """
        docker_registry_password: NotRequired[pulumi.Input[str]]
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        docker_registry_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        docker_registry_username: NotRequired[pulumi.Input[str]]
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        dotnet_version: NotRequired[pulumi.Input[str]]
        """
        The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0`, `7.0` and `8.0`.
        """
        go_version: NotRequired[pulumi.Input[str]]
        """
        The version of Go to use. Possible values include `1.18`, and `1.19`.
        """
        java_server: NotRequired[pulumi.Input[str]]
        """
        The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.

        > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        """
        java_server_version: NotRequired[pulumi.Input[str]]
        """
        The Version of the `java_server` to use.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The Version of Java to use. Possible values include `8`, `11`, and `17`.

        > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.

        > **NOTE:** `java_server`, `java_server_version`, and `java_version` must all be specified if building a java app
        """
        node_version: NotRequired[pulumi.Input[str]]
        """
        The version of Node to run. Possible values include `12-lts`, `14-lts`, `16-lts`, `18-lts` and `20-lts`. This property conflicts with `java_version`.

        > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        """
        php_version: NotRequired[pulumi.Input[str]]
        """
        The version of PHP to run. Possible values are `7.4`, `8.0`, `8.1`, `8.2` and `8.3`.

        > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        """
        python_version: NotRequired[pulumi.Input[str]]
        """
        The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10`, `3.11` and `3.12`.
        """
        ruby_version: NotRequired[pulumi.Input[str]]
        """
        The version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
elif False:
    LinuxWebAppSiteConfigApplicationStackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigApplicationStackArgs:
    def __init__(__self__, *,
                 docker_image_name: Optional[pulumi.Input[str]] = None,
                 docker_registry_password: Optional[pulumi.Input[str]] = None,
                 docker_registry_url: Optional[pulumi.Input[str]] = None,
                 docker_registry_username: Optional[pulumi.Input[str]] = None,
                 dotnet_version: Optional[pulumi.Input[str]] = None,
                 go_version: Optional[pulumi.Input[str]] = None,
                 java_server: Optional[pulumi.Input[str]] = None,
                 java_server_version: Optional[pulumi.Input[str]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 node_version: Optional[pulumi.Input[str]] = None,
                 php_version: Optional[pulumi.Input[str]] = None,
                 python_version: Optional[pulumi.Input[str]] = None,
                 ruby_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] docker_image_name: The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        :param pulumi.Input[str] docker_registry_password: The User Name to use for authentication against the registry to pull the image.
               
               > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        :param pulumi.Input[str] docker_registry_url: The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        :param pulumi.Input[str] docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param pulumi.Input[str] dotnet_version: The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0`, `7.0` and `8.0`.
        :param pulumi.Input[str] go_version: The version of Go to use. Possible values include `1.18`, and `1.19`.
        :param pulumi.Input[str] java_server: The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
               
               > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        :param pulumi.Input[str] java_server_version: The Version of the `java_server` to use.
        :param pulumi.Input[str] java_version: The Version of Java to use. Possible values include `8`, `11`, and `17`.
               
               > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.
               
               > **NOTE:** `java_server`, `java_server_version`, and `java_version` must all be specified if building a java app
        :param pulumi.Input[str] node_version: The version of Node to run. Possible values include `12-lts`, `14-lts`, `16-lts`, `18-lts` and `20-lts`. This property conflicts with `java_version`.
               
               > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        :param pulumi.Input[str] php_version: The version of PHP to run. Possible values are `7.4`, `8.0`, `8.1`, `8.2` and `8.3`.
               
               > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        :param pulumi.Input[str] python_version: The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10`, `3.11` and `3.12`.
        :param pulumi.Input[str] ruby_version: The version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        if docker_image_name is not None:
            pulumi.set(__self__, "docker_image_name", docker_image_name)
        if docker_registry_password is not None:
            pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        if docker_registry_url is not None:
            pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        if docker_registry_username is not None:
            pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if go_version is not None:
            pulumi.set(__self__, "go_version", go_version)
        if java_server is not None:
            pulumi.set(__self__, "java_server", java_server)
        if java_server_version is not None:
            pulumi.set(__self__, "java_server_version", java_server_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if ruby_version is not None:
            pulumi.set(__self__, "ruby_version", ruby_version)

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        """
        return pulumi.get(self, "docker_image_name")

    @docker_image_name.setter
    def docker_image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_image_name", value)

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> Optional[pulumi.Input[str]]:
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        return pulumi.get(self, "docker_registry_password")

    @docker_registry_password.setter
    def docker_registry_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_password", value)

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        return pulumi.get(self, "docker_registry_url")

    @docker_registry_url.setter
    def docker_registry_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_url", value)

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> Optional[pulumi.Input[str]]:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @docker_registry_username.setter
    def docker_registry_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_username", value)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0`, `7.0` and `8.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @dotnet_version.setter
    def dotnet_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_version", value)

    @property
    @pulumi.getter(name="goVersion")
    def go_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Go to use. Possible values include `1.18`, and `1.19`.
        """
        return pulumi.get(self, "go_version")

    @go_version.setter
    def go_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "go_version", value)

    @property
    @pulumi.getter(name="javaServer")
    def java_server(self) -> Optional[pulumi.Input[str]]:
        """
        The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.

        > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        """
        return pulumi.get(self, "java_server")

    @java_server.setter
    def java_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_server", value)

    @property
    @pulumi.getter(name="javaServerVersion")
    def java_server_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Version of the `java_server` to use.
        """
        return pulumi.get(self, "java_server_version")

    @java_server_version.setter
    def java_server_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_server_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Version of Java to use. Possible values include `8`, `11`, and `17`.

        > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.

        > **NOTE:** `java_server`, `java_server_version`, and `java_version` must all be specified if building a java app
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Node to run. Possible values include `12-lts`, `14-lts`, `16-lts`, `18-lts` and `20-lts`. This property conflicts with `java_version`.

        > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of PHP to run. Possible values are `7.4`, `8.0`, `8.1`, `8.2` and `8.3`.

        > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        """
        return pulumi.get(self, "php_version")

    @php_version.setter
    def php_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "php_version", value)

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10`, `3.11` and `3.12`.
        """
        return pulumi.get(self, "python_version")

    @python_version.setter
    def python_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "python_version", value)

    @property
    @pulumi.getter(name="rubyVersion")
    def ruby_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        return pulumi.get(self, "ruby_version")

    @ruby_version.setter
    def ruby_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ruby_version", value)


if not MYPY:
    class LinuxWebAppSiteConfigAutoHealSettingArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingActionArgsDict']]
        """
        A `action` block as defined above.
        """
        trigger: NotRequired[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerArgsDict']]
        """
        A `trigger` block as defined below.
        """
elif False:
    LinuxWebAppSiteConfigAutoHealSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigAutoHealSettingArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingActionArgs']] = None,
                 trigger: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerArgs']] = None):
        """
        :param pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingActionArgs'] action: A `action` block as defined above.
        :param pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerArgs'] trigger: A `trigger` block as defined below.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingActionArgs']]:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerArgs']]:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerArgs']]):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class LinuxWebAppSiteConfigAutoHealSettingActionArgsDict(TypedDict):
        action_type: pulumi.Input[str]
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        """
        minimum_process_execution_time: NotRequired[pulumi.Input[str]]
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
elif False:
    LinuxWebAppSiteConfigAutoHealSettingActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigAutoHealSettingActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 minimum_process_execution_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        :param pulumi.Input[str] minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")

    @minimum_process_execution_time.setter
    def minimum_process_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_process_execution_time", value)


if not MYPY:
    class LinuxWebAppSiteConfigAutoHealSettingTriggerArgsDict(TypedDict):
        requests: NotRequired[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgsDict']]
        """
        A `requests` block as defined above.
        """
        slow_request: NotRequired[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgsDict']]
        """
        A `slow_request` blocks as defined above.
        """
        slow_request_with_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict']]]]
        """
        One or more `slow_request_with_path` blocks as defined above.
        """
        status_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgsDict']]]]
        """
        One or more `status_code` blocks as defined above.
        """
elif False:
    LinuxWebAppSiteConfigAutoHealSettingTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgs']] = None,
                 slow_request: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs']] = None,
                 slow_request_with_paths: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]] = None,
                 status_codes: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]] = None):
        """
        :param pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgs'] requests: A `requests` block as defined above.
        :param pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_request: A `slow_request` blocks as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]] slow_request_with_paths: One or more `slow_request_with_path` blocks as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs']]] status_codes: One or more `status_code` blocks as defined above.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_request is not None:
            pulumi.set(__self__, "slow_request", slow_request)
        if slow_request_with_paths is not None:
            pulumi.set(__self__, "slow_request_with_paths", slow_request_with_paths)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgs']]:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgs']]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="slowRequest")
    def slow_request(self) -> Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs']]:
        """
        A `slow_request` blocks as defined above.
        """
        return pulumi.get(self, "slow_request")

    @slow_request.setter
    def slow_request(self, value: Optional[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs']]):
        pulumi.set(self, "slow_request", value)

    @property
    @pulumi.getter(name="slowRequestWithPaths")
    def slow_request_with_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]]:
        """
        One or more `slow_request_with_path` blocks as defined above.
        """
        return pulumi.get(self, "slow_request_with_paths")

    @slow_request_with_paths.setter
    def slow_request_with_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]]):
        pulumi.set(self, "slow_request_with_paths", value)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]]):
        pulumi.set(self, "status_codes", value)


if not MYPY:
    class LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The interval in `hh:mm:ss`.
        """
elif False:
    LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerRequestsArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: The number of requests in the specified `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        time_taken: pulumi.Input[str]
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
elif False:
    LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 time_taken: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> pulumi.Input[str]:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_taken", value)


if not MYPY:
    class LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        time_taken: pulumi.Input[str]
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path for which this slow request rule applies.
        """
elif False:
    LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 time_taken: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param pulumi.Input[str] path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> pulumi.Input[str]:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_taken", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        status_code_range: pulumi.Input[str]
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path to which this rule status code applies.
        """
        sub_status: NotRequired[pulumi.Input[int]]
        """
        The Request Sub Status of the Status Code.
        """
        win32_status_code: NotRequired[pulumi.Input[int]]
        """
        The Win32 Status Code of the Request.
        """
elif False:
    LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 status_code_range: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 sub_status: Optional[pulumi.Input[int]] = None,
                 win32_status_code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param pulumi.Input[str] path: The path to which this rule status code applies.
        :param pulumi.Input[int] sub_status: The Request Sub Status of the Status Code.
        :param pulumi.Input[int] win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status_code is not None:
            pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> pulumi.Input[str]:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @status_code_range.setter
    def status_code_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_code_range", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[pulumi.Input[int]]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @sub_status.setter
    def sub_status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sub_status", value)

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")

    @win32_status_code.setter
    def win32_status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "win32_status_code", value)


if not MYPY:
    class LinuxWebAppSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
elif False:
    LinuxWebAppSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param pulumi.Input[bool] support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class LinuxWebAppSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['LinuxWebAppSiteConfigIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    LinuxWebAppSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['LinuxWebAppSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['LinuxWebAppSiteConfigIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['LinuxWebAppSiteConfigIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['LinuxWebAppSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class LinuxWebAppSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    LinuxWebAppSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class LinuxWebAppSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    LinuxWebAppSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['LinuxWebAppSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class LinuxWebAppSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    LinuxWebAppSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class LinuxWebAppSiteCredentialArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Username used for publishing.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Password used for publishing.
        """
elif False:
    LinuxWebAppSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSiteCredentialArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Site Credentials Username used for publishing.
        :param pulumi.Input[str] password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Username used for publishing.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        active_directory: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsActiveDirectoryArgsDict']]
        """
        An `active_directory` block as defined above.
        """
        additional_login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        facebook: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        github: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsGithubArgsDict']]
        """
        A `github` block as defined below.
        """
        google: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
elif False:
    LinuxWebAppSlotAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsFacebookArgs']] = None,
                 github: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsGithubArgs']] = None,
                 google: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Authentication / Authorization feature be enabled for the Linux Web App?
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsActiveDirectoryArgs'] active_directory: An `active_directory` block as defined above.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        :param pulumi.Input[str] default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`
               
               > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsGithubArgs'] github: A `github` block as defined below.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the Authentication / Authorization feature be enabled for the Linux Web App?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsActiveDirectoryArgs']]:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @additional_login_parameters.setter
    def additional_login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_parameters", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsGithubArgs']]:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
elif False:
    LinuxWebAppSlotAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param pulumi.Input[str] client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret: NotRequired[pulumi.Input[str]]
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
elif False:
    LinuxWebAppSlotAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsGithubArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
elif False:
    LinuxWebAppSlotAuthSettingsGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsGithubArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login.
        :param pulumi.Input[str] client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
elif False:
    LinuxWebAppSlotAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
elif False:
    LinuxWebAppSlotAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
elif False:
    LinuxWebAppSlotAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2ArgsDict(TypedDict):
        login: pulumi.Input['LinuxWebAppSlotAuthSettingsV2LoginArgsDict']
        """
        A `login` block as defined below.
        """
        active_directory_v2: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict']]
        """
        An `active_directory_v2` block as defined below.
        """
        apple_v2: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsV2AppleV2ArgsDict']]
        """
        An `apple_v2` block as defined below.
        """
        auth_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        azure_static_web_app_v2: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict']]
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        config_file_path: NotRequired[pulumi.Input[str]]
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        custom_oidc_v2s: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotAuthSettingsV2CustomOidcV2ArgsDict']]]]
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        facebook_v2: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsV2FacebookV2ArgsDict']]
        """
        A `facebook_v2` block as defined below.
        """
        forward_proxy_convention: NotRequired[pulumi.Input[str]]
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        forward_proxy_custom_host_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the host of the request.
        """
        forward_proxy_custom_scheme_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the scheme of the request.
        """
        github_v2: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsV2GithubV2ArgsDict']]
        """
        A `github_v2` block as defined below.
        """
        google_v2: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsV2GoogleV2ArgsDict']]
        """
        A `google_v2` block as defined below.
        """
        http_route_api_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        microsoft_v2: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsV2MicrosoftV2ArgsDict']]
        """
        A `microsoft_v2` block as defined below.
        """
        require_authentication: NotRequired[pulumi.Input[bool]]
        """
        Should the authentication flow be used for all requests.
        """
        require_https: NotRequired[pulumi.Input[bool]]
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        twitter_v2: NotRequired[pulumi.Input['LinuxWebAppSlotAuthSettingsV2TwitterV2ArgsDict']]
        """
        A `twitter_v2` block as defined below.
        """
        unauthenticated_action: NotRequired[pulumi.Input[str]]
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2Args:
    def __init__(__self__, *,
                 login: pulumi.Input['LinuxWebAppSlotAuthSettingsV2LoginArgs'],
                 active_directory_v2: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2Args']] = None,
                 apple_v2: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2AppleV2Args']] = None,
                 auth_enabled: Optional[pulumi.Input[bool]] = None,
                 azure_static_web_app_v2: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args']] = None,
                 config_file_path: Optional[pulumi.Input[str]] = None,
                 custom_oidc_v2s: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotAuthSettingsV2CustomOidcV2Args']]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 facebook_v2: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2FacebookV2Args']] = None,
                 forward_proxy_convention: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_scheme_header_name: Optional[pulumi.Input[str]] = None,
                 github_v2: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2GithubV2Args']] = None,
                 google_v2: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2GoogleV2Args']] = None,
                 http_route_api_prefix: Optional[pulumi.Input[str]] = None,
                 microsoft_v2: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2MicrosoftV2Args']] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 twitter_v2: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2TwitterV2Args']] = None,
                 unauthenticated_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsV2LoginArgs'] login: A `login` block as defined below.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2: An `active_directory_v2` block as defined below.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsV2AppleV2Args'] apple_v2: An `apple_v2` block as defined below.
        :param pulumi.Input[bool] auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param pulumi.Input[str] config_file_path: The path to the App Auth settings.
               
               > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotAuthSettingsV2CustomOidcV2Args']]] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param pulumi.Input[str] default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsV2FacebookV2Args'] facebook_v2: A `facebook_v2` block as defined below.
        :param pulumi.Input[str] forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param pulumi.Input[str] forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param pulumi.Input[str] forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsV2GithubV2Args'] github_v2: A `github_v2` block as defined below.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsV2GoogleV2Args'] google_v2: A `google_v2` block as defined below.
        :param pulumi.Input[str] http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsV2MicrosoftV2Args'] microsoft_v2: A `microsoft_v2` block as defined below.
        :param pulumi.Input[bool] require_authentication: Should the authentication flow be used for all requests.
        :param pulumi.Input[bool] require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param pulumi.Input[str] runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param pulumi.Input['LinuxWebAppSlotAuthSettingsV2TwitterV2Args'] twitter_v2: A `twitter_v2` block as defined below.
        :param pulumi.Input[str] unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> pulumi.Input['LinuxWebAppSlotAuthSettingsV2LoginArgs']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: pulumi.Input['LinuxWebAppSlotAuthSettingsV2LoginArgs']):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2Args']]:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @active_directory_v2.setter
    def active_directory_v2(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2Args']]):
        pulumi.set(self, "active_directory_v2", value)

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2AppleV2Args']]:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @apple_v2.setter
    def apple_v2(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2AppleV2Args']]):
        pulumi.set(self, "apple_v2", value)

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @auth_enabled.setter
    def auth_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auth_enabled", value)

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args']]:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @azure_static_web_app_v2.setter
    def azure_static_web_app_v2(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args']]):
        pulumi.set(self, "azure_static_web_app_v2", value)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotAuthSettingsV2CustomOidcV2Args']]]]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @custom_oidc_v2s.setter
    def custom_oidc_v2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotAuthSettingsV2CustomOidcV2Args']]]]):
        pulumi.set(self, "custom_oidc_v2s", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2FacebookV2Args']]:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @facebook_v2.setter
    def facebook_v2(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2FacebookV2Args']]):
        pulumi.set(self, "facebook_v2", value)

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @forward_proxy_convention.setter
    def forward_proxy_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_convention", value)

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @forward_proxy_custom_host_header_name.setter
    def forward_proxy_custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_host_header_name", value)

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @forward_proxy_custom_scheme_header_name.setter
    def forward_proxy_custom_scheme_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_scheme_header_name", value)

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2GithubV2Args']]:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @github_v2.setter
    def github_v2(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2GithubV2Args']]):
        pulumi.set(self, "github_v2", value)

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2GoogleV2Args']]:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @google_v2.setter
    def google_v2(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2GoogleV2Args']]):
        pulumi.set(self, "google_v2", value)

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @http_route_api_prefix.setter
    def http_route_api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_route_api_prefix", value)

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2MicrosoftV2Args']]:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @microsoft_v2.setter
    def microsoft_v2(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2MicrosoftV2Args']]):
        pulumi.set(self, "microsoft_v2", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2TwitterV2Args']]:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @twitter_v2.setter
    def twitter_v2(self, value: Optional[pulumi.Input['LinuxWebAppSlotAuthSettingsV2TwitterV2Args']]):
        pulumi.set(self, "twitter_v2", value)

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")

    @unauthenticated_action.setter
    def unauthenticated_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_action", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        tenant_auth_endpoint: pulumi.Input[str]
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        allowed_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the certificate used for signing purposes.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        jwt_allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        jwt_allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Groups in the JWT Claim.
        """
        login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        www_authentication_disabled: NotRequired[pulumi.Input[bool]]
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 tenant_auth_endpoint: pulumi.Input[str],
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 jwt_allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jwt_allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 www_authentication_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[str] tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`
               
               > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param pulumi.Input[str] client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param pulumi.Input[bool] www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> pulumi.Input[str]:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @tenant_auth_endpoint.setter
    def tenant_auth_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_auth_endpoint", value)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @allowed_identities.setter
    def allowed_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_identities", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @jwt_allowed_client_applications.setter
    def jwt_allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_client_applications", value)

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @jwt_allowed_groups.setter
    def jwt_allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_groups", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        return pulumi.get(self, "www_authentication_disabled")

    @www_authentication_disabled.setter
    def www_authentication_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "www_authentication_disabled", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2AppleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2AppleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2AppleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Apple web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Apple Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: A list of Login Scopes provided by this Authentication Provider.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2CustomOidcV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        name: pulumi.Input[str]
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        openid_configuration_endpoint: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        authorisation_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        certification_uri: NotRequired[pulumi.Input[str]]
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        client_credential_method: NotRequired[pulumi.Input[str]]
        """
        The Client Credential Method used.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        issuer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        name_claim_type: NotRequired[pulumi.Input[str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of the scopes that should be requested while authenticating.
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2CustomOidcV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2CustomOidcV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 openid_configuration_endpoint: pulumi.Input[str],
                 authorisation_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 client_credential_method: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 issuer_endpoint: Optional[pulumi.Input[str]] = None,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with the Custom OIDC.
        :param pulumi.Input[str] name: The name of the Custom OIDC Authentication Provider.
               
               > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        :param pulumi.Input[str] openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param pulumi.Input[str] authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] client_credential_method: The Client Credential Method used.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        :param pulumi.Input[str] issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of the scopes that should be requested while authenticating.
        :param pulumi.Input[str] token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @openid_configuration_endpoint.setter
    def openid_configuration_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "openid_configuration_endpoint", value)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @authorisation_endpoint.setter
    def authorisation_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorisation_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @client_credential_method.setter
    def client_credential_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_credential_method", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @issuer_endpoint.setter
    def issuer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_endpoint", value)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2FacebookV2ArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        graph_api_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Facebook API to be used while logging in.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2FacebookV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2FacebookV2Args:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret_setting_name: pulumi.Input[str],
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[str] graph_api_version: The version of the Facebook API to be used while logging in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of scopes that should be requested as part of Facebook Login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2GithubV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login..
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2GithubV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2GithubV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login..
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login..
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2GoogleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2GoogleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2GoogleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2LoginArgsDict(TypedDict):
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration_convention: NotRequired[pulumi.Input[str]]
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        cookie_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        logout_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to which logout requests should be made.
        """
        nonce_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[bool]]
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        token_refresh_extension_time: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        token_store_path: NotRequired[pulumi.Input[str]]
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        token_store_sas_setting_name: NotRequired[pulumi.Input[str]]
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        validate_nonce: NotRequired[pulumi.Input[bool]]
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration_convention: Optional[pulumi.Input[str]] = None,
                 cookie_expiration_time: Optional[pulumi.Input[str]] = None,
                 logout_endpoint: Optional[pulumi.Input[str]] = None,
                 nonce_expiration_time: Optional[pulumi.Input[str]] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 token_refresh_extension_time: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 token_store_path: Optional[pulumi.Input[str]] = None,
                 token_store_sas_setting_name: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param pulumi.Input[str] cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param pulumi.Input[str] cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param pulumi.Input[str] logout_endpoint: The endpoint to which logout requests should be made.
        :param pulumi.Input[str] nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param pulumi.Input[bool] preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param pulumi.Input[float] token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param pulumi.Input[str] token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param pulumi.Input[str] token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param pulumi.Input[bool] validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @cookie_expiration_convention.setter
    def cookie_expiration_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_convention", value)

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @cookie_expiration_time.setter
    def cookie_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_time", value)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @nonce_expiration_time.setter
    def nonce_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_time", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @token_refresh_extension_time.setter
    def token_refresh_extension_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_time", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @token_store_path.setter
    def token_store_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_path", value)

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @token_store_sas_setting_name.setter
    def token_store_sas_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_sas_setting_name", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2MicrosoftV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2MicrosoftV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2MicrosoftV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class LinuxWebAppSlotAuthSettingsV2TwitterV2ArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
elif False:
    LinuxWebAppSlotAuthSettingsV2TwitterV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotAuthSettingsV2TwitterV2Args:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret_setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class LinuxWebAppSlotBackupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Backup.
        """
        schedule: pulumi.Input['LinuxWebAppSlotBackupScheduleArgsDict']
        """
        An `schedule` block as defined below.
        """
        storage_account_url: pulumi.Input[str]
        """
        The SAS URL to the container.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Should this backup job be enabled? Defaults to `true`.
        """
elif False:
    LinuxWebAppSlotBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotBackupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['LinuxWebAppSlotBackupScheduleArgs'],
                 storage_account_url: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Backup.
        :param pulumi.Input['LinuxWebAppSlotBackupScheduleArgs'] schedule: An `schedule` block as defined below.
        :param pulumi.Input[str] storage_account_url: The SAS URL to the container.
        :param pulumi.Input[bool] enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['LinuxWebAppSlotBackupScheduleArgs']:
        """
        An `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['LinuxWebAppSlotBackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> pulumi.Input[str]:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LinuxWebAppSlotBackupScheduleArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        frequency_unit: pulumi.Input[str]
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        keep_at_least_one_backup: NotRequired[pulumi.Input[bool]]
        """
        Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        """
        last_execution_time: NotRequired[pulumi.Input[str]]
        """
        The time the backup was last attempted.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        When the schedule should start working in RFC-3339 format.
        """
elif False:
    LinuxWebAppSlotBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotBackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_unit: pulumi.Input[str],
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 last_execution_time: Optional[pulumi.Input[str]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        :param pulumi.Input[str] frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param pulumi.Input[bool] keep_at_least_one_backup: Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        :param pulumi.Input[str] last_execution_time: The time the backup was last attempted.
        :param pulumi.Input[int] retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param pulumi.Input[str] start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input[str]:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @last_execution_time.setter
    def last_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_execution_time", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class LinuxWebAppSlotConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Connection String.
        """
        type: pulumi.Input[str]
        """
        Type of database. Possible values include `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The connection string value.
        """
elif False:
    LinuxWebAppSlotConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Connection String.
        :param pulumi.Input[str] type: Type of database. Possible values include `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param pulumi.Input[str] value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of database. Possible values include `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LinuxWebAppSlotIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Web App Slot. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    LinuxWebAppSlotIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Linux Web App Slot. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App Slot.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Linux Web App Slot. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class LinuxWebAppSlotLogsArgsDict(TypedDict):
        application_logs: NotRequired[pulumi.Input['LinuxWebAppSlotLogsApplicationLogsArgsDict']]
        """
        A `application_logs` block as defined above.
        """
        detailed_error_messages: NotRequired[pulumi.Input[bool]]
        """
        Should detailed error messages be enabled?
        """
        failed_request_tracing: NotRequired[pulumi.Input[bool]]
        """
        Should the failed request tracing be enabled?
        """
        http_logs: NotRequired[pulumi.Input['LinuxWebAppSlotLogsHttpLogsArgsDict']]
        """
        An `http_logs` block as defined above.
        """
elif False:
    LinuxWebAppSlotLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotLogsArgs:
    def __init__(__self__, *,
                 application_logs: Optional[pulumi.Input['LinuxWebAppSlotLogsApplicationLogsArgs']] = None,
                 detailed_error_messages: Optional[pulumi.Input[bool]] = None,
                 failed_request_tracing: Optional[pulumi.Input[bool]] = None,
                 http_logs: Optional[pulumi.Input['LinuxWebAppSlotLogsHttpLogsArgs']] = None):
        """
        :param pulumi.Input['LinuxWebAppSlotLogsApplicationLogsArgs'] application_logs: A `application_logs` block as defined above.
        :param pulumi.Input[bool] detailed_error_messages: Should detailed error messages be enabled?
        :param pulumi.Input[bool] failed_request_tracing: Should the failed request tracing be enabled?
        :param pulumi.Input['LinuxWebAppSlotLogsHttpLogsArgs'] http_logs: An `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional[pulumi.Input['LinuxWebAppSlotLogsApplicationLogsArgs']]:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @application_logs.setter
    def application_logs(self, value: Optional[pulumi.Input['LinuxWebAppSlotLogsApplicationLogsArgs']]):
        pulumi.set(self, "application_logs", value)

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[pulumi.Input[bool]]:
        """
        Should detailed error messages be enabled?
        """
        return pulumi.get(self, "detailed_error_messages")

    @detailed_error_messages.setter
    def detailed_error_messages(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_messages", value)

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the failed request tracing be enabled?
        """
        return pulumi.get(self, "failed_request_tracing")

    @failed_request_tracing.setter
    def failed_request_tracing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failed_request_tracing", value)

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional[pulumi.Input['LinuxWebAppSlotLogsHttpLogsArgs']]:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")

    @http_logs.setter
    def http_logs(self, value: Optional[pulumi.Input['LinuxWebAppSlotLogsHttpLogsArgs']]):
        pulumi.set(self, "http_logs", value)


if not MYPY:
    class LinuxWebAppSlotLogsApplicationLogsArgsDict(TypedDict):
        file_system_level: pulumi.Input[str]
        """
        Log level. Possible values include `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        """
        azure_blob_storage: NotRequired[pulumi.Input['LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgsDict']]
        """
        An `azure_blob_storage` block as defined below.
        """
elif False:
    LinuxWebAppSlotLogsApplicationLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotLogsApplicationLogsArgs:
    def __init__(__self__, *,
                 file_system_level: pulumi.Input[str],
                 azure_blob_storage: Optional[pulumi.Input['LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgs']] = None):
        """
        :param pulumi.Input[str] file_system_level: Log level. Possible values include `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        :param pulumi.Input['LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgs'] azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> pulumi.Input[str]:
        """
        Log level. Possible values include `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @file_system_level.setter
    def file_system_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_system_level", value)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgs']]:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)


if not MYPY:
    class LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgsDict(TypedDict):
        level: pulumi.Input[str]
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        retention_in_days: pulumi.Input[int]
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        sas_url: pulumi.Input[str]
        """
        SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
elif False:
    LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotLogsApplicationLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[str],
                 retention_in_days: pulumi.Input[int],
                 sas_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param pulumi.Input[int] retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param pulumi.Input[str] sas_url: SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input[str]:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[str]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class LinuxWebAppSlotLogsHttpLogsArgsDict(TypedDict):
        azure_blob_storage: NotRequired[pulumi.Input['LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgsDict']]
        """
        A `azure_blob_storage_http` block as defined above.
        """
        file_system: NotRequired[pulumi.Input['LinuxWebAppSlotLogsHttpLogsFileSystemArgsDict']]
        """
        A `file_system` block as defined above.
        """
elif False:
    LinuxWebAppSlotLogsHttpLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotLogsHttpLogsArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgs']] = None,
                 file_system: Optional[pulumi.Input['LinuxWebAppSlotLogsHttpLogsFileSystemArgs']] = None):
        """
        :param pulumi.Input['LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgs'] azure_blob_storage: A `azure_blob_storage_http` block as defined above.
        :param pulumi.Input['LinuxWebAppSlotLogsHttpLogsFileSystemArgs'] file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgs']]:
        """
        A `azure_blob_storage_http` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['LinuxWebAppSlotLogsHttpLogsFileSystemArgs']]:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['LinuxWebAppSlotLogsHttpLogsFileSystemArgs']]):
        pulumi.set(self, "file_system", value)


if not MYPY:
    class LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgsDict(TypedDict):
        sas_url: pulumi.Input[str]
        """
        SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        retention_in_days: NotRequired[pulumi.Input[int]]
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
elif False:
    LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotLogsHttpLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 sas_url: pulumi.Input[str],
                 retention_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] sas_url: SAS URL to an Azure blob container with read/write/list/delete permissions.
        :param pulumi.Input[int] retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        SAS URL to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)


if not MYPY:
    class LinuxWebAppSlotLogsHttpLogsFileSystemArgsDict(TypedDict):
        retention_in_days: pulumi.Input[int]
        """
        The retention period in days. A values of `0` means no retention.
        """
        retention_in_mb: pulumi.Input[int]
        """
        The maximum size in megabytes that log files can use.
        """
elif False:
    LinuxWebAppSlotLogsHttpLogsFileSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotLogsHttpLogsFileSystemArgs:
    def __init__(__self__, *,
                 retention_in_days: pulumi.Input[int],
                 retention_in_mb: pulumi.Input[int]):
        """
        :param pulumi.Input[int] retention_in_days: The retention period in days. A values of `0` means no retention.
        :param pulumi.Input[int] retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The retention period in days. A values of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> pulumi.Input[int]:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")

    @retention_in_mb.setter
    def retention_in_mb(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_mb", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        If this Linux Web App is Always On enabled. Defaults to `true`.
        """
        api_definition_url: NotRequired[pulumi.Input[str]]
        """
        The URL to the API Definition for this Linux Web App Slot.
        """
        api_management_api_id: NotRequired[pulumi.Input[str]]
        """
        The API Management API ID this Linux Web App Slot is associated with.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        The App command line to launch.
        """
        application_stack: NotRequired[pulumi.Input['LinuxWebAppSlotSiteConfigApplicationStackArgsDict']]
        """
        A `application_stack` block as defined above.
        """
        auto_heal_setting: NotRequired[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingArgsDict']]
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        auto_swap_slot_name: NotRequired[pulumi.Input[str]]
        """
        The Linux Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.

        > **Note:** This must be a valid slot name on the target Linux Web App.
        """
        container_registry_managed_identity_client_id: NotRequired[pulumi.Input[str]]
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        container_registry_use_managed_identity: NotRequired[pulumi.Input[bool]]
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        cors: NotRequired[pulumi.Input['LinuxWebAppSlotSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined above.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        detailed_error_logging_enabled: NotRequired[pulumi.Input[bool]]
        ftps_state: NotRequired[pulumi.Input[str]]
        health_check_eviction_time_in_min: NotRequired[pulumi.Input[int]]
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The path to the Health Check.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the HTTP2 be enabled?
        """
        ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionArgsDict']]]]
        """
        One or more `ip_restriction` blocks as defined above.
        """
        linux_fx_version: NotRequired[pulumi.Input[str]]
        load_balancing_mode: NotRequired[pulumi.Input[str]]
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        local_mysql_enabled: NotRequired[pulumi.Input[bool]]
        """
        Use Local MySQL. Defaults to `false`.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Remote Debugging be enabled? Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`
        """
        scm_ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionArgsDict']]]]
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        scm_minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        """
        use32_bit_worker: NotRequired[pulumi.Input[bool]]
        """
        Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Web Sockets be enabled? Defaults to `false`.
        """
        worker_count: NotRequired[pulumi.Input[int]]
        """
        The number of Workers for this Linux App Service Slot.
        """
elif False:
    LinuxWebAppSlotSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 api_definition_url: Optional[pulumi.Input[str]] = None,
                 api_management_api_id: Optional[pulumi.Input[str]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 application_stack: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigApplicationStackArgs']] = None,
                 auto_heal_setting: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingArgs']] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
                 container_registry_managed_identity_client_id: Optional[pulumi.Input[str]] = None,
                 container_registry_use_managed_identity: Optional[pulumi.Input[bool]] = None,
                 cors: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_eviction_time_in_min: Optional[pulumi.Input[int]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionArgs']]]] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 load_balancing_mode: Optional[pulumi.Input[str]] = None,
                 local_mysql_enabled: Optional[pulumi.Input[bool]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 scm_ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 worker_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] always_on: If this Linux Web App is Always On enabled. Defaults to `true`.
        :param pulumi.Input[str] api_definition_url: The URL to the API Definition for this Linux Web App Slot.
        :param pulumi.Input[str] api_management_api_id: The API Management API ID this Linux Web App Slot is associated with.
        :param pulumi.Input[str] app_command_line: The App command line to launch.
        :param pulumi.Input['LinuxWebAppSlotSiteConfigApplicationStackArgs'] application_stack: A `application_stack` block as defined above.
        :param pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingArgs'] auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param pulumi.Input[str] auto_swap_slot_name: The Linux Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
               
               > **Note:** This must be a valid slot name on the target Linux Web App.
        :param pulumi.Input[str] container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param pulumi.Input[bool] container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param pulumi.Input['LinuxWebAppSlotSiteConfigCorsArgs'] cors: A `cors` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: Specifies a list of Default Documents for the Linux Web App.
        :param pulumi.Input[int] health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param pulumi.Input[str] health_check_path: The path to the Health Check.
        :param pulumi.Input[bool] http2_enabled: Should the HTTP2 be enabled?
        :param pulumi.Input[str] ip_restriction_default_action: The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionArgs']]] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param pulumi.Input[str] load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param pulumi.Input[bool] local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param pulumi.Input[str] managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[bool] remote_debugging_enabled: Should Remote Debugging be enabled? Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`
        :param pulumi.Input[str] scm_ip_restriction_default_action: The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param pulumi.Input[str] scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        :param pulumi.Input[bool] use32_bit_worker: Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        :param pulumi.Input[bool] vnet_route_all_enabled: Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param pulumi.Input[bool] websockets_enabled: Should Web Sockets be enabled? Defaults to `false`.
        :param pulumi.Input[int] worker_count: The number of Workers for this Linux App Service Slot.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restriction_default_action is not None:
            pulumi.set(__self__, "ip_restriction_default_action", ip_restriction_default_action)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restriction_default_action is not None:
            pulumi.set(__self__, "scm_ip_restriction_default_action", scm_ip_restriction_default_action)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        If this Linux Web App is Always On enabled. Defaults to `true`.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to the API Definition for this Linux Web App Slot.
        """
        return pulumi.get(self, "api_definition_url")

    @api_definition_url.setter
    def api_definition_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_definition_url", value)

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[pulumi.Input[str]]:
        """
        The API Management API ID this Linux Web App Slot is associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @api_management_api_id.setter
    def api_management_api_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_management_api_id", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional[pulumi.Input['LinuxWebAppSlotSiteConfigApplicationStackArgs']]:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @application_stack.setter
    def application_stack(self, value: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigApplicationStackArgs']]):
        pulumi.set(self, "application_stack", value)

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingArgs']]:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @auto_heal_setting.setter
    def auto_heal_setting(self, value: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingArgs']]):
        pulumi.set(self, "auto_heal_setting", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Linux Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.

        > **Note:** This must be a valid slot name on the target Linux Web App.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @container_registry_managed_identity_client_id.setter
    def container_registry_managed_identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_registry_managed_identity_client_id", value)

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[pulumi.Input[bool]]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @container_registry_use_managed_identity.setter
    def container_registry_use_managed_identity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_registry_use_managed_identity", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['LinuxWebAppSlotSiteConfigCorsArgs']]:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Default Documents for the Linux Web App.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @health_check_eviction_time_in_min.setter
    def health_check_eviction_time_in_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_eviction_time_in_min", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictionDefaultAction")
    def ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "ip_restriction_default_action")

    @ip_restriction_default_action.setter
    def ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionArgs']]]]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @load_balancing_mode.setter
    def load_balancing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancing_mode", value)

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @local_mysql_enabled.setter
    def local_mysql_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local_mysql_enabled", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Remote Debugging be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="scmIpRestrictionDefaultAction")
    def scm_ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "scm_ip_restriction_default_action")

    @scm_ip_restriction_default_action.setter
    def scm_ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionArgs']]]]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @scm_minimum_tls_version.setter
    def scm_minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_minimum_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Linux Web App use a 32-bit worker? Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @use32_bit_worker.setter
    def use32_bit_worker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Web Sockets be enabled? Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Workers for this Linux App Service Slot.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigApplicationStackArgsDict(TypedDict):
        docker_image_name: NotRequired[pulumi.Input[str]]
        """
        The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        """
        docker_registry_password: NotRequired[pulumi.Input[str]]
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        docker_registry_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        docker_registry_username: NotRequired[pulumi.Input[str]]
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        dotnet_version: NotRequired[pulumi.Input[str]]
        """
        The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0`, `7.0` and `8.0`.
        """
        go_version: NotRequired[pulumi.Input[str]]
        """
        The version of Go to use. Possible values include `1.18`, and `1.19`.
        """
        java_server: NotRequired[pulumi.Input[str]]
        """
        The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.

        > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        """
        java_server_version: NotRequired[pulumi.Input[str]]
        """
        The Version of the `java_server` to use.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The Version of Java to use. Possible values include `8`, `11`, and `17`.

        > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.
        """
        node_version: NotRequired[pulumi.Input[str]]
        """
        The version of Node to run. Possible values are `12-lts`, `14-lts`, `16-lts`, `18-lts` and `20-lts`. This property conflicts with `java_version`.

        > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        """
        php_version: NotRequired[pulumi.Input[str]]
        """
        The version of PHP to run. Possible values are `7.4`, `8.0`, `8.1`, `8.2` and `8.3`.

        > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        """
        python_version: NotRequired[pulumi.Input[str]]
        """
        The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10`, `3.11` and `3.12`.
        """
        ruby_version: NotRequired[pulumi.Input[str]]
        """
        The version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
elif False:
    LinuxWebAppSlotSiteConfigApplicationStackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigApplicationStackArgs:
    def __init__(__self__, *,
                 docker_image_name: Optional[pulumi.Input[str]] = None,
                 docker_registry_password: Optional[pulumi.Input[str]] = None,
                 docker_registry_url: Optional[pulumi.Input[str]] = None,
                 docker_registry_username: Optional[pulumi.Input[str]] = None,
                 dotnet_version: Optional[pulumi.Input[str]] = None,
                 go_version: Optional[pulumi.Input[str]] = None,
                 java_server: Optional[pulumi.Input[str]] = None,
                 java_server_version: Optional[pulumi.Input[str]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 node_version: Optional[pulumi.Input[str]] = None,
                 php_version: Optional[pulumi.Input[str]] = None,
                 python_version: Optional[pulumi.Input[str]] = None,
                 ruby_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] docker_image_name: The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        :param pulumi.Input[str] docker_registry_password: The User Name to use for authentication against the registry to pull the image.
               
               > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        :param pulumi.Input[str] docker_registry_url: The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        :param pulumi.Input[str] docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param pulumi.Input[str] dotnet_version: The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0`, `7.0` and `8.0`.
        :param pulumi.Input[str] go_version: The version of Go to use. Possible values include `1.18`, and `1.19`.
        :param pulumi.Input[str] java_server: The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
               
               > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        :param pulumi.Input[str] java_server_version: The Version of the `java_server` to use.
        :param pulumi.Input[str] java_version: The Version of Java to use. Possible values include `8`, `11`, and `17`.
               
               > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.
        :param pulumi.Input[str] node_version: The version of Node to run. Possible values are `12-lts`, `14-lts`, `16-lts`, `18-lts` and `20-lts`. This property conflicts with `java_version`.
               
               > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        :param pulumi.Input[str] php_version: The version of PHP to run. Possible values are `7.4`, `8.0`, `8.1`, `8.2` and `8.3`.
               
               > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        :param pulumi.Input[str] python_version: The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10`, `3.11` and `3.12`.
        :param pulumi.Input[str] ruby_version: The version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        if docker_image_name is not None:
            pulumi.set(__self__, "docker_image_name", docker_image_name)
        if docker_registry_password is not None:
            pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        if docker_registry_url is not None:
            pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        if docker_registry_username is not None:
            pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if go_version is not None:
            pulumi.set(__self__, "go_version", go_version)
        if java_server is not None:
            pulumi.set(__self__, "java_server", java_server)
        if java_server_version is not None:
            pulumi.set(__self__, "java_server_version", java_server_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if ruby_version is not None:
            pulumi.set(__self__, "ruby_version", ruby_version)

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
        """
        return pulumi.get(self, "docker_image_name")

    @docker_image_name.setter
    def docker_image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_image_name", value)

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> Optional[pulumi.Input[str]]:
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        return pulumi.get(self, "docker_registry_password")

    @docker_registry_password.setter
    def docker_registry_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_password", value)

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        return pulumi.get(self, "docker_registry_url")

    @docker_registry_url.setter
    def docker_registry_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_url", value)

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> Optional[pulumi.Input[str]]:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @docker_registry_username.setter
    def docker_registry_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_username", value)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0`, `7.0` and `8.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @dotnet_version.setter
    def dotnet_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_version", value)

    @property
    @pulumi.getter(name="goVersion")
    def go_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Go to use. Possible values include `1.18`, and `1.19`.
        """
        return pulumi.get(self, "go_version")

    @go_version.setter
    def go_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "go_version", value)

    @property
    @pulumi.getter(name="javaServer")
    def java_server(self) -> Optional[pulumi.Input[str]]:
        """
        The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.

        > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
        """
        return pulumi.get(self, "java_server")

    @java_server.setter
    def java_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_server", value)

    @property
    @pulumi.getter(name="javaServerVersion")
    def java_server_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Version of the `java_server` to use.
        """
        return pulumi.get(self, "java_server_version")

    @java_server_version.setter
    def java_server_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_server_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Version of Java to use. Possible values include `8`, `11`, and `17`.

        > **NOTE:** The valid version combinations for `java_version`, `java_server` and `java_server_version` can be checked from the command line via `az webapp list-runtimes --linux`.
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Node to run. Possible values are `12-lts`, `14-lts`, `16-lts`, `18-lts` and `20-lts`. This property conflicts with `java_version`.

        > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of PHP to run. Possible values are `7.4`, `8.0`, `8.1`, `8.2` and `8.3`.

        > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
        """
        return pulumi.get(self, "php_version")

    @php_version.setter
    def php_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "php_version", value)

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10`, `3.11` and `3.12`.
        """
        return pulumi.get(self, "python_version")

    @python_version.setter
    def python_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "python_version", value)

    @property
    @pulumi.getter(name="rubyVersion")
    def ruby_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Ruby to run. Possible values include `2.6` and `2.7`.
        """
        return pulumi.get(self, "ruby_version")

    @ruby_version.setter
    def ruby_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ruby_version", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigAutoHealSettingArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingActionArgsDict']]
        """
        A `action` block as defined above.
        """
        trigger: NotRequired[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgsDict']]
        """
        A `trigger` block as defined below.
        """
elif False:
    LinuxWebAppSlotSiteConfigAutoHealSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigAutoHealSettingArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingActionArgs']] = None,
                 trigger: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgs']] = None):
        """
        :param pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingActionArgs'] action: A `action` block as defined above.
        :param pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgs'] trigger: A `trigger` block as defined below.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingActionArgs']]:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgs']]:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgs']]):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigAutoHealSettingActionArgsDict(TypedDict):
        action_type: pulumi.Input[str]
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        """
        minimum_process_execution_time: NotRequired[pulumi.Input[str]]
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
elif False:
    LinuxWebAppSlotSiteConfigAutoHealSettingActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigAutoHealSettingActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 minimum_process_execution_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        :param pulumi.Input[str] minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")

    @minimum_process_execution_time.setter
    def minimum_process_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_process_execution_time", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgsDict(TypedDict):
        requests: NotRequired[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgsDict']]
        """
        A `requests` block as defined above.
        """
        slow_request: NotRequired[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgsDict']]
        """
        A `slow_request` block as defined above.
        """
        slow_request_with_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict']]]]
        """
        One or more `slow_request_with_path` blocks as defined above.
        """
        status_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgsDict']]]]
        """
        One or more `status_code` blocks as defined above.
        """
elif False:
    LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs']] = None,
                 slow_request: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs']] = None,
                 slow_request_with_paths: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]] = None,
                 status_codes: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]] = None):
        """
        :param pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs'] requests: A `requests` block as defined above.
        :param pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_request: A `slow_request` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]] slow_request_with_paths: One or more `slow_request_with_path` blocks as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs']]] status_codes: One or more `status_code` blocks as defined above.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_request is not None:
            pulumi.set(__self__, "slow_request", slow_request)
        if slow_request_with_paths is not None:
            pulumi.set(__self__, "slow_request_with_paths", slow_request_with_paths)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs']]:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs']]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="slowRequest")
    def slow_request(self) -> Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs']]:
        """
        A `slow_request` block as defined above.
        """
        return pulumi.get(self, "slow_request")

    @slow_request.setter
    def slow_request(self, value: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs']]):
        pulumi.set(self, "slow_request", value)

    @property
    @pulumi.getter(name="slowRequestWithPaths")
    def slow_request_with_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]]:
        """
        One or more `slow_request_with_path` blocks as defined above.
        """
        return pulumi.get(self, "slow_request_with_paths")

    @slow_request_with_paths.setter
    def slow_request_with_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]]):
        pulumi.set(self, "slow_request_with_paths", value)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]]):
        pulumi.set(self, "status_codes", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The interval in `hh:mm:ss`.
        """
elif False:
    LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: The number of requests in the specified `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        time_taken: pulumi.Input[str]
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
elif False:
    LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 time_taken: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> pulumi.Input[str]:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_taken", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        time_taken: pulumi.Input[str]
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path for which this slow request rule applies.
        """
elif False:
    LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 time_taken: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param pulumi.Input[str] path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> pulumi.Input[str]:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_taken", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        status_code_range: pulumi.Input[str]
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path to which this rule status code applies.
        """
        sub_status: NotRequired[pulumi.Input[int]]
        """
        The Request Sub Status of the Status Code.
        """
        win32_status_code: NotRequired[pulumi.Input[int]]
        """
        The Win32 Status Code of the Request.
        """
elif False:
    LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 status_code_range: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 sub_status: Optional[pulumi.Input[int]] = None,
                 win32_status_code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param pulumi.Input[str] path: The path to which this rule status code applies.
        :param pulumi.Input[int] sub_status: The Request Sub Status of the Status Code.
        :param pulumi.Input[int] win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status_code is not None:
            pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> pulumi.Input[str]:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @status_code_range.setter
    def status_code_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_code_range", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[pulumi.Input[int]]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @sub_status.setter
    def sub_status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sub_status", value)

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")

    @win32_status_code.setter
    def win32_status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "win32_status_code", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
elif False:
    LinuxWebAppSlotSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param pulumi.Input[bool] support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    LinuxWebAppSlotSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    LinuxWebAppSlotSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class LinuxWebAppSlotSiteCredentialArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Username used for publishing.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Password used for publishing.
        """
elif False:
    LinuxWebAppSlotSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotSiteCredentialArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Site Credentials Username used for publishing.
        :param pulumi.Input[str] password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Username used for publishing.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class LinuxWebAppSlotStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The Access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The Name of the Storage Account.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this Storage Account.
        """
        share_name: pulumi.Input[str]
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        type: pulumi.Input[str]
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path at which to mount the storage share.
        """
elif False:
    LinuxWebAppSlotStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppSlotStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The Access key for the storage account.
        :param pulumi.Input[str] account_name: The Name of the Storage Account.
        :param pulumi.Input[str] name: The name which should be used for this Storage Account.
        :param pulumi.Input[str] share_name: The Name of the File Share or Container Name for Blob storage.
        :param pulumi.Input[str] type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param pulumi.Input[str] mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class LinuxWebAppStickySettingsArgsDict(TypedDict):
        app_setting_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        connection_string_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
elif False:
    LinuxWebAppStickySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppStickySettingsArgs:
    def __init__(__self__, *,
                 app_setting_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 connection_string_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_setting_names: A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] connection_string_names: A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of `app_setting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @app_setting_names.setter
    def app_setting_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_setting_names", value)

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of `connection_string` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")

    @connection_string_names.setter
    def connection_string_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "connection_string_names", value)


if not MYPY:
    class LinuxWebAppStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The Access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The Name of the Storage Account.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this Storage Account.
        """
        share_name: pulumi.Input[str]
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        type: pulumi.Input[str]
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path at which to mount the storage share.
        """
elif False:
    LinuxWebAppStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxWebAppStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The Access key for the storage account.
        :param pulumi.Input[str] account_name: The Name of the Storage Account.
        :param pulumi.Input[str] name: The name which should be used for this Storage Account.
        :param pulumi.Input[str] share_name: The Name of the File Share or Container Name for Blob storage.
        :param pulumi.Input[str] type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param pulumi.Input[str] mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class PlanSkuArgsDict(TypedDict):
        size: pulumi.Input[str]
        """
        Specifies the plan's instance size.
        """
        tier: pulumi.Input[str]
        """
        Specifies the plan's pricing tier.
        """
        capacity: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of workers associated with this App Service Plan.
        """
elif False:
    PlanSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanSkuArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[str],
                 tier: pulumi.Input[str],
                 capacity: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] size: Specifies the plan's instance size.
        :param pulumi.Input[str] tier: Specifies the plan's pricing tier.
        :param pulumi.Input[int] capacity: Specifies the number of workers associated with this App Service Plan.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "tier", tier)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[str]:
        """
        Specifies the plan's instance size.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> pulumi.Input[str]:
        """
        Specifies the plan's pricing tier.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: pulumi.Input[str]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of workers associated with this App Service Plan.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)


if not MYPY:
    class SlotAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Is Authentication enabled?
        """
        active_directory: NotRequired[pulumi.Input['SlotAuthSettingsActiveDirectoryArgsDict']]
        """
        A `active_directory` block as defined below.
        """
        additional_login_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        facebook: NotRequired[pulumi.Input['SlotAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        google: NotRequired[pulumi.Input['SlotAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['SlotAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The runtime version of the Authentication/Authorization module.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['SlotAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
elif False:
    SlotAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['SlotAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['SlotAuthSettingsFacebookArgs']] = None,
                 google: Optional[pulumi.Input['SlotAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['SlotAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['SlotAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Is Authentication enabled?
        :param pulumi.Input['SlotAuthSettingsActiveDirectoryArgs'] active_directory: A `active_directory` block as defined below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_params: Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app.
        :param pulumi.Input[str] default_provider: The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
               
               > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        :param pulumi.Input['SlotAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['SlotAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['SlotAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The runtime version of the Authentication/Authorization module.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        :param pulumi.Input[bool] token_store_enabled: If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        :param pulumi.Input['SlotAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_params is not None:
            pulumi.set(__self__, "additional_login_params", additional_login_params)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Is Authentication enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['SlotAuthSettingsActiveDirectoryArgs']]:
        """
        A `active_directory` block as defined below.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['SlotAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParams")
    def additional_login_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "additional_login_params")

    @additional_login_params.setter
    def additional_login_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_params", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.

        > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticated_client_action` to work.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['SlotAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['SlotAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['SlotAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['SlotAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['SlotAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['SlotAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The runtime version of the Authentication/Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['SlotAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['SlotAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class SlotAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
elif False:
    SlotAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        :param pulumi.Input[str] client_secret: The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


if not MYPY:
    class SlotAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login
        """
        app_secret: pulumi.Input[str]
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
elif False:
    SlotAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret", app_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> pulumi.Input[str]:
        """
        The App Secret of the Facebook app used for Facebook login.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class SlotAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: pulumi.Input[str]
        """
        The client secret associated with the Google web application.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
elif False:
    SlotAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret associated with the Google web application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class SlotAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: pulumi.Input[str]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
elif False:
    SlotAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class SlotAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The consumer key of the Twitter app used for login
        """
        consumer_secret: pulumi.Input[str]
        """
        The consumer secret of the Twitter app used for login.
        """
elif False:
    SlotAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The consumer key of the Twitter app used for login
        :param pulumi.Input[str] consumer_secret: The consumer secret of the Twitter app used for login.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The consumer key of the Twitter app used for login
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> pulumi.Input[str]:
        """
        The consumer secret of the Twitter app used for login.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret", value)


if not MYPY:
    class SlotConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Connection String.
        """
        type: pulumi.Input[str]
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The value for the Connection String.
        """
elif False:
    SlotConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Connection String.
        :param pulumi.Input[str] type: The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param pulumi.Input[str] value: The value for the Connection String.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value for the Connection String.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SlotIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
elif False:
    SlotIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
               
               > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        :param pulumi.Input[str] tenant_id: The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identity_ids` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.

        > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principal_id` and `tenant_id` can be retrieved after the App Service has been created. More details are available below.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class SlotLogsArgsDict(TypedDict):
        application_logs: NotRequired[pulumi.Input['SlotLogsApplicationLogsArgsDict']]
        """
        An `application_logs` block as defined below.
        """
        detailed_error_messages_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should `Detailed error messages` be enabled on this App Service slot? Defaults to `false`.
        """
        failed_request_tracing_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should `Failed request tracing` be enabled on this App Service slot? Defaults to `false`.
        """
        http_logs: NotRequired[pulumi.Input['SlotLogsHttpLogsArgsDict']]
        """
        An `http_logs` block as defined below.
        """
elif False:
    SlotLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotLogsArgs:
    def __init__(__self__, *,
                 application_logs: Optional[pulumi.Input['SlotLogsApplicationLogsArgs']] = None,
                 detailed_error_messages_enabled: Optional[pulumi.Input[bool]] = None,
                 failed_request_tracing_enabled: Optional[pulumi.Input[bool]] = None,
                 http_logs: Optional[pulumi.Input['SlotLogsHttpLogsArgs']] = None):
        """
        :param pulumi.Input['SlotLogsApplicationLogsArgs'] application_logs: An `application_logs` block as defined below.
        :param pulumi.Input[bool] detailed_error_messages_enabled: Should `Detailed error messages` be enabled on this App Service slot? Defaults to `false`.
        :param pulumi.Input[bool] failed_request_tracing_enabled: Should `Failed request tracing` be enabled on this App Service slot? Defaults to `false`.
        :param pulumi.Input['SlotLogsHttpLogsArgs'] http_logs: An `http_logs` block as defined below.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages_enabled is not None:
            pulumi.set(__self__, "detailed_error_messages_enabled", detailed_error_messages_enabled)
        if failed_request_tracing_enabled is not None:
            pulumi.set(__self__, "failed_request_tracing_enabled", failed_request_tracing_enabled)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional[pulumi.Input['SlotLogsApplicationLogsArgs']]:
        """
        An `application_logs` block as defined below.
        """
        return pulumi.get(self, "application_logs")

    @application_logs.setter
    def application_logs(self, value: Optional[pulumi.Input['SlotLogsApplicationLogsArgs']]):
        pulumi.set(self, "application_logs", value)

    @property
    @pulumi.getter(name="detailedErrorMessagesEnabled")
    def detailed_error_messages_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should `Detailed error messages` be enabled on this App Service slot? Defaults to `false`.
        """
        return pulumi.get(self, "detailed_error_messages_enabled")

    @detailed_error_messages_enabled.setter
    def detailed_error_messages_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_messages_enabled", value)

    @property
    @pulumi.getter(name="failedRequestTracingEnabled")
    def failed_request_tracing_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should `Failed request tracing` be enabled on this App Service slot? Defaults to `false`.
        """
        return pulumi.get(self, "failed_request_tracing_enabled")

    @failed_request_tracing_enabled.setter
    def failed_request_tracing_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failed_request_tracing_enabled", value)

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional[pulumi.Input['SlotLogsHttpLogsArgs']]:
        """
        An `http_logs` block as defined below.
        """
        return pulumi.get(self, "http_logs")

    @http_logs.setter
    def http_logs(self, value: Optional[pulumi.Input['SlotLogsHttpLogsArgs']]):
        pulumi.set(self, "http_logs", value)


if not MYPY:
    class SlotLogsApplicationLogsArgsDict(TypedDict):
        azure_blob_storage: NotRequired[pulumi.Input['SlotLogsApplicationLogsAzureBlobStorageArgsDict']]
        """
        An `azure_blob_storage` block as defined below.
        """
        file_system_level: NotRequired[pulumi.Input[str]]
        """
        The file system log level. Possible values are `Off`, `Error`, `Warning`, `Information`, and `Verbose`. Defaults to `Off`.
        """
elif False:
    SlotLogsApplicationLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotLogsApplicationLogsArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['SlotLogsApplicationLogsAzureBlobStorageArgs']] = None,
                 file_system_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SlotLogsApplicationLogsAzureBlobStorageArgs'] azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param pulumi.Input[str] file_system_level: The file system log level. Possible values are `Off`, `Error`, `Warning`, `Information`, and `Verbose`. Defaults to `Off`.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system_level is not None:
            pulumi.set(__self__, "file_system_level", file_system_level)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['SlotLogsApplicationLogsAzureBlobStorageArgs']]:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['SlotLogsApplicationLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> Optional[pulumi.Input[str]]:
        """
        The file system log level. Possible values are `Off`, `Error`, `Warning`, `Information`, and `Verbose`. Defaults to `Off`.
        """
        return pulumi.get(self, "file_system_level")

    @file_system_level.setter
    def file_system_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_system_level", value)


if not MYPY:
    class SlotLogsApplicationLogsAzureBlobStorageArgsDict(TypedDict):
        level: pulumi.Input[str]
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        retention_in_days: pulumi.Input[int]
        """
        The number of days to retain logs for.
        """
        sas_url: pulumi.Input[str]
        """
        The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
elif False:
    SlotLogsApplicationLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotLogsApplicationLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[str],
                 retention_in_days: pulumi.Input[int],
                 sas_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param pulumi.Input[int] retention_in_days: The number of days to retain logs for.
        :param pulumi.Input[str] sas_url: The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input[str]:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[str]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class SlotLogsHttpLogsArgsDict(TypedDict):
        azure_blob_storage: NotRequired[pulumi.Input['SlotLogsHttpLogsAzureBlobStorageArgsDict']]
        """
        An `azure_blob_storage` block as defined below.
        """
        file_system: NotRequired[pulumi.Input['SlotLogsHttpLogsFileSystemArgsDict']]
        """
        A `file_system` block as defined below.
        """
elif False:
    SlotLogsHttpLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotLogsHttpLogsArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['SlotLogsHttpLogsAzureBlobStorageArgs']] = None,
                 file_system: Optional[pulumi.Input['SlotLogsHttpLogsFileSystemArgs']] = None):
        """
        :param pulumi.Input['SlotLogsHttpLogsAzureBlobStorageArgs'] azure_blob_storage: An `azure_blob_storage` block as defined below.
        :param pulumi.Input['SlotLogsHttpLogsFileSystemArgs'] file_system: A `file_system` block as defined below.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['SlotLogsHttpLogsAzureBlobStorageArgs']]:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['SlotLogsHttpLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['SlotLogsHttpLogsFileSystemArgs']]:
        """
        A `file_system` block as defined below.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['SlotLogsHttpLogsFileSystemArgs']]):
        pulumi.set(self, "file_system", value)


if not MYPY:
    class SlotLogsHttpLogsAzureBlobStorageArgsDict(TypedDict):
        retention_in_days: pulumi.Input[int]
        """
        The number of days to retain logs for.
        """
        sas_url: pulumi.Input[str]
        """
        The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
elif False:
    SlotLogsHttpLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotLogsHttpLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 retention_in_days: pulumi.Input[int],
                 sas_url: pulumi.Input[str]):
        """
        :param pulumi.Input[int] retention_in_days: The number of days to retain logs for.
        :param pulumi.Input[str] sas_url: The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class SlotLogsHttpLogsFileSystemArgsDict(TypedDict):
        retention_in_days: pulumi.Input[int]
        """
        The number of days to retain logs for.
        """
        retention_in_mb: pulumi.Input[int]
        """
        The maximum size in megabytes that HTTP log files can use before being removed.
        """
elif False:
    SlotLogsHttpLogsFileSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotLogsHttpLogsFileSystemArgs:
    def __init__(__self__, *,
                 retention_in_days: pulumi.Input[int],
                 retention_in_mb: pulumi.Input[int]):
        """
        :param pulumi.Input[int] retention_in_days: The number of days to retain logs for.
        :param pulumi.Input[int] retention_in_mb: The maximum size in megabytes that HTTP log files can use before being removed.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The number of days to retain logs for.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> pulumi.Input[int]:
        """
        The maximum size in megabytes that HTTP log files can use before being removed.
        """
        return pulumi.get(self, "retention_in_mb")

    @retention_in_mb.setter
    def retention_in_mb(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_mb", value)


if not MYPY:
    class SlotSiteConfigArgsDict(TypedDict):
        acr_use_managed_identity_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are Managed Identity Credentials used for Azure Container Registry pull
        """
        acr_user_managed_identity_client_id: NotRequired[pulumi.Input[str]]
        """
        If using User Managed Identity, the User Managed Identity Client Id

        > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        """
        always_on: NotRequired[pulumi.Input[bool]]
        """
        Should the slot be loaded at all times? Defaults to `false`.

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        """
        auto_swap_slot_name: NotRequired[pulumi.Input[str]]
        """
        The name of the slot to automatically swap to during deployment
        """
        cors: NotRequired[pulumi.Input['SlotSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined below.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        dotnet_framework_version: NotRequired[pulumi.Input[str]]
        """
        The version of the .NET framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        """
        ftps_state: NotRequired[pulumi.Input[str]]
        """
        State of FTP / FTPS service for this App Service Slot. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The health check path to be pinged by App Service Slot. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is HTTP2 Enabled on this App Service? Defaults to `false`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigIpRestrictionArgsDict']]]]
        """
        A list of objects representing ip restrictions as defined below.

        > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        """
        java_container: NotRequired[pulumi.Input[str]]
        """
        The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        """
        java_container_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        """
        linux_fx_version: NotRequired[pulumi.Input[str]]
        """
        Linux App Framework and version for the App Service Slot. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).

        > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        """
        local_mysql_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.

        > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        """
        min_tls_version: NotRequired[pulumi.Input[str]]
        """
        The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        """
        number_of_workers: NotRequired[pulumi.Input[int]]
        """
        The scaled number of workers (for per site scaling) of this App Service Slot. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        """
        php_version: NotRequired[pulumi.Input[str]]
        """
        The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3`, and `7.4`.
        """
        python_version: NotRequired[pulumi.Input[str]]
        """
        The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is Remote Debugging Enabled? Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017`, `VS2019`, and `VS2022`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigScmIpRestrictionArgsDict']]]]
        """
        A list of `scm_ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        """
        The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        """
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        IP security restrictions for scm to use main. Defaults to `false`. 

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        use32_bit_worker_process: NotRequired[pulumi.Input[bool]]
        """
        Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should WebSockets be enabled?
        """
        windows_fx_version: NotRequired[pulumi.Input[str]]
        """
        The Windows Docker container image (`DOCKER|<user/image:tag>`)

        Additional examples of how to run Containers via the `appservice.Slot` resource can be found in the `./examples/app-service` directory within the GitHub Repository.
        """
elif False:
    SlotSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotSiteConfigArgs:
    def __init__(__self__, *,
                 acr_use_managed_identity_credentials: Optional[pulumi.Input[bool]] = None,
                 acr_user_managed_identity_client_id: Optional[pulumi.Input[str]] = None,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
                 cors: Optional[pulumi.Input['SlotSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dotnet_framework_version: Optional[pulumi.Input[str]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigIpRestrictionArgs']]]] = None,
                 java_container: Optional[pulumi.Input[str]] = None,
                 java_container_version: Optional[pulumi.Input[str]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 local_mysql_enabled: Optional[pulumi.Input[bool]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 number_of_workers: Optional[pulumi.Input[int]] = None,
                 php_version: Optional[pulumi.Input[str]] = None,
                 python_version: Optional[pulumi.Input[str]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker_process: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 windows_fx_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] acr_use_managed_identity_credentials: Are Managed Identity Credentials used for Azure Container Registry pull
        :param pulumi.Input[str] acr_user_managed_identity_client_id: If using User Managed Identity, the User Managed Identity Client Id
               
               > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        :param pulumi.Input[bool] always_on: Should the slot be loaded at all times? Defaults to `false`.
               
               > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        :param pulumi.Input[str] app_command_line: App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        :param pulumi.Input[str] auto_swap_slot_name: The name of the slot to automatically swap to during deployment
        :param pulumi.Input['SlotSiteConfigCorsArgs'] cors: A `cors` block as defined below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: The ordering of default documents to load, if an address isn't specified.
        :param pulumi.Input[str] dotnet_framework_version: The version of the .NET framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        :param pulumi.Input[str] ftps_state: State of FTP / FTPS service for this App Service Slot. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        :param pulumi.Input[str] health_check_path: The health check path to be pinged by App Service Slot. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        :param pulumi.Input[bool] http2_enabled: Is HTTP2 Enabled on this App Service? Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigIpRestrictionArgs']]] ip_restrictions: A list of objects representing ip restrictions as defined below.
               
               > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        :param pulumi.Input[str] java_container: The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        :param pulumi.Input[str] java_container_version: The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        :param pulumi.Input[str] java_version: The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        :param pulumi.Input[str] linux_fx_version: Linux App Framework and version for the App Service Slot. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
               
               > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        :param pulumi.Input[bool] local_mysql_enabled: Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
               
               > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        :param pulumi.Input[str] managed_pipeline_mode: The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] min_tls_version: The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        :param pulumi.Input[int] number_of_workers: The scaled number of workers (for per site scaling) of this App Service Slot. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        :param pulumi.Input[str] php_version: The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3`, and `7.4`.
        :param pulumi.Input[str] python_version: The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
        :param pulumi.Input[bool] remote_debugging_enabled: Is Remote Debugging Enabled? Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017`, `VS2019`, and `VS2022`.
        :param pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: A list of `scm_ip_restriction` objects representing IP restrictions as defined below.
               
               > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        :param pulumi.Input[str] scm_type: The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        :param pulumi.Input[bool] scm_use_main_ip_restriction: IP security restrictions for scm to use main. Defaults to `false`. 
               
               > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        :param pulumi.Input[bool] use32_bit_worker_process: Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?
               
               > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        :param pulumi.Input[bool] websockets_enabled: Should WebSockets be enabled?
        :param pulumi.Input[str] windows_fx_version: The Windows Docker container image (`DOCKER|<user/image:tag>`)
               
               Additional examples of how to run Containers via the `appservice.Slot` resource can be found in the `./examples/app-service` directory within the GitHub Repository.
        """
        if acr_use_managed_identity_credentials is not None:
            pulumi.set(__self__, "acr_use_managed_identity_credentials", acr_use_managed_identity_credentials)
        if acr_user_managed_identity_client_id is not None:
            pulumi.set(__self__, "acr_user_managed_identity_client_id", acr_user_managed_identity_client_id)
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if dotnet_framework_version is not None:
            pulumi.set(__self__, "dotnet_framework_version", dotnet_framework_version)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCredentials")
    def acr_use_managed_identity_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are Managed Identity Credentials used for Azure Container Registry pull
        """
        return pulumi.get(self, "acr_use_managed_identity_credentials")

    @acr_use_managed_identity_credentials.setter
    def acr_use_managed_identity_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "acr_use_managed_identity_credentials", value)

    @property
    @pulumi.getter(name="acrUserManagedIdentityClientId")
    def acr_user_managed_identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        If using User Managed Identity, the User Managed Identity Client Id

        > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
        """
        return pulumi.get(self, "acr_user_managed_identity_client_id")

    @acr_user_managed_identity_client_id.setter
    def acr_user_managed_identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acr_user_managed_identity_client_id", value)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the slot be loaded at all times? Defaults to `false`.

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `always_on` must be set to `false`.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the slot to automatically swap to during deployment
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['SlotSiteConfigCorsArgs']]:
        """
        A `cors` block as defined below.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['SlotSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The ordering of default documents to load, if an address isn't specified.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="dotnetFrameworkVersion")
    def dotnet_framework_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the .NET framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_framework_version")

    @dotnet_framework_version.setter
    def dotnet_framework_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_framework_version", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        """
        State of FTP / FTPS service for this App Service Slot. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The health check path to be pinged by App Service Slot. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is HTTP2 Enabled on this App Service? Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigIpRestrictionArgs']]]]:
        """
        A list of objects representing ip restrictions as defined below.

        > **NOTE** User has to explicitly set `ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[pulumi.Input[str]]:
        """
        The Java Container to use. If specified `java_version` and `java_container_version` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
        """
        return pulumi.get(self, "java_container")

    @java_container.setter
    def java_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container", value)

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Java Container to use. If specified `java_version` and `java_container` must also be specified.
        """
        return pulumi.get(self, "java_container_version")

    @java_container_version.setter
    def java_container_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Java to use. If specified `java_container` and `java_container_version` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        Linux App Framework and version for the App Service Slot. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).

        > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
        """
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.

        > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @local_mysql_enabled.setter
    def local_mysql_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local_mysql_enabled", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[pulumi.Input[int]]:
        """
        The scaled number of workers (for per site scaling) of this App Service Slot. Requires that `per_site_scaling` is enabled on the `appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
        """
        return pulumi.get(self, "number_of_workers")

    @number_of_workers.setter
    def number_of_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_workers", value)

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3`, and `7.4`.
        """
        return pulumi.get(self, "php_version")

    @php_version.setter
    def php_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "php_version", value)

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
        """
        return pulumi.get(self, "python_version")

    @python_version.setter
    def python_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "python_version", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is Remote Debugging Enabled? Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017`, `VS2019`, and `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigScmIpRestrictionArgs']]]]:
        """
        A list of `scm_ip_restriction` objects representing IP restrictions as defined below.

        > **NOTE** User has to explicitly set `scm_ip_restriction` to empty slice (`[]`) to remove it.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SlotSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        IP security restrictions for scm to use main. Defaults to `false`. 

        > **NOTE** Any `scm_ip_restriction` blocks configured are ignored by the service when `scm_use_main_ip_restriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?

        > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use_32_bit_worker_process` must be set to `true`.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @use32_bit_worker_process.setter
    def use32_bit_worker_process(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker_process", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should WebSockets be enabled?
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Windows Docker container image (`DOCKER|<user/image:tag>`)

        Additional examples of how to run Containers via the `appservice.Slot` resource can be found in the `./examples/app-service` directory within the GitHub Repository.
        """
        return pulumi.get(self, "windows_fx_version")

    @windows_fx_version.setter
    def windows_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_fx_version", value)


if not MYPY:
    class SlotSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are credentials supported?
        """
elif False:
    SlotSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        :param pulumi.Input[bool] support_credentials: Are credentials supported?
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are credentials supported?
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class SlotSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        headers: NotRequired[pulumi.Input['SlotSiteConfigIpRestrictionHeadersArgsDict']]
        """
        The `headers` block for this specific `ip_restriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for this IP Restriction.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
elif False:
    SlotSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['SlotSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        :param pulumi.Input['SlotSiteConfigIpRestrictionHeadersArgs'] headers: The `headers` block for this specific `ip_restriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
        :param pulumi.Input[str] ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param pulumi.Input[str] name: The name for this IP Restriction.
        :param pulumi.Input[int] priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['SlotSiteConfigIpRestrictionHeadersArgs']]:
        """
        The `headers` block for this specific `ip_restriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['SlotSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class SlotSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
elif False:
    SlotSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param pulumi.Input[str] x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class SlotSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        headers: NotRequired[pulumi.Input['SlotSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        The `headers` block for this specific `scm_ip_restriction` as defined below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for this IP Restriction.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
elif False:
    SlotSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['SlotSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Allow or Deny access for this IP range. Defaults to `Allow`.
        :param pulumi.Input['SlotSiteConfigScmIpRestrictionHeadersArgs'] headers: The `headers` block for this specific `scm_ip_restriction` as defined below.
        :param pulumi.Input[str] ip_address: The IP Address used for this IP Restriction in CIDR notation.
        :param pulumi.Input[str] name: The name for this IP Restriction.
        :param pulumi.Input[int] priority: The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Allow or Deny access for this IP range. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['SlotSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        The `headers` block for this specific `scm_ip_restriction` as defined below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['SlotSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP Address used for this IP Restriction in CIDR notation.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for this IP Restriction.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One of either `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class SlotSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
elif False:
    SlotSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        :param pulumi.Input[str] x_fd_health_probe: A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class SlotSiteCredentialArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username which can be used to publish to this App Service
        """
elif False:
    SlotSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotSiteCredentialArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: The password associated with the username, which can be used to publish to this App Service.
        :param pulumi.Input[str] username: The username which can be used to publish to this App Service
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with the username, which can be used to publish to this App Service.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username which can be used to publish to this App Service
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class SlotStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The name of the storage account.
        """
        name: pulumi.Input[str]
        """
        The name of the storage account identifier.
        """
        share_name: pulumi.Input[str]
        """
        The name of the file share (container name, for Blob storage).
        """
        type: pulumi.Input[str]
        """
        The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path to mount the storage within the site's runtime environment.
        """
elif False:
    SlotStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlotStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The access key for the storage account.
        :param pulumi.Input[str] account_name: The name of the storage account.
        :param pulumi.Input[str] name: The name of the storage account identifier.
        :param pulumi.Input[str] share_name: The name of the file share (container name, for Blob storage).
        :param pulumi.Input[str] type: The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        :param pulumi.Input[str] mount_path: The path to mount the storage within the site's runtime environment.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the storage account identifier.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class SourceControlGithubActionConfigurationArgsDict(TypedDict):
        code_configuration: NotRequired[pulumi.Input['SourceControlGithubActionConfigurationCodeConfigurationArgsDict']]
        """
        A `code_configuration` block as defined above. Changing this forces a new resource to be created.
        """
        container_configuration: NotRequired[pulumi.Input['SourceControlGithubActionConfigurationContainerConfigurationArgsDict']]
        """
        A `container_configuration` block as defined above.
        """
        generate_workflow_file: NotRequired[pulumi.Input[bool]]
        """
        Whether to generate the GitHub work flow file. Defaults to `true`. Changing this forces a new resource to be created.
        """
        linux_action: NotRequired[pulumi.Input[bool]]
        """
        Denotes this action uses a Linux base image.
        """
elif False:
    SourceControlGithubActionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceControlGithubActionConfigurationArgs:
    def __init__(__self__, *,
                 code_configuration: Optional[pulumi.Input['SourceControlGithubActionConfigurationCodeConfigurationArgs']] = None,
                 container_configuration: Optional[pulumi.Input['SourceControlGithubActionConfigurationContainerConfigurationArgs']] = None,
                 generate_workflow_file: Optional[pulumi.Input[bool]] = None,
                 linux_action: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['SourceControlGithubActionConfigurationCodeConfigurationArgs'] code_configuration: A `code_configuration` block as defined above. Changing this forces a new resource to be created.
        :param pulumi.Input['SourceControlGithubActionConfigurationContainerConfigurationArgs'] container_configuration: A `container_configuration` block as defined above.
        :param pulumi.Input[bool] generate_workflow_file: Whether to generate the GitHub work flow file. Defaults to `true`. Changing this forces a new resource to be created.
        :param pulumi.Input[bool] linux_action: Denotes this action uses a Linux base image.
        """
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)
        if generate_workflow_file is not None:
            pulumi.set(__self__, "generate_workflow_file", generate_workflow_file)
        if linux_action is not None:
            pulumi.set(__self__, "linux_action", linux_action)

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional[pulumi.Input['SourceControlGithubActionConfigurationCodeConfigurationArgs']]:
        """
        A `code_configuration` block as defined above. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "code_configuration")

    @code_configuration.setter
    def code_configuration(self, value: Optional[pulumi.Input['SourceControlGithubActionConfigurationCodeConfigurationArgs']]):
        pulumi.set(self, "code_configuration", value)

    @property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional[pulumi.Input['SourceControlGithubActionConfigurationContainerConfigurationArgs']]:
        """
        A `container_configuration` block as defined above.
        """
        return pulumi.get(self, "container_configuration")

    @container_configuration.setter
    def container_configuration(self, value: Optional[pulumi.Input['SourceControlGithubActionConfigurationContainerConfigurationArgs']]):
        pulumi.set(self, "container_configuration", value)

    @property
    @pulumi.getter(name="generateWorkflowFile")
    def generate_workflow_file(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to generate the GitHub work flow file. Defaults to `true`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "generate_workflow_file")

    @generate_workflow_file.setter
    def generate_workflow_file(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_workflow_file", value)

    @property
    @pulumi.getter(name="linuxAction")
    def linux_action(self) -> Optional[pulumi.Input[bool]]:
        """
        Denotes this action uses a Linux base image.
        """
        return pulumi.get(self, "linux_action")

    @linux_action.setter
    def linux_action(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "linux_action", value)


if not MYPY:
    class SourceControlGithubActionConfigurationCodeConfigurationArgsDict(TypedDict):
        runtime_stack: pulumi.Input[str]
        """
        The value to use for the Runtime Stack in the workflow file content for code base apps. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`. Changing this forces a new resource to be created.
        """
        runtime_version: pulumi.Input[str]
        """
        The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
elif False:
    SourceControlGithubActionConfigurationCodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceControlGithubActionConfigurationCodeConfigurationArgs:
    def __init__(__self__, *,
                 runtime_stack: pulumi.Input[str],
                 runtime_version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] runtime_stack: The value to use for the Runtime Stack in the workflow file content for code base apps. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`. Changing this forces a new resource to be created.
        :param pulumi.Input[str] runtime_version: The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "runtime_stack", runtime_stack)
        pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> pulumi.Input[str]:
        """
        The value to use for the Runtime Stack in the workflow file content for code base apps. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "runtime_stack")

    @runtime_stack.setter
    def runtime_stack(self, value: pulumi.Input[str]):
        pulumi.set(self, "runtime_stack", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> pulumi.Input[str]:
        """
        The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "runtime_version", value)


if not MYPY:
    class SourceControlGithubActionConfigurationContainerConfigurationArgsDict(TypedDict):
        image_name: pulumi.Input[str]
        """
        The image name for the build. Changing this forces a new resource to be created.
        """
        registry_url: pulumi.Input[str]
        """
        The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        """
        registry_password: NotRequired[pulumi.Input[str]]
        """
        The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        registry_username: NotRequired[pulumi.Input[str]]
        """
        The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
elif False:
    SourceControlGithubActionConfigurationContainerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceControlGithubActionConfigurationContainerConfigurationArgs:
    def __init__(__self__, *,
                 image_name: pulumi.Input[str],
                 registry_url: pulumi.Input[str],
                 registry_password: Optional[pulumi.Input[str]] = None,
                 registry_username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_name: The image name for the build. Changing this forces a new resource to be created.
        :param pulumi.Input[str] registry_url: The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        :param pulumi.Input[str] registry_password: The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        :param pulumi.Input[str] registry_username: The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        """
        The image name for the build. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> pulumi.Input[str]:
        """
        The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_url")

    @registry_url.setter
    def registry_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_url", value)

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_password")

    @registry_password.setter
    def registry_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_password", value)

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[pulumi.Input[str]]:
        """
        The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_username")

    @registry_username.setter
    def registry_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_username", value)


if not MYPY:
    class SourceControlSlotGithubActionConfigurationArgsDict(TypedDict):
        code_configuration: NotRequired[pulumi.Input['SourceControlSlotGithubActionConfigurationCodeConfigurationArgsDict']]
        """
        A `code_configuration` block as detailed below. Changing this forces a new resource to be created.
        """
        container_configuration: NotRequired[pulumi.Input['SourceControlSlotGithubActionConfigurationContainerConfigurationArgsDict']]
        """
        A `container_configuration` block as detailed below.
        """
        generate_workflow_file: NotRequired[pulumi.Input[bool]]
        """
        Should the service generate the GitHub Action Workflow file. Defaults to `true` Changing this forces a new resource to be created.
        """
        linux_action: NotRequired[pulumi.Input[bool]]
        """
        Denotes this action uses a Linux base image.
        """
elif False:
    SourceControlSlotGithubActionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceControlSlotGithubActionConfigurationArgs:
    def __init__(__self__, *,
                 code_configuration: Optional[pulumi.Input['SourceControlSlotGithubActionConfigurationCodeConfigurationArgs']] = None,
                 container_configuration: Optional[pulumi.Input['SourceControlSlotGithubActionConfigurationContainerConfigurationArgs']] = None,
                 generate_workflow_file: Optional[pulumi.Input[bool]] = None,
                 linux_action: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['SourceControlSlotGithubActionConfigurationCodeConfigurationArgs'] code_configuration: A `code_configuration` block as detailed below. Changing this forces a new resource to be created.
        :param pulumi.Input['SourceControlSlotGithubActionConfigurationContainerConfigurationArgs'] container_configuration: A `container_configuration` block as detailed below.
        :param pulumi.Input[bool] generate_workflow_file: Should the service generate the GitHub Action Workflow file. Defaults to `true` Changing this forces a new resource to be created.
        :param pulumi.Input[bool] linux_action: Denotes this action uses a Linux base image.
        """
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)
        if generate_workflow_file is not None:
            pulumi.set(__self__, "generate_workflow_file", generate_workflow_file)
        if linux_action is not None:
            pulumi.set(__self__, "linux_action", linux_action)

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional[pulumi.Input['SourceControlSlotGithubActionConfigurationCodeConfigurationArgs']]:
        """
        A `code_configuration` block as detailed below. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "code_configuration")

    @code_configuration.setter
    def code_configuration(self, value: Optional[pulumi.Input['SourceControlSlotGithubActionConfigurationCodeConfigurationArgs']]):
        pulumi.set(self, "code_configuration", value)

    @property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional[pulumi.Input['SourceControlSlotGithubActionConfigurationContainerConfigurationArgs']]:
        """
        A `container_configuration` block as detailed below.
        """
        return pulumi.get(self, "container_configuration")

    @container_configuration.setter
    def container_configuration(self, value: Optional[pulumi.Input['SourceControlSlotGithubActionConfigurationContainerConfigurationArgs']]):
        pulumi.set(self, "container_configuration", value)

    @property
    @pulumi.getter(name="generateWorkflowFile")
    def generate_workflow_file(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the service generate the GitHub Action Workflow file. Defaults to `true` Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "generate_workflow_file")

    @generate_workflow_file.setter
    def generate_workflow_file(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_workflow_file", value)

    @property
    @pulumi.getter(name="linuxAction")
    def linux_action(self) -> Optional[pulumi.Input[bool]]:
        """
        Denotes this action uses a Linux base image.
        """
        return pulumi.get(self, "linux_action")

    @linux_action.setter
    def linux_action(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "linux_action", value)


if not MYPY:
    class SourceControlSlotGithubActionConfigurationCodeConfigurationArgsDict(TypedDict):
        runtime_stack: pulumi.Input[str]
        """
        The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`.
        """
        runtime_version: pulumi.Input[str]
        """
        The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
elif False:
    SourceControlSlotGithubActionConfigurationCodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceControlSlotGithubActionConfigurationCodeConfigurationArgs:
    def __init__(__self__, *,
                 runtime_stack: pulumi.Input[str],
                 runtime_version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] runtime_stack: The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`.
        :param pulumi.Input[str] runtime_version: The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "runtime_stack", runtime_stack)
        pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> pulumi.Input[str]:
        """
        The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`.
        """
        return pulumi.get(self, "runtime_stack")

    @runtime_stack.setter
    def runtime_stack(self, value: pulumi.Input[str]):
        pulumi.set(self, "runtime_stack", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> pulumi.Input[str]:
        """
        The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "runtime_version", value)


if not MYPY:
    class SourceControlSlotGithubActionConfigurationContainerConfigurationArgsDict(TypedDict):
        image_name: pulumi.Input[str]
        """
        The image name for the build. Changing this forces a new resource to be created.
        """
        registry_url: pulumi.Input[str]
        """
        The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        """
        registry_password: NotRequired[pulumi.Input[str]]
        """
        The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        registry_username: NotRequired[pulumi.Input[str]]
        """
        The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
elif False:
    SourceControlSlotGithubActionConfigurationContainerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceControlSlotGithubActionConfigurationContainerConfigurationArgs:
    def __init__(__self__, *,
                 image_name: pulumi.Input[str],
                 registry_url: pulumi.Input[str],
                 registry_password: Optional[pulumi.Input[str]] = None,
                 registry_username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_name: The image name for the build. Changing this forces a new resource to be created.
        :param pulumi.Input[str] registry_url: The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        :param pulumi.Input[str] registry_password: The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        :param pulumi.Input[str] registry_username: The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "registry_url", registry_url)
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_username is not None:
            pulumi.set(__self__, "registry_username", registry_username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        """
        The image name for the build. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> pulumi.Input[str]:
        """
        The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_url")

    @registry_url.setter
    def registry_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_url", value)

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_password")

    @registry_password.setter
    def registry_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_password", value)

    @property
    @pulumi.getter(name="registryUsername")
    def registry_username(self) -> Optional[pulumi.Input[str]]:
        """
        The username used to upload the image to the container registry. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "registry_username")

    @registry_username.setter
    def registry_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_username", value)


if not MYPY:
    class StaticSiteIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The Type of Managed Identity assigned to this Static Site resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Managed Identity IDs which should be assigned to this Static Site resource.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    StaticSiteIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StaticSiteIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The Type of Managed Identity assigned to this Static Site resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of Managed Identity IDs which should be assigned to this Static Site resource.
        :param pulumi.Input[str] principal_id: (Optional) The Principal ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Type of Managed Identity assigned to this Static Site resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Managed Identity IDs which should be assigned to this Static Site resource.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class StaticWebAppBasicAuthArgsDict(TypedDict):
        environments: pulumi.Input[str]
        """
        The Environment types to use the Basic Auth for access. Possible values include `AllEnvironments` and `StagingEnvironments`.
        """
        password: pulumi.Input[str]
        """
        The password for the basic authentication access.
        """
elif False:
    StaticWebAppBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StaticWebAppBasicAuthArgs:
    def __init__(__self__, *,
                 environments: pulumi.Input[str],
                 password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] environments: The Environment types to use the Basic Auth for access. Possible values include `AllEnvironments` and `StagingEnvironments`.
        :param pulumi.Input[str] password: The password for the basic authentication access.
        """
        pulumi.set(__self__, "environments", environments)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def environments(self) -> pulumi.Input[str]:
        """
        The Environment types to use the Basic Auth for access. Possible values include `AllEnvironments` and `StagingEnvironments`.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: pulumi.Input[str]):
        pulumi.set(self, "environments", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password for the basic authentication access.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


if not MYPY:
    class StaticWebAppIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The Type of Managed Identity assigned to this Static Web App resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Managed Identity IDs which should be assigned to this Static Web App resource.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    StaticWebAppIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StaticWebAppIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The Type of Managed Identity assigned to this Static Web App resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of Managed Identity IDs which should be assigned to this Static Web App resource.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Type of Managed Identity assigned to this Static Web App resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Managed Identity IDs which should be assigned to this Static Web App resource.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Should the Authentication / Authorization feature be enabled for the Windows Function App?
        """
        active_directory: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsActiveDirectoryArgsDict']]
        """
        An `active_directory` block as defined above.
        """
        additional_login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        facebook: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        github: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsGithubArgsDict']]
        """
        A `github` block as defined below.
        """
        google: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The Runtime Version of the Authentication / Authorization feature in use for the Windows Function App.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Function App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
elif False:
    WindowsFunctionAppAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsFacebookArgs']] = None,
                 github: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsGithubArgs']] = None,
                 google: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Authentication / Authorization feature be enabled for the Windows Function App?
        :param pulumi.Input['WindowsFunctionAppAuthSettingsActiveDirectoryArgs'] active_directory: An `active_directory` block as defined above.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
        :param pulumi.Input[str] default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
               
               > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        :param pulumi.Input['WindowsFunctionAppAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsGithubArgs'] github: A `github` block as defined below.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The Runtime Version of the Authentication / Authorization feature in use for the Windows Function App.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Windows Function App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the Authentication / Authorization feature be enabled for the Windows Function App?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsActiveDirectoryArgs']]:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @additional_login_parameters.setter
    def additional_login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_parameters", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsGithubArgs']]:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Runtime Version of the Authentication / Authorization feature in use for the Windows Function App.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Function App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
elif False:
    WindowsFunctionAppAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param pulumi.Input[str] client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret: NotRequired[pulumi.Input[str]]
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
elif False:
    WindowsFunctionAppAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsGithubArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
elif False:
    WindowsFunctionAppAuthSettingsGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsGithubArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login.
        :param pulumi.Input[str] client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
elif False:
    WindowsFunctionAppAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
elif False:
    WindowsFunctionAppAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
elif False:
    WindowsFunctionAppAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2ArgsDict(TypedDict):
        login: pulumi.Input['WindowsFunctionAppAuthSettingsV2LoginArgsDict']
        """
        A `login` block as defined below.
        """
        active_directory_v2: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2ArgsDict']]
        """
        An `active_directory_v2` block as defined below.
        """
        apple_v2: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsV2AppleV2ArgsDict']]
        """
        An `apple_v2` block as defined below.
        """
        auth_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        azure_static_web_app_v2: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2ArgsDict']]
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        config_file_path: NotRequired[pulumi.Input[str]]
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        custom_oidc_v2s: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppAuthSettingsV2CustomOidcV2ArgsDict']]]]
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        facebook_v2: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsV2FacebookV2ArgsDict']]
        """
        A `facebook_v2` block as defined below.
        """
        forward_proxy_convention: NotRequired[pulumi.Input[str]]
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        forward_proxy_custom_host_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the host of the request.
        """
        forward_proxy_custom_scheme_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the scheme of the request.
        """
        github_v2: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsV2GithubV2ArgsDict']]
        """
        A `github_v2` block as defined below.
        """
        google_v2: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsV2GoogleV2ArgsDict']]
        """
        A `google_v2` block as defined below.
        """
        http_route_api_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        microsoft_v2: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsV2MicrosoftV2ArgsDict']]
        """
        A `microsoft_v2` block as defined below.
        """
        require_authentication: NotRequired[pulumi.Input[bool]]
        """
        Should the authentication flow be used for all requests.
        """
        require_https: NotRequired[pulumi.Input[bool]]
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        twitter_v2: NotRequired[pulumi.Input['WindowsFunctionAppAuthSettingsV2TwitterV2ArgsDict']]
        """
        A `twitter_v2` block as defined below.
        """
        unauthenticated_action: NotRequired[pulumi.Input[str]]
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2Args:
    def __init__(__self__, *,
                 login: pulumi.Input['WindowsFunctionAppAuthSettingsV2LoginArgs'],
                 active_directory_v2: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Args']] = None,
                 apple_v2: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2AppleV2Args']] = None,
                 auth_enabled: Optional[pulumi.Input[bool]] = None,
                 azure_static_web_app_v2: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Args']] = None,
                 config_file_path: Optional[pulumi.Input[str]] = None,
                 custom_oidc_v2s: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppAuthSettingsV2CustomOidcV2Args']]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 facebook_v2: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2FacebookV2Args']] = None,
                 forward_proxy_convention: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_scheme_header_name: Optional[pulumi.Input[str]] = None,
                 github_v2: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2GithubV2Args']] = None,
                 google_v2: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2GoogleV2Args']] = None,
                 http_route_api_prefix: Optional[pulumi.Input[str]] = None,
                 microsoft_v2: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2MicrosoftV2Args']] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 twitter_v2: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2TwitterV2Args']] = None,
                 unauthenticated_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WindowsFunctionAppAuthSettingsV2LoginArgs'] login: A `login` block as defined below.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2: An `active_directory_v2` block as defined below.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsV2AppleV2Args'] apple_v2: An `apple_v2` block as defined below.
        :param pulumi.Input[bool] auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param pulumi.Input[str] config_file_path: The path to the App Auth settings.
               
               > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppAuthSettingsV2CustomOidcV2Args']]] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param pulumi.Input[str] default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsV2FacebookV2Args'] facebook_v2: A `facebook_v2` block as defined below.
        :param pulumi.Input[str] forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param pulumi.Input[str] forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param pulumi.Input[str] forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsV2GithubV2Args'] github_v2: A `github_v2` block as defined below.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsV2GoogleV2Args'] google_v2: A `google_v2` block as defined below.
        :param pulumi.Input[str] http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsV2MicrosoftV2Args'] microsoft_v2: A `microsoft_v2` block as defined below.
        :param pulumi.Input[bool] require_authentication: Should the authentication flow be used for all requests.
        :param pulumi.Input[bool] require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param pulumi.Input[str] runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param pulumi.Input['WindowsFunctionAppAuthSettingsV2TwitterV2Args'] twitter_v2: A `twitter_v2` block as defined below.
        :param pulumi.Input[str] unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> pulumi.Input['WindowsFunctionAppAuthSettingsV2LoginArgs']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: pulumi.Input['WindowsFunctionAppAuthSettingsV2LoginArgs']):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Args']]:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @active_directory_v2.setter
    def active_directory_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Args']]):
        pulumi.set(self, "active_directory_v2", value)

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2AppleV2Args']]:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @apple_v2.setter
    def apple_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2AppleV2Args']]):
        pulumi.set(self, "apple_v2", value)

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @auth_enabled.setter
    def auth_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auth_enabled", value)

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Args']]:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @azure_static_web_app_v2.setter
    def azure_static_web_app_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Args']]):
        pulumi.set(self, "azure_static_web_app_v2", value)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppAuthSettingsV2CustomOidcV2Args']]]]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @custom_oidc_v2s.setter
    def custom_oidc_v2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppAuthSettingsV2CustomOidcV2Args']]]]):
        pulumi.set(self, "custom_oidc_v2s", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2FacebookV2Args']]:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @facebook_v2.setter
    def facebook_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2FacebookV2Args']]):
        pulumi.set(self, "facebook_v2", value)

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @forward_proxy_convention.setter
    def forward_proxy_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_convention", value)

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @forward_proxy_custom_host_header_name.setter
    def forward_proxy_custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_host_header_name", value)

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @forward_proxy_custom_scheme_header_name.setter
    def forward_proxy_custom_scheme_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_scheme_header_name", value)

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2GithubV2Args']]:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @github_v2.setter
    def github_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2GithubV2Args']]):
        pulumi.set(self, "github_v2", value)

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2GoogleV2Args']]:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @google_v2.setter
    def google_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2GoogleV2Args']]):
        pulumi.set(self, "google_v2", value)

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @http_route_api_prefix.setter
    def http_route_api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_route_api_prefix", value)

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2MicrosoftV2Args']]:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @microsoft_v2.setter
    def microsoft_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2MicrosoftV2Args']]):
        pulumi.set(self, "microsoft_v2", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2TwitterV2Args']]:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @twitter_v2.setter
    def twitter_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppAuthSettingsV2TwitterV2Args']]):
        pulumi.set(self, "twitter_v2", value)

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")

    @unauthenticated_action.setter
    def unauthenticated_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_action", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        tenant_auth_endpoint: pulumi.Input[str]
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        allowed_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the certificate used for signing purposes.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        jwt_allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        jwt_allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Groups in the JWT Claim.
        """
        login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        www_authentication_disabled: NotRequired[pulumi.Input[bool]]
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 tenant_auth_endpoint: pulumi.Input[str],
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 jwt_allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jwt_allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 www_authentication_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[str] tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`
               
               > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param pulumi.Input[str] client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param pulumi.Input[bool] www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> pulumi.Input[str]:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @tenant_auth_endpoint.setter
    def tenant_auth_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_auth_endpoint", value)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @allowed_identities.setter
    def allowed_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_identities", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @jwt_allowed_client_applications.setter
    def jwt_allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_client_applications", value)

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @jwt_allowed_groups.setter
    def jwt_allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_groups", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        return pulumi.get(self, "www_authentication_disabled")

    @www_authentication_disabled.setter
    def www_authentication_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "www_authentication_disabled", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2AppleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2AppleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2AppleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Apple web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Apple Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: A list of Login Scopes provided by this Authentication Provider.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2CustomOidcV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        name: pulumi.Input[str]
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        openid_configuration_endpoint: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        authorisation_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        certification_uri: NotRequired[pulumi.Input[str]]
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        client_credential_method: NotRequired[pulumi.Input[str]]
        """
        The Client Credential Method used.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        issuer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        name_claim_type: NotRequired[pulumi.Input[str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of the scopes that should be requested while authenticating.
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2CustomOidcV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2CustomOidcV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 openid_configuration_endpoint: pulumi.Input[str],
                 authorisation_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 client_credential_method: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 issuer_endpoint: Optional[pulumi.Input[str]] = None,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with the Custom OIDC.
        :param pulumi.Input[str] name: The name of the Custom OIDC Authentication Provider.
               
               > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        :param pulumi.Input[str] openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param pulumi.Input[str] authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] client_credential_method: The Client Credential Method used.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        :param pulumi.Input[str] issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of the scopes that should be requested while authenticating.
        :param pulumi.Input[str] token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @openid_configuration_endpoint.setter
    def openid_configuration_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "openid_configuration_endpoint", value)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @authorisation_endpoint.setter
    def authorisation_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorisation_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @client_credential_method.setter
    def client_credential_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_credential_method", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @issuer_endpoint.setter
    def issuer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_endpoint", value)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2FacebookV2ArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        graph_api_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Facebook API to be used while logging in.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2FacebookV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2FacebookV2Args:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret_setting_name: pulumi.Input[str],
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[str] graph_api_version: The version of the Facebook API to be used while logging in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of scopes that should be requested as part of Facebook Login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2GithubV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login..
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2GithubV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2GithubV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login..
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login..
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2GoogleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2GoogleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2GoogleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2LoginArgsDict(TypedDict):
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration_convention: NotRequired[pulumi.Input[str]]
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        cookie_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        logout_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to which logout requests should be made.
        """
        nonce_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[bool]]
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        token_refresh_extension_time: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        token_store_path: NotRequired[pulumi.Input[str]]
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        token_store_sas_setting_name: NotRequired[pulumi.Input[str]]
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        validate_nonce: NotRequired[pulumi.Input[bool]]
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration_convention: Optional[pulumi.Input[str]] = None,
                 cookie_expiration_time: Optional[pulumi.Input[str]] = None,
                 logout_endpoint: Optional[pulumi.Input[str]] = None,
                 nonce_expiration_time: Optional[pulumi.Input[str]] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 token_refresh_extension_time: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 token_store_path: Optional[pulumi.Input[str]] = None,
                 token_store_sas_setting_name: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param pulumi.Input[str] cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param pulumi.Input[str] cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param pulumi.Input[str] logout_endpoint: The endpoint to which logout requests should be made.
        :param pulumi.Input[str] nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param pulumi.Input[bool] preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param pulumi.Input[float] token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param pulumi.Input[str] token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param pulumi.Input[str] token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param pulumi.Input[bool] validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @cookie_expiration_convention.setter
    def cookie_expiration_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_convention", value)

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @cookie_expiration_time.setter
    def cookie_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_time", value)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @nonce_expiration_time.setter
    def nonce_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_time", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @token_refresh_extension_time.setter
    def token_refresh_extension_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_time", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @token_store_path.setter
    def token_store_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_path", value)

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @token_store_sas_setting_name.setter
    def token_store_sas_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_sas_setting_name", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2MicrosoftV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2MicrosoftV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2MicrosoftV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppAuthSettingsV2TwitterV2ArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
elif False:
    WindowsFunctionAppAuthSettingsV2TwitterV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppAuthSettingsV2TwitterV2Args:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret_setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class WindowsFunctionAppBackupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Backup.
        """
        schedule: pulumi.Input['WindowsFunctionAppBackupScheduleArgsDict']
        """
        A `schedule` block as defined below.
        """
        storage_account_url: pulumi.Input[str]
        """
        The SAS URL to the container.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Should this backup job be enabled? Defaults to `true`.
        """
elif False:
    WindowsFunctionAppBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppBackupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['WindowsFunctionAppBackupScheduleArgs'],
                 storage_account_url: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Backup.
        :param pulumi.Input['WindowsFunctionAppBackupScheduleArgs'] schedule: A `schedule` block as defined below.
        :param pulumi.Input[str] storage_account_url: The SAS URL to the container.
        :param pulumi.Input[bool] enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['WindowsFunctionAppBackupScheduleArgs']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['WindowsFunctionAppBackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> pulumi.Input[str]:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WindowsFunctionAppBackupScheduleArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Windows Function App SKUs. Please refer to the official documentation for appropriate values.
        """
        frequency_unit: pulumi.Input[str]
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        keep_at_least_one_backup: NotRequired[pulumi.Input[bool]]
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        last_execution_time: NotRequired[pulumi.Input[str]]
        """
        The time the backup was last attempted.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        When the schedule should start working in RFC-3339 format.
        """
elif False:
    WindowsFunctionAppBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppBackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_unit: pulumi.Input[str],
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 last_execution_time: Optional[pulumi.Input[str]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Windows Function App SKUs. Please refer to the official documentation for appropriate values.
        :param pulumi.Input[str] frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param pulumi.Input[bool] keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param pulumi.Input[str] last_execution_time: The time the backup was last attempted.
        :param pulumi.Input[int] retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param pulumi.Input[str] start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Windows Function App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input[str]:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @last_execution_time.setter
    def last_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_execution_time", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class WindowsFunctionAppConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Connection.
        """
        type: pulumi.Input[str]
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The connection string value.
        """
elif False:
    WindowsFunctionAppConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name which should be used for this Connection.
        :param pulumi.Input[str] type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param pulumi.Input[str] value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WindowsFunctionAppIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    WindowsFunctionAppIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Windows Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class WindowsFunctionAppSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        If this Windows Function App is Always On enabled. Defaults to `false`.

        > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        """
        api_definition_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the API definition that describes this Windows Function App.
        """
        api_management_api_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the API Management API for this Windows Function App.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        The App command line to launch.
        """
        app_scale_limit: NotRequired[pulumi.Input[int]]
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        app_service_logs: NotRequired[pulumi.Input['WindowsFunctionAppSiteConfigAppServiceLogsArgsDict']]
        """
        An `app_service_logs` block as defined above.
        """
        application_insights_connection_string: NotRequired[pulumi.Input[str]]
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        application_insights_key: NotRequired[pulumi.Input[str]]
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        application_stack: NotRequired[pulumi.Input['WindowsFunctionAppSiteConfigApplicationStackArgsDict']]
        """
        An `application_stack` block as defined above.

        > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        """
        cors: NotRequired[pulumi.Input['WindowsFunctionAppSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined above.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Default Documents for the Windows Function App.
        """
        detailed_error_logging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is detailed error logging enabled
        """
        elastic_instance_minimum: NotRequired[pulumi.Input[int]]
        """
        The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        """
        ftps_state: NotRequired[pulumi.Input[str]]
        """
        State of FTP / FTPS service for this Windows Function App. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        health_check_eviction_time_in_min: NotRequired[pulumi.Input[int]]
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The path to be checked for this Windows Function App health.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionArgsDict']]]]
        """
        One or more `ip_restriction` blocks as defined above.
        """
        load_balancing_mode: NotRequired[pulumi.Input[str]]
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        Configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        """
        pre_warmed_instance_count: NotRequired[pulumi.Input[int]]
        """
        The number of pre-warmed instances for this Windows Function App. Only affects apps on an Elastic Premium plan.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        """
        runtime_scale_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Scale Monitoring of the Functions Runtime be enabled?

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        scm_ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionArgsDict']]]]
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        scm_minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        """
        The SCM Type in use by the Windows Function App.
        """
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        """
        use32_bit_worker: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Function App use a 32-bit worker process. Defaults to `true`.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        windows_fx_version: NotRequired[pulumi.Input[str]]
        """
        The Windows FX Version string.
        """
        worker_count: NotRequired[pulumi.Input[int]]
        """
        The number of Workers for this Windows Function App.
        """
elif False:
    WindowsFunctionAppSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 api_definition_url: Optional[pulumi.Input[str]] = None,
                 api_management_api_id: Optional[pulumi.Input[str]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 app_scale_limit: Optional[pulumi.Input[int]] = None,
                 app_service_logs: Optional[pulumi.Input['WindowsFunctionAppSiteConfigAppServiceLogsArgs']] = None,
                 application_insights_connection_string: Optional[pulumi.Input[str]] = None,
                 application_insights_key: Optional[pulumi.Input[str]] = None,
                 application_stack: Optional[pulumi.Input['WindowsFunctionAppSiteConfigApplicationStackArgs']] = None,
                 cors: Optional[pulumi.Input['WindowsFunctionAppSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 elastic_instance_minimum: Optional[pulumi.Input[int]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_eviction_time_in_min: Optional[pulumi.Input[int]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionArgs']]]] = None,
                 load_balancing_mode: Optional[pulumi.Input[str]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 pre_warmed_instance_count: Optional[pulumi.Input[int]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 runtime_scale_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 scm_ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 windows_fx_version: Optional[pulumi.Input[str]] = None,
                 worker_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] always_on: If this Windows Function App is Always On enabled. Defaults to `false`.
               
               > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        :param pulumi.Input[str] api_definition_url: The URL of the API definition that describes this Windows Function App.
        :param pulumi.Input[str] api_management_api_id: The ID of the API Management API for this Windows Function App.
        :param pulumi.Input[str] app_command_line: The App command line to launch.
        :param pulumi.Input[int] app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param pulumi.Input['WindowsFunctionAppSiteConfigAppServiceLogsArgs'] app_service_logs: An `app_service_logs` block as defined above.
        :param pulumi.Input[str] application_insights_connection_string: The Connection String for linking the Windows Function App to Application Insights.
        :param pulumi.Input[str] application_insights_key: The Instrumentation Key for connecting the Windows Function App to Application Insights.
        :param pulumi.Input['WindowsFunctionAppSiteConfigApplicationStackArgs'] application_stack: An `application_stack` block as defined above.
               
               > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        :param pulumi.Input['WindowsFunctionAppSiteConfigCorsArgs'] cors: A `cors` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: Specifies a list of Default Documents for the Windows Function App.
        :param pulumi.Input[bool] detailed_error_logging_enabled: Is detailed error logging enabled
        :param pulumi.Input[int] elastic_instance_minimum: The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        :param pulumi.Input[str] ftps_state: State of FTP / FTPS service for this Windows Function App. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param pulumi.Input[int] health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param pulumi.Input[str] health_check_path: The path to be checked for this Windows Function App health.
        :param pulumi.Input[bool] http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param pulumi.Input[str] ip_restriction_default_action: The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionArgs']]] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param pulumi.Input[str] load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param pulumi.Input[str] managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] minimum_tls_version: Configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        :param pulumi.Input[int] pre_warmed_instance_count: The number of pre-warmed instances for this Windows Function App. Only affects apps on an Elastic Premium plan.
        :param pulumi.Input[bool] remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        :param pulumi.Input[bool] runtime_scale_monitoring_enabled: Should Scale Monitoring of the Functions Runtime be enabled?
               
               > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        :param pulumi.Input[str] scm_ip_restriction_default_action: The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param pulumi.Input[str] scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[str] scm_type: The SCM Type in use by the Windows Function App.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        :param pulumi.Input[bool] use32_bit_worker: Should the Windows Function App use a 32-bit worker process. Defaults to `true`.
        :param pulumi.Input[bool] vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param pulumi.Input[bool] websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param pulumi.Input[str] windows_fx_version: The Windows FX Version string.
        :param pulumi.Input[int] worker_count: The number of Workers for this Windows Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restriction_default_action is not None:
            pulumi.set(__self__, "ip_restriction_default_action", ip_restriction_default_action)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restriction_default_action is not None:
            pulumi.set(__self__, "scm_ip_restriction_default_action", scm_ip_restriction_default_action)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        If this Windows Function App is Always On enabled. Defaults to `false`.

        > **NOTE:** when running in a Consumption or Premium Plan, `always_on` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the API definition that describes this Windows Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @api_definition_url.setter
    def api_definition_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_definition_url", value)

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the API Management API for this Windows Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @api_management_api_id.setter
    def api_management_api_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_management_api_id", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @app_scale_limit.setter
    def app_scale_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "app_scale_limit", value)

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional[pulumi.Input['WindowsFunctionAppSiteConfigAppServiceLogsArgs']]:
        """
        An `app_service_logs` block as defined above.
        """
        return pulumi.get(self, "app_service_logs")

    @app_service_logs.setter
    def app_service_logs(self, value: Optional[pulumi.Input['WindowsFunctionAppSiteConfigAppServiceLogsArgs']]):
        pulumi.set(self, "app_service_logs", value)

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @application_insights_connection_string.setter
    def application_insights_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_insights_connection_string", value)

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @application_insights_key.setter
    def application_insights_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_insights_key", value)

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional[pulumi.Input['WindowsFunctionAppSiteConfigApplicationStackArgs']]:
        """
        An `application_stack` block as defined above.

        > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
        """
        return pulumi.get(self, "application_stack")

    @application_stack.setter
    def application_stack(self, value: Optional[pulumi.Input['WindowsFunctionAppSiteConfigApplicationStackArgs']]):
        pulumi.set(self, "application_stack", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['WindowsFunctionAppSiteConfigCorsArgs']]:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['WindowsFunctionAppSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Default Documents for the Windows Function App.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is detailed error logging enabled
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @elastic_instance_minimum.setter
    def elastic_instance_minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "elastic_instance_minimum", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        """
        State of FTP / FTPS service for this Windows Function App. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @health_check_eviction_time_in_min.setter
    def health_check_eviction_time_in_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_eviction_time_in_min", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to be checked for this Windows Function App health.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictionDefaultAction")
    def ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "ip_restriction_default_action")

    @ip_restriction_default_action.setter
    def ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionArgs']]]]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @load_balancing_mode.setter
    def load_balancing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancing_mode", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of pre-warmed instances for this Windows Function App. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @pre_warmed_instance_count.setter
    def pre_warmed_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pre_warmed_instance_count", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Scale Monitoring of the Functions Runtime be enabled?

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @runtime_scale_monitoring_enabled.setter
    def runtime_scale_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "runtime_scale_monitoring_enabled", value)

    @property
    @pulumi.getter(name="scmIpRestrictionDefaultAction")
    def scm_ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "scm_ip_restriction_default_action")

    @scm_ip_restriction_default_action.setter
    def scm_ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionArgs']]]]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @scm_minimum_tls_version.setter
    def scm_minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_minimum_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        """
        The SCM Type in use by the Windows Function App.
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Function App use a 32-bit worker process. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @use32_bit_worker.setter
    def use32_bit_worker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Windows FX Version string.
        """
        return pulumi.get(self, "windows_fx_version")

    @windows_fx_version.setter
    def windows_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_fx_version", value)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Workers for this Windows Function App.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class WindowsFunctionAppSiteConfigAppServiceLogsArgsDict(TypedDict):
        disk_quota_mb: NotRequired[pulumi.Input[int]]
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
elif False:
    WindowsFunctionAppSiteConfigAppServiceLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSiteConfigAppServiceLogsArgs:
    def __init__(__self__, *,
                 disk_quota_mb: Optional[pulumi.Input[int]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        :param pulumi.Input[int] retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
               
               > **NOTE:** This block is not supported on Consumption plans.
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @disk_quota_mb.setter
    def disk_quota_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_quota_mb", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)


if not MYPY:
    class WindowsFunctionAppSiteConfigApplicationStackArgsDict(TypedDict):
        dotnet_version: NotRequired[pulumi.Input[str]]
        """
        The version of .NET to use. Possible values include `v3.0`, `v4.0` `v6.0`, `v7.0` and `v8.0`. Defaults to `v4.0`.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The Version of Java to use. Supported versions include `1.8`, `11` & `17` (In-Preview).
        """
        node_version: NotRequired[pulumi.Input[str]]
        """
        The version of Node to run. Possible values include `~12`, `~14`, `~16`, `~18` and `~20`.
        """
        powershell_core_version: NotRequired[pulumi.Input[str]]
        """
        The version of PowerShell Core to run. Possible values are `7`, `7.2`, and `7.4`.

        > **NOTE:** A value of `7` will provide the latest stable version. `7.2` is in preview at the time of writing.
        """
        use_custom_runtime: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Function App use a custom runtime?
        """
        use_dotnet_isolated_runtime: NotRequired[pulumi.Input[bool]]
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
elif False:
    WindowsFunctionAppSiteConfigApplicationStackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSiteConfigApplicationStackArgs:
    def __init__(__self__, *,
                 dotnet_version: Optional[pulumi.Input[str]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 node_version: Optional[pulumi.Input[str]] = None,
                 powershell_core_version: Optional[pulumi.Input[str]] = None,
                 use_custom_runtime: Optional[pulumi.Input[bool]] = None,
                 use_dotnet_isolated_runtime: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] dotnet_version: The version of .NET to use. Possible values include `v3.0`, `v4.0` `v6.0`, `v7.0` and `v8.0`. Defaults to `v4.0`.
        :param pulumi.Input[str] java_version: The Version of Java to use. Supported versions include `1.8`, `11` & `17` (In-Preview).
        :param pulumi.Input[str] node_version: The version of Node to run. Possible values include `~12`, `~14`, `~16`, `~18` and `~20`.
        :param pulumi.Input[str] powershell_core_version: The version of PowerShell Core to run. Possible values are `7`, `7.2`, and `7.4`.
               
               > **NOTE:** A value of `7` will provide the latest stable version. `7.2` is in preview at the time of writing.
        :param pulumi.Input[bool] use_custom_runtime: Should the Windows Function App use a custom runtime?
        :param pulumi.Input[bool] use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .NET to use. Possible values include `v3.0`, `v4.0` `v6.0`, `v7.0` and `v8.0`. Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @dotnet_version.setter
    def dotnet_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Version of Java to use. Supported versions include `1.8`, `11` & `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Node to run. Possible values include `~12`, `~14`, `~16`, `~18` and `~20`.
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of PowerShell Core to run. Possible values are `7`, `7.2`, and `7.4`.

        > **NOTE:** A value of `7` will provide the latest stable version. `7.2` is in preview at the time of writing.
        """
        return pulumi.get(self, "powershell_core_version")

    @powershell_core_version.setter
    def powershell_core_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "powershell_core_version", value)

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Function App use a custom runtime?
        """
        return pulumi.get(self, "use_custom_runtime")

    @use_custom_runtime.setter
    def use_custom_runtime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_custom_runtime", value)

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")

    @use_dotnet_isolated_runtime.setter
    def use_dotnet_isolated_runtime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_dotnet_isolated_runtime", value)


if not MYPY:
    class WindowsFunctionAppSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
elif False:
    WindowsFunctionAppSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param pulumi.Input[bool] support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class WindowsFunctionAppSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    WindowsFunctionAppSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WindowsFunctionAppSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class WindowsFunctionAppSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    WindowsFunctionAppSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class WindowsFunctionAppSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    WindowsFunctionAppSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class WindowsFunctionAppSiteCredentialArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Password used for publishing.
        """
elif False:
    WindowsFunctionAppSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSiteCredentialArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        :param pulumi.Input[str] password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Should the Authentication / Authorization feature be enabled?
        """
        active_directory: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgsDict']]
        """
        an `active_directory` block as detailed below.
        """
        additional_login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        facebook: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsFacebookArgsDict']]
        """
        a `facebook` block as detailed below.
        """
        github: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsGithubArgsDict']]
        """
        a `github` block as detailed below.
        """
        google: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsGoogleArgsDict']]
        """
        a `google` block as detailed below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsMicrosoftArgsDict']]
        """
        a `microsoft` block as detailed below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The RuntimeVersion of the Authentication / Authorization feature in use.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsTwitterArgsDict']]
        """
        a `twitter` block as detailed below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsFacebookArgs']] = None,
                 github: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsGithubArgs']] = None,
                 google: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Authentication / Authorization feature be enabled?
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgs'] active_directory: an `active_directory` block as detailed below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        :param pulumi.Input[str] default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
               
               > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsFacebookArgs'] facebook: a `facebook` block as detailed below.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsGithubArgs'] github: a `github` block as detailed below.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsGoogleArgs'] google: a `google` block as detailed below.
        :param pulumi.Input[str] issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsMicrosoftArgs'] microsoft: a `microsoft` block as detailed below.
        :param pulumi.Input[str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsTwitterArgs'] twitter: a `twitter` block as detailed below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the Authentication / Authorization feature be enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgs']]:
        """
        an `active_directory` block as detailed below.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @additional_login_parameters.setter
    def additional_login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_parameters", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsFacebookArgs']]:
        """
        a `facebook` block as detailed below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsGithubArgs']]:
        """
        a `github` block as detailed below.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsGoogleArgs']]:
        """
        a `google` block as detailed below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsMicrosoftArgs']]:
        """
        a `microsoft` block as detailed below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsTwitterArgs']]:
        """
        a `twitter` block as detailed below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param pulumi.Input[str] client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret: NotRequired[pulumi.Input[str]]
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsGithubArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        an `oauth_scopes`.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsGithubArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login.
        :param pulumi.Input[str] client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: an `oauth_scopes`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        an `oauth_scopes`.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2ArgsDict(TypedDict):
        login: pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2LoginArgsDict']
        """
        A `login` block as defined below.
        """
        active_directory_v2: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict']]
        """
        An `active_directory_v2` block as defined below.
        """
        apple_v2: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AppleV2ArgsDict']]
        """
        An `apple_v2` block as defined below.
        """
        auth_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        azure_static_web_app_v2: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict']]
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        config_file_path: NotRequired[pulumi.Input[str]]
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        custom_oidc_v2s: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2ArgsDict']]]]
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        facebook_v2: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2FacebookV2ArgsDict']]
        """
        A `facebook_v2` block as defined below.
        """
        forward_proxy_convention: NotRequired[pulumi.Input[str]]
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        forward_proxy_custom_host_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the host of the request.
        """
        forward_proxy_custom_scheme_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the scheme of the request.
        """
        github_v2: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GithubV2ArgsDict']]
        """
        A `github_v2` block as defined below.
        """
        google_v2: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GoogleV2ArgsDict']]
        """
        A `google_v2` block as defined below.
        """
        http_route_api_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        microsoft_v2: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2ArgsDict']]
        """
        A `microsoft_v2` block as defined below.
        """
        require_authentication: NotRequired[pulumi.Input[bool]]
        """
        Should the authentication flow be used for all requests.
        """
        require_https: NotRequired[pulumi.Input[bool]]
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        twitter_v2: NotRequired[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2TwitterV2ArgsDict']]
        """
        A `twitter_v2` block as defined below.
        """
        unauthenticated_action: NotRequired[pulumi.Input[str]]
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2Args:
    def __init__(__self__, *,
                 login: pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2LoginArgs'],
                 active_directory_v2: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args']] = None,
                 apple_v2: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AppleV2Args']] = None,
                 auth_enabled: Optional[pulumi.Input[bool]] = None,
                 azure_static_web_app_v2: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args']] = None,
                 config_file_path: Optional[pulumi.Input[str]] = None,
                 custom_oidc_v2s: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2Args']]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 facebook_v2: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2FacebookV2Args']] = None,
                 forward_proxy_convention: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_scheme_header_name: Optional[pulumi.Input[str]] = None,
                 github_v2: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GithubV2Args']] = None,
                 google_v2: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GoogleV2Args']] = None,
                 http_route_api_prefix: Optional[pulumi.Input[str]] = None,
                 microsoft_v2: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2Args']] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 twitter_v2: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2TwitterV2Args']] = None,
                 unauthenticated_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2LoginArgs'] login: A `login` block as defined below.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2: An `active_directory_v2` block as defined below.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AppleV2Args'] apple_v2: An `apple_v2` block as defined below.
        :param pulumi.Input[bool] auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param pulumi.Input[str] config_file_path: The path to the App Auth settings.
               
               > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2Args']]] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param pulumi.Input[str] default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2FacebookV2Args'] facebook_v2: A `facebook_v2` block as defined below.
        :param pulumi.Input[str] forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param pulumi.Input[str] forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param pulumi.Input[str] forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GithubV2Args'] github_v2: A `github_v2` block as defined below.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GoogleV2Args'] google_v2: A `google_v2` block as defined below.
        :param pulumi.Input[str] http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2Args'] microsoft_v2: A `microsoft_v2` block as defined below.
        :param pulumi.Input[bool] require_authentication: Should the authentication flow be used for all requests.
        :param pulumi.Input[bool] require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param pulumi.Input[str] runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2TwitterV2Args'] twitter_v2: A `twitter_v2` block as defined below.
        :param pulumi.Input[str] unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2LoginArgs']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2LoginArgs']):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args']]:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @active_directory_v2.setter
    def active_directory_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args']]):
        pulumi.set(self, "active_directory_v2", value)

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AppleV2Args']]:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @apple_v2.setter
    def apple_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AppleV2Args']]):
        pulumi.set(self, "apple_v2", value)

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @auth_enabled.setter
    def auth_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auth_enabled", value)

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args']]:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @azure_static_web_app_v2.setter
    def azure_static_web_app_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args']]):
        pulumi.set(self, "azure_static_web_app_v2", value)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2Args']]]]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @custom_oidc_v2s.setter
    def custom_oidc_v2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2Args']]]]):
        pulumi.set(self, "custom_oidc_v2s", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2FacebookV2Args']]:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @facebook_v2.setter
    def facebook_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2FacebookV2Args']]):
        pulumi.set(self, "facebook_v2", value)

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @forward_proxy_convention.setter
    def forward_proxy_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_convention", value)

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @forward_proxy_custom_host_header_name.setter
    def forward_proxy_custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_host_header_name", value)

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @forward_proxy_custom_scheme_header_name.setter
    def forward_proxy_custom_scheme_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_scheme_header_name", value)

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GithubV2Args']]:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @github_v2.setter
    def github_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GithubV2Args']]):
        pulumi.set(self, "github_v2", value)

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GoogleV2Args']]:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @google_v2.setter
    def google_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2GoogleV2Args']]):
        pulumi.set(self, "google_v2", value)

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @http_route_api_prefix.setter
    def http_route_api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_route_api_prefix", value)

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2Args']]:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @microsoft_v2.setter
    def microsoft_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2Args']]):
        pulumi.set(self, "microsoft_v2", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2TwitterV2Args']]:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @twitter_v2.setter
    def twitter_v2(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotAuthSettingsV2TwitterV2Args']]):
        pulumi.set(self, "twitter_v2", value)

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")

    @unauthenticated_action.setter
    def unauthenticated_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_action", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        tenant_auth_endpoint: pulumi.Input[str]
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        allowed_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the certificate used for signing purposes.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        jwt_allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        jwt_allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Groups in the JWT Claim.
        """
        login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        www_authentication_disabled: NotRequired[pulumi.Input[bool]]
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 tenant_auth_endpoint: pulumi.Input[str],
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 jwt_allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jwt_allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 www_authentication_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[str] tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`
               
               > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param pulumi.Input[str] client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param pulumi.Input[bool] www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> pulumi.Input[str]:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @tenant_auth_endpoint.setter
    def tenant_auth_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_auth_endpoint", value)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @allowed_identities.setter
    def allowed_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_identities", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @jwt_allowed_client_applications.setter
    def jwt_allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_client_applications", value)

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @jwt_allowed_groups.setter
    def jwt_allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_groups", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        return pulumi.get(self, "www_authentication_disabled")

    @www_authentication_disabled.setter
    def www_authentication_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "www_authentication_disabled", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2AppleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2AppleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2AppleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Apple web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Apple Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: A list of Login Scopes provided by this Authentication Provider.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        name: pulumi.Input[str]
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        openid_configuration_endpoint: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        authorisation_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        certification_uri: NotRequired[pulumi.Input[str]]
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        client_credential_method: NotRequired[pulumi.Input[str]]
        """
        The Client Credential Method used.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        issuer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        name_claim_type: NotRequired[pulumi.Input[str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of the scopes that should be requested while authenticating.
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 openid_configuration_endpoint: pulumi.Input[str],
                 authorisation_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 client_credential_method: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 issuer_endpoint: Optional[pulumi.Input[str]] = None,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with the Custom OIDC.
        :param pulumi.Input[str] name: The name of the Custom OIDC Authentication Provider.
               
               > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        :param pulumi.Input[str] openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param pulumi.Input[str] authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] client_credential_method: The Client Credential Method used.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        :param pulumi.Input[str] issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of the scopes that should be requested while authenticating.
        :param pulumi.Input[str] token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @openid_configuration_endpoint.setter
    def openid_configuration_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "openid_configuration_endpoint", value)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @authorisation_endpoint.setter
    def authorisation_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorisation_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @client_credential_method.setter
    def client_credential_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_credential_method", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @issuer_endpoint.setter
    def issuer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_endpoint", value)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2FacebookV2ArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        graph_api_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Facebook API to be used while logging in.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2FacebookV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2FacebookV2Args:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret_setting_name: pulumi.Input[str],
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[str] graph_api_version: The version of the Facebook API to be used while logging in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of scopes that should be requested as part of Facebook Login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2GithubV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login..
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2GithubV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2GithubV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login..
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login..
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2GoogleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2GoogleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2GoogleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2LoginArgsDict(TypedDict):
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration_convention: NotRequired[pulumi.Input[str]]
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        cookie_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        logout_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to which logout requests should be made.
        """
        nonce_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[bool]]
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        token_refresh_extension_time: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        token_store_path: NotRequired[pulumi.Input[str]]
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        token_store_sas_setting_name: NotRequired[pulumi.Input[str]]
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        validate_nonce: NotRequired[pulumi.Input[bool]]
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration_convention: Optional[pulumi.Input[str]] = None,
                 cookie_expiration_time: Optional[pulumi.Input[str]] = None,
                 logout_endpoint: Optional[pulumi.Input[str]] = None,
                 nonce_expiration_time: Optional[pulumi.Input[str]] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 token_refresh_extension_time: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 token_store_path: Optional[pulumi.Input[str]] = None,
                 token_store_sas_setting_name: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param pulumi.Input[str] cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param pulumi.Input[str] cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param pulumi.Input[str] logout_endpoint: The endpoint to which logout requests should be made.
        :param pulumi.Input[str] nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param pulumi.Input[bool] preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param pulumi.Input[float] token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param pulumi.Input[str] token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param pulumi.Input[str] token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param pulumi.Input[bool] validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @cookie_expiration_convention.setter
    def cookie_expiration_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_convention", value)

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @cookie_expiration_time.setter
    def cookie_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_time", value)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @nonce_expiration_time.setter
    def nonce_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_time", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @token_refresh_extension_time.setter
    def token_refresh_extension_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_time", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @token_store_path.setter
    def token_store_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_path", value)

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @token_store_sas_setting_name.setter
    def token_store_sas_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_sas_setting_name", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsFunctionAppSlotAuthSettingsV2TwitterV2ArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
elif False:
    WindowsFunctionAppSlotAuthSettingsV2TwitterV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotAuthSettingsV2TwitterV2Args:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret_setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class WindowsFunctionAppSlotBackupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Backup.
        """
        schedule: pulumi.Input['WindowsFunctionAppSlotBackupScheduleArgsDict']
        """
        a `schedule` block as detailed below.
        """
        storage_account_url: pulumi.Input[str]
        """
        The SAS URL to the container.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Should this backup job be enabled? Defaults to `true`.
        """
elif False:
    WindowsFunctionAppSlotBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotBackupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['WindowsFunctionAppSlotBackupScheduleArgs'],
                 storage_account_url: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Backup.
        :param pulumi.Input['WindowsFunctionAppSlotBackupScheduleArgs'] schedule: a `schedule` block as detailed below.
        :param pulumi.Input[str] storage_account_url: The SAS URL to the container.
        :param pulumi.Input[bool] enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['WindowsFunctionAppSlotBackupScheduleArgs']:
        """
        a `schedule` block as detailed below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['WindowsFunctionAppSlotBackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> pulumi.Input[str]:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WindowsFunctionAppSlotBackupScheduleArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all SKUs. Please refer to the official documentation for appropriate values.
        """
        frequency_unit: pulumi.Input[str]
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        keep_at_least_one_backup: NotRequired[pulumi.Input[bool]]
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        last_execution_time: NotRequired[pulumi.Input[str]]
        """
        The time the backup was last attempted.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        When the schedule should start working in RFC-3339 format.
        """
elif False:
    WindowsFunctionAppSlotBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotBackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_unit: pulumi.Input[str],
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 last_execution_time: Optional[pulumi.Input[str]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all SKUs. Please refer to the official documentation for appropriate values.
        :param pulumi.Input[str] frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        :param pulumi.Input[bool] keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param pulumi.Input[str] last_execution_time: The time the backup was last attempted.
        :param pulumi.Input[int] retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param pulumi.Input[str] start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input[str]:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @last_execution_time.setter
    def last_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_execution_time", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class WindowsFunctionAppSlotConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Connection.
        """
        type: pulumi.Input[str]
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The connection string value.
        """
elif False:
    WindowsFunctionAppSlotConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name which should be used for this Connection.
        :param pulumi.Input[str] type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param pulumi.Input[str] value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Connection.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WindowsFunctionAppSlotIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    WindowsFunctionAppSlotIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Windows Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App Slot.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class WindowsFunctionAppSlotSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        If this Windows Web App is Always On enabled. Defaults to `false`.
        """
        api_definition_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the API definition that describes this Windows Function App.
        """
        api_management_api_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the API Management API for this Windows Function App.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        """
        app_scale_limit: NotRequired[pulumi.Input[int]]
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        app_service_logs: NotRequired[pulumi.Input['WindowsFunctionAppSlotSiteConfigAppServiceLogsArgsDict']]
        """
        an `app_service_logs` block as detailed below.
        """
        application_insights_connection_string: NotRequired[pulumi.Input[str]]
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        application_insights_key: NotRequired[pulumi.Input[str]]
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        application_stack: NotRequired[pulumi.Input['WindowsFunctionAppSlotSiteConfigApplicationStackArgsDict']]
        """
        an `application_stack` block as detailed below.
        """
        auto_swap_slot_name: NotRequired[pulumi.Input[str]]
        """
        The name of the slot to automatically swap with when this slot is successfully deployed.
        """
        cors: NotRequired[pulumi.Input['WindowsFunctionAppSlotSiteConfigCorsArgsDict']]
        """
        a `cors` block as detailed below.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Default Documents for the Windows Web App.
        """
        detailed_error_logging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is detailed error logging enabled
        """
        elastic_instance_minimum: NotRequired[pulumi.Input[int]]
        """
        The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        """
        ftps_state: NotRequired[pulumi.Input[str]]
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        health_check_eviction_time_in_min: NotRequired[pulumi.Input[int]]
        """
        The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `0`. Only valid in conjunction with `health_check_path`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The path to be checked for this function app health.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionArgsDict']]]]
        """
        an `ip_restriction` block as detailed below.
        """
        load_balancing_mode: NotRequired[pulumi.Input[str]]
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        pre_warmed_instance_count: NotRequired[pulumi.Input[int]]
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        """
        runtime_scale_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Scale Monitoring of the Functions Runtime be enabled?

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        scm_ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgsDict']]]]
        """
        a `scm_ip_restriction` block as detailed below.
        """
        scm_minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        """
        The SCM Type in use by the Windows Function App.
        """
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        """
        use32_bit_worker: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        windows_fx_version: NotRequired[pulumi.Input[str]]
        """
        The Windows FX Version string.
        """
        worker_count: NotRequired[pulumi.Input[int]]
        """
        The number of Workers for this Windows Function App.
        """
elif False:
    WindowsFunctionAppSlotSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 api_definition_url: Optional[pulumi.Input[str]] = None,
                 api_management_api_id: Optional[pulumi.Input[str]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 app_scale_limit: Optional[pulumi.Input[int]] = None,
                 app_service_logs: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigAppServiceLogsArgs']] = None,
                 application_insights_connection_string: Optional[pulumi.Input[str]] = None,
                 application_insights_key: Optional[pulumi.Input[str]] = None,
                 application_stack: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigApplicationStackArgs']] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
                 cors: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 elastic_instance_minimum: Optional[pulumi.Input[int]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 health_check_eviction_time_in_min: Optional[pulumi.Input[int]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionArgs']]]] = None,
                 load_balancing_mode: Optional[pulumi.Input[str]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 pre_warmed_instance_count: Optional[pulumi.Input[int]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 runtime_scale_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 scm_ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker: Optional[pulumi.Input[bool]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 windows_fx_version: Optional[pulumi.Input[str]] = None,
                 worker_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] always_on: If this Windows Web App is Always On enabled. Defaults to `false`.
        :param pulumi.Input[str] api_definition_url: The URL of the API definition that describes this Windows Function App.
        :param pulumi.Input[str] api_management_api_id: The ID of the API Management API for this Windows Function App.
        :param pulumi.Input[str] app_command_line: The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        :param pulumi.Input[int] app_scale_limit: The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        :param pulumi.Input['WindowsFunctionAppSlotSiteConfigAppServiceLogsArgs'] app_service_logs: an `app_service_logs` block as detailed below.
        :param pulumi.Input[str] application_insights_connection_string: The Connection String for linking the Windows Function App to Application Insights.
        :param pulumi.Input[str] application_insights_key: The Instrumentation Key for connecting the Windows Function App to Application Insights.
        :param pulumi.Input['WindowsFunctionAppSlotSiteConfigApplicationStackArgs'] application_stack: an `application_stack` block as detailed below.
        :param pulumi.Input[str] auto_swap_slot_name: The name of the slot to automatically swap with when this slot is successfully deployed.
        :param pulumi.Input['WindowsFunctionAppSlotSiteConfigCorsArgs'] cors: a `cors` block as detailed below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: Specifies a list of Default Documents for the Windows Web App.
        :param pulumi.Input[bool] detailed_error_logging_enabled: Is detailed error logging enabled
        :param pulumi.Input[int] elastic_instance_minimum: The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        :param pulumi.Input[str] ftps_state: State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        :param pulumi.Input[int] health_check_eviction_time_in_min: The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `0`. Only valid in conjunction with `health_check_path`.
        :param pulumi.Input[str] health_check_path: The path to be checked for this function app health.
        :param pulumi.Input[bool] http2_enabled: Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        :param pulumi.Input[str] ip_restriction_default_action: The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionArgs']]] ip_restrictions: an `ip_restriction` block as detailed below.
        :param pulumi.Input[str] load_balancing_mode: The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param pulumi.Input[str] managed_pipeline_mode: The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[int] pre_warmed_instance_count: The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        :param pulumi.Input[bool] remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        :param pulumi.Input[bool] runtime_scale_monitoring_enabled: Should Scale Monitoring of the Functions Runtime be enabled?
               
               > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        :param pulumi.Input[str] scm_ip_restriction_default_action: The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: a `scm_ip_restriction` block as detailed below.
        :param pulumi.Input[str] scm_minimum_tls_version: Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[str] scm_type: The SCM Type in use by the Windows Function App.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        :param pulumi.Input[bool] use32_bit_worker: Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        :param pulumi.Input[bool] vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param pulumi.Input[bool] websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param pulumi.Input[str] windows_fx_version: The Windows FX Version string.
        :param pulumi.Input[int] worker_count: The number of Workers for this Windows Function App.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_scale_limit is not None:
            pulumi.set(__self__, "app_scale_limit", app_scale_limit)
        if app_service_logs is not None:
            pulumi.set(__self__, "app_service_logs", app_service_logs)
        if application_insights_connection_string is not None:
            pulumi.set(__self__, "application_insights_connection_string", application_insights_connection_string)
        if application_insights_key is not None:
            pulumi.set(__self__, "application_insights_key", application_insights_key)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if elastic_instance_minimum is not None:
            pulumi.set(__self__, "elastic_instance_minimum", elastic_instance_minimum)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restriction_default_action is not None:
            pulumi.set(__self__, "ip_restriction_default_action", ip_restriction_default_action)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "runtime_scale_monitoring_enabled", runtime_scale_monitoring_enabled)
        if scm_ip_restriction_default_action is not None:
            pulumi.set(__self__, "scm_ip_restriction_default_action", scm_ip_restriction_default_action)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        If this Windows Web App is Always On enabled. Defaults to `false`.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the API definition that describes this Windows Function App.
        """
        return pulumi.get(self, "api_definition_url")

    @api_definition_url.setter
    def api_definition_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_definition_url", value)

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the API Management API for this Windows Function App.
        """
        return pulumi.get(self, "api_management_api_id")

    @api_management_api_id.setter
    def api_management_api_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_management_api_id", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="appScaleLimit")
    def app_scale_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
        """
        return pulumi.get(self, "app_scale_limit")

    @app_scale_limit.setter
    def app_scale_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "app_scale_limit", value)

    @property
    @pulumi.getter(name="appServiceLogs")
    def app_service_logs(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigAppServiceLogsArgs']]:
        """
        an `app_service_logs` block as detailed below.
        """
        return pulumi.get(self, "app_service_logs")

    @app_service_logs.setter
    def app_service_logs(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigAppServiceLogsArgs']]):
        pulumi.set(self, "app_service_logs", value)

    @property
    @pulumi.getter(name="applicationInsightsConnectionString")
    def application_insights_connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        The Connection String for linking the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_connection_string")

    @application_insights_connection_string.setter
    def application_insights_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_insights_connection_string", value)

    @property
    @pulumi.getter(name="applicationInsightsKey")
    def application_insights_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Instrumentation Key for connecting the Windows Function App to Application Insights.
        """
        return pulumi.get(self, "application_insights_key")

    @application_insights_key.setter
    def application_insights_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_insights_key", value)

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigApplicationStackArgs']]:
        """
        an `application_stack` block as detailed below.
        """
        return pulumi.get(self, "application_stack")

    @application_stack.setter
    def application_stack(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigApplicationStackArgs']]):
        pulumi.set(self, "application_stack", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the slot to automatically swap with when this slot is successfully deployed.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigCorsArgs']]:
        """
        a `cors` block as detailed below.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Default Documents for the Windows Web App.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is detailed error logging enabled
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="elasticInstanceMinimum")
    def elastic_instance_minimum(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
        """
        return pulumi.get(self, "elastic_instance_minimum")

    @elastic_instance_minimum.setter
    def elastic_instance_minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "elastic_instance_minimum", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        """
        State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `0`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @health_check_eviction_time_in_min.setter
    def health_check_eviction_time_in_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_eviction_time_in_min", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to be checked for this function app health.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictionDefaultAction")
    def ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "ip_restriction_default_action")

    @ip_restriction_default_action.setter
    def ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionArgs']]]]:
        """
        an `ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @load_balancing_mode.setter
    def load_balancing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancing_mode", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @pre_warmed_instance_count.setter
    def pre_warmed_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pre_warmed_instance_count", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="runtimeScaleMonitoringEnabled")
    def runtime_scale_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Scale Monitoring of the Functions Runtime be enabled?

        > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
        """
        return pulumi.get(self, "runtime_scale_monitoring_enabled")

    @runtime_scale_monitoring_enabled.setter
    def runtime_scale_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "runtime_scale_monitoring_enabled", value)

    @property
    @pulumi.getter(name="scmIpRestrictionDefaultAction")
    def scm_ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "scm_ip_restriction_default_action")

    @scm_ip_restriction_default_action.setter
    def scm_ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgs']]]]:
        """
        a `scm_ip_restriction` block as detailed below.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @scm_minimum_tls_version.setter
    def scm_minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_minimum_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        """
        The SCM Type in use by the Windows Function App.
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @use32_bit_worker.setter
    def use32_bit_worker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Windows FX Version string.
        """
        return pulumi.get(self, "windows_fx_version")

    @windows_fx_version.setter
    def windows_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_fx_version", value)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Workers for this Windows Function App.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class WindowsFunctionAppSlotSiteConfigAppServiceLogsArgsDict(TypedDict):
        disk_quota_mb: NotRequired[pulumi.Input[int]]
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
elif False:
    WindowsFunctionAppSlotSiteConfigAppServiceLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotSiteConfigAppServiceLogsArgs:
    def __init__(__self__, *,
                 disk_quota_mb: Optional[pulumi.Input[int]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_quota_mb: The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        :param pulumi.Input[int] retention_period_days: The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
               
               > **NOTE:** This block is not supported on Consumption plans.
        """
        if disk_quota_mb is not None:
            pulumi.set(__self__, "disk_quota_mb", disk_quota_mb)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter(name="diskQuotaMb")
    def disk_quota_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
        """
        return pulumi.get(self, "disk_quota_mb")

    @disk_quota_mb.setter
    def disk_quota_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_quota_mb", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).

        > **NOTE:** This block is not supported on Consumption plans.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)


if not MYPY:
    class WindowsFunctionAppSlotSiteConfigApplicationStackArgsDict(TypedDict):
        dotnet_version: NotRequired[pulumi.Input[str]]
        """
        The version of .Net. Possible values are `v3.0`, `v4.0`, `v6.0`, `v7.0` and `v8.0`. Defaults to `v4.0`.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The version of Java to use. Possible values are `1.8`, `11` and `17` (In-Preview).
        """
        node_version: NotRequired[pulumi.Input[str]]
        """
        The version of Node to use. Possible values are `~12`, `~14`, `~16`, `~18` and `~20`.
        """
        powershell_core_version: NotRequired[pulumi.Input[str]]
        """
        The PowerShell Core version to use. Possible values are `7`, `7.2`, and `7.4`.
        """
        use_custom_runtime: NotRequired[pulumi.Input[bool]]
        """
        Does the Function App use a custom Application Stack?
        """
        use_dotnet_isolated_runtime: NotRequired[pulumi.Input[bool]]
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
elif False:
    WindowsFunctionAppSlotSiteConfigApplicationStackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotSiteConfigApplicationStackArgs:
    def __init__(__self__, *,
                 dotnet_version: Optional[pulumi.Input[str]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 node_version: Optional[pulumi.Input[str]] = None,
                 powershell_core_version: Optional[pulumi.Input[str]] = None,
                 use_custom_runtime: Optional[pulumi.Input[bool]] = None,
                 use_dotnet_isolated_runtime: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] dotnet_version: The version of .Net. Possible values are `v3.0`, `v4.0`, `v6.0`, `v7.0` and `v8.0`. Defaults to `v4.0`.
        :param pulumi.Input[str] java_version: The version of Java to use. Possible values are `1.8`, `11` and `17` (In-Preview).
        :param pulumi.Input[str] node_version: The version of Node to use. Possible values are `~12`, `~14`, `~16`, `~18` and `~20`.
        :param pulumi.Input[str] powershell_core_version: The PowerShell Core version to use. Possible values are `7`, `7.2`, and `7.4`.
        :param pulumi.Input[bool] use_custom_runtime: Does the Function App use a custom Application Stack?
        :param pulumi.Input[bool] use_dotnet_isolated_runtime: Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if powershell_core_version is not None:
            pulumi.set(__self__, "powershell_core_version", powershell_core_version)
        if use_custom_runtime is not None:
            pulumi.set(__self__, "use_custom_runtime", use_custom_runtime)
        if use_dotnet_isolated_runtime is not None:
            pulumi.set(__self__, "use_dotnet_isolated_runtime", use_dotnet_isolated_runtime)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .Net. Possible values are `v3.0`, `v4.0`, `v6.0`, `v7.0` and `v8.0`. Defaults to `v4.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @dotnet_version.setter
    def dotnet_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Java to use. Possible values are `1.8`, `11` and `17` (In-Preview).
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Node to use. Possible values are `~12`, `~14`, `~16`, `~18` and `~20`.
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="powershellCoreVersion")
    def powershell_core_version(self) -> Optional[pulumi.Input[str]]:
        """
        The PowerShell Core version to use. Possible values are `7`, `7.2`, and `7.4`.
        """
        return pulumi.get(self, "powershell_core_version")

    @powershell_core_version.setter
    def powershell_core_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "powershell_core_version", value)

    @property
    @pulumi.getter(name="useCustomRuntime")
    def use_custom_runtime(self) -> Optional[pulumi.Input[bool]]:
        """
        Does the Function App use a custom Application Stack?
        """
        return pulumi.get(self, "use_custom_runtime")

    @use_custom_runtime.setter
    def use_custom_runtime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_custom_runtime", value)

    @property
    @pulumi.getter(name="useDotnetIsolatedRuntime")
    def use_dotnet_isolated_runtime(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the DotNet process use an isolated runtime. Defaults to `false`.
        """
        return pulumi.get(self, "use_dotnet_isolated_runtime")

    @use_dotnet_isolated_runtime.setter
    def use_dotnet_isolated_runtime(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_dotnet_isolated_runtime", value)


if not MYPY:
    class WindowsFunctionAppSlotSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
elif False:
    WindowsFunctionAppSlotSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param pulumi.Input[bool] support_credentials: Are credentials allowed in CORS requests? Defaults to `false`.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Are credentials allowed in CORS requests? Defaults to `false`.
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class WindowsFunctionAppSlotSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict']]
        """
        a `headers` block as detailed below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    WindowsFunctionAppSlotSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgs'] headers: a `headers` block as detailed below.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgs']]:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        a `headers` block as detailed below.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT

        > **NOTE:** Exactly one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs'] headers: a `headers` block as detailed below.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
               
               > **NOTE:** Exactly one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        a `headers` block as detailed below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT

        > **NOTE:** Exactly one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class WindowsFunctionAppSlotSiteCredentialArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Username used for publishing.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Password used for publishing.
        """
elif False:
    WindowsFunctionAppSlotSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotSiteCredentialArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Site Credentials Username used for publishing.
        :param pulumi.Input[str] password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Username used for publishing.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class WindowsFunctionAppSlotStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The Access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The Name of the Storage Account.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this Storage Account.
        """
        share_name: pulumi.Input[str]
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        type: pulumi.Input[str]
        """
        The Azure Storage Type. Possible values include `AzureFiles`.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path at which to mount the storage share.
        """
elif False:
    WindowsFunctionAppSlotStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppSlotStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The Access key for the storage account.
        :param pulumi.Input[str] account_name: The Name of the Storage Account.
        :param pulumi.Input[str] name: The name which should be used for this Storage Account.
        :param pulumi.Input[str] share_name: The Name of the File Share or Container Name for Blob storage.
        :param pulumi.Input[str] type: The Azure Storage Type. Possible values include `AzureFiles`.
        :param pulumi.Input[str] mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Azure Storage Type. Possible values include `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class WindowsFunctionAppStickySettingsArgsDict(TypedDict):
        app_setting_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        connection_string_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
elif False:
    WindowsFunctionAppStickySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppStickySettingsArgs:
    def __init__(__self__, *,
                 app_setting_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 connection_string_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_setting_names: A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] connection_string_names: A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of `app_setting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @app_setting_names.setter
    def app_setting_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_setting_names", value)

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of `connection_string` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")

    @connection_string_names.setter
    def connection_string_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "connection_string_names", value)


if not MYPY:
    class WindowsFunctionAppStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The Access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The Name of the Storage Account.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this Storage Account.
        """
        share_name: pulumi.Input[str]
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        type: pulumi.Input[str]
        """
        The Azure Storage Type. Possible values include `AzureFiles`.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path at which to mount the storage share.
        """
elif False:
    WindowsFunctionAppStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsFunctionAppStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The Access key for the storage account.
        :param pulumi.Input[str] account_name: The Name of the Storage Account.
        :param pulumi.Input[str] name: The name which should be used for this Storage Account.
        :param pulumi.Input[str] share_name: The Name of the File Share or Container Name for Blob storage.
        :param pulumi.Input[str] type: The Azure Storage Type. Possible values include `AzureFiles`.
        :param pulumi.Input[str] mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Azure Storage Type. Possible values include `AzureFiles`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class WindowsWebAppAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Should the Authentication / Authorization feature is enabled for the Windows Web App be enabled?
        """
        active_directory: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsActiveDirectoryArgsDict']]
        """
        An `active_directory` block as defined above.
        """
        additional_login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        facebook: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        github: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsGithubArgsDict']]
        """
        A `github` block as defined below.
        """
        google: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
elif False:
    WindowsWebAppAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['WindowsWebAppAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['WindowsWebAppAuthSettingsFacebookArgs']] = None,
                 github: Optional[pulumi.Input['WindowsWebAppAuthSettingsGithubArgs']] = None,
                 google: Optional[pulumi.Input['WindowsWebAppAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['WindowsWebAppAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['WindowsWebAppAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Authentication / Authorization feature is enabled for the Windows Web App be enabled?
        :param pulumi.Input['WindowsWebAppAuthSettingsActiveDirectoryArgs'] active_directory: An `active_directory` block as defined above.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        :param pulumi.Input[str] default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
               
               > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        :param pulumi.Input['WindowsWebAppAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['WindowsWebAppAuthSettingsGithubArgs'] github: A `github` block as defined below.
        :param pulumi.Input['WindowsWebAppAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['WindowsWebAppAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param pulumi.Input['WindowsWebAppAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the Authentication / Authorization feature is enabled for the Windows Web App be enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsActiveDirectoryArgs']]:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @additional_login_parameters.setter
    def additional_login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_parameters", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsGithubArgs']]:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class WindowsWebAppAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
elif False:
    WindowsWebAppAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience.
        :param pulumi.Input[str] client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class WindowsWebAppAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret: NotRequired[pulumi.Input[str]]
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
elif False:
    WindowsWebAppAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsWebAppAuthSettingsGithubArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
elif False:
    WindowsWebAppAuthSettingsGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsGithubArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login.
        :param pulumi.Input[str] client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsWebAppAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
elif False:
    WindowsWebAppAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsWebAppAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
elif False:
    WindowsWebAppAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsWebAppAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
elif False:
    WindowsWebAppAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2ArgsDict(TypedDict):
        login: pulumi.Input['WindowsWebAppAuthSettingsV2LoginArgsDict']
        """
        A `login` block as defined below.
        """
        active_directory_v2: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsV2ActiveDirectoryV2ArgsDict']]
        """
        An `active_directory_v2` block as defined below.
        """
        apple_v2: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsV2AppleV2ArgsDict']]
        """
        An `apple_v2` block as defined below.
        """
        auth_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        azure_static_web_app_v2: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsV2AzureStaticWebAppV2ArgsDict']]
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        config_file_path: NotRequired[pulumi.Input[str]]
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        custom_oidc_v2s: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppAuthSettingsV2CustomOidcV2ArgsDict']]]]
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        facebook_v2: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsV2FacebookV2ArgsDict']]
        """
        A `facebook_v2` block as defined below.
        """
        forward_proxy_convention: NotRequired[pulumi.Input[str]]
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        forward_proxy_custom_host_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the host of the request.
        """
        forward_proxy_custom_scheme_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the scheme of the request.
        """
        github_v2: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsV2GithubV2ArgsDict']]
        """
        A `github_v2` block as defined below.
        """
        google_v2: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsV2GoogleV2ArgsDict']]
        """
        A `google_v2` block as defined below.
        """
        http_route_api_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        microsoft_v2: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsV2MicrosoftV2ArgsDict']]
        """
        A `microsoft_v2` block as defined below.
        """
        require_authentication: NotRequired[pulumi.Input[bool]]
        """
        Should the authentication flow be used for all requests.
        """
        require_https: NotRequired[pulumi.Input[bool]]
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        twitter_v2: NotRequired[pulumi.Input['WindowsWebAppAuthSettingsV2TwitterV2ArgsDict']]
        """
        A `twitter_v2` block as defined below.
        """
        unauthenticated_action: NotRequired[pulumi.Input[str]]
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
elif False:
    WindowsWebAppAuthSettingsV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2Args:
    def __init__(__self__, *,
                 login: pulumi.Input['WindowsWebAppAuthSettingsV2LoginArgs'],
                 active_directory_v2: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2ActiveDirectoryV2Args']] = None,
                 apple_v2: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2AppleV2Args']] = None,
                 auth_enabled: Optional[pulumi.Input[bool]] = None,
                 azure_static_web_app_v2: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2AzureStaticWebAppV2Args']] = None,
                 config_file_path: Optional[pulumi.Input[str]] = None,
                 custom_oidc_v2s: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppAuthSettingsV2CustomOidcV2Args']]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 facebook_v2: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2FacebookV2Args']] = None,
                 forward_proxy_convention: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_scheme_header_name: Optional[pulumi.Input[str]] = None,
                 github_v2: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2GithubV2Args']] = None,
                 google_v2: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2GoogleV2Args']] = None,
                 http_route_api_prefix: Optional[pulumi.Input[str]] = None,
                 microsoft_v2: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2MicrosoftV2Args']] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 twitter_v2: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2TwitterV2Args']] = None,
                 unauthenticated_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WindowsWebAppAuthSettingsV2LoginArgs'] login: A `login` block as defined below.
        :param pulumi.Input['WindowsWebAppAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2: An `active_directory_v2` block as defined below.
        :param pulumi.Input['WindowsWebAppAuthSettingsV2AppleV2Args'] apple_v2: An `apple_v2` block as defined below.
        :param pulumi.Input[bool] auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param pulumi.Input['WindowsWebAppAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param pulumi.Input[str] config_file_path: The path to the App Auth settings.
               
               > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppAuthSettingsV2CustomOidcV2Args']]] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param pulumi.Input[str] default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param pulumi.Input['WindowsWebAppAuthSettingsV2FacebookV2Args'] facebook_v2: A `facebook_v2` block as defined below.
        :param pulumi.Input[str] forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param pulumi.Input[str] forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param pulumi.Input[str] forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param pulumi.Input['WindowsWebAppAuthSettingsV2GithubV2Args'] github_v2: A `github_v2` block as defined below.
        :param pulumi.Input['WindowsWebAppAuthSettingsV2GoogleV2Args'] google_v2: A `google_v2` block as defined below.
        :param pulumi.Input[str] http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param pulumi.Input['WindowsWebAppAuthSettingsV2MicrosoftV2Args'] microsoft_v2: A `microsoft_v2` block as defined below.
        :param pulumi.Input[bool] require_authentication: Should the authentication flow be used for all requests.
        :param pulumi.Input[bool] require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param pulumi.Input[str] runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param pulumi.Input['WindowsWebAppAuthSettingsV2TwitterV2Args'] twitter_v2: A `twitter_v2` block as defined below.
        :param pulumi.Input[str] unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> pulumi.Input['WindowsWebAppAuthSettingsV2LoginArgs']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: pulumi.Input['WindowsWebAppAuthSettingsV2LoginArgs']):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsV2ActiveDirectoryV2Args']]:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @active_directory_v2.setter
    def active_directory_v2(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2ActiveDirectoryV2Args']]):
        pulumi.set(self, "active_directory_v2", value)

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsV2AppleV2Args']]:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @apple_v2.setter
    def apple_v2(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2AppleV2Args']]):
        pulumi.set(self, "apple_v2", value)

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @auth_enabled.setter
    def auth_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auth_enabled", value)

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsV2AzureStaticWebAppV2Args']]:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @azure_static_web_app_v2.setter
    def azure_static_web_app_v2(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2AzureStaticWebAppV2Args']]):
        pulumi.set(self, "azure_static_web_app_v2", value)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppAuthSettingsV2CustomOidcV2Args']]]]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @custom_oidc_v2s.setter
    def custom_oidc_v2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppAuthSettingsV2CustomOidcV2Args']]]]):
        pulumi.set(self, "custom_oidc_v2s", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsV2FacebookV2Args']]:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @facebook_v2.setter
    def facebook_v2(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2FacebookV2Args']]):
        pulumi.set(self, "facebook_v2", value)

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @forward_proxy_convention.setter
    def forward_proxy_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_convention", value)

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @forward_proxy_custom_host_header_name.setter
    def forward_proxy_custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_host_header_name", value)

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @forward_proxy_custom_scheme_header_name.setter
    def forward_proxy_custom_scheme_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_scheme_header_name", value)

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsV2GithubV2Args']]:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @github_v2.setter
    def github_v2(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2GithubV2Args']]):
        pulumi.set(self, "github_v2", value)

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsV2GoogleV2Args']]:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @google_v2.setter
    def google_v2(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2GoogleV2Args']]):
        pulumi.set(self, "google_v2", value)

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @http_route_api_prefix.setter
    def http_route_api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_route_api_prefix", value)

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsV2MicrosoftV2Args']]:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @microsoft_v2.setter
    def microsoft_v2(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2MicrosoftV2Args']]):
        pulumi.set(self, "microsoft_v2", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional[pulumi.Input['WindowsWebAppAuthSettingsV2TwitterV2Args']]:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @twitter_v2.setter
    def twitter_v2(self, value: Optional[pulumi.Input['WindowsWebAppAuthSettingsV2TwitterV2Args']]):
        pulumi.set(self, "twitter_v2", value)

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")

    @unauthenticated_action.setter
    def unauthenticated_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_action", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2ActiveDirectoryV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        tenant_auth_endpoint: pulumi.Input[str]
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        allowed_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the certificate used for signing purposes.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        jwt_allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        jwt_allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Groups in the JWT Claim.
        """
        login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        www_authentication_disabled: NotRequired[pulumi.Input[bool]]
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
elif False:
    WindowsWebAppAuthSettingsV2ActiveDirectoryV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2ActiveDirectoryV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 tenant_auth_endpoint: pulumi.Input[str],
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 jwt_allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jwt_allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 www_authentication_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[str] tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`
               
               > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param pulumi.Input[str] client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param pulumi.Input[bool] www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> pulumi.Input[str]:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @tenant_auth_endpoint.setter
    def tenant_auth_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_auth_endpoint", value)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @allowed_identities.setter
    def allowed_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_identities", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @jwt_allowed_client_applications.setter
    def jwt_allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_client_applications", value)

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @jwt_allowed_groups.setter
    def jwt_allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_groups", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        return pulumi.get(self, "www_authentication_disabled")

    @www_authentication_disabled.setter
    def www_authentication_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "www_authentication_disabled", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2AppleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
elif False:
    WindowsWebAppAuthSettingsV2AppleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2AppleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Apple web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Apple Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: A list of Login Scopes provided by this Authentication Provider.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2AzureStaticWebAppV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
elif False:
    WindowsWebAppAuthSettingsV2AzureStaticWebAppV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2AzureStaticWebAppV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2CustomOidcV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        name: pulumi.Input[str]
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        openid_configuration_endpoint: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        authorisation_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        certification_uri: NotRequired[pulumi.Input[str]]
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        client_credential_method: NotRequired[pulumi.Input[str]]
        """
        The Client Credential Method used.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        issuer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        name_claim_type: NotRequired[pulumi.Input[str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of the scopes that should be requested while authenticating.
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
elif False:
    WindowsWebAppAuthSettingsV2CustomOidcV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2CustomOidcV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 openid_configuration_endpoint: pulumi.Input[str],
                 authorisation_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 client_credential_method: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 issuer_endpoint: Optional[pulumi.Input[str]] = None,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with the Custom OIDC.
        :param pulumi.Input[str] name: The name of the Custom OIDC Authentication Provider.
               
               > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        :param pulumi.Input[str] openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param pulumi.Input[str] authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] client_credential_method: The Client Credential Method used.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        :param pulumi.Input[str] issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of the scopes that should be requested while authenticating.
        :param pulumi.Input[str] token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @openid_configuration_endpoint.setter
    def openid_configuration_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "openid_configuration_endpoint", value)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @authorisation_endpoint.setter
    def authorisation_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorisation_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @client_credential_method.setter
    def client_credential_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_credential_method", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @issuer_endpoint.setter
    def issuer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_endpoint", value)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2FacebookV2ArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        graph_api_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Facebook API to be used while logging in.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
elif False:
    WindowsWebAppAuthSettingsV2FacebookV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2FacebookV2Args:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret_setting_name: pulumi.Input[str],
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[str] graph_api_version: The version of the Facebook API to be used while logging in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of scopes that should be requested as part of Facebook Login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2GithubV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login..
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
elif False:
    WindowsWebAppAuthSettingsV2GithubV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2GithubV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login..
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login..
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2GoogleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
elif False:
    WindowsWebAppAuthSettingsV2GoogleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2GoogleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2LoginArgsDict(TypedDict):
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration_convention: NotRequired[pulumi.Input[str]]
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        cookie_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        logout_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to which logout requests should be made.
        """
        nonce_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[bool]]
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        token_refresh_extension_time: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        token_store_path: NotRequired[pulumi.Input[str]]
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        token_store_sas_setting_name: NotRequired[pulumi.Input[str]]
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        validate_nonce: NotRequired[pulumi.Input[bool]]
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
elif False:
    WindowsWebAppAuthSettingsV2LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration_convention: Optional[pulumi.Input[str]] = None,
                 cookie_expiration_time: Optional[pulumi.Input[str]] = None,
                 logout_endpoint: Optional[pulumi.Input[str]] = None,
                 nonce_expiration_time: Optional[pulumi.Input[str]] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 token_refresh_extension_time: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 token_store_path: Optional[pulumi.Input[str]] = None,
                 token_store_sas_setting_name: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param pulumi.Input[str] cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param pulumi.Input[str] cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param pulumi.Input[str] logout_endpoint: The endpoint to which logout requests should be made.
        :param pulumi.Input[str] nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param pulumi.Input[bool] preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param pulumi.Input[float] token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param pulumi.Input[str] token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param pulumi.Input[str] token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param pulumi.Input[bool] validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @cookie_expiration_convention.setter
    def cookie_expiration_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_convention", value)

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @cookie_expiration_time.setter
    def cookie_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_time", value)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @nonce_expiration_time.setter
    def nonce_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_time", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @token_refresh_extension_time.setter
    def token_refresh_extension_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_time", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @token_store_path.setter
    def token_store_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_path", value)

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @token_store_sas_setting_name.setter
    def token_store_sas_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_sas_setting_name", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2MicrosoftV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
elif False:
    WindowsWebAppAuthSettingsV2MicrosoftV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2MicrosoftV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppAuthSettingsV2TwitterV2ArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
elif False:
    WindowsWebAppAuthSettingsV2TwitterV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppAuthSettingsV2TwitterV2Args:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret_setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class WindowsWebAppBackupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Backup.
        """
        schedule: pulumi.Input['WindowsWebAppBackupScheduleArgsDict']
        """
        A `schedule` block as defined below.
        """
        storage_account_url: pulumi.Input[str]
        """
        The SAS URL to the container.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Should this backup job be enabled? Defaults to `true`.
        """
elif False:
    WindowsWebAppBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppBackupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['WindowsWebAppBackupScheduleArgs'],
                 storage_account_url: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Backup.
        :param pulumi.Input['WindowsWebAppBackupScheduleArgs'] schedule: A `schedule` block as defined below.
        :param pulumi.Input[str] storage_account_url: The SAS URL to the container.
        :param pulumi.Input[bool] enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['WindowsWebAppBackupScheduleArgs']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['WindowsWebAppBackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> pulumi.Input[str]:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WindowsWebAppBackupScheduleArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        frequency_unit: pulumi.Input[str]
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        keep_at_least_one_backup: NotRequired[pulumi.Input[bool]]
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        last_execution_time: NotRequired[pulumi.Input[str]]
        """
        The time the backup was last attempted.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        When the schedule should start working in RFC-3339 format.
        """
elif False:
    WindowsWebAppBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppBackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_unit: pulumi.Input[str],
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 last_execution_time: Optional[pulumi.Input[str]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        :param pulumi.Input[str] frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param pulumi.Input[bool] keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param pulumi.Input[str] last_execution_time: The time the backup was last attempted.
        :param pulumi.Input[int] retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param pulumi.Input[str] start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input[str]:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @last_execution_time.setter
    def last_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_execution_time", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class WindowsWebAppConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Connection String.
        """
        type: pulumi.Input[str]
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The connection string value.
        """
elif False:
    WindowsWebAppConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Connection String.
        :param pulumi.Input[str] type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param pulumi.Input[str] value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Connection String.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WindowsWebAppIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Web App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    WindowsWebAppIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Windows Web App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Web App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class WindowsWebAppLogsArgsDict(TypedDict):
        application_logs: NotRequired[pulumi.Input['WindowsWebAppLogsApplicationLogsArgsDict']]
        """
        A `application_logs` block as defined above.
        """
        detailed_error_messages: NotRequired[pulumi.Input[bool]]
        """
        Should detailed error messages be enabled.
        """
        failed_request_tracing: NotRequired[pulumi.Input[bool]]
        """
        Should tracing be enabled for failed requests.
        """
        http_logs: NotRequired[pulumi.Input['WindowsWebAppLogsHttpLogsArgsDict']]
        """
        A `http_logs` block as defined above.
        """
elif False:
    WindowsWebAppLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppLogsArgs:
    def __init__(__self__, *,
                 application_logs: Optional[pulumi.Input['WindowsWebAppLogsApplicationLogsArgs']] = None,
                 detailed_error_messages: Optional[pulumi.Input[bool]] = None,
                 failed_request_tracing: Optional[pulumi.Input[bool]] = None,
                 http_logs: Optional[pulumi.Input['WindowsWebAppLogsHttpLogsArgs']] = None):
        """
        :param pulumi.Input['WindowsWebAppLogsApplicationLogsArgs'] application_logs: A `application_logs` block as defined above.
        :param pulumi.Input[bool] detailed_error_messages: Should detailed error messages be enabled.
        :param pulumi.Input[bool] failed_request_tracing: Should tracing be enabled for failed requests.
        :param pulumi.Input['WindowsWebAppLogsHttpLogsArgs'] http_logs: A `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional[pulumi.Input['WindowsWebAppLogsApplicationLogsArgs']]:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @application_logs.setter
    def application_logs(self, value: Optional[pulumi.Input['WindowsWebAppLogsApplicationLogsArgs']]):
        pulumi.set(self, "application_logs", value)

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[pulumi.Input[bool]]:
        """
        Should detailed error messages be enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @detailed_error_messages.setter
    def detailed_error_messages(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_messages", value)

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[pulumi.Input[bool]]:
        """
        Should tracing be enabled for failed requests.
        """
        return pulumi.get(self, "failed_request_tracing")

    @failed_request_tracing.setter
    def failed_request_tracing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failed_request_tracing", value)

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional[pulumi.Input['WindowsWebAppLogsHttpLogsArgs']]:
        """
        A `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")

    @http_logs.setter
    def http_logs(self, value: Optional[pulumi.Input['WindowsWebAppLogsHttpLogsArgs']]):
        pulumi.set(self, "http_logs", value)


if not MYPY:
    class WindowsWebAppLogsApplicationLogsArgsDict(TypedDict):
        file_system_level: pulumi.Input[str]
        """
        Log level. Possible values include: `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        """
        azure_blob_storage: NotRequired[pulumi.Input['WindowsWebAppLogsApplicationLogsAzureBlobStorageArgsDict']]
        """
        An `azure_blob_storage` block as defined below.
        """
elif False:
    WindowsWebAppLogsApplicationLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppLogsApplicationLogsArgs:
    def __init__(__self__, *,
                 file_system_level: pulumi.Input[str],
                 azure_blob_storage: Optional[pulumi.Input['WindowsWebAppLogsApplicationLogsAzureBlobStorageArgs']] = None):
        """
        :param pulumi.Input[str] file_system_level: Log level. Possible values include: `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        :param pulumi.Input['WindowsWebAppLogsApplicationLogsAzureBlobStorageArgs'] azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> pulumi.Input[str]:
        """
        Log level. Possible values include: `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @file_system_level.setter
    def file_system_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_system_level", value)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['WindowsWebAppLogsApplicationLogsAzureBlobStorageArgs']]:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['WindowsWebAppLogsApplicationLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)


if not MYPY:
    class WindowsWebAppLogsApplicationLogsAzureBlobStorageArgsDict(TypedDict):
        level: pulumi.Input[str]
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        retention_in_days: pulumi.Input[int]
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        sas_url: pulumi.Input[str]
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
elif False:
    WindowsWebAppLogsApplicationLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppLogsApplicationLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[str],
                 retention_in_days: pulumi.Input[int],
                 sas_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param pulumi.Input[int] retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param pulumi.Input[str] sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input[str]:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[str]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class WindowsWebAppLogsHttpLogsArgsDict(TypedDict):
        azure_blob_storage: NotRequired[pulumi.Input['WindowsWebAppLogsHttpLogsAzureBlobStorageArgsDict']]
        """
        A `azure_blob_storage_http` block as defined below.
        """
        file_system: NotRequired[pulumi.Input['WindowsWebAppLogsHttpLogsFileSystemArgsDict']]
        """
        A `file_system` block as defined above.
        """
elif False:
    WindowsWebAppLogsHttpLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppLogsHttpLogsArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['WindowsWebAppLogsHttpLogsAzureBlobStorageArgs']] = None,
                 file_system: Optional[pulumi.Input['WindowsWebAppLogsHttpLogsFileSystemArgs']] = None):
        """
        :param pulumi.Input['WindowsWebAppLogsHttpLogsAzureBlobStorageArgs'] azure_blob_storage: A `azure_blob_storage_http` block as defined below.
        :param pulumi.Input['WindowsWebAppLogsHttpLogsFileSystemArgs'] file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['WindowsWebAppLogsHttpLogsAzureBlobStorageArgs']]:
        """
        A `azure_blob_storage_http` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['WindowsWebAppLogsHttpLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['WindowsWebAppLogsHttpLogsFileSystemArgs']]:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['WindowsWebAppLogsHttpLogsFileSystemArgs']]):
        pulumi.set(self, "file_system", value)


if not MYPY:
    class WindowsWebAppLogsHttpLogsAzureBlobStorageArgsDict(TypedDict):
        sas_url: pulumi.Input[str]
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        retention_in_days: NotRequired[pulumi.Input[int]]
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
elif False:
    WindowsWebAppLogsHttpLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppLogsHttpLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 sas_url: pulumi.Input[str],
                 retention_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        :param pulumi.Input[int] retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)


if not MYPY:
    class WindowsWebAppLogsHttpLogsFileSystemArgsDict(TypedDict):
        retention_in_days: pulumi.Input[int]
        """
        The retention period in days. A values of `0` means no retention.
        """
        retention_in_mb: pulumi.Input[int]
        """
        The maximum size in megabytes that log files can use.
        """
elif False:
    WindowsWebAppLogsHttpLogsFileSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppLogsHttpLogsFileSystemArgs:
    def __init__(__self__, *,
                 retention_in_days: pulumi.Input[int],
                 retention_in_mb: pulumi.Input[int]):
        """
        :param pulumi.Input[int] retention_in_days: The retention period in days. A values of `0` means no retention.
        :param pulumi.Input[int] retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The retention period in days. A values of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> pulumi.Input[int]:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")

    @retention_in_mb.setter
    def retention_in_mb(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_mb", value)


if not MYPY:
    class WindowsWebAppSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        If this Windows Web App is Always On enabled. Defaults to `true`.

        > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        """
        api_definition_url: NotRequired[pulumi.Input[str]]
        """
        The URL to the API Definition for this Windows Web App.
        """
        api_management_api_id: NotRequired[pulumi.Input[str]]
        """
        The API Management API ID this Windows Web App Slot is associated with.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        The App command line to launch.
        """
        application_stack: NotRequired[pulumi.Input['WindowsWebAppSiteConfigApplicationStackArgsDict']]
        """
        A `application_stack` block as defined above.
        """
        auto_heal_setting: NotRequired[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingArgsDict']]
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        container_registry_managed_identity_client_id: NotRequired[pulumi.Input[str]]
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        container_registry_use_managed_identity: NotRequired[pulumi.Input[bool]]
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        cors: NotRequired[pulumi.Input['WindowsWebAppSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined above.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Default Documents for the Windows Web App.
        """
        detailed_error_logging_enabled: NotRequired[pulumi.Input[bool]]
        ftps_state: NotRequired[pulumi.Input[str]]
        handler_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigHandlerMappingArgsDict']]]]
        """
        One or more `handler_mapping` blocks as defined below.
        """
        health_check_eviction_time_in_min: NotRequired[pulumi.Input[int]]
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The path to the Health Check.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the HTTP2 be enabled?
        """
        ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigIpRestrictionArgsDict']]]]
        """
        One or more `ip_restriction` blocks as defined above.
        """
        linux_fx_version: NotRequired[pulumi.Input[str]]
        load_balancing_mode: NotRequired[pulumi.Input[str]]
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        local_mysql_enabled: NotRequired[pulumi.Input[bool]]
        """
        Use Local MySQL. Defaults to `false`.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`.
        """
        scm_ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionArgsDict']]]]
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        scm_minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Web App `ip_restriction` configuration be used for the SCM also.
        """
        use32_bit_worker: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        """
        virtual_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationArgsDict']]]]
        """
        One or more `virtual_application` blocks as defined below.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        windows_fx_version: NotRequired[pulumi.Input[str]]
        worker_count: NotRequired[pulumi.Input[int]]
        """
        The number of Workers for this Windows App Service.
        """
elif False:
    WindowsWebAppSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 api_definition_url: Optional[pulumi.Input[str]] = None,
                 api_management_api_id: Optional[pulumi.Input[str]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 application_stack: Optional[pulumi.Input['WindowsWebAppSiteConfigApplicationStackArgs']] = None,
                 auto_heal_setting: Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingArgs']] = None,
                 container_registry_managed_identity_client_id: Optional[pulumi.Input[str]] = None,
                 container_registry_use_managed_identity: Optional[pulumi.Input[bool]] = None,
                 cors: Optional[pulumi.Input['WindowsWebAppSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 handler_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigHandlerMappingArgs']]]] = None,
                 health_check_eviction_time_in_min: Optional[pulumi.Input[int]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigIpRestrictionArgs']]]] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 load_balancing_mode: Optional[pulumi.Input[str]] = None,
                 local_mysql_enabled: Optional[pulumi.Input[bool]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 scm_ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker: Optional[pulumi.Input[bool]] = None,
                 virtual_applications: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationArgs']]]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 windows_fx_version: Optional[pulumi.Input[str]] = None,
                 worker_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] always_on: If this Windows Web App is Always On enabled. Defaults to `true`.
               
               > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        :param pulumi.Input[str] api_definition_url: The URL to the API Definition for this Windows Web App.
        :param pulumi.Input[str] api_management_api_id: The API Management API ID this Windows Web App Slot is associated with.
        :param pulumi.Input[str] app_command_line: The App command line to launch.
        :param pulumi.Input['WindowsWebAppSiteConfigApplicationStackArgs'] application_stack: A `application_stack` block as defined above.
        :param pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingArgs'] auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param pulumi.Input[str] container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param pulumi.Input[bool] container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param pulumi.Input['WindowsWebAppSiteConfigCorsArgs'] cors: A `cors` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: Specifies a list of Default Documents for the Windows Web App.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigHandlerMappingArgs']]] handler_mappings: One or more `handler_mapping` blocks as defined below.
        :param pulumi.Input[int] health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param pulumi.Input[str] health_check_path: The path to the Health Check.
        :param pulumi.Input[bool] http2_enabled: Should the HTTP2 be enabled?
        :param pulumi.Input[str] ip_restriction_default_action: The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigIpRestrictionArgs']]] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param pulumi.Input[str] load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param pulumi.Input[bool] local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param pulumi.Input[str] managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        :param pulumi.Input[bool] remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`.
        :param pulumi.Input[str] scm_ip_restriction_default_action: The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param pulumi.Input[str] scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: Should the Windows Web App `ip_restriction` configuration be used for the SCM also.
        :param pulumi.Input[bool] use32_bit_worker: Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationArgs']]] virtual_applications: One or more `virtual_application` blocks as defined below.
        :param pulumi.Input[bool] vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param pulumi.Input[bool] websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param pulumi.Input[int] worker_count: The number of Workers for this Windows App Service.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if handler_mappings is not None:
            pulumi.set(__self__, "handler_mappings", handler_mappings)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restriction_default_action is not None:
            pulumi.set(__self__, "ip_restriction_default_action", ip_restriction_default_action)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restriction_default_action is not None:
            pulumi.set(__self__, "scm_ip_restriction_default_action", scm_ip_restriction_default_action)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if virtual_applications is not None:
            pulumi.set(__self__, "virtual_applications", virtual_applications)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        If this Windows Web App is Always On enabled. Defaults to `true`.

        > **NOTE:** `always_on` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to the API Definition for this Windows Web App.
        """
        return pulumi.get(self, "api_definition_url")

    @api_definition_url.setter
    def api_definition_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_definition_url", value)

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[pulumi.Input[str]]:
        """
        The API Management API ID this Windows Web App Slot is associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @api_management_api_id.setter
    def api_management_api_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_management_api_id", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional[pulumi.Input['WindowsWebAppSiteConfigApplicationStackArgs']]:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @application_stack.setter
    def application_stack(self, value: Optional[pulumi.Input['WindowsWebAppSiteConfigApplicationStackArgs']]):
        pulumi.set(self, "application_stack", value)

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingArgs']]:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @auto_heal_setting.setter
    def auto_heal_setting(self, value: Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingArgs']]):
        pulumi.set(self, "auto_heal_setting", value)

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @container_registry_managed_identity_client_id.setter
    def container_registry_managed_identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_registry_managed_identity_client_id", value)

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[pulumi.Input[bool]]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @container_registry_use_managed_identity.setter
    def container_registry_use_managed_identity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_registry_use_managed_identity", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['WindowsWebAppSiteConfigCorsArgs']]:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['WindowsWebAppSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Default Documents for the Windows Web App.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="handlerMappings")
    def handler_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigHandlerMappingArgs']]]]:
        """
        One or more `handler_mapping` blocks as defined below.
        """
        return pulumi.get(self, "handler_mappings")

    @handler_mappings.setter
    def handler_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigHandlerMappingArgs']]]]):
        pulumi.set(self, "handler_mappings", value)

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @health_check_eviction_time_in_min.setter
    def health_check_eviction_time_in_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_eviction_time_in_min", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictionDefaultAction")
    def ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "ip_restriction_default_action")

    @ip_restriction_default_action.setter
    def ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigIpRestrictionArgs']]]]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @load_balancing_mode.setter
    def load_balancing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancing_mode", value)

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @local_mysql_enabled.setter
    def local_mysql_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local_mysql_enabled", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, `1.2` and `1.3`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`.
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="scmIpRestrictionDefaultAction")
    def scm_ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "scm_ip_restriction_default_action")

    @scm_ip_restriction_default_action.setter
    def scm_ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionArgs']]]]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @scm_minimum_tls_version.setter
    def scm_minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_minimum_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Web App `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Web App use a 32-bit worker. Defaults to `true`.
        """
        return pulumi.get(self, "use32_bit_worker")

    @use32_bit_worker.setter
    def use32_bit_worker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker", value)

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationArgs']]]]:
        """
        One or more `virtual_application` blocks as defined below.
        """
        return pulumi.get(self, "virtual_applications")

    @virtual_applications.setter
    def virtual_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationArgs']]]]):
        pulumi.set(self, "virtual_applications", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "windows_fx_version")

    @windows_fx_version.setter
    def windows_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_fx_version", value)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Workers for this Windows App Service.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class WindowsWebAppSiteConfigApplicationStackArgsDict(TypedDict):
        current_stack: NotRequired[pulumi.Input[str]]
        """
        The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.

        > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.

        > **NOTE:** Windows Web apps can configure multiple `app_stack` properties, it is recommended to always configure this `Optional` value and set it to the primary application stack of your app to ensure correct operation of this resource and display the correct metadata in the Azure Portal.
        """
        docker_image_name: NotRequired[pulumi.Input[str]]
        """
        The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        """
        docker_registry_password: NotRequired[pulumi.Input[str]]
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        docker_registry_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        docker_registry_username: NotRequired[pulumi.Input[str]]
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        dotnet_core_version: NotRequired[pulumi.Input[str]]
        """
        The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        """
        dotnet_version: NotRequired[pulumi.Input[str]]
        """
        The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0`, `v7.0` and `v8.0`.

        > **NOTE:** The Portal displayed values and the actual underlying API values differ for this setting, as follows:
        Portal Value | API value
        :--|--:
        ASP.NET V3.5 | v2.0
        ASP.NET V4.8 | v4.0
        .NET 6 (LTS) | v6.0
        .NET 7 (STS) | v7.0
        .NET 8 (LTS) | v8.0
        """
        java_container: NotRequired[pulumi.Input[str]]
        java_container_version: NotRequired[pulumi.Input[str]]
        java_embedded_server_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Java Embedded Server (Java SE) be used to run the app.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The version of Java to use when `current_stack` is set to `java`. 

        > **NOTE:** For currently supported versions, please see the official documentation. Some example values include: `1.8`, `1.8.0_322`,  `11`, `11.0.14`, `17` and `17.0.2`
        """
        node_version: NotRequired[pulumi.Input[str]]
        """
        The version of node to use when `current_stack` is set to `node`. Possible values are `~12`, `~14`, `~16`, `~18` and `~20`.

        > **NOTE:** This property conflicts with `java_version`.
        """
        php_version: NotRequired[pulumi.Input[str]]
        """
        The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.

        > **NOTE:** The value `Off` is used to signify latest supported by the service.
        """
        python: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether this is a Python app. Defaults to `false`.
        """
        tomcat_version: NotRequired[pulumi.Input[str]]
        """
        The version of Tomcat the Java App should use. Conflicts with `java_embedded_server_enabled`

        > **NOTE:** See the official documentation for current supported versions.  Some example valuess include: `10.0`, `10.0.20`.
        """
elif False:
    WindowsWebAppSiteConfigApplicationStackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigApplicationStackArgs:
    def __init__(__self__, *,
                 current_stack: Optional[pulumi.Input[str]] = None,
                 docker_image_name: Optional[pulumi.Input[str]] = None,
                 docker_registry_password: Optional[pulumi.Input[str]] = None,
                 docker_registry_url: Optional[pulumi.Input[str]] = None,
                 docker_registry_username: Optional[pulumi.Input[str]] = None,
                 dotnet_core_version: Optional[pulumi.Input[str]] = None,
                 dotnet_version: Optional[pulumi.Input[str]] = None,
                 java_container: Optional[pulumi.Input[str]] = None,
                 java_container_version: Optional[pulumi.Input[str]] = None,
                 java_embedded_server_enabled: Optional[pulumi.Input[bool]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 node_version: Optional[pulumi.Input[str]] = None,
                 php_version: Optional[pulumi.Input[str]] = None,
                 python: Optional[pulumi.Input[bool]] = None,
                 tomcat_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] current_stack: The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
               
               > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
               
               > **NOTE:** Windows Web apps can configure multiple `app_stack` properties, it is recommended to always configure this `Optional` value and set it to the primary application stack of your app to ensure correct operation of this resource and display the correct metadata in the Azure Portal.
        :param pulumi.Input[str] docker_image_name: The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        :param pulumi.Input[str] docker_registry_password: The User Name to use for authentication against the registry to pull the image.
               
               > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        :param pulumi.Input[str] docker_registry_url: The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        :param pulumi.Input[str] docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param pulumi.Input[str] dotnet_core_version: The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        :param pulumi.Input[str] dotnet_version: The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0`, `v7.0` and `v8.0`.
               
               > **NOTE:** The Portal displayed values and the actual underlying API values differ for this setting, as follows:
               Portal Value | API value
               :--|--:
               ASP.NET V3.5 | v2.0
               ASP.NET V4.8 | v4.0
               .NET 6 (LTS) | v6.0
               .NET 7 (STS) | v7.0
               .NET 8 (LTS) | v8.0
        :param pulumi.Input[bool] java_embedded_server_enabled: Should the Java Embedded Server (Java SE) be used to run the app.
        :param pulumi.Input[str] java_version: The version of Java to use when `current_stack` is set to `java`. 
               
               > **NOTE:** For currently supported versions, please see the official documentation. Some example values include: `1.8`, `1.8.0_322`,  `11`, `11.0.14`, `17` and `17.0.2`
        :param pulumi.Input[str] node_version: The version of node to use when `current_stack` is set to `node`. Possible values are `~12`, `~14`, `~16`, `~18` and `~20`.
               
               > **NOTE:** This property conflicts with `java_version`.
        :param pulumi.Input[str] php_version: The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.
               
               > **NOTE:** The value `Off` is used to signify latest supported by the service.
        :param pulumi.Input[bool] python: Specifies whether this is a Python app. Defaults to `false`.
        :param pulumi.Input[str] tomcat_version: The version of Tomcat the Java App should use. Conflicts with `java_embedded_server_enabled`
               
               > **NOTE:** See the official documentation for current supported versions.  Some example valuess include: `10.0`, `10.0.20`.
        """
        if current_stack is not None:
            pulumi.set(__self__, "current_stack", current_stack)
        if docker_image_name is not None:
            pulumi.set(__self__, "docker_image_name", docker_image_name)
        if docker_registry_password is not None:
            pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        if docker_registry_url is not None:
            pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        if docker_registry_username is not None:
            pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        if dotnet_core_version is not None:
            pulumi.set(__self__, "dotnet_core_version", dotnet_core_version)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_container is not None:
            warnings.warn("""this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""", DeprecationWarning)
            pulumi.log.warn("""java_container is deprecated: this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            warnings.warn("""This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""", DeprecationWarning)
            pulumi.log.warn("""java_container_version is deprecated: This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_embedded_server_enabled is not None:
            pulumi.set(__self__, "java_embedded_server_enabled", java_embedded_server_enabled)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python is not None:
            pulumi.set(__self__, "python", python)
        if tomcat_version is not None:
            pulumi.set(__self__, "tomcat_version", tomcat_version)

    @property
    @pulumi.getter(name="currentStack")
    def current_stack(self) -> Optional[pulumi.Input[str]]:
        """
        The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.

        > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.

        > **NOTE:** Windows Web apps can configure multiple `app_stack` properties, it is recommended to always configure this `Optional` value and set it to the primary application stack of your app to ensure correct operation of this resource and display the correct metadata in the Azure Portal.
        """
        return pulumi.get(self, "current_stack")

    @current_stack.setter
    def current_stack(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_stack", value)

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        """
        return pulumi.get(self, "docker_image_name")

    @docker_image_name.setter
    def docker_image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_image_name", value)

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> Optional[pulumi.Input[str]]:
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        return pulumi.get(self, "docker_registry_password")

    @docker_registry_password.setter
    def docker_registry_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_password", value)

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        return pulumi.get(self, "docker_registry_url")

    @docker_registry_url.setter
    def docker_registry_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_url", value)

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> Optional[pulumi.Input[str]]:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @docker_registry_username.setter
    def docker_registry_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_username", value)

    @property
    @pulumi.getter(name="dotnetCoreVersion")
    def dotnet_core_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        """
        return pulumi.get(self, "dotnet_core_version")

    @dotnet_core_version.setter
    def dotnet_core_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_core_version", value)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0`, `v7.0` and `v8.0`.

        > **NOTE:** The Portal displayed values and the actual underlying API values differ for this setting, as follows:
        Portal Value | API value
        :--|--:
        ASP.NET V3.5 | v2.0
        ASP.NET V4.8 | v4.0
        .NET 6 (LTS) | v6.0
        .NET 7 (STS) | v7.0
        .NET 8 (LTS) | v8.0
        """
        return pulumi.get(self, "dotnet_version")

    @dotnet_version.setter
    def dotnet_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_version", value)

    @property
    @pulumi.getter(name="javaContainer")
    @_utilities.deprecated("""this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")
    def java_container(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "java_container")

    @java_container.setter
    def java_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container", value)

    @property
    @pulumi.getter(name="javaContainerVersion")
    @_utilities.deprecated("""This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")
    def java_container_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "java_container_version")

    @java_container_version.setter
    def java_container_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container_version", value)

    @property
    @pulumi.getter(name="javaEmbeddedServerEnabled")
    def java_embedded_server_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Java Embedded Server (Java SE) be used to run the app.
        """
        return pulumi.get(self, "java_embedded_server_enabled")

    @java_embedded_server_enabled.setter
    def java_embedded_server_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "java_embedded_server_enabled", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Java to use when `current_stack` is set to `java`. 

        > **NOTE:** For currently supported versions, please see the official documentation. Some example values include: `1.8`, `1.8.0_322`,  `11`, `11.0.14`, `17` and `17.0.2`
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of node to use when `current_stack` is set to `node`. Possible values are `~12`, `~14`, `~16`, `~18` and `~20`.

        > **NOTE:** This property conflicts with `java_version`.
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.

        > **NOTE:** The value `Off` is used to signify latest supported by the service.
        """
        return pulumi.get(self, "php_version")

    @php_version.setter
    def php_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "php_version", value)

    @property
    @pulumi.getter
    def python(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether this is a Python app. Defaults to `false`.
        """
        return pulumi.get(self, "python")

    @python.setter
    def python(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "python", value)

    @property
    @pulumi.getter(name="tomcatVersion")
    def tomcat_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Tomcat the Java App should use. Conflicts with `java_embedded_server_enabled`

        > **NOTE:** See the official documentation for current supported versions.  Some example valuess include: `10.0`, `10.0.20`.
        """
        return pulumi.get(self, "tomcat_version")

    @tomcat_version.setter
    def tomcat_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tomcat_version", value)


if not MYPY:
    class WindowsWebAppSiteConfigAutoHealSettingArgsDict(TypedDict):
        action: pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionArgsDict']
        """
        An `action` block as defined above.
        """
        trigger: pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerArgsDict']
        """
        A `trigger` block as defined below.
        """
elif False:
    WindowsWebAppSiteConfigAutoHealSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigAutoHealSettingArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionArgs'],
                 trigger: pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerArgs']):
        """
        :param pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionArgs'] action: An `action` block as defined above.
        :param pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerArgs'] trigger: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionArgs']:
        """
        An `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def trigger(self) -> pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerArgs']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerArgs']):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class WindowsWebAppSiteConfigAutoHealSettingActionArgsDict(TypedDict):
        action_type: pulumi.Input[str]
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`, `LogEvent`, and `CustomAction`.
        """
        custom_action: NotRequired[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgsDict']]
        """
        A `custom_action` block as defined below.
        """
        minimum_process_execution_time: NotRequired[pulumi.Input[str]]
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
elif False:
    WindowsWebAppSiteConfigAutoHealSettingActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigAutoHealSettingActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 custom_action: Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs']] = None,
                 minimum_process_execution_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_type: Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`, `LogEvent`, and `CustomAction`.
        :param pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs'] custom_action: A `custom_action` block as defined below.
        :param pulumi.Input[str] minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if custom_action is not None:
            pulumi.set(__self__, "custom_action", custom_action)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`, `LogEvent`, and `CustomAction`.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs']]:
        """
        A `custom_action` block as defined below.
        """
        return pulumi.get(self, "custom_action")

    @custom_action.setter
    def custom_action(self, value: Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs']]):
        pulumi.set(self, "custom_action", value)

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")

    @minimum_process_execution_time.setter
    def minimum_process_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_process_execution_time", value)


if not MYPY:
    class WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgsDict(TypedDict):
        executable: pulumi.Input[str]
        """
        The executable to run for the `custom_action`.
        """
        parameters: NotRequired[pulumi.Input[str]]
        """
        The parameters to pass to the specified `executable`.
        """
elif False:
    WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigAutoHealSettingActionCustomActionArgs:
    def __init__(__self__, *,
                 executable: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] executable: The executable to run for the `custom_action`.
        :param pulumi.Input[str] parameters: The parameters to pass to the specified `executable`.
        """
        pulumi.set(__self__, "executable", executable)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def executable(self) -> pulumi.Input[str]:
        """
        The executable to run for the `custom_action`.
        """
        return pulumi.get(self, "executable")

    @executable.setter
    def executable(self, value: pulumi.Input[str]):
        pulumi.set(self, "executable", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        The parameters to pass to the specified `executable`.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class WindowsWebAppSiteConfigAutoHealSettingTriggerArgsDict(TypedDict):
        private_memory_kb: NotRequired[pulumi.Input[int]]
        """
        The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        """
        requests: NotRequired[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgsDict']]
        """
        A `requests` block as defined above.
        """
        slow_request: NotRequired[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgsDict']]
        """
        A `slow_request` block as defined above.
        """
        slow_request_with_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict']]]]
        """
        One or more `slow_request_with_path` blocks as defined above.
        """
        status_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgsDict']]]]
        """
        One or more `status_code` blocks as defined above.
        """
elif False:
    WindowsWebAppSiteConfigAutoHealSettingTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerArgs:
    def __init__(__self__, *,
                 private_memory_kb: Optional[pulumi.Input[int]] = None,
                 requests: Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgs']] = None,
                 slow_request: Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs']] = None,
                 slow_request_with_paths: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]] = None,
                 status_codes: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]] = None):
        """
        :param pulumi.Input[int] private_memory_kb: The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        :param pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgs'] requests: A `requests` block as defined above.
        :param pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_request: A `slow_request` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]] slow_request_with_paths: One or more `slow_request_with_path` blocks as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs']]] status_codes: One or more `status_code` blocks as defined above.
        """
        if private_memory_kb is not None:
            pulumi.set(__self__, "private_memory_kb", private_memory_kb)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_request is not None:
            pulumi.set(__self__, "slow_request", slow_request)
        if slow_request_with_paths is not None:
            pulumi.set(__self__, "slow_request_with_paths", slow_request_with_paths)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="privateMemoryKb")
    def private_memory_kb(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        """
        return pulumi.get(self, "private_memory_kb")

    @private_memory_kb.setter
    def private_memory_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "private_memory_kb", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgs']]:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgs']]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="slowRequest")
    def slow_request(self) -> Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs']]:
        """
        A `slow_request` block as defined above.
        """
        return pulumi.get(self, "slow_request")

    @slow_request.setter
    def slow_request(self, value: Optional[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs']]):
        pulumi.set(self, "slow_request", value)

    @property
    @pulumi.getter(name="slowRequestWithPaths")
    def slow_request_with_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]]:
        """
        One or more `slow_request_with_path` blocks as defined above.
        """
        return pulumi.get(self, "slow_request_with_paths")

    @slow_request_with_paths.setter
    def slow_request_with_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]]):
        pulumi.set(self, "slow_request_with_paths", value)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]]):
        pulumi.set(self, "status_codes", value)


if not MYPY:
    class WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The interval in `hh:mm:ss`.
        """
elif False:
    WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerRequestsArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: The number of requests in the specified `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        time_taken: pulumi.Input[str]
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
elif False:
    WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 time_taken: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> pulumi.Input[str]:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_taken", value)


if not MYPY:
    class WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        time_taken: pulumi.Input[str]
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path for which this slow request rule applies.
        """
elif False:
    WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 time_taken: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param pulumi.Input[str] path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> pulumi.Input[str]:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_taken", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        status_code_range: pulumi.Input[str]
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path to which this rule status code applies.
        """
        sub_status: NotRequired[pulumi.Input[int]]
        """
        The Request Sub Status of the Status Code.
        """
        win32_status_code: NotRequired[pulumi.Input[int]]
        """
        The Win32 Status Code of the Request.
        """
elif False:
    WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCodeArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 status_code_range: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 sub_status: Optional[pulumi.Input[int]] = None,
                 win32_status_code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param pulumi.Input[str] path: The path to which this rule status code applies.
        :param pulumi.Input[int] sub_status: The Request Sub Status of the Status Code.
        :param pulumi.Input[int] win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status_code is not None:
            pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> pulumi.Input[str]:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @status_code_range.setter
    def status_code_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_code_range", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[pulumi.Input[int]]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @sub_status.setter
    def sub_status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sub_status", value)

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")

    @win32_status_code.setter
    def win32_status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "win32_status_code", value)


if not MYPY:
    class WindowsWebAppSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
elif False:
    WindowsWebAppSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param pulumi.Input[bool] support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class WindowsWebAppSiteConfigHandlerMappingArgsDict(TypedDict):
        extension: pulumi.Input[str]
        """
        Specifies which extension to be handled by the specified FastCGI application.
        """
        script_processor_path: pulumi.Input[str]
        """
        Specifies the absolute path to the FastCGI application.
        """
        arguments: NotRequired[pulumi.Input[str]]
        """
        Specifies the command-line arguments to be passed to the script processor.
        """
elif False:
    WindowsWebAppSiteConfigHandlerMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigHandlerMappingArgs:
    def __init__(__self__, *,
                 extension: pulumi.Input[str],
                 script_processor_path: pulumi.Input[str],
                 arguments: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] extension: Specifies which extension to be handled by the specified FastCGI application.
        :param pulumi.Input[str] script_processor_path: Specifies the absolute path to the FastCGI application.
        :param pulumi.Input[str] arguments: Specifies the command-line arguments to be passed to the script processor.
        """
        pulumi.set(__self__, "extension", extension)
        pulumi.set(__self__, "script_processor_path", script_processor_path)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)

    @property
    @pulumi.getter
    def extension(self) -> pulumi.Input[str]:
        """
        Specifies which extension to be handled by the specified FastCGI application.
        """
        return pulumi.get(self, "extension")

    @extension.setter
    def extension(self, value: pulumi.Input[str]):
        pulumi.set(self, "extension", value)

    @property
    @pulumi.getter(name="scriptProcessorPath")
    def script_processor_path(self) -> pulumi.Input[str]:
        """
        Specifies the absolute path to the FastCGI application.
        """
        return pulumi.get(self, "script_processor_path")

    @script_processor_path.setter
    def script_processor_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "script_processor_path", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the command-line arguments to be passed to the script processor.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arguments", value)


if not MYPY:
    class WindowsWebAppSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['WindowsWebAppSiteConfigIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    WindowsWebAppSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['WindowsWebAppSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['WindowsWebAppSiteConfigIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WindowsWebAppSiteConfigIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WindowsWebAppSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class WindowsWebAppSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    WindowsWebAppSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class WindowsWebAppSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    WindowsWebAppSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WindowsWebAppSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class WindowsWebAppSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    WindowsWebAppSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class WindowsWebAppSiteConfigVirtualApplicationArgsDict(TypedDict):
        physical_path: pulumi.Input[str]
        """
        The physical path for the Virtual Application.
        """
        preload: pulumi.Input[bool]
        """
        Should pre-loading be enabled.
        """
        virtual_path: pulumi.Input[str]
        """
        The Virtual Path for the Virtual Application.
        """
        virtual_directories: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgsDict']]]]
        """
        One or more `virtual_directory` blocks as defined below.
        """
elif False:
    WindowsWebAppSiteConfigVirtualApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigVirtualApplicationArgs:
    def __init__(__self__, *,
                 physical_path: pulumi.Input[str],
                 preload: pulumi.Input[bool],
                 virtual_path: pulumi.Input[str],
                 virtual_directories: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs']]]] = None):
        """
        :param pulumi.Input[str] physical_path: The physical path for the Virtual Application.
        :param pulumi.Input[bool] preload: Should pre-loading be enabled.
        :param pulumi.Input[str] virtual_path: The Virtual Path for the Virtual Application.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs']]] virtual_directories: One or more `virtual_directory` blocks as defined below.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "preload", preload)
        pulumi.set(__self__, "virtual_path", virtual_path)
        if virtual_directories is not None:
            pulumi.set(__self__, "virtual_directories", virtual_directories)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> pulumi.Input[str]:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @physical_path.setter
    def physical_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "physical_path", value)

    @property
    @pulumi.getter
    def preload(self) -> pulumi.Input[bool]:
        """
        Should pre-loading be enabled.
        """
        return pulumi.get(self, "preload")

    @preload.setter
    def preload(self, value: pulumi.Input[bool]):
        pulumi.set(self, "preload", value)

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> pulumi.Input[str]:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")

    @virtual_path.setter
    def virtual_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_path", value)

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs']]]]:
        """
        One or more `virtual_directory` blocks as defined below.
        """
        return pulumi.get(self, "virtual_directories")

    @virtual_directories.setter
    def virtual_directories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs']]]]):
        pulumi.set(self, "virtual_directories", value)


if not MYPY:
    class WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgsDict(TypedDict):
        physical_path: NotRequired[pulumi.Input[str]]
        """
        The physical path for the Virtual Application.
        """
        virtual_path: NotRequired[pulumi.Input[str]]
        """
        The Virtual Path for the Virtual Application.
        """
elif False:
    WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteConfigVirtualApplicationVirtualDirectoryArgs:
    def __init__(__self__, *,
                 physical_path: Optional[pulumi.Input[str]] = None,
                 virtual_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] physical_path: The physical path for the Virtual Application.
        :param pulumi.Input[str] virtual_path: The Virtual Path for the Virtual Application.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[pulumi.Input[str]]:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @physical_path.setter
    def physical_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "physical_path", value)

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")

    @virtual_path.setter
    def virtual_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_path", value)


if not MYPY:
    class WindowsWebAppSiteCredentialArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Password used for publishing.
        """
elif False:
    WindowsWebAppSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSiteCredentialArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
        :param pulumi.Input[str] password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Should the Authentication / Authorization feature be enabled for the Windows Web App?
        """
        active_directory: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsActiveDirectoryArgsDict']]
        """
        An `active_directory` block as defined above.
        """
        additional_login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App Slot.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        facebook: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsFacebookArgsDict']]
        """
        A `facebook` block as defined below.
        """
        github: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsGithubArgsDict']]
        """
        A `github` block as defined below.
        """
        google: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsGoogleArgsDict']]
        """
        A `google` block as defined below.
        """
        issuer: NotRequired[pulumi.Input[str]]
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App Slot.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        microsoft: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsMicrosoftArgsDict']]
        """
        A `microsoft` block as defined below.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App Slot.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Web App Slot durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        twitter: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsTwitterArgsDict']]
        """
        A `twitter` block as defined below.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input[str]]
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
elif False:
    WindowsWebAppSlotAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 active_directory: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsActiveDirectoryArgs']] = None,
                 additional_login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 facebook: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsFacebookArgs']] = None,
                 github: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsGithubArgs']] = None,
                 google: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsGoogleArgs']] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 microsoft: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsMicrosoftArgs']] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 twitter: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsTwitterArgs']] = None,
                 unauthenticated_client_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Should the Authentication / Authorization feature be enabled for the Windows Web App?
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsActiveDirectoryArgs'] active_directory: An `active_directory` block as defined above.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_login_parameters: Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App Slot.
        :param pulumi.Input[str] default_provider: The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
               
               > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsFacebookArgs'] facebook: A `facebook` block as defined below.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsGithubArgs'] github: A `github` block as defined below.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsGoogleArgs'] google: A `google` block as defined below.
        :param pulumi.Input[str] issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App Slot.
               
               > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsMicrosoftArgs'] microsoft: A `microsoft` block as defined below.
        :param pulumi.Input[str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App Slot.
        :param pulumi.Input[float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Windows Web App Slot durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsTwitterArgs'] twitter: A `twitter` block as defined below.
        :param pulumi.Input[str] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if additional_login_parameters is not None:
            pulumi.set(__self__, "additional_login_parameters", additional_login_parameters)
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Should the Authentication / Authorization feature be enabled for the Windows Web App?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsActiveDirectoryArgs']]:
        """
        An `active_directory` block as defined above.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="additionalLoginParameters")
    def additional_login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
        """
        return pulumi.get(self, "additional_login_parameters")

    @additional_login_parameters.setter
    def additional_login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_login_parameters", value)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App Slot.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.

        > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticated_client_action` is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsFacebookArgs']]:
        """
        A `facebook` block as defined below.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsGithubArgs']]:
        """
        A `github` block as defined below.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsGoogleArgs']]:
        """
        A `google` block as defined below.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsGoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App Slot.

        > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsMicrosoftArgs']]:
        """
        A `microsoft` block as defined below.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App Slot.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Web App Slot durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsTwitterArgs']]:
        """
        A `twitter` block as defined below.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsTwitterArgs']]):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsActiveDirectoryArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
elif False:
    WindowsWebAppSlotAuthSettingsActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        :param pulumi.Input[str] client_secret: The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        pulumi.set(__self__, "client_id", client_id)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **Note:** The `client_id` value is always considered an allowed audience, so should not be included.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsFacebookArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret: NotRequired[pulumi.Input[str]]
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
elif False:
    WindowsWebAppSlotAuthSettingsFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsFacebookArgs:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret: The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The App Secret of the Facebook app used for Facebook login. Cannot be specified with `app_secret_setting_name`.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `app_secret` value used for Facebook login. Cannot be specified with `app_secret`.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsGithubArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
elif False:
    WindowsWebAppSlotAuthSettingsGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsGithubArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login.
        :param pulumi.Input[str] client_secret: The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for GitHub login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsGoogleArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
elif False:
    WindowsWebAppSlotAuthSettingsGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsGoogleArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret: The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret associated with the Google web application. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the `client_secret` value used for Google login. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsMicrosoftArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
elif False:
    WindowsWebAppSlotAuthSettingsMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret: The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsTwitterArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret: NotRequired[pulumi.Input[str]]
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
elif False:
    WindowsWebAppSlotAuthSettingsTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsTwitterArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret: The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2ArgsDict(TypedDict):
        login: pulumi.Input['WindowsWebAppSlotAuthSettingsV2LoginArgsDict']
        """
        A `login` block as defined below.
        """
        active_directory_v2: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict']]
        """
        An `active_directory_v2` block as defined below.
        """
        apple_v2: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsV2AppleV2ArgsDict']]
        """
        An `apple_v2` block as defined below.
        """
        auth_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        azure_static_web_app_v2: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict']]
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        config_file_path: NotRequired[pulumi.Input[str]]
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        custom_oidc_v2s: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotAuthSettingsV2CustomOidcV2ArgsDict']]]]
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        default_provider: NotRequired[pulumi.Input[str]]
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        facebook_v2: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsV2FacebookV2ArgsDict']]
        """
        A `facebook_v2` block as defined below.
        """
        forward_proxy_convention: NotRequired[pulumi.Input[str]]
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        forward_proxy_custom_host_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the host of the request.
        """
        forward_proxy_custom_scheme_header_name: NotRequired[pulumi.Input[str]]
        """
        The name of the custom header containing the scheme of the request.
        """
        github_v2: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsV2GithubV2ArgsDict']]
        """
        A `github_v2` block as defined below.
        """
        google_v2: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsV2GoogleV2ArgsDict']]
        """
        A `google_v2` block as defined below.
        """
        http_route_api_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        microsoft_v2: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsV2MicrosoftV2ArgsDict']]
        """
        A `microsoft_v2` block as defined below.
        """
        require_authentication: NotRequired[pulumi.Input[bool]]
        """
        Should the authentication flow be used for all requests.
        """
        require_https: NotRequired[pulumi.Input[bool]]
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        twitter_v2: NotRequired[pulumi.Input['WindowsWebAppSlotAuthSettingsV2TwitterV2ArgsDict']]
        """
        A `twitter_v2` block as defined below.
        """
        unauthenticated_action: NotRequired[pulumi.Input[str]]
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2Args:
    def __init__(__self__, *,
                 login: pulumi.Input['WindowsWebAppSlotAuthSettingsV2LoginArgs'],
                 active_directory_v2: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2Args']] = None,
                 apple_v2: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2AppleV2Args']] = None,
                 auth_enabled: Optional[pulumi.Input[bool]] = None,
                 azure_static_web_app_v2: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args']] = None,
                 config_file_path: Optional[pulumi.Input[str]] = None,
                 custom_oidc_v2s: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotAuthSettingsV2CustomOidcV2Args']]]] = None,
                 default_provider: Optional[pulumi.Input[str]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 facebook_v2: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2FacebookV2Args']] = None,
                 forward_proxy_convention: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 forward_proxy_custom_scheme_header_name: Optional[pulumi.Input[str]] = None,
                 github_v2: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2GithubV2Args']] = None,
                 google_v2: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2GoogleV2Args']] = None,
                 http_route_api_prefix: Optional[pulumi.Input[str]] = None,
                 microsoft_v2: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2MicrosoftV2Args']] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 twitter_v2: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2TwitterV2Args']] = None,
                 unauthenticated_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsV2LoginArgs'] login: A `login` block as defined below.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2Args'] active_directory_v2: An `active_directory_v2` block as defined below.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsV2AppleV2Args'] apple_v2: An `apple_v2` block as defined below.
        :param pulumi.Input[bool] auth_enabled: Should the AuthV2 Settings be enabled. Defaults to `false`.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args'] azure_static_web_app_v2: An `azure_static_web_app_v2` block as defined below.
        :param pulumi.Input[str] config_file_path: The path to the App Auth settings.
               
               > **Note:** Relative Paths are evaluated from the Site Root directory.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotAuthSettingsV2CustomOidcV2Args']]] custom_oidc_v2s: Zero or more `custom_oidc_v2` blocks as defined below.
        :param pulumi.Input[str] default_provider: The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
               
               > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_paths: The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
               
               > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsV2FacebookV2Args'] facebook_v2: A `facebook_v2` block as defined below.
        :param pulumi.Input[str] forward_proxy_convention: The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        :param pulumi.Input[str] forward_proxy_custom_host_header_name: The name of the custom header containing the host of the request.
        :param pulumi.Input[str] forward_proxy_custom_scheme_header_name: The name of the custom header containing the scheme of the request.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsV2GithubV2Args'] github_v2: A `github_v2` block as defined below.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsV2GoogleV2Args'] google_v2: A `google_v2` block as defined below.
        :param pulumi.Input[str] http_route_api_prefix: The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsV2MicrosoftV2Args'] microsoft_v2: A `microsoft_v2` block as defined below.
        :param pulumi.Input[bool] require_authentication: Should the authentication flow be used for all requests.
        :param pulumi.Input[bool] require_https: Should HTTPS be required on connections? Defaults to `true`.
        :param pulumi.Input[str] runtime_version: The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        :param pulumi.Input['WindowsWebAppSlotAuthSettingsV2TwitterV2Args'] twitter_v2: A `twitter_v2` block as defined below.
        :param pulumi.Input[str] unauthenticated_action: The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        pulumi.set(__self__, "login", login)
        if active_directory_v2 is not None:
            pulumi.set(__self__, "active_directory_v2", active_directory_v2)
        if apple_v2 is not None:
            pulumi.set(__self__, "apple_v2", apple_v2)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if azure_static_web_app_v2 is not None:
            pulumi.set(__self__, "azure_static_web_app_v2", azure_static_web_app_v2)
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if custom_oidc_v2s is not None:
            pulumi.set(__self__, "custom_oidc_v2s", custom_oidc_v2s)
        if default_provider is not None:
            pulumi.set(__self__, "default_provider", default_provider)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if facebook_v2 is not None:
            pulumi.set(__self__, "facebook_v2", facebook_v2)
        if forward_proxy_convention is not None:
            pulumi.set(__self__, "forward_proxy_convention", forward_proxy_convention)
        if forward_proxy_custom_host_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_host_header_name", forward_proxy_custom_host_header_name)
        if forward_proxy_custom_scheme_header_name is not None:
            pulumi.set(__self__, "forward_proxy_custom_scheme_header_name", forward_proxy_custom_scheme_header_name)
        if github_v2 is not None:
            pulumi.set(__self__, "github_v2", github_v2)
        if google_v2 is not None:
            pulumi.set(__self__, "google_v2", google_v2)
        if http_route_api_prefix is not None:
            pulumi.set(__self__, "http_route_api_prefix", http_route_api_prefix)
        if microsoft_v2 is not None:
            pulumi.set(__self__, "microsoft_v2", microsoft_v2)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if twitter_v2 is not None:
            pulumi.set(__self__, "twitter_v2", twitter_v2)
        if unauthenticated_action is not None:
            pulumi.set(__self__, "unauthenticated_action", unauthenticated_action)

    @property
    @pulumi.getter
    def login(self) -> pulumi.Input['WindowsWebAppSlotAuthSettingsV2LoginArgs']:
        """
        A `login` block as defined below.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: pulumi.Input['WindowsWebAppSlotAuthSettingsV2LoginArgs']):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="activeDirectoryV2")
    def active_directory_v2(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2Args']]:
        """
        An `active_directory_v2` block as defined below.
        """
        return pulumi.get(self, "active_directory_v2")

    @active_directory_v2.setter
    def active_directory_v2(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2Args']]):
        pulumi.set(self, "active_directory_v2", value)

    @property
    @pulumi.getter(name="appleV2")
    def apple_v2(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2AppleV2Args']]:
        """
        An `apple_v2` block as defined below.
        """
        return pulumi.get(self, "apple_v2")

    @apple_v2.setter
    def apple_v2(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2AppleV2Args']]):
        pulumi.set(self, "apple_v2", value)

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the AuthV2 Settings be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "auth_enabled")

    @auth_enabled.setter
    def auth_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auth_enabled", value)

    @property
    @pulumi.getter(name="azureStaticWebAppV2")
    def azure_static_web_app_v2(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args']]:
        """
        An `azure_static_web_app_v2` block as defined below.
        """
        return pulumi.get(self, "azure_static_web_app_v2")

    @azure_static_web_app_v2.setter
    def azure_static_web_app_v2(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args']]):
        pulumi.set(self, "azure_static_web_app_v2", value)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the App Auth settings.

        > **Note:** Relative Paths are evaluated from the Site Root directory.
        """
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter(name="customOidcV2s")
    def custom_oidc_v2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotAuthSettingsV2CustomOidcV2Args']]]]:
        """
        Zero or more `custom_oidc_v2` blocks as defined below.
        """
        return pulumi.get(self, "custom_oidc_v2s")

    @custom_oidc_v2s.setter
    def custom_oidc_v2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotAuthSettingsV2CustomOidcV2Args']]]]):
        pulumi.set(self, "custom_oidc_v2s", value)

    @property
    @pulumi.getter(name="defaultProvider")
    def default_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.

        > **NOTE:** Whilst any value will be accepted by the API for `default_provider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or custom_oidc name) as it is used to build the auth endpoint URI.
        """
        return pulumi.get(self, "default_provider")

    @default_provider.setter
    def default_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_provider", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.

        > **NOTE:** This list should be used instead of setting `WEBSITE_WARMUP_PATH` in `app_settings` as it takes priority.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="facebookV2")
    def facebook_v2(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2FacebookV2Args']]:
        """
        A `facebook_v2` block as defined below.
        """
        return pulumi.get(self, "facebook_v2")

    @facebook_v2.setter
    def facebook_v2(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2FacebookV2Args']]):
        pulumi.set(self, "facebook_v2", value)

    @property
    @pulumi.getter(name="forwardProxyConvention")
    def forward_proxy_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The convention used to determine the url of the request made. Possible values include `NoProxy`, `Standard`, `Custom`. Defaults to `NoProxy`.
        """
        return pulumi.get(self, "forward_proxy_convention")

    @forward_proxy_convention.setter
    def forward_proxy_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_convention", value)

    @property
    @pulumi.getter(name="forwardProxyCustomHostHeaderName")
    def forward_proxy_custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the host of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_host_header_name")

    @forward_proxy_custom_host_header_name.setter
    def forward_proxy_custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_host_header_name", value)

    @property
    @pulumi.getter(name="forwardProxyCustomSchemeHeaderName")
    def forward_proxy_custom_scheme_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the custom header containing the scheme of the request.
        """
        return pulumi.get(self, "forward_proxy_custom_scheme_header_name")

    @forward_proxy_custom_scheme_header_name.setter
    def forward_proxy_custom_scheme_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_proxy_custom_scheme_header_name", value)

    @property
    @pulumi.getter(name="githubV2")
    def github_v2(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2GithubV2Args']]:
        """
        A `github_v2` block as defined below.
        """
        return pulumi.get(self, "github_v2")

    @github_v2.setter
    def github_v2(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2GithubV2Args']]):
        pulumi.set(self, "github_v2", value)

    @property
    @pulumi.getter(name="googleV2")
    def google_v2(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2GoogleV2Args']]:
        """
        A `google_v2` block as defined below.
        """
        return pulumi.get(self, "google_v2")

    @google_v2.setter
    def google_v2(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2GoogleV2Args']]):
        pulumi.set(self, "google_v2", value)

    @property
    @pulumi.getter(name="httpRouteApiPrefix")
    def http_route_api_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
        """
        return pulumi.get(self, "http_route_api_prefix")

    @http_route_api_prefix.setter
    def http_route_api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_route_api_prefix", value)

    @property
    @pulumi.getter(name="microsoftV2")
    def microsoft_v2(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2MicrosoftV2Args']]:
        """
        A `microsoft_v2` block as defined below.
        """
        return pulumi.get(self, "microsoft_v2")

    @microsoft_v2.setter
    def microsoft_v2(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2MicrosoftV2Args']]):
        pulumi.set(self, "microsoft_v2", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the authentication flow be used for all requests.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Should HTTPS be required on connections? Defaults to `true`.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter(name="twitterV2")
    def twitter_v2(self) -> Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2TwitterV2Args']]:
        """
        A `twitter_v2` block as defined below.
        """
        return pulumi.get(self, "twitter_v2")

    @twitter_v2.setter
    def twitter_v2(self, value: Optional[pulumi.Input['WindowsWebAppSlotAuthSettingsV2TwitterV2Args']]):
        pulumi.set(self, "twitter_v2", value)

    @property
    @pulumi.getter(name="unauthenticatedAction")
    def unauthenticated_action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
        """
        return pulumi.get(self, "unauthenticated_action")

    @unauthenticated_action.setter
    def unauthenticated_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unauthenticated_action", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        tenant_auth_endpoint: pulumi.Input[str]
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        allowed_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        The thumbprint of the certificate used for signing purposes.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        jwt_allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        jwt_allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Allowed Groups in the JWT Claim.
        """
        login_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        www_authentication_disabled: NotRequired[pulumi.Input[bool]]
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 tenant_auth_endpoint: pulumi.Input[str],
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 jwt_allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jwt_allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 www_authentication_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Active Directory.
        :param pulumi.Input[str] tenant_auth_endpoint: The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`
               
               > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_applications: The list of allowed Applications for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_groups: The list of allowed Group Names for the Default Authorisation Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_identities: The list of allowed Identities for the Default Authorisation Policy.
        :param pulumi.Input[str] client_secret_certificate_thumbprint: The thumbprint of the certificate used for signing purposes.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the client secret of the Client.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_client_applications: A list of Allowed Client Applications in the JWT Claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jwt_allowed_groups: A list of Allowed Groups in the JWT Claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] login_parameters: A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        :param pulumi.Input[bool] www_authentication_disabled: Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_auth_endpoint", tenant_auth_endpoint)
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)
        if allowed_identities is not None:
            pulumi.set(__self__, "allowed_identities", allowed_identities)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if jwt_allowed_client_applications is not None:
            pulumi.set(__self__, "jwt_allowed_client_applications", jwt_allowed_client_applications)
        if jwt_allowed_groups is not None:
            pulumi.set(__self__, "jwt_allowed_groups", jwt_allowed_groups)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)
        if www_authentication_disabled is not None:
            pulumi.set(__self__, "www_authentication_disabled", www_authentication_disabled)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Active Directory.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantAuthEndpoint")
    def tenant_auth_endpoint(self) -> pulumi.Input[str]:
        """
        The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/{tenant-guid}/v2.0/`

        > **NOTE:** [Here](https://learn.microsoft.com/en-us/entra/identity-platform/authentication-national-cloud#microsoft-entra-authentication-endpoints) is a list of possible authentication endpoints based on the cloud environment. [Here](https://learn.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad?tabs=workforce-tenant) is more information to better understand how to configure authentication for Azure App Service or Azure Functions.
        """
        return pulumi.get(self, "tenant_auth_endpoint")

    @tenant_auth_endpoint.setter
    def tenant_auth_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_auth_endpoint", value)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Applications for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Group Names for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter(name="allowedIdentities")
    def allowed_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed Identities for the Default Authorisation Policy.
        """
        return pulumi.get(self, "allowed_identities")

    @allowed_identities.setter
    def allowed_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_identities", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of the certificate used for signing purposes.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the client secret of the Client.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="jwtAllowedClientApplications")
    def jwt_allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Client Applications in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_client_applications")

    @jwt_allowed_client_applications.setter
    def jwt_allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_client_applications", value)

    @property
    @pulumi.getter(name="jwtAllowedGroups")
    def jwt_allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Allowed Groups in the JWT Claim.
        """
        return pulumi.get(self, "jwt_allowed_groups")

    @jwt_allowed_groups.setter
    def jwt_allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jwt_allowed_groups", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)

    @property
    @pulumi.getter(name="wwwAuthenticationDisabled")
    def www_authentication_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the www-authenticate provider should be omitted from the request? Defaults to `false`.
        """
        return pulumi.get(self, "www_authentication_disabled")

    @www_authentication_disabled.setter
    def www_authentication_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "www_authentication_disabled", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2AppleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2AppleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2AppleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Apple web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Apple Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: A list of Login Scopes provided by this Authentication Provider.
               
               > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Apple web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Apple Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Login Scopes provided by this Authentication Provider.

        > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with Azure Static Web App Authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2CustomOidcV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        name: pulumi.Input[str]
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        openid_configuration_endpoint: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        authorisation_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        certification_uri: NotRequired[pulumi.Input[str]]
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        client_credential_method: NotRequired[pulumi.Input[str]]
        """
        The Client Credential Method used.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[str]]
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        issuer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        name_claim_type: NotRequired[pulumi.Input[str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of the scopes that should be requested while authenticating.
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2CustomOidcV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2CustomOidcV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 openid_configuration_endpoint: pulumi.Input[str],
                 authorisation_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 client_credential_method: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 issuer_endpoint: Optional[pulumi.Input[str]] = None,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the Client to use to authenticate with the Custom OIDC.
        :param pulumi.Input[str] name: The name of the Custom OIDC Authentication Provider.
               
               > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        :param pulumi.Input[str] openid_configuration_endpoint: The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        :param pulumi.Input[str] authorisation_endpoint: The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] certification_uri: The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] client_credential_method: The Client Credential Method used.
        :param pulumi.Input[str] client_secret_setting_name: The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        :param pulumi.Input[str] issuer_endpoint: The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        :param pulumi.Input[str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of the scopes that should be requested while authenticating.
        :param pulumi.Input[str] token_endpoint: The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "openid_configuration_endpoint", openid_configuration_endpoint)
        if authorisation_endpoint is not None:
            pulumi.set(__self__, "authorisation_endpoint", authorisation_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if client_credential_method is not None:
            pulumi.set(__self__, "client_credential_method", client_credential_method)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if issuer_endpoint is not None:
            pulumi.set(__self__, "issuer_endpoint", issuer_endpoint)
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the Client to use to authenticate with the Custom OIDC.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Custom OIDC Authentication Provider.

        > **NOTE:** An `app_setting` matching this value in upper case with the suffix of `_PROVIDER_AUTHENTICATION_SECRET` is required. e.g. `MYOIDC_PROVIDER_AUTHENTICATION_SECRET` for a value of `myoidc`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openidConfigurationEndpoint")
    def openid_configuration_endpoint(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for the Custom OIDC Login.
        """
        return pulumi.get(self, "openid_configuration_endpoint")

    @openid_configuration_endpoint.setter
    def openid_configuration_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "openid_configuration_endpoint", value)

    @property
    @pulumi.getter(name="authorisationEndpoint")
    def authorisation_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to make the Authorisation Request as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "authorisation_endpoint")

    @authorisation_endpoint.setter
    def authorisation_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorisation_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that provides the keys necessary to validate the token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter(name="clientCredentialMethod")
    def client_credential_method(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Credential Method used.
        """
        return pulumi.get(self, "client_credential_method")

    @client_credential_method.setter
    def client_credential_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_credential_method", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The App Setting name that contains the secret for this Custom OIDC Client. This is generated from `name` above and suffixed with `_PROVIDER_AUTHENTICATION_SECRET`.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="issuerEndpoint")
    def issuer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that issued the Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "issuer_endpoint")

    @issuer_endpoint.setter
    def issuer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_endpoint", value)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to request a Token as supplied by `openid_configuration_endpoint` response.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2FacebookV2ArgsDict(TypedDict):
        app_id: pulumi.Input[str]
        """
        The App ID of the Facebook app used for login.
        """
        app_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        graph_api_version: NotRequired[pulumi.Input[str]]
        """
        The version of the Facebook API to be used while logging in.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2FacebookV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2FacebookV2Args:
    def __init__(__self__, *,
                 app_id: pulumi.Input[str],
                 app_secret_setting_name: pulumi.Input[str],
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] app_id: The App ID of the Facebook app used for login.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the `app_secret` value used for Facebook Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[str] graph_api_version: The version of the Facebook API to be used while logging in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of scopes that should be requested as part of Facebook Login authentication.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The App ID of the Facebook app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `app_secret` value used for Facebook Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Facebook API to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of scopes that should be requested as part of Facebook Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2GithubV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The ID of the GitHub app used for login..
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2GithubV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2GithubV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the GitHub app used for login..
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for GitHub Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The ID of the GitHub app used for login..
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for GitHub Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of GitHub Login authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2GoogleV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OpenID Connect Client ID for the Google web application.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2GoogleV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2GoogleV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OpenID Connect Client ID for the Google web application.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the `client_secret` value used for Google Login.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OpenID Connect Client ID for the Google web application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the `client_secret` value used for Google Login.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of OAuth 2.0 scopes that should be requested as part of Google Sign-In authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2LoginArgsDict(TypedDict):
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration_convention: NotRequired[pulumi.Input[str]]
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        cookie_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        logout_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint to which logout requests should be made.
        """
        nonce_expiration_time: NotRequired[pulumi.Input[str]]
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[bool]]
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        token_refresh_extension_time: NotRequired[pulumi.Input[float]]
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        token_store_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        token_store_path: NotRequired[pulumi.Input[str]]
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        token_store_sas_setting_name: NotRequired[pulumi.Input[str]]
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        validate_nonce: NotRequired[pulumi.Input[bool]]
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration_convention: Optional[pulumi.Input[str]] = None,
                 cookie_expiration_time: Optional[pulumi.Input[str]] = None,
                 logout_endpoint: Optional[pulumi.Input[str]] = None,
                 nonce_expiration_time: Optional[pulumi.Input[str]] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 token_refresh_extension_time: Optional[pulumi.Input[float]] = None,
                 token_store_enabled: Optional[pulumi.Input[bool]] = None,
                 token_store_path: Optional[pulumi.Input[str]] = None,
                 token_store_sas_setting_name: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
               
               > **Note:** URLs within the current domain are always implicitly allowed.
        :param pulumi.Input[str] cookie_expiration_convention: The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        :param pulumi.Input[str] cookie_expiration_time: The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        :param pulumi.Input[str] logout_endpoint: The endpoint to which logout requests should be made.
        :param pulumi.Input[str] nonce_expiration_time: The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        :param pulumi.Input[bool] preserve_url_fragments_for_logins: Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        :param pulumi.Input[float] token_refresh_extension_time: The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        :param pulumi.Input[bool] token_store_enabled: Should the Token Store configuration Enabled. Defaults to `false`
        :param pulumi.Input[str] token_store_path: The directory path in the App Filesystem in which the tokens will be stored.
        :param pulumi.Input[str] token_store_sas_setting_name: The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        :param pulumi.Input[bool] validate_nonce: Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration_convention is not None:
            pulumi.set(__self__, "cookie_expiration_convention", cookie_expiration_convention)
        if cookie_expiration_time is not None:
            pulumi.set(__self__, "cookie_expiration_time", cookie_expiration_time)
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)
        if nonce_expiration_time is not None:
            pulumi.set(__self__, "nonce_expiration_time", nonce_expiration_time)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if token_refresh_extension_time is not None:
            pulumi.set(__self__, "token_refresh_extension_time", token_refresh_extension_time)
        if token_store_enabled is not None:
            pulumi.set(__self__, "token_store_enabled", token_store_enabled)
        if token_store_path is not None:
            pulumi.set(__self__, "token_store_path", token_store_path)
        if token_store_sas_setting_name is not None:
            pulumi.set(__self__, "token_store_sas_setting_name", token_store_sas_setting_name)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.

        > **Note:** URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpirationConvention")
    def cookie_expiration_convention(self) -> Optional[pulumi.Input[str]]:
        """
        The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
        """
        return pulumi.get(self, "cookie_expiration_convention")

    @cookie_expiration_convention.setter
    def cookie_expiration_convention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_convention", value)

    @property
    @pulumi.getter(name="cookieExpirationTime")
    def cookie_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
        """
        return pulumi.get(self, "cookie_expiration_time")

    @cookie_expiration_time.setter
    def cookie_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_expiration_time", value)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to which logout requests should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)

    @property
    @pulumi.getter(name="nonceExpirationTime")
    def nonce_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
        """
        return pulumi.get(self, "nonce_expiration_time")

    @nonce_expiration_time.setter
    def nonce_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_time", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionTime")
    def token_refresh_extension_time(self) -> Optional[pulumi.Input[float]]:
        """
        The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
        """
        return pulumi.get(self, "token_refresh_extension_time")

    @token_refresh_extension_time.setter
    def token_refresh_extension_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_time", value)

    @property
    @pulumi.getter(name="tokenStoreEnabled")
    def token_store_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Token Store configuration Enabled. Defaults to `false`
        """
        return pulumi.get(self, "token_store_enabled")

    @token_store_enabled.setter
    def token_store_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_store_enabled", value)

    @property
    @pulumi.getter(name="tokenStorePath")
    def token_store_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory path in the App Filesystem in which the tokens will be stored.
        """
        return pulumi.get(self, "token_store_path")

    @token_store_path.setter
    def token_store_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_path", value)

    @property
    @pulumi.getter(name="tokenStoreSasSettingName")
    def token_store_sas_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "token_store_sas_setting_name")

    @token_store_sas_setting_name.setter
    def token_store_sas_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_store_sas_setting_name", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the nonce be validated while completing the login flow. Defaults to `true`.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2MicrosoftV2ArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        client_secret_setting_name: pulumi.Input[str]
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        login_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2MicrosoftV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2MicrosoftV2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_setting_name: pulumi.Input[str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 login_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The OAuth 2.0 client ID that was created for the app used for authentication.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_scopes: The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if login_scopes is not None:
            pulumi.set(__self__, "login_scopes", login_scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The OAuth 2.0 client ID that was created for the app used for authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="loginScopes")
    def login_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Login scopes that should be requested as part of Microsoft Account authentication.
        """
        return pulumi.get(self, "login_scopes")

    @login_scopes.setter
    def login_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_scopes", value)


if not MYPY:
    class WindowsWebAppSlotAuthSettingsV2TwitterV2ArgsDict(TypedDict):
        consumer_key: pulumi.Input[str]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        consumer_secret_setting_name: pulumi.Input[str]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
elif False:
    WindowsWebAppSlotAuthSettingsV2TwitterV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotAuthSettingsV2TwitterV2Args:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret_setting_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
               
               !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> pulumi.Input[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.

        !> **NOTE:** A setting with this name must exist in `app_settings` to function correctly.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class WindowsWebAppSlotBackupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name which should be used for this Backup.
        """
        schedule: pulumi.Input['WindowsWebAppSlotBackupScheduleArgsDict']
        """
        A `schedule` block as defined below.
        """
        storage_account_url: pulumi.Input[str]
        """
        The SAS URL to the container.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Should this backup job be enabled? Defaults to `true`.
        """
elif False:
    WindowsWebAppSlotBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotBackupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['WindowsWebAppSlotBackupScheduleArgs'],
                 storage_account_url: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name which should be used for this Backup.
        :param pulumi.Input['WindowsWebAppSlotBackupScheduleArgs'] schedule: A `schedule` block as defined below.
        :param pulumi.Input[str] storage_account_url: The SAS URL to the container.
        :param pulumi.Input[bool] enabled: Should this backup job be enabled? Defaults to `true`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Backup.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['WindowsWebAppSlotBackupScheduleArgs']:
        """
        A `schedule` block as defined below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['WindowsWebAppSlotBackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> pulumi.Input[str]:
        """
        The SAS URL to the container.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should this backup job be enabled? Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WindowsWebAppSlotBackupScheduleArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        frequency_unit: pulumi.Input[str]
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        keep_at_least_one_backup: NotRequired[pulumi.Input[bool]]
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        last_execution_time: NotRequired[pulumi.Input[str]]
        """
        The time the backup was last attempted.
        """
        retention_period_days: NotRequired[pulumi.Input[int]]
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        When the schedule should start working in RFC-3339 format.
        """
elif False:
    WindowsWebAppSlotBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotBackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_unit: pulumi.Input[str],
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 last_execution_time: Optional[pulumi.Input[str]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
               
               > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        :param pulumi.Input[str] frequency_unit: The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        :param pulumi.Input[bool] keep_at_least_one_backup: Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        :param pulumi.Input[str] last_execution_time: The time the backup was last attempted.
        :param pulumi.Input[int] retention_period_days: After how many days backups should be deleted. Defaults to `30`.
        :param pulumi.Input[str] start_time: When the schedule should start working in RFC-3339 format.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is not None:
            pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).

        > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input[str]:
        """
        The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time the backup was last attempted.
        """
        return pulumi.get(self, "last_execution_time")

    @last_execution_time.setter
    def last_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_execution_time", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        After how many days backups should be deleted. Defaults to `30`.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When the schedule should start working in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class WindowsWebAppSlotConnectionStringArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the connection String.
        """
        type: pulumi.Input[str]
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        value: pulumi.Input[str]
        """
        The connection string value.
        """
elif False:
    WindowsWebAppSlotConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotConnectionStringArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the connection String.
        :param pulumi.Input[str] type: Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        :param pulumi.Input[str] value: The connection string value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the connection String.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WindowsWebAppSlotIdentityArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Web App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        identity_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The Principal ID associated with this Managed Service Identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The Tenant ID associated with this Managed Service Identity.
        """
elif False:
    WindowsWebAppSlotIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 identity_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of Managed Service Identity that should be configured on this Windows Web App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identity_ids: A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App Slot.
               
               > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        :param pulumi.Input[str] principal_id: The Principal ID associated with this Managed Service Identity.
        :param pulumi.Input[str] tenant_id: The Tenant ID associated with this Managed Service Identity.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of Managed Service Identity that should be configured on this Windows Web App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App Slot.

        > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @identity_ids.setter
    def identity_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identity_ids", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Principal ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID associated with this Managed Service Identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class WindowsWebAppSlotLogsArgsDict(TypedDict):
        application_logs: NotRequired[pulumi.Input['WindowsWebAppSlotLogsApplicationLogsArgsDict']]
        """
        A `application_logs` block as defined above.
        """
        detailed_error_messages: NotRequired[pulumi.Input[bool]]
        """
        Should detailed error messages be enabled.
        """
        failed_request_tracing: NotRequired[pulumi.Input[bool]]
        """
        Should failed request tracing be enabled.
        """
        http_logs: NotRequired[pulumi.Input['WindowsWebAppSlotLogsHttpLogsArgsDict']]
        """
        An `http_logs` block as defined above.
        """
elif False:
    WindowsWebAppSlotLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotLogsArgs:
    def __init__(__self__, *,
                 application_logs: Optional[pulumi.Input['WindowsWebAppSlotLogsApplicationLogsArgs']] = None,
                 detailed_error_messages: Optional[pulumi.Input[bool]] = None,
                 failed_request_tracing: Optional[pulumi.Input[bool]] = None,
                 http_logs: Optional[pulumi.Input['WindowsWebAppSlotLogsHttpLogsArgs']] = None):
        """
        :param pulumi.Input['WindowsWebAppSlotLogsApplicationLogsArgs'] application_logs: A `application_logs` block as defined above.
        :param pulumi.Input[bool] detailed_error_messages: Should detailed error messages be enabled.
        :param pulumi.Input[bool] failed_request_tracing: Should failed request tracing be enabled.
        :param pulumi.Input['WindowsWebAppSlotLogsHttpLogsArgs'] http_logs: An `http_logs` block as defined above.
        """
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if detailed_error_messages is not None:
            pulumi.set(__self__, "detailed_error_messages", detailed_error_messages)
        if failed_request_tracing is not None:
            pulumi.set(__self__, "failed_request_tracing", failed_request_tracing)
        if http_logs is not None:
            pulumi.set(__self__, "http_logs", http_logs)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional[pulumi.Input['WindowsWebAppSlotLogsApplicationLogsArgs']]:
        """
        A `application_logs` block as defined above.
        """
        return pulumi.get(self, "application_logs")

    @application_logs.setter
    def application_logs(self, value: Optional[pulumi.Input['WindowsWebAppSlotLogsApplicationLogsArgs']]):
        pulumi.set(self, "application_logs", value)

    @property
    @pulumi.getter(name="detailedErrorMessages")
    def detailed_error_messages(self) -> Optional[pulumi.Input[bool]]:
        """
        Should detailed error messages be enabled.
        """
        return pulumi.get(self, "detailed_error_messages")

    @detailed_error_messages.setter
    def detailed_error_messages(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_messages", value)

    @property
    @pulumi.getter(name="failedRequestTracing")
    def failed_request_tracing(self) -> Optional[pulumi.Input[bool]]:
        """
        Should failed request tracing be enabled.
        """
        return pulumi.get(self, "failed_request_tracing")

    @failed_request_tracing.setter
    def failed_request_tracing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failed_request_tracing", value)

    @property
    @pulumi.getter(name="httpLogs")
    def http_logs(self) -> Optional[pulumi.Input['WindowsWebAppSlotLogsHttpLogsArgs']]:
        """
        An `http_logs` block as defined above.
        """
        return pulumi.get(self, "http_logs")

    @http_logs.setter
    def http_logs(self, value: Optional[pulumi.Input['WindowsWebAppSlotLogsHttpLogsArgs']]):
        pulumi.set(self, "http_logs", value)


if not MYPY:
    class WindowsWebAppSlotLogsApplicationLogsArgsDict(TypedDict):
        file_system_level: pulumi.Input[str]
        """
        Log level. Possible values include: `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        """
        azure_blob_storage: NotRequired[pulumi.Input['WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgsDict']]
        """
        An `azure_blob_storage` block as defined below.
        """
elif False:
    WindowsWebAppSlotLogsApplicationLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotLogsApplicationLogsArgs:
    def __init__(__self__, *,
                 file_system_level: pulumi.Input[str],
                 azure_blob_storage: Optional[pulumi.Input['WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgs']] = None):
        """
        :param pulumi.Input[str] file_system_level: Log level. Possible values include: `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        :param pulumi.Input['WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgs'] azure_blob_storage: An `azure_blob_storage` block as defined below.
        """
        pulumi.set(__self__, "file_system_level", file_system_level)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)

    @property
    @pulumi.getter(name="fileSystemLevel")
    def file_system_level(self) -> pulumi.Input[str]:
        """
        Log level. Possible values include: `Off`, `Verbose`, `Information`, `Warning`, and `Error`.
        """
        return pulumi.get(self, "file_system_level")

    @file_system_level.setter
    def file_system_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_system_level", value)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgs']]:
        """
        An `azure_blob_storage` block as defined below.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)


if not MYPY:
    class WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgsDict(TypedDict):
        level: pulumi.Input[str]
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        retention_in_days: pulumi.Input[int]
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        sas_url: pulumi.Input[str]
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
elif False:
    WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotLogsApplicationLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[str],
                 retention_in_days: pulumi.Input[int],
                 sas_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] level: The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        :param pulumi.Input[int] retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        :param pulumi.Input[str] sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input[str]:
        """
        The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `http_logs`
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[str]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class WindowsWebAppSlotLogsHttpLogsArgsDict(TypedDict):
        azure_blob_storage: NotRequired[pulumi.Input['WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgsDict']]
        """
        A `azure_blob_storage_http` block as defined above.
        """
        file_system: NotRequired[pulumi.Input['WindowsWebAppSlotLogsHttpLogsFileSystemArgsDict']]
        """
        A `file_system` block as defined above.
        """
elif False:
    WindowsWebAppSlotLogsHttpLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotLogsHttpLogsArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgs']] = None,
                 file_system: Optional[pulumi.Input['WindowsWebAppSlotLogsHttpLogsFileSystemArgs']] = None):
        """
        :param pulumi.Input['WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgs'] azure_blob_storage: A `azure_blob_storage_http` block as defined above.
        :param pulumi.Input['WindowsWebAppSlotLogsHttpLogsFileSystemArgs'] file_system: A `file_system` block as defined above.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgs']]:
        """
        A `azure_blob_storage_http` block as defined above.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['WindowsWebAppSlotLogsHttpLogsFileSystemArgs']]:
        """
        A `file_system` block as defined above.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['WindowsWebAppSlotLogsHttpLogsFileSystemArgs']]):
        pulumi.set(self, "file_system", value)


if not MYPY:
    class WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgsDict(TypedDict):
        sas_url: pulumi.Input[str]
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        retention_in_days: NotRequired[pulumi.Input[int]]
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
elif False:
    WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotLogsHttpLogsAzureBlobStorageArgs:
    def __init__(__self__, *,
                 sas_url: pulumi.Input[str],
                 retention_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] sas_url: SAS url to an Azure blob container with read/write/list/delete permissions.
        :param pulumi.Input[int] retention_in_days: The time in days after which to remove blobs. A value of `0` means no retention.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        SAS url to an Azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        The time in days after which to remove blobs. A value of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)


if not MYPY:
    class WindowsWebAppSlotLogsHttpLogsFileSystemArgsDict(TypedDict):
        retention_in_days: pulumi.Input[int]
        """
        The retention period in days. A values of `0` means no retention.
        """
        retention_in_mb: pulumi.Input[int]
        """
        The maximum size in megabytes that log files can use.
        """
elif False:
    WindowsWebAppSlotLogsHttpLogsFileSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotLogsHttpLogsFileSystemArgs:
    def __init__(__self__, *,
                 retention_in_days: pulumi.Input[int],
                 retention_in_mb: pulumi.Input[int]):
        """
        :param pulumi.Input[int] retention_in_days: The retention period in days. A values of `0` means no retention.
        :param pulumi.Input[int] retention_in_mb: The maximum size in megabytes that log files can use.
        """
        pulumi.set(__self__, "retention_in_days", retention_in_days)
        pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> pulumi.Input[int]:
        """
        The retention period in days. A values of `0` means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> pulumi.Input[int]:
        """
        The maximum size in megabytes that log files can use.
        """
        return pulumi.get(self, "retention_in_mb")

    @retention_in_mb.setter
    def retention_in_mb(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_in_mb", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigArgsDict(TypedDict):
        always_on: NotRequired[pulumi.Input[bool]]
        """
        If this Windows Web App Slot is Always On enabled. Defaults to `true`.
        """
        api_definition_url: NotRequired[pulumi.Input[str]]
        """
        The URL to the API Definition for this Windows Web App Slot.
        """
        api_management_api_id: NotRequired[pulumi.Input[str]]
        """
        The API Management API ID this Windows Web App Slot os associated with.
        """
        app_command_line: NotRequired[pulumi.Input[str]]
        """
        The App command line to launch.
        """
        application_stack: NotRequired[pulumi.Input['WindowsWebAppSlotSiteConfigApplicationStackArgsDict']]
        """
        A `application_stack` block as defined above.
        """
        auto_heal_setting: NotRequired[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingArgsDict']]
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        auto_swap_slot_name: NotRequired[pulumi.Input[str]]
        """
        The Windows Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.

        > **Note:** This must be a valid slot name on the target Windows Web App Slot.
        """
        container_registry_managed_identity_client_id: NotRequired[pulumi.Input[str]]
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        container_registry_use_managed_identity: NotRequired[pulumi.Input[bool]]
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        cors: NotRequired[pulumi.Input['WindowsWebAppSlotSiteConfigCorsArgsDict']]
        """
        A `cors` block as defined above.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Default Documents for the Windows Web App Slot.
        """
        detailed_error_logging_enabled: NotRequired[pulumi.Input[bool]]
        ftps_state: NotRequired[pulumi.Input[str]]
        handler_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigHandlerMappingArgsDict']]]]
        """
        One or more `handler_mapping` blocks as defined below.
        """
        health_check_eviction_time_in_min: NotRequired[pulumi.Input[int]]
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        health_check_path: NotRequired[pulumi.Input[str]]
        """
        The path to the Health Check.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the HTTP2 be enabled?
        """
        ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionArgsDict']]]]
        """
        One or more `ip_restriction` blocks as defined above.
        """
        load_balancing_mode: NotRequired[pulumi.Input[str]]
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        local_mysql_enabled: NotRequired[pulumi.Input[bool]]
        """
        Use Local MySQL. Defaults to `false`.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input[str]]
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        remote_debugging_version: NotRequired[pulumi.Input[str]]
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`
        """
        scm_ip_restriction_default_action: NotRequired[pulumi.Input[str]]
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        scm_ip_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionArgsDict']]]]
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        scm_minimum_tls_version: NotRequired[pulumi.Input[str]]
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        scm_type: NotRequired[pulumi.Input[str]]
        scm_use_main_ip_restriction: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Web App Slot `ip_restriction` configuration be used for the SCM also.
        """
        use32_bit_worker: NotRequired[pulumi.Input[bool]]
        """
        Should the Windows Web App Slot use a 32-bit worker. The default value varies from different service plans.
        """
        virtual_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationArgsDict']]]]
        """
        One or more `virtual_application` blocks as defined below.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        websockets_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        windows_fx_version: NotRequired[pulumi.Input[str]]
        worker_count: NotRequired[pulumi.Input[int]]
        """
        The number of Workers for this Windows App Service Slot.
        """
elif False:
    WindowsWebAppSlotSiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigArgs:
    def __init__(__self__, *,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 api_definition_url: Optional[pulumi.Input[str]] = None,
                 api_management_api_id: Optional[pulumi.Input[str]] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 application_stack: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigApplicationStackArgs']] = None,
                 auto_heal_setting: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingArgs']] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
                 container_registry_managed_identity_client_id: Optional[pulumi.Input[str]] = None,
                 container_registry_use_managed_identity: Optional[pulumi.Input[bool]] = None,
                 cors: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigCorsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 ftps_state: Optional[pulumi.Input[str]] = None,
                 handler_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigHandlerMappingArgs']]]] = None,
                 health_check_eviction_time_in_min: Optional[pulumi.Input[int]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionArgs']]]] = None,
                 load_balancing_mode: Optional[pulumi.Input[str]] = None,
                 local_mysql_enabled: Optional[pulumi.Input[bool]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input[str]] = None,
                 minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 scm_ip_restriction_default_action: Optional[pulumi.Input[str]] = None,
                 scm_ip_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionArgs']]]] = None,
                 scm_minimum_tls_version: Optional[pulumi.Input[str]] = None,
                 scm_type: Optional[pulumi.Input[str]] = None,
                 scm_use_main_ip_restriction: Optional[pulumi.Input[bool]] = None,
                 use32_bit_worker: Optional[pulumi.Input[bool]] = None,
                 virtual_applications: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationArgs']]]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 websockets_enabled: Optional[pulumi.Input[bool]] = None,
                 windows_fx_version: Optional[pulumi.Input[str]] = None,
                 worker_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] always_on: If this Windows Web App Slot is Always On enabled. Defaults to `true`.
        :param pulumi.Input[str] api_definition_url: The URL to the API Definition for this Windows Web App Slot.
        :param pulumi.Input[str] api_management_api_id: The API Management API ID this Windows Web App Slot os associated with.
        :param pulumi.Input[str] app_command_line: The App command line to launch.
        :param pulumi.Input['WindowsWebAppSlotSiteConfigApplicationStackArgs'] application_stack: A `application_stack` block as defined above.
        :param pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingArgs'] auto_heal_setting: A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        :param pulumi.Input[str] auto_swap_slot_name: The Windows Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
               
               > **Note:** This must be a valid slot name on the target Windows Web App Slot.
        :param pulumi.Input[str] container_registry_managed_identity_client_id: The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        :param pulumi.Input[bool] container_registry_use_managed_identity: Should connections for Azure Container Registry use Managed Identity.
        :param pulumi.Input['WindowsWebAppSlotSiteConfigCorsArgs'] cors: A `cors` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: Specifies a list of Default Documents for the Windows Web App Slot.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigHandlerMappingArgs']]] handler_mappings: One or more `handler_mapping` blocks as defined below.
        :param pulumi.Input[int] health_check_eviction_time_in_min: The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        :param pulumi.Input[str] health_check_path: The path to the Health Check.
        :param pulumi.Input[bool] http2_enabled: Should the HTTP2 be enabled?
        :param pulumi.Input[str] ip_restriction_default_action: The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionArgs']]] ip_restrictions: One or more `ip_restriction` blocks as defined above.
        :param pulumi.Input[str] load_balancing_mode: The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        :param pulumi.Input[bool] local_mysql_enabled: Use Local MySQL. Defaults to `false`.
        :param pulumi.Input[str] managed_pipeline_mode: Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        :param pulumi.Input[str] minimum_tls_version: The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[bool] remote_debugging_enabled: Should Remote Debugging be enabled. Defaults to `false`.
        :param pulumi.Input[str] remote_debugging_version: The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`
        :param pulumi.Input[str] scm_ip_restriction_default_action: The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionArgs']]] scm_ip_restrictions: One or more `scm_ip_restriction` blocks as defined above.
        :param pulumi.Input[str] scm_minimum_tls_version: The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        :param pulumi.Input[bool] scm_use_main_ip_restriction: Should the Windows Web App Slot `ip_restriction` configuration be used for the SCM also.
        :param pulumi.Input[bool] use32_bit_worker: Should the Windows Web App Slot use a 32-bit worker. The default value varies from different service plans.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationArgs']]] virtual_applications: One or more `virtual_application` blocks as defined below.
        :param pulumi.Input[bool] vnet_route_all_enabled: Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        :param pulumi.Input[bool] websockets_enabled: Should Web Sockets be enabled. Defaults to `false`.
        :param pulumi.Input[int] worker_count: The number of Workers for this Windows App Service Slot.
        """
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition_url is not None:
            pulumi.set(__self__, "api_definition_url", api_definition_url)
        if api_management_api_id is not None:
            pulumi.set(__self__, "api_management_api_id", api_management_api_id)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if application_stack is not None:
            pulumi.set(__self__, "application_stack", application_stack)
        if auto_heal_setting is not None:
            pulumi.set(__self__, "auto_heal_setting", auto_heal_setting)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if container_registry_managed_identity_client_id is not None:
            pulumi.set(__self__, "container_registry_managed_identity_client_id", container_registry_managed_identity_client_id)
        if container_registry_use_managed_identity is not None:
            pulumi.set(__self__, "container_registry_use_managed_identity", container_registry_use_managed_identity)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if handler_mappings is not None:
            pulumi.set(__self__, "handler_mappings", handler_mappings)
        if health_check_eviction_time_in_min is not None:
            pulumi.set(__self__, "health_check_eviction_time_in_min", health_check_eviction_time_in_min)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if ip_restriction_default_action is not None:
            pulumi.set(__self__, "ip_restriction_default_action", ip_restriction_default_action)
        if ip_restrictions is not None:
            pulumi.set(__self__, "ip_restrictions", ip_restrictions)
        if load_balancing_mode is not None:
            pulumi.set(__self__, "load_balancing_mode", load_balancing_mode)
        if local_mysql_enabled is not None:
            pulumi.set(__self__, "local_mysql_enabled", local_mysql_enabled)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if scm_ip_restriction_default_action is not None:
            pulumi.set(__self__, "scm_ip_restriction_default_action", scm_ip_restriction_default_action)
        if scm_ip_restrictions is not None:
            pulumi.set(__self__, "scm_ip_restrictions", scm_ip_restrictions)
        if scm_minimum_tls_version is not None:
            pulumi.set(__self__, "scm_minimum_tls_version", scm_minimum_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if scm_use_main_ip_restriction is not None:
            pulumi.set(__self__, "scm_use_main_ip_restriction", scm_use_main_ip_restriction)
        if use32_bit_worker is not None:
            pulumi.set(__self__, "use32_bit_worker", use32_bit_worker)
        if virtual_applications is not None:
            pulumi.set(__self__, "virtual_applications", virtual_applications)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if websockets_enabled is not None:
            pulumi.set(__self__, "websockets_enabled", websockets_enabled)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        If this Windows Web App Slot is Always On enabled. Defaults to `true`.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinitionUrl")
    def api_definition_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to the API Definition for this Windows Web App Slot.
        """
        return pulumi.get(self, "api_definition_url")

    @api_definition_url.setter
    def api_definition_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_definition_url", value)

    @property
    @pulumi.getter(name="apiManagementApiId")
    def api_management_api_id(self) -> Optional[pulumi.Input[str]]:
        """
        The API Management API ID this Windows Web App Slot os associated with.
        """
        return pulumi.get(self, "api_management_api_id")

    @api_management_api_id.setter
    def api_management_api_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_management_api_id", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        The App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="applicationStack")
    def application_stack(self) -> Optional[pulumi.Input['WindowsWebAppSlotSiteConfigApplicationStackArgs']]:
        """
        A `application_stack` block as defined above.
        """
        return pulumi.get(self, "application_stack")

    @application_stack.setter
    def application_stack(self, value: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigApplicationStackArgs']]):
        pulumi.set(self, "application_stack", value)

    @property
    @pulumi.getter(name="autoHealSetting")
    def auto_heal_setting(self) -> Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingArgs']]:
        """
        A `auto_heal_setting` block as defined above. Required with `auto_heal`.
        """
        return pulumi.get(self, "auto_heal_setting")

    @auto_heal_setting.setter
    def auto_heal_setting(self, value: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingArgs']]):
        pulumi.set(self, "auto_heal_setting", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Windows Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.

        > **Note:** This must be a valid slot name on the target Windows Web App Slot.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter(name="containerRegistryManagedIdentityClientId")
    def container_registry_managed_identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
        """
        return pulumi.get(self, "container_registry_managed_identity_client_id")

    @container_registry_managed_identity_client_id.setter
    def container_registry_managed_identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_registry_managed_identity_client_id", value)

    @property
    @pulumi.getter(name="containerRegistryUseManagedIdentity")
    def container_registry_use_managed_identity(self) -> Optional[pulumi.Input[bool]]:
        """
        Should connections for Azure Container Registry use Managed Identity.
        """
        return pulumi.get(self, "container_registry_use_managed_identity")

    @container_registry_use_managed_identity.setter
    def container_registry_use_managed_identity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "container_registry_use_managed_identity", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['WindowsWebAppSlotSiteConfigCorsArgs']]:
        """
        A `cors` block as defined above.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Default Documents for the Windows Web App Slot.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="handlerMappings")
    def handler_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigHandlerMappingArgs']]]]:
        """
        One or more `handler_mapping` blocks as defined below.
        """
        return pulumi.get(self, "handler_mappings")

    @handler_mappings.setter
    def handler_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigHandlerMappingArgs']]]]):
        pulumi.set(self, "handler_mappings", value)

    @property
    @pulumi.getter(name="healthCheckEvictionTimeInMin")
    def health_check_eviction_time_in_min(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`.
        """
        return pulumi.get(self, "health_check_eviction_time_in_min")

    @health_check_eviction_time_in_min.setter
    def health_check_eviction_time_in_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_eviction_time_in_min", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the Health Check.
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the HTTP2 be enabled?
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="ipRestrictionDefaultAction")
    def ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "ip_restriction_default_action")

    @ip_restriction_default_action.setter
    def ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="ipRestrictions")
    def ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionArgs']]]]:
        """
        One or more `ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "ip_restrictions")

    @ip_restrictions.setter
    def ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionArgs']]]]):
        pulumi.set(self, "ip_restrictions", value)

    @property
    @pulumi.getter(name="loadBalancingMode")
    def load_balancing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
        """
        return pulumi.get(self, "load_balancing_mode")

    @load_balancing_mode.setter
    def load_balancing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancing_mode", value)

    @property
    @pulumi.getter(name="localMysqlEnabled")
    def local_mysql_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Use Local MySQL. Defaults to `false`.
        """
        return pulumi.get(self, "local_mysql_enabled")

    @local_mysql_enabled.setter
    def local_mysql_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local_mysql_enabled", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Remote Debugging be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Remote Debugging Version. Possible values include `VS2017`, `VS2019` and `VS2022`
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="scmIpRestrictionDefaultAction")
    def scm_ip_restriction_default_action(self) -> Optional[pulumi.Input[str]]:
        """
        The Default action for traffic that does not match any `scm_ip_restriction` rule. possible values include `Allow` and `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "scm_ip_restriction_default_action")

    @scm_ip_restriction_default_action.setter
    def scm_ip_restriction_default_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_ip_restriction_default_action", value)

    @property
    @pulumi.getter(name="scmIpRestrictions")
    def scm_ip_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionArgs']]]]:
        """
        One or more `scm_ip_restriction` blocks as defined above.
        """
        return pulumi.get(self, "scm_ip_restrictions")

    @scm_ip_restrictions.setter
    def scm_ip_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_restrictions", value)

    @property
    @pulumi.getter(name="scmMinimumTlsVersion")
    def scm_minimum_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
        """
        return pulumi.get(self, "scm_minimum_tls_version")

    @scm_minimum_tls_version.setter
    def scm_minimum_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_minimum_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="scmUseMainIpRestriction")
    def scm_use_main_ip_restriction(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Web App Slot `ip_restriction` configuration be used for the SCM also.
        """
        return pulumi.get(self, "scm_use_main_ip_restriction")

    @scm_use_main_ip_restriction.setter
    def scm_use_main_ip_restriction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_use_main_ip_restriction", value)

    @property
    @pulumi.getter(name="use32BitWorker")
    def use32_bit_worker(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Windows Web App Slot use a 32-bit worker. The default value varies from different service plans.
        """
        return pulumi.get(self, "use32_bit_worker")

    @use32_bit_worker.setter
    def use32_bit_worker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker", value)

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationArgs']]]]:
        """
        One or more `virtual_application` blocks as defined below.
        """
        return pulumi.get(self, "virtual_applications")

    @virtual_applications.setter
    def virtual_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationArgs']]]]):
        pulumi.set(self, "virtual_applications", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="websocketsEnabled")
    def websockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Web Sockets be enabled. Defaults to `false`.
        """
        return pulumi.get(self, "websockets_enabled")

    @websockets_enabled.setter
    def websockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "websockets_enabled", value)

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "windows_fx_version")

    @windows_fx_version.setter
    def windows_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_fx_version", value)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Workers for this Windows App Service Slot.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigApplicationStackArgsDict(TypedDict):
        current_stack: NotRequired[pulumi.Input[str]]
        """
        The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.

        > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
        """
        docker_image_name: NotRequired[pulumi.Input[str]]
        """
        The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        """
        docker_registry_password: NotRequired[pulumi.Input[str]]
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        docker_registry_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        docker_registry_username: NotRequired[pulumi.Input[str]]
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        dotnet_core_version: NotRequired[pulumi.Input[str]]
        """
        The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        """
        dotnet_version: NotRequired[pulumi.Input[str]]
        """
        The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0`, `v7.0` and `v8.0`.
        """
        java_container: NotRequired[pulumi.Input[str]]
        java_container_version: NotRequired[pulumi.Input[str]]
        java_embedded_server_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should the Java Embedded Server (Java SE) be used to run the app.
        """
        java_version: NotRequired[pulumi.Input[str]]
        """
        The version of Java to use when `current_stack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `java_container` and `java_container_version`.

        > **NOTE:** For compatible combinations of `java_version`, `java_container` and `java_container_version` users can use `az webapp list-runtimes` from command line.
        """
        node_version: NotRequired[pulumi.Input[str]]
        """
        The version of node to use when `current_stack` is set to `node`. Possible values include `~12`, `~14`, `~16`, `~18` and `~20`.

        > **NOTE:** This property conflicts with `java_version`.
        """
        php_version: NotRequired[pulumi.Input[str]]
        """
        The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.

        > **NOTE:** The value `Off` is used to signify latest supported by the service.
        """
        python: NotRequired[pulumi.Input[bool]]
        """
        The app is a Python app. Defaults to `false`.
        """
        tomcat_version: NotRequired[pulumi.Input[str]]
        """
        The version of Tomcat the Java App should use.

        > **NOTE:** See the official documentation for current supported versions.
        """
elif False:
    WindowsWebAppSlotSiteConfigApplicationStackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigApplicationStackArgs:
    def __init__(__self__, *,
                 current_stack: Optional[pulumi.Input[str]] = None,
                 docker_image_name: Optional[pulumi.Input[str]] = None,
                 docker_registry_password: Optional[pulumi.Input[str]] = None,
                 docker_registry_url: Optional[pulumi.Input[str]] = None,
                 docker_registry_username: Optional[pulumi.Input[str]] = None,
                 dotnet_core_version: Optional[pulumi.Input[str]] = None,
                 dotnet_version: Optional[pulumi.Input[str]] = None,
                 java_container: Optional[pulumi.Input[str]] = None,
                 java_container_version: Optional[pulumi.Input[str]] = None,
                 java_embedded_server_enabled: Optional[pulumi.Input[bool]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 node_version: Optional[pulumi.Input[str]] = None,
                 php_version: Optional[pulumi.Input[str]] = None,
                 python: Optional[pulumi.Input[bool]] = None,
                 tomcat_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] current_stack: The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
               
               > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
        :param pulumi.Input[str] docker_image_name: The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        :param pulumi.Input[str] docker_registry_password: The User Name to use for authentication against the registry to pull the image.
               
               > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        :param pulumi.Input[str] docker_registry_url: The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        :param pulumi.Input[str] docker_registry_username: The User Name to use for authentication against the registry to pull the image.
        :param pulumi.Input[str] dotnet_core_version: The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        :param pulumi.Input[str] dotnet_version: The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0`, `v7.0` and `v8.0`.
        :param pulumi.Input[bool] java_embedded_server_enabled: Should the Java Embedded Server (Java SE) be used to run the app.
        :param pulumi.Input[str] java_version: The version of Java to use when `current_stack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `java_container` and `java_container_version`.
               
               > **NOTE:** For compatible combinations of `java_version`, `java_container` and `java_container_version` users can use `az webapp list-runtimes` from command line.
        :param pulumi.Input[str] node_version: The version of node to use when `current_stack` is set to `node`. Possible values include `~12`, `~14`, `~16`, `~18` and `~20`.
               
               > **NOTE:** This property conflicts with `java_version`.
        :param pulumi.Input[str] php_version: The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.
               
               > **NOTE:** The value `Off` is used to signify latest supported by the service.
        :param pulumi.Input[bool] python: The app is a Python app. Defaults to `false`.
        :param pulumi.Input[str] tomcat_version: The version of Tomcat the Java App should use.
               
               > **NOTE:** See the official documentation for current supported versions.
        """
        if current_stack is not None:
            pulumi.set(__self__, "current_stack", current_stack)
        if docker_image_name is not None:
            pulumi.set(__self__, "docker_image_name", docker_image_name)
        if docker_registry_password is not None:
            pulumi.set(__self__, "docker_registry_password", docker_registry_password)
        if docker_registry_url is not None:
            pulumi.set(__self__, "docker_registry_url", docker_registry_url)
        if docker_registry_username is not None:
            pulumi.set(__self__, "docker_registry_username", docker_registry_username)
        if dotnet_core_version is not None:
            pulumi.set(__self__, "dotnet_core_version", dotnet_core_version)
        if dotnet_version is not None:
            pulumi.set(__self__, "dotnet_version", dotnet_version)
        if java_container is not None:
            warnings.warn("""this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""", DeprecationWarning)
            pulumi.log.warn("""java_container is deprecated: this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            warnings.warn("""This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""", DeprecationWarning)
            pulumi.log.warn("""java_container_version is deprecated: This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_embedded_server_enabled is not None:
            pulumi.set(__self__, "java_embedded_server_enabled", java_embedded_server_enabled)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if python is not None:
            pulumi.set(__self__, "python", python)
        if tomcat_version is not None:
            pulumi.set(__self__, "tomcat_version", tomcat_version)

    @property
    @pulumi.getter(name="currentStack")
    def current_stack(self) -> Optional[pulumi.Input[str]]:
        """
        The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.

        > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
        """
        return pulumi.get(self, "current_stack")

    @current_stack.setter
    def current_stack(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_stack", value)

    @property
    @pulumi.getter(name="dockerImageName")
    def docker_image_name(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
        """
        return pulumi.get(self, "docker_image_name")

    @docker_image_name.setter
    def docker_image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_image_name", value)

    @property
    @pulumi.getter(name="dockerRegistryPassword")
    def docker_registry_password(self) -> Optional[pulumi.Input[str]]:
        """
        The User Name to use for authentication against the registry to pull the image.

        > **NOTE:** `docker_registry_url`, `docker_registry_username`, and `docker_registry_password` replace the use of the `app_settings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `app_settings` map.
        """
        return pulumi.get(self, "docker_registry_password")

    @docker_registry_password.setter
    def docker_registry_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_password", value)

    @property
    @pulumi.getter(name="dockerRegistryUrl")
    def docker_registry_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the container registry where the `docker_image_name` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `docker_image_name`.
        """
        return pulumi.get(self, "docker_registry_url")

    @docker_registry_url.setter
    def docker_registry_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_url", value)

    @property
    @pulumi.getter(name="dockerRegistryUsername")
    def docker_registry_username(self) -> Optional[pulumi.Input[str]]:
        """
        The User Name to use for authentication against the registry to pull the image.
        """
        return pulumi.get(self, "docker_registry_username")

    @docker_registry_username.setter
    def docker_registry_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_registry_username", value)

    @property
    @pulumi.getter(name="dotnetCoreVersion")
    def dotnet_core_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .NET to use when `current_stack` is set to `dotnetcore`. Possible values include `v4.0`.
        """
        return pulumi.get(self, "dotnet_core_version")

    @dotnet_core_version.setter
    def dotnet_core_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_core_version", value)

    @property
    @pulumi.getter(name="dotnetVersion")
    def dotnet_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of .NET to use when `current_stack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0`, `v7.0` and `v8.0`.
        """
        return pulumi.get(self, "dotnet_version")

    @dotnet_version.setter
    def dotnet_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dotnet_version", value)

    @property
    @pulumi.getter(name="javaContainer")
    @_utilities.deprecated("""this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")
    def java_container(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "java_container")

    @java_container.setter
    def java_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container", value)

    @property
    @pulumi.getter(name="javaContainerVersion")
    @_utilities.deprecated("""This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`""")
    def java_container_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "java_container_version")

    @java_container_version.setter
    def java_container_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container_version", value)

    @property
    @pulumi.getter(name="javaEmbeddedServerEnabled")
    def java_embedded_server_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the Java Embedded Server (Java SE) be used to run the app.
        """
        return pulumi.get(self, "java_embedded_server_enabled")

    @java_embedded_server_enabled.setter
    def java_embedded_server_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "java_embedded_server_enabled", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Java to use when `current_stack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `java_container` and `java_container_version`.

        > **NOTE:** For compatible combinations of `java_version`, `java_container` and `java_container_version` users can use `az webapp list-runtimes` from command line.
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of node to use when `current_stack` is set to `node`. Possible values include `~12`, `~14`, `~16`, `~18` and `~20`.

        > **NOTE:** This property conflicts with `java_version`.
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of PHP to use when `current_stack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.

        > **NOTE:** The value `Off` is used to signify latest supported by the service.
        """
        return pulumi.get(self, "php_version")

    @php_version.setter
    def php_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "php_version", value)

    @property
    @pulumi.getter
    def python(self) -> Optional[pulumi.Input[bool]]:
        """
        The app is a Python app. Defaults to `false`.
        """
        return pulumi.get(self, "python")

    @python.setter
    def python(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "python", value)

    @property
    @pulumi.getter(name="tomcatVersion")
    def tomcat_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of Tomcat the Java App should use.

        > **NOTE:** See the official documentation for current supported versions.
        """
        return pulumi.get(self, "tomcat_version")

    @tomcat_version.setter
    def tomcat_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tomcat_version", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigAutoHealSettingArgsDict(TypedDict):
        action: pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionArgsDict']
        """
        A `action` block as defined above.
        """
        trigger: pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgsDict']
        """
        A `trigger` block as defined below.
        """
elif False:
    WindowsWebAppSlotSiteConfigAutoHealSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigAutoHealSettingArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionArgs'],
                 trigger: pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgs']):
        """
        :param pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionArgs'] action: A `action` block as defined above.
        :param pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgs'] trigger: A `trigger` block as defined below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "trigger", trigger)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionArgs']:
        """
        A `action` block as defined above.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def trigger(self) -> pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgs']:
        """
        A `trigger` block as defined below.
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgs']):
        pulumi.set(self, "trigger", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigAutoHealSettingActionArgsDict(TypedDict):
        action_type: pulumi.Input[str]
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values are `CustomAction`, `LogEvent` and `Recycle`.
        """
        custom_action: NotRequired[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgsDict']]
        """
        A `custom_action` block as defined below.
        """
        minimum_process_execution_time: NotRequired[pulumi.Input[str]]
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App Slot must have been running before the defined action will be run in the event of a trigger.
        """
elif False:
    WindowsWebAppSlotSiteConfigAutoHealSettingActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigAutoHealSettingActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 custom_action: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgs']] = None,
                 minimum_process_execution_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_type: Predefined action to be taken to an Auto Heal trigger. Possible values are `CustomAction`, `LogEvent` and `Recycle`.
        :param pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgs'] custom_action: A `custom_action` block as defined below.
        :param pulumi.Input[str] minimum_process_execution_time: The minimum amount of time in `hh:mm:ss` the Windows Web App Slot must have been running before the defined action will be run in the event of a trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        if custom_action is not None:
            pulumi.set(__self__, "custom_action", custom_action)
        if minimum_process_execution_time is not None:
            pulumi.set(__self__, "minimum_process_execution_time", minimum_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        Predefined action to be taken to an Auto Heal trigger. Possible values are `CustomAction`, `LogEvent` and `Recycle`.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgs']]:
        """
        A `custom_action` block as defined below.
        """
        return pulumi.get(self, "custom_action")

    @custom_action.setter
    def custom_action(self, value: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgs']]):
        pulumi.set(self, "custom_action", value)

    @property
    @pulumi.getter(name="minimumProcessExecutionTime")
    def minimum_process_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum amount of time in `hh:mm:ss` the Windows Web App Slot must have been running before the defined action will be run in the event of a trigger.
        """
        return pulumi.get(self, "minimum_process_execution_time")

    @minimum_process_execution_time.setter
    def minimum_process_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_process_execution_time", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgsDict(TypedDict):
        executable: pulumi.Input[str]
        """
        The executable to run for the `custom_action`.
        """
        parameters: NotRequired[pulumi.Input[str]]
        """
        The parameters to pass to the specified `executable`.
        """
elif False:
    WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomActionArgs:
    def __init__(__self__, *,
                 executable: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] executable: The executable to run for the `custom_action`.
        :param pulumi.Input[str] parameters: The parameters to pass to the specified `executable`.
        """
        pulumi.set(__self__, "executable", executable)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def executable(self) -> pulumi.Input[str]:
        """
        The executable to run for the `custom_action`.
        """
        return pulumi.get(self, "executable")

    @executable.setter
    def executable(self, value: pulumi.Input[str]):
        pulumi.set(self, "executable", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        The parameters to pass to the specified `executable`.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgsDict(TypedDict):
        private_memory_kb: NotRequired[pulumi.Input[int]]
        """
        The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        """
        requests: NotRequired[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgsDict']]
        """
        A `requests` block as defined above.
        """
        slow_request: NotRequired[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgsDict']]
        """
        A `slow_request` block as defined above.
        """
        slow_request_with_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict']]]]
        """
        One or more `slow_request_with_path` blocks as defined above.
        """
        status_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgsDict']]]]
        """
        One or more `status_code` blocks as defined above.
        """
elif False:
    WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerArgs:
    def __init__(__self__, *,
                 private_memory_kb: Optional[pulumi.Input[int]] = None,
                 requests: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs']] = None,
                 slow_request: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs']] = None,
                 slow_request_with_paths: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]] = None,
                 status_codes: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]] = None):
        """
        :param pulumi.Input[int] private_memory_kb: The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        :param pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs'] requests: A `requests` block as defined above.
        :param pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs'] slow_request: A `slow_request` block as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]] slow_request_with_paths: One or more `slow_request_with_path` blocks as defined above.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs']]] status_codes: One or more `status_code` blocks as defined above.
        """
        if private_memory_kb is not None:
            pulumi.set(__self__, "private_memory_kb", private_memory_kb)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_request is not None:
            pulumi.set(__self__, "slow_request", slow_request)
        if slow_request_with_paths is not None:
            pulumi.set(__self__, "slow_request_with_paths", slow_request_with_paths)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="privateMemoryKb")
    def private_memory_kb(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
        """
        return pulumi.get(self, "private_memory_kb")

    @private_memory_kb.setter
    def private_memory_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "private_memory_kb", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs']]:
        """
        A `requests` block as defined above.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs']]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="slowRequest")
    def slow_request(self) -> Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs']]:
        """
        A `slow_request` block as defined above.
        """
        return pulumi.get(self, "slow_request")

    @slow_request.setter
    def slow_request(self, value: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs']]):
        pulumi.set(self, "slow_request", value)

    @property
    @pulumi.getter(name="slowRequestWithPaths")
    def slow_request_with_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]]:
        """
        One or more `slow_request_with_path` blocks as defined above.
        """
        return pulumi.get(self, "slow_request_with_paths")

    @slow_request_with_paths.setter
    def slow_request_with_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs']]]]):
        pulumi.set(self, "slow_request_with_paths", value)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]]:
        """
        One or more `status_code` blocks as defined above.
        """
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs']]]]):
        pulumi.set(self, "status_codes", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The interval in `hh:mm:ss`.
        """
elif False:
    WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequestsArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: The number of requests in the specified `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The interval in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of requests in the specified `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The interval in `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        time_taken: pulumi.Input[str]
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
elif False:
    WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 time_taken: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> pulumi.Input[str]:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_taken", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        time_taken: pulumi.Input[str]
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path for which this slow request rule applies.
        """
elif False:
    WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPathArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 time_taken: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of Slow Requests in the time `interval` to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] time_taken: The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        :param pulumi.Input[str] path: The path for which this slow request rule applies.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "time_taken", time_taken)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of Slow Requests in the time `interval` to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> pulumi.Input[str]:
        """
        The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_taken", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path for which this slow request rule applies.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        interval: pulumi.Input[str]
        """
        The time interval in the form `hh:mm:ss`.
        """
        status_code_range: pulumi.Input[str]
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path to which this rule status code applies.
        """
        sub_status: NotRequired[pulumi.Input[int]]
        """
        The Request Sub Status of the Status Code.
        """
        win32_status_code: NotRequired[pulumi.Input[int]]
        """
        The Win32 Status Code of the Request.
        """
elif False:
    WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCodeArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 interval: pulumi.Input[str],
                 status_code_range: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 sub_status: Optional[pulumi.Input[int]] = None,
                 win32_status_code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] count: The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        :param pulumi.Input[str] interval: The time interval in the form `hh:mm:ss`.
        :param pulumi.Input[str] status_code_range: The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        :param pulumi.Input[str] path: The path to which this rule status code applies.
        :param pulumi.Input[int] sub_status: The Request Sub Status of the Status Code.
        :param pulumi.Input[int] win32_status_code: The Win32 Status Code of the Request.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "status_code_range", status_code_range)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if win32_status_code is not None:
            pulumi.set(__self__, "win32_status_code", win32_status_code)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of occurrences of the defined `status_code` in the specified `interval` on which to trigger this rule.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The time interval in the form `hh:mm:ss`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> pulumi.Input[str]:
        """
        The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
        """
        return pulumi.get(self, "status_code_range")

    @status_code_range.setter
    def status_code_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_code_range", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to which this rule status code applies.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[pulumi.Input[int]]:
        """
        The Request Sub Status of the Status Code.
        """
        return pulumi.get(self, "sub_status")

    @sub_status.setter
    def sub_status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sub_status", value)

    @property
    @pulumi.getter(name="win32StatusCode")
    def win32_status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The Win32 Status Code of the Request.
        """
        return pulumi.get(self, "win32_status_code")

    @win32_status_code.setter
    def win32_status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "win32_status_code", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigCorsArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        support_credentials: NotRequired[pulumi.Input[bool]]
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
elif False:
    WindowsWebAppSlotSiteConfigCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies a list of origins that should be allowed to make cross-origin calls.
        :param pulumi.Input[bool] support_credentials: Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of origins that should be allowed to make cross-origin calls.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether CORS requests with credentials are allowed. Defaults to `false`
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigHandlerMappingArgsDict(TypedDict):
        extension: pulumi.Input[str]
        """
        Specify which extension to be handled by the specified FastCGI application.
        """
        script_processor_path: pulumi.Input[str]
        """
        Specify the absolute path to the FastCGI application.
        """
        arguments: NotRequired[pulumi.Input[str]]
        """
        Specify the command-line arguments to be passed to the script processor.
        """
elif False:
    WindowsWebAppSlotSiteConfigHandlerMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigHandlerMappingArgs:
    def __init__(__self__, *,
                 extension: pulumi.Input[str],
                 script_processor_path: pulumi.Input[str],
                 arguments: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] extension: Specify which extension to be handled by the specified FastCGI application.
        :param pulumi.Input[str] script_processor_path: Specify the absolute path to the FastCGI application.
        :param pulumi.Input[str] arguments: Specify the command-line arguments to be passed to the script processor.
        """
        pulumi.set(__self__, "extension", extension)
        pulumi.set(__self__, "script_processor_path", script_processor_path)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)

    @property
    @pulumi.getter
    def extension(self) -> pulumi.Input[str]:
        """
        Specify which extension to be handled by the specified FastCGI application.
        """
        return pulumi.get(self, "extension")

    @extension.setter
    def extension(self, value: pulumi.Input[str]):
        pulumi.set(self, "extension", value)

    @property
    @pulumi.getter(name="scriptProcessorPath")
    def script_processor_path(self) -> pulumi.Input[str]:
        """
        Specify the absolute path to the FastCGI application.
        """
        return pulumi.get(self, "script_processor_path")

    @script_processor_path.setter
    def script_processor_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "script_processor_path", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the command-line arguments to be passed to the script processor.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arguments", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    WindowsWebAppSlotSiteConfigIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigScmIpRestrictionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The Description of this IP Restriction.
        """
        headers: NotRequired[pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgsDict']]
        """
        A `headers` block as defined above.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name which should be used for this `ip_restriction`.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        service_tag: NotRequired[pulumi.Input[str]]
        """
        The Service Tag used for this IP Restriction.
        """
        virtual_network_subnet_id: NotRequired[pulumi.Input[str]]
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
elif False:
    WindowsWebAppSlotSiteConfigScmIpRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigScmIpRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgs']] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None,
                 virtual_network_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        :param pulumi.Input[str] description: The Description of this IP Restriction.
        :param pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgs'] headers: A `headers` block as defined above.
        :param pulumi.Input[str] ip_address: The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        :param pulumi.Input[str] name: The name which should be used for this `ip_restriction`.
        :param pulumi.Input[int] priority: The priority value of this `ip_restriction`. Defaults to `65000`.
        :param pulumi.Input[str] service_tag: The Service Tag used for this IP Restriction.
        :param pulumi.Input[str] virtual_network_subnet_id: The Virtual Network Subnet ID used for this IP Restriction.
               
               > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if virtual_network_subnet_id is not None:
            pulumi.set(__self__, "virtual_network_subnet_id", virtual_network_subnet_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to take. Possible values are `Allow` or `Deny`. Defaults to `Allow`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The Description of this IP Restriction.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgs']]:
        """
        A `headers` block as defined above.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name which should be used for this `ip_restriction`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority value of this `ip_restriction`. Defaults to `65000`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Service Tag used for this IP Restriction.
        """
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)

    @property
    @pulumi.getter(name="virtualNetworkSubnetId")
    def virtual_network_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Network Subnet ID used for this IP Restriction.

        > **NOTE:** One and only one of `ip_address`, `service_tag` or `virtual_network_subnet_id` must be specified.
        """
        return pulumi.get(self, "virtual_network_subnet_id")

    @virtual_network_subnet_id.setter
    def virtual_network_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_subnet_id", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgsDict(TypedDict):
        x_azure_fdids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Azure Front Door IDs.
        """
        x_fd_health_probe: NotRequired[pulumi.Input[str]]
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        x_forwarded_fors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        x_forwarded_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of Hosts for which matching should be applied.
        """
elif False:
    WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigScmIpRestrictionHeadersArgs:
    def __init__(__self__, *,
                 x_azure_fdids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_fd_health_probe: Optional[pulumi.Input[str]] = None,
                 x_forwarded_fors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 x_forwarded_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_azure_fdids: Specifies a list of Azure Front Door IDs.
        :param pulumi.Input[str] x_fd_health_probe: Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_fors: Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] x_forwarded_hosts: Specifies a list of Hosts for which matching should be applied.
        """
        if x_azure_fdids is not None:
            pulumi.set(__self__, "x_azure_fdids", x_azure_fdids)
        if x_fd_health_probe is not None:
            pulumi.set(__self__, "x_fd_health_probe", x_fd_health_probe)
        if x_forwarded_fors is not None:
            pulumi.set(__self__, "x_forwarded_fors", x_forwarded_fors)
        if x_forwarded_hosts is not None:
            pulumi.set(__self__, "x_forwarded_hosts", x_forwarded_hosts)

    @property
    @pulumi.getter(name="xAzureFdids")
    def x_azure_fdids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Azure Front Door IDs.
        """
        return pulumi.get(self, "x_azure_fdids")

    @x_azure_fdids.setter
    def x_azure_fdids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_azure_fdids", value)

    @property
    @pulumi.getter(name="xFdHealthProbe")
    def x_fd_health_probe(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
        """
        return pulumi.get(self, "x_fd_health_probe")

    @x_fd_health_probe.setter
    def x_fd_health_probe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_fd_health_probe", value)

    @property
    @pulumi.getter(name="xForwardedFors")
    def x_forwarded_fors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
        """
        return pulumi.get(self, "x_forwarded_fors")

    @x_forwarded_fors.setter
    def x_forwarded_fors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_fors", value)

    @property
    @pulumi.getter(name="xForwardedHosts")
    def x_forwarded_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of Hosts for which matching should be applied.
        """
        return pulumi.get(self, "x_forwarded_hosts")

    @x_forwarded_hosts.setter
    def x_forwarded_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_forwarded_hosts", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigVirtualApplicationArgsDict(TypedDict):
        physical_path: pulumi.Input[str]
        """
        The physical path for the Virtual Application.
        """
        preload: pulumi.Input[bool]
        """
        Should pre-loading be enabled.
        """
        virtual_path: pulumi.Input[str]
        """
        The Virtual Path for the Virtual Application.
        """
        virtual_directories: NotRequired[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgsDict']]]]
        """
        One or more `virtual_directory` blocks as defined below.
        """
elif False:
    WindowsWebAppSlotSiteConfigVirtualApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigVirtualApplicationArgs:
    def __init__(__self__, *,
                 physical_path: pulumi.Input[str],
                 preload: pulumi.Input[bool],
                 virtual_path: pulumi.Input[str],
                 virtual_directories: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgs']]]] = None):
        """
        :param pulumi.Input[str] physical_path: The physical path for the Virtual Application.
        :param pulumi.Input[bool] preload: Should pre-loading be enabled.
        :param pulumi.Input[str] virtual_path: The Virtual Path for the Virtual Application.
        :param pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgs']]] virtual_directories: One or more `virtual_directory` blocks as defined below.
        """
        pulumi.set(__self__, "physical_path", physical_path)
        pulumi.set(__self__, "preload", preload)
        pulumi.set(__self__, "virtual_path", virtual_path)
        if virtual_directories is not None:
            pulumi.set(__self__, "virtual_directories", virtual_directories)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> pulumi.Input[str]:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @physical_path.setter
    def physical_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "physical_path", value)

    @property
    @pulumi.getter
    def preload(self) -> pulumi.Input[bool]:
        """
        Should pre-loading be enabled.
        """
        return pulumi.get(self, "preload")

    @preload.setter
    def preload(self, value: pulumi.Input[bool]):
        pulumi.set(self, "preload", value)

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> pulumi.Input[str]:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")

    @virtual_path.setter
    def virtual_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_path", value)

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgs']]]]:
        """
        One or more `virtual_directory` blocks as defined below.
        """
        return pulumi.get(self, "virtual_directories")

    @virtual_directories.setter
    def virtual_directories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgs']]]]):
        pulumi.set(self, "virtual_directories", value)


if not MYPY:
    class WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgsDict(TypedDict):
        physical_path: NotRequired[pulumi.Input[str]]
        """
        The physical path for the Virtual Application.
        """
        virtual_path: NotRequired[pulumi.Input[str]]
        """
        The Virtual Path for the Virtual Application.
        """
elif False:
    WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectoryArgs:
    def __init__(__self__, *,
                 physical_path: Optional[pulumi.Input[str]] = None,
                 virtual_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] physical_path: The physical path for the Virtual Application.
        :param pulumi.Input[str] virtual_path: The Virtual Path for the Virtual Application.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[pulumi.Input[str]]:
        """
        The physical path for the Virtual Application.
        """
        return pulumi.get(self, "physical_path")

    @physical_path.setter
    def physical_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "physical_path", value)

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Path for the Virtual Application.
        """
        return pulumi.get(self, "virtual_path")

    @virtual_path.setter
    def virtual_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_path", value)


if not MYPY:
    class WindowsWebAppSlotSiteCredentialArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Username used for publishing.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The Site Credentials Password used for publishing.
        """
elif False:
    WindowsWebAppSlotSiteCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotSiteCredentialArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The Site Credentials Username used for publishing.
        :param pulumi.Input[str] password: The Site Credentials Password used for publishing.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Username used for publishing.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The Site Credentials Password used for publishing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class WindowsWebAppSlotStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The Access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The Name of the Storage Account.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this Storage Account.
        """
        share_name: pulumi.Input[str]
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        type: pulumi.Input[str]
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path at which to mount the storage share.
        """
elif False:
    WindowsWebAppSlotStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppSlotStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The Access key for the storage account.
        :param pulumi.Input[str] account_name: The Name of the Storage Account.
        :param pulumi.Input[str] name: The name which should be used for this Storage Account.
        :param pulumi.Input[str] share_name: The Name of the File Share or Container Name for Blob storage.
        :param pulumi.Input[str] type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param pulumi.Input[str] mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this Storage Account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class WindowsWebAppStickySettingsArgsDict(TypedDict):
        app_setting_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        connection_string_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
elif False:
    WindowsWebAppStickySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppStickySettingsArgs:
    def __init__(__self__, *,
                 app_setting_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 connection_string_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_setting_names: A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] connection_string_names: A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        if app_setting_names is not None:
            pulumi.set(__self__, "app_setting_names", app_setting_names)
        if connection_string_names is not None:
            pulumi.set(__self__, "connection_string_names", connection_string_names)

    @property
    @pulumi.getter(name="appSettingNames")
    def app_setting_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of `app_setting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "app_setting_names")

    @app_setting_names.setter
    def app_setting_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_setting_names", value)

    @property
    @pulumi.getter(name="connectionStringNames")
    def connection_string_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of `connection_string` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
        """
        return pulumi.get(self, "connection_string_names")

    @connection_string_names.setter
    def connection_string_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "connection_string_names", value)


if not MYPY:
    class WindowsWebAppStorageAccountArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The Access key for the storage account.
        """
        account_name: pulumi.Input[str]
        """
        The Name of the Storage Account.
        """
        name: pulumi.Input[str]
        """
        The name which should be used for this TODO.
        """
        share_name: pulumi.Input[str]
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        type: pulumi.Input[str]
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path at which to mount the storage share.
        """
elif False:
    WindowsWebAppStorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WindowsWebAppStorageAccountArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 share_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The Access key for the storage account.
        :param pulumi.Input[str] account_name: The Name of the Storage Account.
        :param pulumi.Input[str] name: The name which should be used for this TODO.
        :param pulumi.Input[str] share_name: The Name of the File Share or Container Name for Blob storage.
        :param pulumi.Input[str] type: The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        :param pulumi.Input[str] mount_path: The path at which to mount the storage share.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "share_name", share_name)
        pulumi.set(__self__, "type", type)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The Name of the Storage Account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name which should be used for this TODO.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> pulumi.Input[str]:
        """
        The Name of the File Share or Container Name for Blob storage.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path at which to mount the storage share.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


